/*

 jsPDF addImage plugin
 Copyright (c) 2012 Jason Siefken, https://github.com/siefkenj/
               2013 Chris Dowling, https://github.com/gingerchris
               2013 Trinh Ho, https://github.com/ineedfat
               2013 Edwin Alejandro Perez, https://github.com/eaparango
               2013 Norah Smith, https://github.com/burnburnrocket
               2014 Diego Casorran, https://github.com/diegocr
               2014 James Robb, https://github.com/jamesbrobb



 jsPDF fromHTML plugin. BETA stage. API subject to change. Needs browser
 Copyright (c) 2012 Willow Systems Corporation, willow-systems.com
               2014 Juan Pablo Gaviria, https://github.com/juanpgaviria
               2014 Diego Casorran, https://github.com/diegocr
               2014 Daniel Husar, https://github.com/danielhusar
               2014 Wolfgang Gassler, https://github.com/woolfg
               2014 Steven Spungin, https://github.com/flamenco


 ====================================================================

  ====================================================================
 jsPDF PNG PlugIn
 Copyright (c) 2014 James Robb, https://github.com/jamesbrobb


 ====================================================================

 jsPDF split_text_to_size plugin - MIT license.
 Copyright (c) 2012 Willow Systems Corporation, willow-systems.com
               2014 Diego Casorran, https://github.com/diegocr
 
jsPDF standard_fonts_metrics plugin
Copyright (c) 2012 Willow Systems Corporation, willow-systems.com
MIT license.

jsPDF SVG plugin
Copyright (c) 2012 Willow Systems Corporation, willow-systems.com
*/
var $jscomp = $jscomp || {};
$jscomp.scope = {};
$jscomp.ASSUME_ES5 = false;
$jscomp.ASSUME_NO_NATIVE_MAP = false;
$jscomp.ASSUME_NO_NATIVE_SET = false;
$jscomp.defineProperty = $jscomp.ASSUME_ES5 || typeof Object.defineProperties == 'function' ? Object.defineProperty : function(target, property, descriptor) {
  descriptor = descriptor;
  if (target == Array.prototype || target == Object.prototype) {
    return;
  }
  target[property] = descriptor.value;
};
$jscomp.getGlobal = function(maybeGlobal) {
  return typeof window != 'undefined' && window === maybeGlobal ? maybeGlobal : typeof global != 'undefined' && global != null ? global : maybeGlobal;
};
$jscomp.global = $jscomp.getGlobal(this);
$jscomp.polyfill = function(target, polyfill, fromLang, toLang) {
  if (!polyfill) {
    return;
  }
  var obj = $jscomp.global;
  var split = target.split('.');
  for (var i = 0; i < split.length - 1; i++) {
    var key = split[i];
    if (!(key in obj)) {
      obj[key] = {};
    }
    obj = obj[key];
  }
  var property = split[split.length - 1];
  var orig = obj[property];
  var impl = polyfill(orig);
  if (impl == orig || impl == null) {
    return;
  }
  $jscomp.defineProperty(obj, property, {configurable:true, writable:true, value:impl});
};
$jscomp.polyfill('Array.prototype.copyWithin', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(target, start, opt_end) {
    var len = this.length;
    target = Number(target);
    start = Number(start);
    opt_end = Number(opt_end != null ? opt_end : len);
    if (target < start) {
      opt_end = Math.min(opt_end, len);
      while (start < opt_end) {
        if (start in this) {
          this[target++] = this[start++];
        } else {
          delete this[target++];
          start++;
        }
      }
    } else {
      opt_end = Math.min(opt_end, len + start - target);
      target += opt_end - start;
      while (opt_end > start) {
        if (--opt_end in this) {
          this[--target] = this[opt_end];
        } else {
          delete this[target];
        }
      }
    }
    return this;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.SYMBOL_PREFIX = 'jscomp_symbol_';
$jscomp.initSymbol = function() {
  $jscomp.initSymbol = function() {
  };
  if (!$jscomp.global['Symbol']) {
    $jscomp.global['Symbol'] = $jscomp.Symbol;
  }
};
$jscomp.Symbol = function() {
  var counter = 0;
  function Symbol(opt_description) {
    return $jscomp.SYMBOL_PREFIX + (opt_description || '') + counter++;
  }
  return Symbol;
}();
$jscomp.initSymbolIterator = function() {
  $jscomp.initSymbol();
  var symbolIterator = $jscomp.global['Symbol'].iterator;
  if (!symbolIterator) {
    symbolIterator = $jscomp.global['Symbol'].iterator = $jscomp.global['Symbol']('iterator');
  }
  if (typeof Array.prototype[symbolIterator] != 'function') {
    $jscomp.defineProperty(Array.prototype, symbolIterator, {configurable:true, writable:true, value:function() {
      return $jscomp.arrayIterator(this);
    }});
  }
  $jscomp.initSymbolIterator = function() {
  };
};
$jscomp.arrayIterator = function(array) {
  var index = 0;
  return $jscomp.iteratorPrototype(function() {
    if (index < array.length) {
      return {done:false, value:array[index++]};
    } else {
      return {done:true};
    }
  });
};
$jscomp.iteratorPrototype = function(next) {
  $jscomp.initSymbolIterator();
  var iterator = {next:next};
  iterator[$jscomp.global['Symbol'].iterator] = function() {
    return this;
  };
  return iterator;
};
$jscomp.iteratorFromArray = function(array, transform) {
  $jscomp.initSymbolIterator();
  if (array instanceof String) {
    array = array + '';
  }
  var i = 0;
  var iter = {next:function() {
    if (i < array.length) {
      var index = i++;
      return {value:transform(index, array[index]), done:false};
    }
    iter.next = function() {
      return {done:true, value:void 0};
    };
    return iter.next();
  }};
  $jscomp.initSymbol();
  $jscomp.initSymbolIterator();
  iter[Symbol.iterator] = function() {
    return iter;
  };
  return iter;
};
$jscomp.polyfill('Array.prototype.entries', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function() {
    return $jscomp.iteratorFromArray(this, function(i, v) {
      return [i, v];
    });
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Array.prototype.fill', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(value, opt_start, opt_end) {
    var length = this.length || 0;
    if (opt_start < 0) {
      opt_start = Math.max(0, length + opt_start);
    }
    if (opt_end == null || opt_end > length) {
      opt_end = length;
    }
    opt_end = Number(opt_end);
    if (opt_end < 0) {
      opt_end = Math.max(0, length + opt_end);
    }
    for (var i = Number(opt_start || 0); i < opt_end; i++) {
      this[i] = value;
    }
    return this;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.findInternal = function(array, callback, thisArg) {
  if (array instanceof String) {
    array = String(array);
  }
  var len = array.length;
  for (var i = 0; i < len; i++) {
    var value = array[i];
    if (callback.call(thisArg, value, i, array)) {
      return {i:i, v:value};
    }
  }
  return {i:-1, v:void 0};
};
$jscomp.polyfill('Array.prototype.find', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(callback, opt_thisArg) {
    return $jscomp.findInternal(this, callback, opt_thisArg).v;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Array.prototype.findIndex', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(callback, opt_thisArg) {
    return $jscomp.findInternal(this, callback, opt_thisArg).i;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Array.from', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(arrayLike, opt_mapFn, opt_thisArg) {
    $jscomp.initSymbolIterator();
    opt_mapFn = opt_mapFn != null ? opt_mapFn : function(x) {
      return x;
    };
    var result = [];
    $jscomp.initSymbol();
    $jscomp.initSymbolIterator();
    var iteratorFunction = arrayLike[Symbol.iterator];
    if (typeof iteratorFunction == 'function') {
      arrayLike = iteratorFunction.call(arrayLike);
      var next;
      var k = 0;
      while (!(next = arrayLike.next()).done) {
        result.push(opt_mapFn.call(opt_thisArg, next.value, k++));
      }
    } else {
      var len = arrayLike.length;
      for (var i = 0; i < len; i++) {
        result.push(opt_mapFn.call(opt_thisArg, arrayLike[i], i));
      }
    }
    return result;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Object.is', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(left, right) {
    if (left === right) {
      return left !== 0 || 1 / left === 1 / right;
    } else {
      return left !== left && right !== right;
    }
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Array.prototype.includes', function(orig) {
  if (orig) {
    return orig;
  }
  var includes = function(searchElement, opt_fromIndex) {
    var array = this;
    if (array instanceof String) {
      array = String(array);
    }
    var len = array.length;
    var i = opt_fromIndex || 0;
    if (i < 0) {
      i = Math.max(i + len, 0);
    }
    for (; i < len; i++) {
      var element = array[i];
      if (element === searchElement || Object.is(element, searchElement)) {
        return true;
      }
    }
    return false;
  };
  return includes;
}, 'es7', 'es3');
$jscomp.polyfill('Array.prototype.keys', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function() {
    return $jscomp.iteratorFromArray(this, function(i) {
      return i;
    });
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Array.of', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(var_args) {
    return Array.from(arguments);
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Array.prototype.values', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function() {
    return $jscomp.iteratorFromArray(this, function(k, v) {
      return v;
    });
  };
  return polyfill;
}, 'es8', 'es3');
$jscomp.makeIterator = function(iterable) {
  $jscomp.initSymbolIterator();
  $jscomp.initSymbol();
  $jscomp.initSymbolIterator();
  var iteratorFunction = iterable[Symbol.iterator];
  return iteratorFunction ? iteratorFunction.call(iterable) : $jscomp.arrayIterator(iterable);
};
$jscomp.FORCE_POLYFILL_PROMISE = false;
$jscomp.polyfill('Promise', function(NativePromise) {
  if (NativePromise && !$jscomp.FORCE_POLYFILL_PROMISE) {
    return NativePromise;
  }
  function AsyncExecutor() {
    this.batch_ = null;
  }
  AsyncExecutor.prototype.asyncExecute = function(f) {
    if (this.batch_ == null) {
      this.batch_ = [];
      this.asyncExecuteBatch_();
    }
    this.batch_.push(f);
    return this;
  };
  AsyncExecutor.prototype.asyncExecuteBatch_ = function() {
    var self = this;
    this.asyncExecuteFunction(function() {
      self.executeBatch_();
    });
  };
  var nativeSetTimeout = $jscomp.global['setTimeout'];
  AsyncExecutor.prototype.asyncExecuteFunction = function(f) {
    nativeSetTimeout(f, 0);
  };
  AsyncExecutor.prototype.executeBatch_ = function() {
    while (this.batch_ && this.batch_.length) {
      var executingBatch = this.batch_;
      this.batch_ = [];
      for (var i = 0; i < executingBatch.length; ++i) {
        var f = executingBatch[i];
        executingBatch[i] = null;
        try {
          f();
        } catch (error) {
          this.asyncThrow_(error);
        }
      }
    }
    this.batch_ = null;
  };
  AsyncExecutor.prototype.asyncThrow_ = function(exception) {
    this.asyncExecuteFunction(function() {
      throw exception;
    });
  };
  var PromiseState = {PENDING:0, FULFILLED:1, REJECTED:2};
  var PolyfillPromise = function(executor) {
    this.state_ = PromiseState.PENDING;
    this.result_ = undefined;
    this.onSettledCallbacks_ = [];
    var resolveAndReject = this.createResolveAndReject_();
    try {
      executor(resolveAndReject.resolve, resolveAndReject.reject);
    } catch (e) {
      resolveAndReject.reject(e);
    }
  };
  PolyfillPromise.prototype.createResolveAndReject_ = function() {
    var thisPromise = this;
    var alreadyCalled = false;
    function firstCallWins(method) {
      return function(x) {
        if (!alreadyCalled) {
          alreadyCalled = true;
          method.call(thisPromise, x);
        }
      };
    }
    return {resolve:firstCallWins(this.resolveTo_), reject:firstCallWins(this.reject_)};
  };
  PolyfillPromise.prototype.resolveTo_ = function(value) {
    if (value === this) {
      this.reject_(new TypeError('A Promise cannot resolve to itself'));
    } else {
      if (value instanceof PolyfillPromise) {
        this.settleSameAsPromise_(value);
      } else {
        if (isObject(value)) {
          this.resolveToNonPromiseObj_(value);
        } else {
          this.fulfill_(value);
        }
      }
    }
  };
  PolyfillPromise.prototype.resolveToNonPromiseObj_ = function(obj) {
    var thenMethod = undefined;
    try {
      thenMethod = obj.then;
    } catch (error) {
      this.reject_(error);
      return;
    }
    if (typeof thenMethod == 'function') {
      this.settleSameAsThenable_(thenMethod, obj);
    } else {
      this.fulfill_(obj);
    }
  };
  function isObject(value) {
    switch(typeof value) {
      case 'object':
        return value != null;
      case 'function':
        return true;
      default:
        return false;
    }
  }
  PolyfillPromise.prototype.reject_ = function(reason) {
    this.settle_(PromiseState.REJECTED, reason);
  };
  PolyfillPromise.prototype.fulfill_ = function(value) {
    this.settle_(PromiseState.FULFILLED, value);
  };
  PolyfillPromise.prototype.settle_ = function(settledState, valueOrReason) {
    if (this.state_ != PromiseState.PENDING) {
      throw new Error('Cannot settle(' + settledState + ', ' + valueOrReason + '): Promise already settled in state' + this.state_);
    }
    this.state_ = settledState;
    this.result_ = valueOrReason;
    this.executeOnSettledCallbacks_();
  };
  PolyfillPromise.prototype.executeOnSettledCallbacks_ = function() {
    if (this.onSettledCallbacks_ != null) {
      for (var i = 0; i < this.onSettledCallbacks_.length; ++i) {
        asyncExecutor.asyncExecute(this.onSettledCallbacks_[i]);
      }
      this.onSettledCallbacks_ = null;
    }
  };
  var asyncExecutor = new AsyncExecutor;
  PolyfillPromise.prototype.settleSameAsPromise_ = function(promise) {
    var methods = this.createResolveAndReject_();
    promise.callWhenSettled_(methods.resolve, methods.reject);
  };
  PolyfillPromise.prototype.settleSameAsThenable_ = function(thenMethod, thenable) {
    var methods = this.createResolveAndReject_();
    try {
      thenMethod.call(thenable, methods.resolve, methods.reject);
    } catch (error) {
      methods.reject(error);
    }
  };
  PolyfillPromise.prototype.then = function(onFulfilled, onRejected) {
    var resolveChild;
    var rejectChild;
    var childPromise = new PolyfillPromise(function(resolve, reject) {
      resolveChild = resolve;
      rejectChild = reject;
    });
    function createCallback(paramF, defaultF) {
      if (typeof paramF == 'function') {
        return function(x) {
          try {
            resolveChild(paramF(x));
          } catch (error) {
            rejectChild(error);
          }
        };
      } else {
        return defaultF;
      }
    }
    this.callWhenSettled_(createCallback(onFulfilled, resolveChild), createCallback(onRejected, rejectChild));
    return childPromise;
  };
  PolyfillPromise.prototype['catch'] = function(onRejected) {
    return this.then(undefined, onRejected);
  };
  PolyfillPromise.prototype.callWhenSettled_ = function(onFulfilled, onRejected) {
    var thisPromise = this;
    function callback() {
      switch(thisPromise.state_) {
        case PromiseState.FULFILLED:
          onFulfilled(thisPromise.result_);
          break;
        case PromiseState.REJECTED:
          onRejected(thisPromise.result_);
          break;
        default:
          throw new Error('Unexpected state: ' + thisPromise.state_);
      }
    }
    if (this.onSettledCallbacks_ == null) {
      asyncExecutor.asyncExecute(callback);
    } else {
      this.onSettledCallbacks_.push(callback);
    }
  };
  function resolvingPromise(opt_value) {
    if (opt_value instanceof PolyfillPromise) {
      return opt_value;
    } else {
      return new PolyfillPromise(function(resolve, reject) {
        resolve(opt_value);
      });
    }
  }
  PolyfillPromise['resolve'] = resolvingPromise;
  PolyfillPromise['reject'] = function(opt_reason) {
    return new PolyfillPromise(function(resolve, reject) {
      reject(opt_reason);
    });
  };
  PolyfillPromise['race'] = function(thenablesOrValues) {
    return new PolyfillPromise(function(resolve, reject) {
      var iterator = $jscomp.makeIterator(thenablesOrValues);
      for (var iterRec = iterator.next(); !iterRec.done; iterRec = iterator.next()) {
        resolvingPromise(iterRec.value).callWhenSettled_(resolve, reject);
      }
    });
  };
  PolyfillPromise['all'] = function(thenablesOrValues) {
    var iterator = $jscomp.makeIterator(thenablesOrValues);
    var iterRec = iterator.next();
    if (iterRec.done) {
      return resolvingPromise([]);
    } else {
      return new PolyfillPromise(function(resolveAll, rejectAll) {
        var resultsArray = [];
        var unresolvedCount = 0;
        function onFulfilled(i) {
          return function(ithResult) {
            resultsArray[i] = ithResult;
            unresolvedCount--;
            if (unresolvedCount == 0) {
              resolveAll(resultsArray);
            }
          };
        }
        do {
          resultsArray.push(undefined);
          unresolvedCount++;
          resolvingPromise(iterRec.value).callWhenSettled_(onFulfilled(resultsArray.length - 1), rejectAll);
          iterRec = iterator.next();
        } while (!iterRec.done);
      });
    }
  };
  return PolyfillPromise;
}, 'es6', 'es3');
$jscomp.polyfill('Promise.prototype.finally', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(onFinally) {
    return this.then(function(value) {
      var promise = Promise.resolve(onFinally());
      return promise.then(function() {
        return value;
      });
    }, function(reason) {
      var promise = Promise.resolve(onFinally());
      return promise.then(function() {
        throw reason;
      });
    });
  };
  return polyfill;
}, 'es9', 'es3');
$jscomp.underscoreProtoCanBeSet = function() {
  var x = {a:true};
  var y = {};
  try {
    y.__proto__ = x;
    return y.a;
  } catch (e) {
  }
  return false;
};
$jscomp.setPrototypeOf = typeof Object.setPrototypeOf == 'function' ? Object.setPrototypeOf : $jscomp.underscoreProtoCanBeSet() ? function(target, proto) {
  target.__proto__ = proto;
  if (target.__proto__ !== proto) {
    throw new TypeError(target + ' is not extensible');
  }
  return target;
} : null;
$jscomp.generator = {};
$jscomp.generator.ensureIteratorResultIsObject_ = function(result) {
  if (result instanceof Object) {
    return;
  }
  throw new TypeError('Iterator result ' + result + ' is not an object');
};
$jscomp.generator.Context = function() {
  this.isRunning_ = false;
  this.yieldAllIterator_ = null;
  this.yieldResult = undefined;
  this.nextAddress = 1;
  this.catchAddress_ = 0;
  this.finallyAddress_ = 0;
  this.abruptCompletion_ = null;
  this.finallyContexts_ = null;
};
$jscomp.generator.Context.prototype.start_ = function() {
  if (this.isRunning_) {
    throw new TypeError('Generator is already running');
  }
  this.isRunning_ = true;
};
$jscomp.generator.Context.prototype.stop_ = function() {
  this.isRunning_ = false;
};
$jscomp.generator.Context.prototype.jumpToErrorHandler_ = function() {
  this.nextAddress = this.catchAddress_ || this.finallyAddress_;
};
$jscomp.generator.Context.prototype.next_ = function(value) {
  this.yieldResult = value;
};
$jscomp.generator.Context.prototype.throw_ = function(e) {
  this.abruptCompletion_ = {exception:e, isException:true};
  this.jumpToErrorHandler_();
};
$jscomp.generator.Context.prototype['return'] = function(value) {
  this.abruptCompletion_ = {'return':value};
  this.nextAddress = this.finallyAddress_;
};
$jscomp.generator.Context.prototype.jumpThroughFinallyBlocks = function(nextAddress) {
  this.abruptCompletion_ = {jumpTo:nextAddress};
  this.nextAddress = this.finallyAddress_;
};
$jscomp.generator.Context.prototype.yield = function(value, resumeAddress) {
  this.nextAddress = resumeAddress;
  return {value:value};
};
$jscomp.generator.Context.prototype.yieldAll = function(iterable, resumeAddress) {
  var iterator = $jscomp.makeIterator(iterable);
  var result = iterator.next();
  $jscomp.generator.ensureIteratorResultIsObject_(result);
  if (result.done) {
    this.yieldResult = result.value;
    this.nextAddress = resumeAddress;
    return;
  }
  this.yieldAllIterator_ = iterator;
  return this.yield(result.value, resumeAddress);
};
$jscomp.generator.Context.prototype.jumpTo = function(nextAddress) {
  this.nextAddress = nextAddress;
};
$jscomp.generator.Context.prototype.jumpToEnd = function() {
  this.nextAddress = 0;
};
$jscomp.generator.Context.prototype.setCatchFinallyBlocks = function(catchAddress, finallyAddress) {
  this.catchAddress_ = catchAddress;
  if (finallyAddress != undefined) {
    this.finallyAddress_ = finallyAddress;
  }
};
$jscomp.generator.Context.prototype.setFinallyBlock = function(finallyAddress) {
  this.catchAddress_ = 0;
  this.finallyAddress_ = finallyAddress || 0;
};
$jscomp.generator.Context.prototype.leaveTryBlock = function(nextAddress, catchAddress) {
  this.nextAddress = nextAddress;
  this.catchAddress_ = catchAddress || 0;
};
$jscomp.generator.Context.prototype.enterCatchBlock = function(nextCatchBlockAddress) {
  this.catchAddress_ = nextCatchBlockAddress || 0;
  var exception = this.abruptCompletion_.exception;
  this.abruptCompletion_ = null;
  return exception;
};
$jscomp.generator.Context.prototype.enterFinallyBlock = function(nextCatchAddress, nextFinallyAddress, finallyDepth) {
  if (!finallyDepth) {
    this.finallyContexts_ = [this.abruptCompletion_];
  } else {
    this.finallyContexts_[finallyDepth] = this.abruptCompletion_;
  }
  this.catchAddress_ = nextCatchAddress || 0;
  this.finallyAddress_ = nextFinallyAddress || 0;
};
$jscomp.generator.Context.prototype.leaveFinallyBlock = function(nextAddress, finallyDepth) {
  var preservedContext = this.finallyContexts_.splice(finallyDepth || 0)[0];
  var abruptCompletion = this.abruptCompletion_ = this.abruptCompletion_ || preservedContext;
  if (abruptCompletion) {
    if (abruptCompletion.isException) {
      return this.jumpToErrorHandler_();
    }
    if (abruptCompletion.jumpTo != undefined && this.finallyAddress_ < abruptCompletion.jumpTo) {
      this.nextAddress = abruptCompletion.jumpTo;
      this.abruptCompletion_ = null;
    } else {
      this.nextAddress = this.finallyAddress_;
    }
  } else {
    this.nextAddress = nextAddress;
  }
};
$jscomp.generator.Context.prototype.forIn = function(object) {
  return new $jscomp.generator.Context.PropertyIterator(object);
};
$jscomp.generator.Context.PropertyIterator = function(object) {
  this.object_ = object;
  this.properties_ = [];
  for (var property in object) {
    this.properties_.push(property);
  }
  this.properties_.reverse();
};
$jscomp.generator.Context.PropertyIterator.prototype.getNext = function() {
  while (this.properties_.length > 0) {
    var property = this.properties_.pop();
    if (property in this.object_) {
      return property;
    }
  }
  return null;
};
$jscomp.generator.Engine_ = function(program) {
  this.context_ = new $jscomp.generator.Context;
  this.program_ = program;
};
$jscomp.generator.Engine_.prototype.next_ = function(value) {
  this.context_.start_();
  if (this.context_.yieldAllIterator_) {
    return this.yieldAllStep_(this.context_.yieldAllIterator_.next, value, this.context_.next_);
  }
  this.context_.next_(value);
  return this.nextStep_();
};
$jscomp.generator.Engine_.prototype.return_ = function(value) {
  this.context_.start_();
  var yieldAllIterator = this.context_.yieldAllIterator_;
  if (yieldAllIterator) {
    var returnFunction = 'return' in yieldAllIterator ? yieldAllIterator['return'] : function(v) {
      return {value:v, done:true};
    };
    return this.yieldAllStep_(returnFunction, value, this.context_['return']);
  }
  this.context_['return'](value);
  return this.nextStep_();
};
$jscomp.generator.Engine_.prototype.throw_ = function(exception) {
  this.context_.start_();
  if (this.context_.yieldAllIterator_) {
    return this.yieldAllStep_(this.context_.yieldAllIterator_['throw'], exception, this.context_.next_);
  }
  this.context_.throw_(exception);
  return this.nextStep_();
};
$jscomp.generator.Engine_.prototype.yieldAllStep_ = function(action, value, nextAction) {
  try {
    var result = action.call(this.context_.yieldAllIterator_, value);
    $jscomp.generator.ensureIteratorResultIsObject_(result);
    if (!result.done) {
      this.context_.stop_();
      return result;
    }
    var resultValue = result.value;
  } catch (e) {
    this.context_.yieldAllIterator_ = null;
    this.context_.throw_(e);
    return this.nextStep_();
  }
  this.context_.yieldAllIterator_ = null;
  nextAction.call(this.context_, resultValue);
  return this.nextStep_();
};
$jscomp.generator.Engine_.prototype.nextStep_ = function() {
  while (this.context_.nextAddress) {
    try {
      var yieldValue = this.program_(this.context_);
      if (yieldValue) {
        this.context_.stop_();
        return {value:yieldValue.value, done:false};
      }
    } catch (e) {
      this.context_.yieldResult = undefined;
      this.context_.throw_(e);
    }
  }
  this.context_.stop_();
  if (this.context_.abruptCompletion_) {
    var abruptCompletion = this.context_.abruptCompletion_;
    this.context_.abruptCompletion_ = null;
    if (abruptCompletion.isException) {
      throw abruptCompletion.exception;
    }
    return {value:abruptCompletion['return'], done:true};
  }
  return {value:undefined, done:true};
};
$jscomp.generator.Generator_ = function(engine) {
  this.next = function(opt_value) {
    return engine.next_(opt_value);
  };
  this['throw'] = function(exception) {
    return engine.throw_(exception);
  };
  this['return'] = function(value) {
    return engine.return_(value);
  };
  $jscomp.initSymbolIterator();
  $jscomp.initSymbol();
  $jscomp.initSymbolIterator();
  this[Symbol.iterator] = function() {
    return this;
  };
};
$jscomp.generator.createGenerator = function(generator, program) {
  var result = new $jscomp.generator.Generator_(new $jscomp.generator.Engine_(program));
  if ($jscomp.setPrototypeOf) {
    $jscomp.setPrototypeOf(result, generator.prototype);
  }
  return result;
};
$jscomp.asyncExecutePromiseGenerator = function(generator) {
  function passValueToGenerator(value) {
    return generator.next(value);
  }
  function passErrorToGenerator(error) {
    return generator['throw'](error);
  }
  return new Promise(function(resolve, reject) {
    function handleGeneratorRecord(genRec) {
      if (genRec.done) {
        resolve(genRec.value);
      } else {
        Promise.resolve(genRec.value).then(passValueToGenerator, passErrorToGenerator).then(handleGeneratorRecord, reject);
      }
    }
    handleGeneratorRecord(generator.next());
  });
};
$jscomp.asyncExecutePromiseGeneratorFunction = function(generatorFunction) {
  return $jscomp.asyncExecutePromiseGenerator(generatorFunction());
};
$jscomp.asyncExecutePromiseGeneratorProgram = function(program) {
  return $jscomp.asyncExecutePromiseGenerator(new $jscomp.generator.Generator_(new $jscomp.generator.Engine_(program)));
};
$jscomp.checkEs6ConformanceViaProxy = function() {
  try {
    var proxied = {};
    var proxy = Object.create(new $jscomp.global['Proxy'](proxied, {'get':function(target, key, receiver) {
      return target == proxied && key == 'q' && receiver == proxy;
    }}));
    return proxy['q'] === true;
  } catch (err) {
    return false;
  }
};
$jscomp.USE_PROXY_FOR_ES6_CONFORMANCE_CHECKS = false;
$jscomp.ES6_CONFORMANCE = $jscomp.USE_PROXY_FOR_ES6_CONFORMANCE_CHECKS && $jscomp.checkEs6ConformanceViaProxy();
$jscomp.owns = function(obj, prop) {
  return Object.prototype.hasOwnProperty.call(obj, prop);
};
$jscomp.polyfill('WeakMap', function(NativeWeakMap) {
  function isConformant() {
    if (!NativeWeakMap || !Object.seal) {
      return false;
    }
    try {
      var x = Object.seal({});
      var y = Object.seal({});
      var map = new NativeWeakMap([[x, 2], [y, 3]]);
      if (map.get(x) != 2 || map.get(y) != 3) {
        return false;
      }
      map['delete'](x);
      map.set(y, 4);
      return !map.has(x) && map.get(y) == 4;
    } catch (err) {
      return false;
    }
  }
  if ($jscomp.USE_PROXY_FOR_ES6_CONFORMANCE_CHECKS) {
    if (NativeWeakMap && $jscomp.ES6_CONFORMANCE) {
      return NativeWeakMap;
    }
  } else {
    if (isConformant()) {
      return NativeWeakMap;
    }
  }
  var prop = '$jscomp_hidden_' + Math.random();
  function insert(target) {
    if (!$jscomp.owns(target, prop)) {
      var obj = {};
      $jscomp.defineProperty(target, prop, {value:obj});
    }
  }
  function patch(name) {
    var prev = Object[name];
    if (prev) {
      Object[name] = function(target) {
        insert(target);
        return prev(target);
      };
    }
  }
  patch('freeze');
  patch('preventExtensions');
  patch('seal');
  var index = 0;
  var PolyfillWeakMap = function(opt_iterable) {
    this.id_ = (index += Math.random() + 1).toString();
    if (opt_iterable) {
      $jscomp.initSymbol();
      $jscomp.initSymbolIterator();
      var iter = $jscomp.makeIterator(opt_iterable);
      var entry;
      while (!(entry = iter.next()).done) {
        var item = entry.value;
        this.set(item[0], item[1]);
      }
    }
  };
  PolyfillWeakMap.prototype.set = function(key, value) {
    insert(key);
    if (!$jscomp.owns(key, prop)) {
      throw new Error('WeakMap key fail: ' + key);
    }
    key[prop][this.id_] = value;
    return this;
  };
  PolyfillWeakMap.prototype.get = function(key) {
    return $jscomp.owns(key, prop) ? key[prop][this.id_] : undefined;
  };
  PolyfillWeakMap.prototype.has = function(key) {
    return $jscomp.owns(key, prop) && $jscomp.owns(key[prop], this.id_);
  };
  PolyfillWeakMap.prototype['delete'] = function(key) {
    if (!$jscomp.owns(key, prop) || !$jscomp.owns(key[prop], this.id_)) {
      return false;
    }
    return delete key[prop][this.id_];
  };
  return PolyfillWeakMap;
}, 'es6', 'es3');
$jscomp.MapEntry = function() {
  this.previous;
  this.next;
  this.head;
  this.key;
  this.value;
};
$jscomp.polyfill('Map', function(NativeMap) {
  function isConformant() {
    if ($jscomp.ASSUME_NO_NATIVE_MAP || !NativeMap || typeof NativeMap != 'function' || !NativeMap.prototype.entries || typeof Object.seal != 'function') {
      return false;
    }
    try {
      NativeMap = NativeMap;
      var key = Object.seal({x:4});
      var map = new NativeMap($jscomp.makeIterator([[key, 's']]));
      if (map.get(key) != 's' || map.size != 1 || map.get({x:4}) || map.set({x:4}, 't') != map || map.size != 2) {
        return false;
      }
      var iter = map.entries();
      var item = iter.next();
      if (item.done || item.value[0] != key || item.value[1] != 's') {
        return false;
      }
      item = iter.next();
      if (item.done || item.value[0].x != 4 || item.value[1] != 't' || !iter.next().done) {
        return false;
      }
      return true;
    } catch (err) {
      return false;
    }
  }
  if ($jscomp.USE_PROXY_FOR_ES6_CONFORMANCE_CHECKS) {
    if (NativeMap && $jscomp.ES6_CONFORMANCE) {
      return NativeMap;
    }
  } else {
    if (isConformant()) {
      return NativeMap;
    }
  }
  $jscomp.initSymbol();
  $jscomp.initSymbolIterator();
  var idMap = new WeakMap;
  var PolyfillMap = function(opt_iterable) {
    this.data_ = {};
    this.head_ = createHead();
    this.size = 0;
    if (opt_iterable) {
      var iter = $jscomp.makeIterator(opt_iterable);
      var entry;
      while (!(entry = iter.next()).done) {
        var item = entry.value;
        this.set(item[0], item[1]);
      }
    }
  };
  PolyfillMap.prototype.set = function(key, value) {
    key = key === 0 ? 0 : key;
    var r = maybeGetEntry(this, key);
    if (!r.list) {
      r.list = this.data_[r.id] = [];
    }
    if (!r.entry) {
      r.entry = {next:this.head_, previous:this.head_.previous, head:this.head_, key:key, value:value};
      r.list.push(r.entry);
      this.head_.previous.next = r.entry;
      this.head_.previous = r.entry;
      this.size++;
    } else {
      r.entry.value = value;
    }
    return this;
  };
  PolyfillMap.prototype['delete'] = function(key) {
    var r = maybeGetEntry(this, key);
    if (r.entry && r.list) {
      r.list.splice(r.index, 1);
      if (!r.list.length) {
        delete this.data_[r.id];
      }
      r.entry.previous.next = r.entry.next;
      r.entry.next.previous = r.entry.previous;
      r.entry.head = null;
      this.size--;
      return true;
    }
    return false;
  };
  PolyfillMap.prototype.clear = function() {
    this.data_ = {};
    this.head_ = this.head_.previous = createHead();
    this.size = 0;
  };
  PolyfillMap.prototype.has = function(key) {
    return !!maybeGetEntry(this, key).entry;
  };
  PolyfillMap.prototype.get = function(key) {
    var entry = maybeGetEntry(this, key).entry;
    return entry && entry.value;
  };
  PolyfillMap.prototype.entries = function() {
    return makeIterator(this, function(entry) {
      return [entry.key, entry.value];
    });
  };
  PolyfillMap.prototype.keys = function() {
    return makeIterator(this, function(entry) {
      return entry.key;
    });
  };
  PolyfillMap.prototype.values = function() {
    return makeIterator(this, function(entry) {
      return entry.value;
    });
  };
  PolyfillMap.prototype.forEach = function(callback, opt_thisArg) {
    var iter = this.entries();
    var item;
    while (!(item = iter.next()).done) {
      var entry = item.value;
      callback.call(opt_thisArg, entry[1], entry[0], this);
    }
  };
  $jscomp.initSymbol();
  $jscomp.initSymbolIterator();
  PolyfillMap.prototype[Symbol.iterator] = PolyfillMap.prototype.entries;
  var maybeGetEntry = function(map, key) {
    var id = getId(key);
    var list = map.data_[id];
    if (list && $jscomp.owns(map.data_, id)) {
      for (var index = 0; index < list.length; index++) {
        var entry = list[index];
        if (key !== key && entry.key !== entry.key || key === entry.key) {
          return {id:id, list:list, index:index, entry:entry};
        }
      }
    }
    return {id:id, list:list, index:-1, entry:undefined};
  };
  var makeIterator = function(map, func) {
    var entry = map.head_;
    return $jscomp.iteratorPrototype(function() {
      if (entry) {
        while (entry.head != map.head_) {
          entry = entry.previous;
        }
        while (entry.next != entry.head) {
          entry = entry.next;
          return {done:false, value:func(entry)};
        }
        entry = null;
      }
      return {done:true, value:void 0};
    });
  };
  var createHead = function() {
    var head = {};
    head.previous = head.next = head.head = head;
    return head;
  };
  var mapIndex = 0;
  var getId = function(obj) {
    var type = obj && typeof obj;
    if (type == 'object' || type == 'function') {
      obj = obj;
      if (!idMap.has(obj)) {
        var id = '' + ++mapIndex;
        idMap.set(obj, id);
        return id;
      }
      return idMap.get(obj);
    }
    return 'p_' + obj;
  };
  return PolyfillMap;
}, 'es6', 'es3');
$jscomp.polyfill('Math.acosh', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    x = Number(x);
    return Math.log(x + Math.sqrt(x * x - 1));
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Math.asinh', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    x = Number(x);
    if (x === 0) {
      return x;
    }
    var y = Math.log(Math.abs(x) + Math.sqrt(x * x + 1));
    return x < 0 ? -y : y;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Math.log1p', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    x = Number(x);
    if (x < 0.25 && x > -0.25) {
      var y = x;
      var d = 1;
      var z = x;
      var zPrev = 0;
      var s = 1;
      while (zPrev != z) {
        y *= x;
        s *= -1;
        z = (zPrev = z) + s * y / ++d;
      }
      return z;
    }
    return Math.log(1 + x);
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Math.atanh', function(orig) {
  if (orig) {
    return orig;
  }
  var log1p = Math.log1p;
  var polyfill = function(x) {
    x = Number(x);
    return (log1p(x) - log1p(-x)) / 2;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Math.cbrt', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    if (x === 0) {
      return x;
    }
    x = Number(x);
    var y = Math.pow(Math.abs(x), 1 / 3);
    return x < 0 ? -y : y;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Math.clz32', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    x = Number(x) >>> 0;
    if (x === 0) {
      return 32;
    }
    var result = 0;
    if ((x & 4294901760) === 0) {
      x <<= 16;
      result += 16;
    }
    if ((x & 4278190080) === 0) {
      x <<= 8;
      result += 8;
    }
    if ((x & 4026531840) === 0) {
      x <<= 4;
      result += 4;
    }
    if ((x & 3221225472) === 0) {
      x <<= 2;
      result += 2;
    }
    if ((x & 2147483648) === 0) {
      result++;
    }
    return result;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Math.cosh', function(orig) {
  if (orig) {
    return orig;
  }
  var exp = Math.exp;
  var polyfill = function(x) {
    x = Number(x);
    return (exp(x) + exp(-x)) / 2;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Math.expm1', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    x = Number(x);
    if (x < .25 && x > -.25) {
      var y = x;
      var d = 1;
      var z = x;
      var zPrev = 0;
      while (zPrev != z) {
        y *= x / ++d;
        z = (zPrev = z) + y;
      }
      return z;
    }
    return Math.exp(x) - 1;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Math.hypot', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x, y, var_args) {
    x = Number(x);
    y = Number(y);
    var i, z, sum;
    var max = Math.max(Math.abs(x), Math.abs(y));
    for (i = 2; i < arguments.length; i++) {
      max = Math.max(max, Math.abs(arguments[i]));
    }
    if (max > 1e100 || max < 1e-100) {
      if (!max) {
        return max;
      }
      x = x / max;
      y = y / max;
      sum = x * x + y * y;
      for (i = 2; i < arguments.length; i++) {
        z = Number(arguments[i]) / max;
        sum += z * z;
      }
      return Math.sqrt(sum) * max;
    } else {
      sum = x * x + y * y;
      for (i = 2; i < arguments.length; i++) {
        z = Number(arguments[i]);
        sum += z * z;
      }
      return Math.sqrt(sum);
    }
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Math.imul', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(a, b) {
    a = Number(a);
    b = Number(b);
    var ah = a >>> 16 & 65535;
    var al = a & 65535;
    var bh = b >>> 16 & 65535;
    var bl = b & 65535;
    var lh = ah * bl + al * bh << 16 >>> 0;
    return al * bl + lh | 0;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Math.log10', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    return Math.log(x) / Math.LN10;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Math.log2', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    return Math.log(x) / Math.LN2;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Math.sign', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    x = Number(x);
    return x === 0 || isNaN(x) ? x : x > 0 ? 1 : -1;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Math.sinh', function(orig) {
  if (orig) {
    return orig;
  }
  var exp = Math.exp;
  var polyfill = function(x) {
    x = Number(x);
    if (x === 0) {
      return x;
    }
    return (exp(x) - exp(-x)) / 2;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Math.tanh', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    x = Number(x);
    if (x === 0) {
      return x;
    }
    var y = Math.exp(-2 * Math.abs(x));
    var z = (1 - y) / (1 + y);
    return x < 0 ? -z : z;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Math.trunc', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    x = Number(x);
    if (isNaN(x) || x === Infinity || x === -Infinity || x === 0) {
      return x;
    }
    var y = Math.floor(Math.abs(x));
    return x < 0 ? -y : y;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Number.EPSILON', function(orig) {
  return Math.pow(2, -52);
}, 'es6', 'es3');
$jscomp.polyfill('Number.MAX_SAFE_INTEGER', function() {
  return 9007199254740991;
}, 'es6', 'es3');
$jscomp.polyfill('Number.MIN_SAFE_INTEGER', function() {
  return -9007199254740991;
}, 'es6', 'es3');
$jscomp.polyfill('Number.isFinite', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    if (typeof x !== 'number') {
      return false;
    }
    return !isNaN(x) && x !== Infinity && x !== -Infinity;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Number.isInteger', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    if (!Number.isFinite(x)) {
      return false;
    }
    return x === Math.floor(x);
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Number.isNaN', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    return typeof x === 'number' && isNaN(x);
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Number.isSafeInteger', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(x) {
    return Number.isInteger(x) && Math.abs(x) <= Number.MAX_SAFE_INTEGER;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Number.parseFloat', function(orig) {
  return orig || parseFloat;
}, 'es6', 'es3');
$jscomp.polyfill('Number.parseInt', function(orig) {
  return orig || parseInt;
}, 'es6', 'es3');
$jscomp.assign = typeof Object.assign == 'function' ? Object.assign : function(target, var_args) {
  for (var i = 1; i < arguments.length; i++) {
    var source = arguments[i];
    if (!source) {
      continue;
    }
    for (var key in source) {
      if ($jscomp.owns(source, key)) {
        target[key] = source[key];
      }
    }
  }
  return target;
};
$jscomp.polyfill('Object.assign', function(orig) {
  return orig || $jscomp.assign;
}, 'es6', 'es3');
$jscomp.polyfill('Object.entries', function(orig) {
  if (orig) {
    return orig;
  }
  var entries = function(obj) {
    var result = [];
    for (var key in obj) {
      if ($jscomp.owns(obj, key)) {
        result.push([key, obj[key]]);
      }
    }
    return result;
  };
  return entries;
}, 'es8', 'es3');
$jscomp.polyfill('Object.getOwnPropertySymbols', function(orig) {
  if (orig) {
    return orig;
  }
  return function() {
    return [];
  };
}, 'es6', 'es5');
$jscomp.polyfill('Reflect.ownKeys', function(orig) {
  if (orig) {
    return orig;
  }
  var symbolPrefix = 'jscomp_symbol_';
  function isSymbol(key) {
    return key.substring(0, symbolPrefix.length) == symbolPrefix;
  }
  var polyfill = function(target) {
    var keys = [];
    var names = Object.getOwnPropertyNames(target);
    var symbols = Object.getOwnPropertySymbols(target);
    for (var i = 0; i < names.length; i++) {
      (isSymbol(names[i]) ? symbols : keys).push(names[i]);
    }
    return keys.concat(symbols);
  };
  return polyfill;
}, 'es6', 'es5');
$jscomp.polyfill('Object.getOwnPropertyDescriptors', function(orig) {
  if (orig) {
    return orig;
  }
  var getOwnPropertyDescriptors = function(obj) {
    var result = {};
    var keys = Reflect.ownKeys(obj);
    for (var i = 0; i < keys.length; i++) {
      result[keys[i]] = Object.getOwnPropertyDescriptor(obj, keys[i]);
    }
    return result;
  };
  return getOwnPropertyDescriptors;
}, 'es8', 'es5');
$jscomp.polyfill('Object.setPrototypeOf', function(orig) {
  return orig || $jscomp.setPrototypeOf;
}, 'es6', 'es5');
$jscomp.polyfill('Object.values', function(orig) {
  if (orig) {
    return orig;
  }
  var values = function(obj) {
    var result = [];
    for (var key in obj) {
      if ($jscomp.owns(obj, key)) {
        result.push(obj[key]);
      }
    }
    return result;
  };
  return values;
}, 'es8', 'es3');
$jscomp.polyfill('Reflect.apply', function(orig) {
  if (orig) {
    return orig;
  }
  var apply = Function.prototype.apply;
  var polyfill = function(target, thisArg, argList) {
    return apply.call(target, thisArg, argList);
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.objectCreate = $jscomp.ASSUME_ES5 || typeof Object.create == 'function' ? Object.create : function(prototype) {
  var ctor = function() {
  };
  ctor.prototype = prototype;
  return new ctor;
};
$jscomp.construct = function() {
  function reflectConstructWorks() {
    function Base() {
    }
    function Derived() {
    }
    new Base;
    Reflect.construct(Base, [], Derived);
    return new Base instanceof Base;
  }
  if (typeof Reflect != 'undefined' && Reflect.construct) {
    if (reflectConstructWorks()) {
      return Reflect.construct;
    }
    var brokenConstruct = Reflect.construct;
    var patchedConstruct = function(target, argList, opt_newTarget) {
      var out = brokenConstruct(target, argList);
      if (opt_newTarget) {
        Reflect.setPrototypeOf(out, opt_newTarget.prototype);
      }
      return out;
    };
    return patchedConstruct;
  }
  function construct(target, argList, opt_newTarget) {
    if (opt_newTarget === undefined) {
      opt_newTarget = target;
    }
    var proto = opt_newTarget.prototype || Object.prototype;
    var obj = $jscomp.objectCreate(proto);
    var apply = Function.prototype.apply;
    var out = apply.call(target, obj, argList);
    return out || obj;
  }
  return construct;
}();
$jscomp.polyfill('Reflect.construct', function(orig) {
  return $jscomp.construct;
}, 'es6', 'es3');
$jscomp.polyfill('Reflect.defineProperty', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(target, propertyKey, attributes) {
    try {
      Object.defineProperty(target, propertyKey, attributes);
      var desc = Object.getOwnPropertyDescriptor(target, propertyKey);
      if (!desc) {
        return false;
      }
      return desc.configurable === (attributes.configurable || false) && desc.enumerable === (attributes.enumerable || false) && ('value' in desc ? desc.value === attributes.value && desc.writable === (attributes.writable || false) : desc.get === attributes.get && desc.set === attributes.set);
    } catch (err) {
      return false;
    }
  };
  return polyfill;
}, 'es6', 'es5');
$jscomp.polyfill('Reflect.deleteProperty', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(target, propertyKey) {
    if (!$jscomp.owns(target, propertyKey)) {
      return true;
    }
    try {
      return delete target[propertyKey];
    } catch (err) {
      return false;
    }
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Reflect.getOwnPropertyDescriptor', function(orig) {
  return orig || Object.getOwnPropertyDescriptor;
}, 'es6', 'es5');
$jscomp.polyfill('Reflect.getPrototypeOf', function(orig) {
  return orig || Object.getPrototypeOf;
}, 'es6', 'es5');
$jscomp.findDescriptor = function(target, propertyKey) {
  var obj = target;
  while (obj) {
    var property = Reflect.getOwnPropertyDescriptor(obj, propertyKey);
    if (property) {
      return property;
    }
    obj = Reflect.getPrototypeOf(obj);
  }
  return undefined;
};
$jscomp.polyfill('Reflect.get', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(target, propertyKey, opt_receiver) {
    if (arguments.length <= 2) {
      return target[propertyKey];
    }
    var property = $jscomp.findDescriptor(target, propertyKey);
    if (property) {
      return property.get ? property.get.call(opt_receiver) : property.value;
    }
    return undefined;
  };
  return polyfill;
}, 'es6', 'es5');
$jscomp.polyfill('Reflect.has', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(target, propertyKey) {
    return propertyKey in target;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Reflect.isExtensible', function(orig) {
  if (orig) {
    return orig;
  }
  if ($jscomp.ASSUME_ES5 || typeof Object.isExtensible == 'function') {
    return Object.isExtensible;
  }
  return function() {
    return true;
  };
}, 'es6', 'es3');
$jscomp.polyfill('Reflect.preventExtensions', function(orig) {
  if (orig) {
    return orig;
  }
  if (!($jscomp.ASSUME_ES5 || typeof Object.preventExtensions == 'function')) {
    return function() {
      return false;
    };
  }
  var polyfill = function(target) {
    Object.preventExtensions(target);
    return !Object.isExtensible(target);
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('Reflect.set', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(target, propertyKey, value, opt_receiver) {
    var property = $jscomp.findDescriptor(target, propertyKey);
    if (!property) {
      if (Reflect.isExtensible(target)) {
        target[propertyKey] = value;
        return true;
      }
      return false;
    }
    if (property.set) {
      property.set.call(arguments.length > 3 ? opt_receiver : target, value);
      return true;
    } else {
      if (property.writable && !Object.isFrozen(target)) {
        target[propertyKey] = value;
        return true;
      }
    }
    return false;
  };
  return polyfill;
}, 'es6', 'es5');
$jscomp.polyfill('Reflect.setPrototypeOf', function(orig) {
  if (orig) {
    return orig;
  } else {
    if ($jscomp.setPrototypeOf) {
      var setPrototypeOf = $jscomp.setPrototypeOf;
      var polyfill = function(target, proto) {
        try {
          setPrototypeOf(target, proto);
          return true;
        } catch (e) {
          return false;
        }
      };
      return polyfill;
    } else {
      return null;
    }
  }
}, 'es6', 'es5');
$jscomp.polyfill('Set', function(NativeSet) {
  function isConformant() {
    if ($jscomp.ASSUME_NO_NATIVE_SET || !NativeSet || typeof NativeSet != 'function' || !NativeSet.prototype.entries || typeof Object.seal != 'function') {
      return false;
    }
    try {
      NativeSet = NativeSet;
      var value = Object.seal({x:4});
      var set = new NativeSet($jscomp.makeIterator([value]));
      if (!set.has(value) || set.size != 1 || set.add(value) != set || set.size != 1 || set.add({x:4}) != set || set.size != 2) {
        return false;
      }
      var iter = set.entries();
      var item = iter.next();
      if (item.done || item.value[0] != value || item.value[1] != value) {
        return false;
      }
      item = iter.next();
      if (item.done || item.value[0] == value || item.value[0].x != 4 || item.value[1] != item.value[0]) {
        return false;
      }
      return iter.next().done;
    } catch (err) {
      return false;
    }
  }
  if ($jscomp.USE_PROXY_FOR_ES6_CONFORMANCE_CHECKS) {
    if (NativeSet && $jscomp.ES6_CONFORMANCE) {
      return NativeSet;
    }
  } else {
    if (isConformant()) {
      return NativeSet;
    }
  }
  $jscomp.initSymbol();
  $jscomp.initSymbolIterator();
  var PolyfillSet = function(opt_iterable) {
    this.map_ = new Map;
    if (opt_iterable) {
      var iter = $jscomp.makeIterator(opt_iterable);
      var entry;
      while (!(entry = iter.next()).done) {
        var item = entry.value;
        this.add(item);
      }
    }
    this.size = this.map_.size;
  };
  PolyfillSet.prototype.add = function(value) {
    value = value === 0 ? 0 : value;
    this.map_.set(value, value);
    this.size = this.map_.size;
    return this;
  };
  PolyfillSet.prototype['delete'] = function(value) {
    var result = this.map_['delete'](value);
    this.size = this.map_.size;
    return result;
  };
  PolyfillSet.prototype.clear = function() {
    this.map_.clear();
    this.size = 0;
  };
  PolyfillSet.prototype.has = function(value) {
    return this.map_.has(value);
  };
  PolyfillSet.prototype.entries = function() {
    return this.map_.entries();
  };
  PolyfillSet.prototype.values = function() {
    return this.map_.values();
  };
  PolyfillSet.prototype.keys = PolyfillSet.prototype.values;
  $jscomp.initSymbol();
  $jscomp.initSymbolIterator();
  PolyfillSet.prototype[Symbol.iterator] = PolyfillSet.prototype.values;
  PolyfillSet.prototype.forEach = function(callback, opt_thisArg) {
    var set = this;
    this.map_.forEach(function(value) {
      return callback.call(opt_thisArg, value, value, set);
    });
  };
  return PolyfillSet;
}, 'es6', 'es3');
$jscomp.checkStringArgs = function(thisArg, arg, func) {
  if (thisArg == null) {
    throw new TypeError("The 'this' value for String.prototype." + func + ' must not be null or undefined');
  }
  if (arg instanceof RegExp) {
    throw new TypeError('First argument to String.prototype.' + func + ' must not be a regular expression');
  }
  return thisArg + '';
};
$jscomp.polyfill('String.prototype.codePointAt', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(position) {
    var string = $jscomp.checkStringArgs(this, null, 'codePointAt');
    var size = string.length;
    position = Number(position) || 0;
    if (!(position >= 0 && position < size)) {
      return void 0;
    }
    position = position | 0;
    var first = string.charCodeAt(position);
    if (first < 55296 || first > 56319 || position + 1 === size) {
      return first;
    }
    var second = string.charCodeAt(position + 1);
    if (second < 56320 || second > 57343) {
      return first;
    }
    return (first - 55296) * 1024 + second + 9216;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('String.prototype.endsWith', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(searchString, opt_position) {
    var string = $jscomp.checkStringArgs(this, searchString, 'endsWith');
    searchString = searchString + '';
    if (opt_position === void 0) {
      opt_position = string.length;
    }
    var i = Math.max(0, Math.min(opt_position | 0, string.length));
    var j = searchString.length;
    while (j > 0 && i > 0) {
      if (string[--i] != searchString[--j]) {
        return false;
      }
    }
    return j <= 0;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('String.fromCodePoint', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(var_args) {
    var result = '';
    for (var i = 0; i < arguments.length; i++) {
      var code = Number(arguments[i]);
      if (code < 0 || code > 1114111 || code !== Math.floor(code)) {
        throw new RangeError('invalid_code_point ' + code);
      }
      if (code <= 65535) {
        result += String.fromCharCode(code);
      } else {
        code -= 65536;
        result += String.fromCharCode(code >>> 10 & 1023 | 55296);
        result += String.fromCharCode(code & 1023 | 56320);
      }
    }
    return result;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('String.prototype.includes', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(searchString, opt_position) {
    var string = $jscomp.checkStringArgs(this, searchString, 'includes');
    return string.indexOf(searchString, opt_position || 0) !== -1;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.polyfill('String.prototype.repeat', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(copies) {
    var string = $jscomp.checkStringArgs(this, null, 'repeat');
    if (copies < 0 || copies > 1342177279) {
      throw new RangeError('Invalid count value');
    }
    copies = copies | 0;
    var result = '';
    while (copies) {
      if (copies & 1) {
        result += string;
      }
      if (copies >>>= 1) {
        string += string;
      }
    }
    return result;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.stringPadding = function(padString, padLength) {
  var padding = padString !== undefined ? String(padString) : ' ';
  if (!(padLength > 0) || !padding) {
    return '';
  }
  var repeats = Math.ceil(padLength / padding.length);
  return padding.repeat(repeats).substring(0, padLength);
};
$jscomp.polyfill('String.prototype.padEnd', function(orig) {
  if (orig) {
    return orig;
  }
  var padEnd = function(targetLength, opt_padString) {
    var string = $jscomp.checkStringArgs(this, null, 'padStart');
    var padLength = targetLength - string.length;
    return string + $jscomp.stringPadding(opt_padString, padLength);
  };
  return padEnd;
}, 'es8', 'es3');
$jscomp.polyfill('String.prototype.padStart', function(orig) {
  if (orig) {
    return orig;
  }
  var padStart = function(targetLength, opt_padString) {
    var string = $jscomp.checkStringArgs(this, null, 'padStart');
    var padLength = targetLength - string.length;
    return $jscomp.stringPadding(opt_padString, padLength) + string;
  };
  return padStart;
}, 'es8', 'es3');
$jscomp.polyfill('String.prototype.startsWith', function(orig) {
  if (orig) {
    return orig;
  }
  var polyfill = function(searchString, opt_position) {
    var string = $jscomp.checkStringArgs(this, searchString, 'startsWith');
    searchString = searchString + '';
    var strLen = string.length;
    var searchLen = searchString.length;
    var i = Math.max(0, Math.min(opt_position | 0, string.length));
    var j = 0;
    while (j < searchLen && i < strLen) {
      if (string[i++] != searchString[j++]) {
        return false;
      }
    }
    return j >= searchLen;
  };
  return polyfill;
}, 'es6', 'es3');
$jscomp.arrayFromIterator = function(iterator) {
  var i;
  var arr = [];
  while (!(i = iterator.next()).done) {
    arr.push(i.value);
  }
  return arr;
};
$jscomp.arrayFromIterable = function(iterable) {
  if (iterable instanceof Array) {
    return iterable;
  } else {
    return $jscomp.arrayFromIterator($jscomp.makeIterator(iterable));
  }
};
$jscomp.inherits = function(childCtor, parentCtor) {
  childCtor.prototype = $jscomp.objectCreate(parentCtor.prototype);
  childCtor.prototype.constructor = childCtor;
  if ($jscomp.setPrototypeOf) {
    var setPrototypeOf = $jscomp.setPrototypeOf;
    setPrototypeOf(childCtor, parentCtor);
  } else {
    for (var p in parentCtor) {
      if (p == 'prototype') {
        continue;
      }
      if (Object.defineProperties) {
        var descriptor = Object.getOwnPropertyDescriptor(parentCtor, p);
        if (descriptor) {
          Object.defineProperty(childCtor, p, descriptor);
        }
      } else {
        childCtor[p] = parentCtor[p];
      }
    }
  }
  childCtor.superClass_ = parentCtor.prototype;
};
$jscomp.polyfill('WeakSet', function(NativeWeakSet) {
  function isConformant() {
    if (!NativeWeakSet || !Object.seal) {
      return false;
    }
    try {
      var x = Object.seal({});
      var y = Object.seal({});
      var set = new NativeWeakSet([x]);
      if (!set.has(x) || set.has(y)) {
        return false;
      }
      set['delete'](x);
      set.add(y);
      return !set.has(x) && set.has(y);
    } catch (err) {
      return false;
    }
  }
  if ($jscomp.USE_PROXY_FOR_ES6_CONFORMANCE_CHECKS) {
    if (NativeWeakSet && $jscomp.ES6_CONFORMANCE) {
      return NativeWeakSet;
    }
  } else {
    if (isConformant()) {
      return NativeWeakSet;
    }
  }
  var PolyfillWeakSet = function(opt_iterable) {
    this.map_ = new WeakMap;
    if (opt_iterable) {
      $jscomp.initSymbol();
      $jscomp.initSymbolIterator();
      var iter = $jscomp.makeIterator(opt_iterable);
      var entry;
      while (!(entry = iter.next()).done) {
        var item = entry.value;
        this.add(item);
      }
    }
  };
  PolyfillWeakSet.prototype.add = function(elem) {
    this.map_.set(elem, true);
    return this;
  };
  PolyfillWeakSet.prototype.has = function(elem) {
    return this.map_.has(elem);
  };
  PolyfillWeakSet.prototype['delete'] = function(elem) {
    return this.map_['delete'](elem);
  };
  return PolyfillWeakSet;
}, 'es6', 'es3');
try {
  if (Array.prototype.values.toString().indexOf('[native code]') == -1) {
    delete Array.prototype.values;
  }
} catch (e) {
}
var Ext = Ext || {};
(function() {
  var global = this, objectPrototype = Object.prototype, toString = objectPrototype.toString, enumerables = ['valueOf', 'toLocaleString', 'toString', 'constructor'], emptyFn = Ext.fireIdle = function() {
  }, privateFn = function() {
  }, identityFn = function(o) {
    return o;
  }, callOverrideParent = function() {
    var method = callOverrideParent.caller.caller;
    return method.$owner.prototype[method.$name].apply(this, arguments);
  }, manifest = Ext.manifest || {}, i, iterableRe = /\[object\s*(?:Array|Arguments|\w*Collection|\w*List|HTML\s+document\.all\s+class)\]/, MSDateRe = /^\\?\/Date\(([-+])?(\d+)(?:[+-]\d{4})?\)\\?\/$/, elevateArgs, elevateFn, elevateRet, elevateScope;
  Ext.global = global;
  Ext.$nextIid = 0;
  Ext.now = Date.now || (Date.now = function() {
    return +new Date;
  });
  Ext.ticks = global.performance && global.performance.now ? function() {
    return performance.now();
  } : Ext.now;
  Ext._startTime = Ext.ticks();
  emptyFn.$nullFn = identityFn.$nullFn = emptyFn.$emptyFn = identityFn.$identityFn = privateFn.$nullFn = true;
  privateFn.$privacy = 'framework';
  emptyFn.$noClearOnDestroy = identityFn.$noClearOnDestroy = true;
  privateFn.$noClearOnDestroy = true;
  Ext['suspendLayouts'] = Ext['resumeLayouts'] = emptyFn;
  for (i in{toString:1}) {
    enumerables = null;
  }
  Ext.enumerables = enumerables;
  Ext.apply = function(object, config, defaults) {
    if (object) {
      if (defaults) {
        Ext.apply(object, defaults);
      }
      if (config && typeof config === 'object') {
        var i, j, k;
        for (i in config) {
          object[i] = config[i];
        }
        if (enumerables) {
          for (j = enumerables.length; j--;) {
            k = enumerables[j];
            if (config.hasOwnProperty(k)) {
              object[k] = config[k];
            }
          }
        }
      }
    }
    return object;
  };
  function addInstanceOverrides(target, owner, overrides) {
    var name, value;
    for (name in overrides) {
      if (overrides.hasOwnProperty(name)) {
        value = overrides[name];
        if (typeof value === 'function') {
          if (owner.$className) {
            value.name = owner.$className + '#' + name;
          }
          value.$name = name;
          value.$owner = owner;
          value.$previous = target.hasOwnProperty(name) ? target[name] : callOverrideParent;
        }
        target[name] = value;
      }
    }
  }
  Ext.buildSettings = Ext.apply({baseCSSPrefix:'x-'}, Ext.buildSettings || {});
  Ext.apply(Ext, {idSeed:0, idPrefix:'ext-', isRobot:false, isSecure:/^https/i.test(window.location.protocol), enableGarbageCollector:false, enableListenerCollection:true, name:Ext.sandboxName || 'Ext', privateFn:privateFn, emptyFn:emptyFn, identityFn:identityFn, frameStartTime:Ext.now(), manifest:manifest, debugConfig:Ext.debugConfig || manifest.debug || {hooks:{'*':true}}, enableAria:true, startsWithHashRe:/^#/, validIdRe:/^[a-z_][a-z0-9\-_]*$/i, BLANK_IMAGE_URL:'data:image/gif;base64,R0lGODlhAQABAID/AMDAwAAAACH5BAEAAAAALAAAAAABAAEAAAICRAEAOw\x3d\x3d', 
  makeIdSelector:function(id) {
    if (!Ext.validIdRe.test(id)) {
      Ext.raise('Invalid id selector: "' + id + '"');
    }
    return '#' + id;
  }, id:function(o, prefix) {
    if (o && o.id) {
      return o.id;
    }
    var id = (prefix || Ext.idPrefix) + ++Ext.idSeed;
    if (o) {
      o.id = id;
    }
    return id;
  }, returnId:function(o) {
    return o.getId();
  }, returnTrue:function() {
    return true;
  }, emptyString:new String, emptyArray:Object.freeze ? Object.freeze([]) : [], baseCSSPrefix:Ext.buildSettings.baseCSSPrefix, $eventNameMap:{}, $vendorEventRe:/^(DOMMouse|Moz.+|MS.+|webkit.+)/, canonicalEventName:function(name) {
    return Ext.$eventNameMap[name] || (Ext.$eventNameMap[name] = Ext.$vendorEventRe.test(name) ? name : name.toLowerCase());
  }, applyIf:function(object, config) {
    if (object && config && typeof config === 'object') {
      for (var property in config) {
        if (object[property] === undefined) {
          object[property] = config[property];
        }
      }
    }
    return object;
  }, destroy:function() {
    var ln = arguments.length, i, arg;
    for (i = 0; i < ln; i++) {
      arg = arguments[i];
      if (arg) {
        if (Ext.isArray(arg)) {
          this.destroy.apply(this, arg);
        } else {
          if (Ext.isFunction(arg.destroy) && !arg.destroyed) {
            arg.destroy();
          }
        }
      }
    }
    return null;
  }, destroyMembers:function(object) {
    for (var ref, name, i = 1, a = arguments, len = a.length; i < len; i++) {
      ref = object[name = a[i]];
      if (ref != null) {
        object[name] = Ext.destroy(ref);
      }
    }
  }, override:function(target, overrides) {
    if (target.$isClass) {
      target.override(overrides);
    } else {
      if (typeof target === 'function') {
        Ext.apply(target.prototype, overrides);
      } else {
        var owner = target.self, privates;
        if (owner && owner.$isClass) {
          privates = overrides.privates;
          if (privates) {
            overrides = Ext.apply({}, overrides);
            delete overrides.privates;
            addInstanceOverrides(target, owner, privates);
          }
          addInstanceOverrides(target, owner, overrides);
        } else {
          Ext.apply(target, overrides);
        }
      }
    }
    return target;
  }, valueFrom:function(value, defaultValue, allowBlank) {
    return Ext.isEmpty(value, allowBlank) ? defaultValue : value;
  }, isEmpty:function(value, allowEmptyString) {
    return value == null || (!allowEmptyString ? value === '' : false) || Ext.isArray(value) && value.length === 0;
  }, isArray:'isArray' in Array ? Array.isArray : function(value) {
    return toString.call(value) === '[object Array]';
  }, isDate:function(obj) {
    return toString.call(obj) === '[object Date]';
  }, isMSDate:function(value) {
    if (!Ext.isString(value)) {
      return false;
    }
    return MSDateRe.test(value);
  }, isObject:toString.call(null) === '[object Object]' ? function(value) {
    return value != null && toString.call(value) === '[object Object]' && value.ownerDocument === undefined;
  } : function(value) {
    return toString.call(value) === '[object Object]';
  }, isSimpleObject:function(value) {
    return value instanceof Object && value.constructor === Object;
  }, isPrimitive:function(value) {
    var type = typeof value;
    return type === 'string' || type === 'number' || type === 'boolean';
  }, isFunction:typeof document !== 'undefined' && typeof document.getElementsByTagName('body') === 'function' ? function(value) {
    return !!value && toString.call(value) === '[object Function]';
  } : function(value) {
    return !!value && typeof value === 'function';
  }, isNumber:function(value) {
    return typeof value === 'number' && isFinite(value);
  }, isNumeric:function(value) {
    return !isNaN(parseFloat(value)) && isFinite(value);
  }, isString:function(value) {
    return typeof value === 'string';
  }, isBoolean:function(value) {
    return typeof value === 'boolean';
  }, isElement:function(value) {
    return value ? value.nodeType === 1 : false;
  }, isTextNode:function(value) {
    return value ? value.nodeName === '#text' : false;
  }, isDefined:function(value) {
    return typeof value !== 'undefined';
  }, isIterable:function(value) {
    if (!value || typeof value.length !== 'number' || typeof value === 'string' || Ext.isFunction(value)) {
      return false;
    }
    if (!value.propertyIsEnumerable) {
      return !!value.item;
    }
    if (value.hasOwnProperty('length') && !value.propertyIsEnumerable('length')) {
      return true;
    }
    return iterableRe.test(toString.call(value));
  }, isDebugEnabled:function(className, defaultEnabled) {
    var debugConfig = Ext.debugConfig.hooks;
    if (debugConfig.hasOwnProperty(className)) {
      return debugConfig[className];
    }
    var enabled = debugConfig['*'], prefixLength = 0;
    if (defaultEnabled !== undefined) {
      enabled = defaultEnabled;
    }
    if (!className) {
      return enabled;
    }
    for (var prefix in debugConfig) {
      var value = debugConfig[prefix];
      if (className.charAt(prefix.length) === '.') {
        if (className.substring(0, prefix.length) === prefix) {
          if (prefixLength < prefix.length) {
            prefixLength = prefix.length;
            enabled = value;
          }
        }
      }
    }
    return enabled;
  } || emptyFn, clone:function(item, cloneDom) {
    if (item == null) {
      return item;
    }
    if (cloneDom !== false && item.nodeType && item.cloneNode) {
      return item.cloneNode(true);
    }
    var type = toString.call(item), i, j, k, clone, key;
    if (type === '[object Date]') {
      return new Date(item.getTime());
    }
    if (type === '[object Array]') {
      i = item.length;
      clone = [];
      while (i--) {
        clone[i] = Ext.clone(item[i], cloneDom);
      }
    } else {
      if (type === '[object Object]' && item.constructor === Object) {
        clone = {};
        for (key in item) {
          clone[key] = Ext.clone(item[key], cloneDom);
        }
        if (enumerables) {
          for (j = enumerables.length; j--;) {
            k = enumerables[j];
            if (item.hasOwnProperty(k)) {
              clone[k] = item[k];
            }
          }
        }
      }
    }
    return clone || item;
  }, getUniqueGlobalNamespace:function() {
    var uniqueGlobalNamespace = this.uniqueGlobalNamespace, i;
    if (uniqueGlobalNamespace === undefined) {
      i = 0;
      do {
        uniqueGlobalNamespace = 'ExtBox' + ++i;
      } while (global[uniqueGlobalNamespace] !== undefined);
      global[uniqueGlobalNamespace] = Ext;
      this.uniqueGlobalNamespace = uniqueGlobalNamespace;
    }
    return uniqueGlobalNamespace;
  }, functionFactoryCache:{}, cacheableFunctionFactory:function() {
    var me = this, args = Array.prototype.slice.call(arguments), cache = me.functionFactoryCache, idx, fn, ln;
    if (Ext.isSandboxed) {
      ln = args.length;
      if (ln > 0) {
        ln--;
        args[ln] = 'var Ext\x3dwindow.' + Ext.name + ';' + args[ln];
      }
    }
    idx = args.join('');
    fn = cache[idx];
    if (!fn) {
      fn = Function.prototype.constructor.apply(Function.prototype, args);
      cache[idx] = fn;
    }
    return fn;
  }, functionFactory:function() {
    var args = Array.prototype.slice.call(arguments), ln;
    if (Ext.isSandboxed) {
      ln = args.length;
      if (ln > 0) {
        ln--;
        args[ln] = 'var Ext\x3dwindow.' + Ext.name + ';' + args[ln];
      }
    }
    return Function.prototype.constructor.apply(Function.prototype, args);
  }, Logger:{log:function(message, priority) {
    if (message && global.console) {
      if (!priority || !(priority in global.console)) {
        priority = 'log';
      }
      message = '[' + priority.toUpperCase() + '] ' + message;
      global.console[priority](message);
    }
  }, verbose:function(message) {
    this.log(message, 'verbose');
  }, info:function(message) {
    this.log(message, 'info');
  }, warn:function(message) {
    this.log(message, 'warn');
  }, error:function(message) {
    throw new Error(message);
  }, deprecate:function(message) {
    this.log(message, 'warn');
  }} || {verbose:emptyFn, log:emptyFn, info:emptyFn, warn:emptyFn, error:function(message) {
    throw new Error(message);
  }, deprecate:emptyFn}, ariaWarn:function(target, msg) {
    if (Ext.enableAria && !Ext.slicer) {
      if (!Ext.ariaWarn.first) {
        Ext.ariaWarn.first = true;
        Ext.log.warn('WAI-ARIA compatibility warnings can be suppressed ' + 'by adding the following to application startup code:');
        Ext.log.warn('    Ext.ariaWarn \x3d Ext.emptyFn;');
      }
      Ext.log.warn({msg:msg, dump:target});
    }
  }, getElementById:function(id) {
    return document.getElementById(id);
  }, splitAndUnescape:function() {
    var cache = {};
    return function(origin, delimiter) {
      if (!origin) {
        return [];
      } else {
        if (!delimiter) {
          return [origin];
        }
      }
      var replaceRe = cache[delimiter] || (cache[delimiter] = new RegExp('\\\\' + delimiter, 'g')), result = [], parts, part;
      parts = origin.split(delimiter);
      while ((part = parts.shift()) !== undefined) {
        while (part.charAt(part.length - 1) === '\\' && parts.length > 0) {
          part = part + delimiter + parts.shift();
        }
        part = part.replace(replaceRe, delimiter);
        result.push(part);
      }
      return result;
    };
  }(), doElevate:function() {
    var fn = elevateFn, args = elevateArgs, scope = elevateScope;
    elevateFn = elevateArgs = elevateScope = null;
    elevateRet = args ? fn.apply(scope, args) : fn.call(scope);
    Ext.fireIdle();
  }, elevate:function(fn, scope, args, timer) {
    var ret;
    if (args && !args.length) {
      args = null;
    }
    Ext._suppressIdle = false;
    if (timer) {
      timer.tick();
    }
    if (Ext.elevateFunction) {
      elevateFn = fn;
      elevateScope = scope;
      elevateArgs = args;
      Ext.elevateFunction(Ext.doElevate);
      ret = elevateRet;
      elevateRet = null;
    } else {
      ret = args ? fn.apply(scope, args) : fn.call(scope);
      Ext.fireIdle();
    }
    if (timer) {
      timer.tock();
    }
    return ret;
  }, Timer:{all:{}, track:false, captureStack:true, created:function(kind, id, info) {
    if (!Ext.Timer.track) {
      return null;
    }
    var timer = Ext.apply({kind:kind, id:id, done:false, firing:false, creator:Ext.Timer.captureStack ? (new Error).stack : null, tick:Ext.Timer.tick, tock:Ext.Timer.tock}, info);
    var timers = Ext.Timer.all[kind] || (Ext.Timer.all[kind] = {});
    timers[timer.id] = timer;
    if (Ext.Timer.hook) {
      Ext.Timer.hook(timer);
    }
    return timer;
  }, get:function(id, kind) {
    kind = kind || 'timeout';
    var timers = Ext.Timer.all[kind];
    return timers && timers[id] || null;
  }, cancel:function(kind, id) {
    var timers = Ext.Timer.all[kind];
    var timer = timers && timers[id];
    if (timer) {
      timer.cancelled = true;
      delete timers[id];
    }
  }, tick:function() {
    if (Ext.Timer.firing) {
      Ext.log.error('Previous timer state not cleaned up properly: ' + Ext.Timer.firing.creator);
    }
    if (this.kind !== 'interval') {
      this.done = true;
      delete Ext.Timer.all[this.kind][this.id];
    }
    this.firing = true;
    Ext.Timer.firing = this;
  }, tock:function() {
    this.firing = false;
    if (Ext.Timer.firing === this) {
      Ext.Timer.firing = null;
    }
  }}, getExpando:function(target, id) {
    var expandos = target.$expandos;
    return expandos && expandos[id] || null;
  }, setExpando:function(target, id, value) {
    var expandos = target.$expandos;
    if (value !== undefined) {
      (expandos || (target.$expandos = {}))[id] = value;
    } else {
      if (expandos) {
        delete expandos[id];
      }
    }
  }});
  Ext.returnTrue.$nullFn = Ext.returnId.$nullFn = true;
})();
Ext.platformTags.classic = !(Ext.platformTags.modern = Ext.isModern = true);
(function() {
  function toString() {
    var me = this, cls = me.sourceClass, method = me.sourceMethod, msg = me.msg;
    if (method) {
      if (msg) {
        method += '(): ';
        method += msg;
      } else {
        method += '()';
      }
    }
    if (cls) {
      method = method ? cls + '.' + method : cls;
    }
    return method || msg || '';
  }
  Ext.Error = function(config) {
    if (Ext.isString(config)) {
      config = {msg:config};
    }
    var error = new Error;
    Ext.apply(error, config);
    error.message = error.message || error.msg;
    error.toString = toString;
    return error;
  };
  Ext.apply(Ext.Error, {ignore:false, raise:function(err) {
    err = err || {};
    if (Ext.isString(err)) {
      err = {msg:err};
    }
    var me = this, method = me.raise.caller, msg, name;
    if (method === Ext.raise) {
      method = method.caller;
    }
    if (method) {
      if (!err.sourceMethod && (name = method.$name)) {
        err.sourceMethod = name;
      }
      if (!err.sourceClass && (name = method.$owner) && (name = name.$className)) {
        err.sourceClass = name;
      }
    }
    if (me.handle(err) !== true) {
      msg = toString.call(err);
      Ext.log({msg:msg, level:'error', dump:err, stack:true});
      throw new Ext.Error(err);
    }
  }, handle:function() {
    return this.ignore;
  }});
})();
Ext.deprecated = function(suggestion) {
  if (!suggestion) {
    suggestion = '';
  }
  function fail() {
    Ext.raise('The method "' + fail.$owner.$className + '.' + fail.$name + '" has been removed. ' + suggestion);
  }
  return fail;
  return Ext.emptyFn;
};
Ext.raise = function() {
  Ext.Error.raise.apply(Ext.Error, arguments);
};
(function(skipNotify) {
  if (skipNotify || typeof window === 'undefined') {
    return;
  }
  var last = 0, notify = function() {
    var cnt = Ext.log && Ext.log.counters, n = cnt && cnt.error + cnt.warn + cnt.info + cnt.log, msg;
    if (n && last !== n) {
      msg = [];
      if (cnt.error) {
        msg.push('Errors: ' + cnt.error);
      }
      if (cnt.warn) {
        msg.push('Warnings: ' + cnt.warn);
      }
      if (cnt.info) {
        msg.push('Info: ' + cnt.info);
      }
      if (cnt.log) {
        msg.push('Log: ' + cnt.log);
      }
      window.status = '*** ' + msg.join(' -- ');
      last = n;
    }
  };
  notify.$skipTimerCheck = true;
  setInterval(notify, 1000);
})(!!window.__UNIT_TESTING__);
Ext.Array = function() {
  var arrayPrototype = Array.prototype, slice = arrayPrototype.slice, supportsSplice = function() {
    var array = [], lengthBefore, j = 20;
    if (!array.splice) {
      return false;
    }
    while (j--) {
      array.push('A');
    }
    array.splice(15, 0, 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F', 'F');
    lengthBefore = array.length;
    array.splice(13, 0, 'XXX');
    if (lengthBefore + 1 !== array.length) {
      return false;
    }
    return true;
  }(), supportsIndexOf = 'indexOf' in arrayPrototype, supportsSliceOnNodeList = true;
  function stableSort(array, userComparator) {
    var len = array.length, indices = new Array(len), i;
    for (i = 0; i < len; i++) {
      indices[i] = i;
    }
    indices.sort(function(index1, index2) {
      return userComparator(array[index1], array[index2]) || index1 - index2;
    });
    for (i = 0; i < len; i++) {
      indices[i] = array[indices[i]];
    }
    for (i = 0; i < len; i++) {
      array[i] = indices[i];
    }
    return array;
  }
  try {
    if (typeof document !== 'undefined') {
      slice.call(document.getElementsByTagName('body'));
    }
  } catch (e$0) {
    supportsSliceOnNodeList = false;
  }
  var fixArrayIndex = function(array, index) {
    return index < 0 ? Math.max(0, array.length + index) : Math.min(array.length, index);
  }, replaceSim = function(array, index, removeCount, insert) {
    var add = insert ? insert.length : 0, length = array.length, pos = fixArrayIndex(array, index);
    if (pos === length) {
      if (add) {
        array.push.apply(array, insert);
      }
    } else {
      var remove = Math.min(removeCount, length - pos), tailOldPos = pos + remove, tailNewPos = tailOldPos + add - remove, tailCount = length - tailOldPos, lengthAfterRemove = length - remove, i;
      if (tailNewPos < tailOldPos) {
        for (i = 0; i < tailCount; ++i) {
          array[tailNewPos + i] = array[tailOldPos + i];
        }
      } else {
        if (tailNewPos > tailOldPos) {
          for (i = tailCount; i--;) {
            array[tailNewPos + i] = array[tailOldPos + i];
          }
        }
      }
      if (add && pos === lengthAfterRemove) {
        array.length = lengthAfterRemove;
        array.push.apply(array, insert);
      } else {
        array.length = lengthAfterRemove + add;
        for (i = 0; i < add; ++i) {
          array[pos + i] = insert[i];
        }
      }
    }
    return array;
  }, replaceNative = function(array, index, removeCount, insert) {
    if (insert && insert.length) {
      if (index === 0 && !removeCount) {
        array.unshift.apply(array, insert);
      } else {
        if (index < array.length) {
          array.splice.apply(array, [index, removeCount].concat(insert));
        } else {
          array.push.apply(array, insert);
        }
      }
    } else {
      array.splice(index, removeCount);
    }
    return array;
  }, eraseSim = function(array, index, removeCount) {
    return replaceSim(array, index, removeCount);
  }, eraseNative = function(array, index, removeCount) {
    array.splice(index, removeCount);
    return array;
  }, spliceSim = function(array, index, removeCount) {
    var len = arguments.length, pos = fixArrayIndex(array, index), removed;
    if (len < 3) {
      removeCount = array.length - pos;
    }
    removed = array.slice(index, fixArrayIndex(array, pos + removeCount));
    if (len < 4) {
      replaceSim(array, pos, removeCount);
    } else {
      replaceSim(array, pos, removeCount, slice.call(arguments, 3));
    }
    return removed;
  }, spliceNative = function(array) {
    return array.splice.apply(array, slice.call(arguments, 1));
  }, erase = supportsSplice ? eraseNative : eraseSim, replace = supportsSplice ? replaceNative : replaceSim, splice = supportsSplice ? spliceNative : spliceSim, ExtArray = {binarySearch:function(array, item, begin, end, compareFn) {
    var length = array.length, middle, comparison;
    if (begin instanceof Function) {
      compareFn = begin;
      begin = 0;
      end = length;
    } else {
      if (end instanceof Function) {
        compareFn = end;
        end = length;
      } else {
        if (begin === undefined) {
          begin = 0;
        }
        if (end === undefined) {
          end = length;
        }
        compareFn = compareFn || ExtArray.lexicalCompare;
      }
    }
    --end;
    while (begin <= end) {
      middle = begin + end >> 1;
      comparison = compareFn(item, array[middle]);
      if (comparison >= 0) {
        begin = middle + 1;
      } else {
        if (comparison < 0) {
          end = middle - 1;
        }
      }
    }
    return begin;
  }, defaultCompare:function(lhs, rhs) {
    return lhs < rhs ? -1 : lhs > rhs ? 1 : 0;
  }, lexicalCompare:function(lhs, rhs) {
    lhs = String(lhs);
    rhs = String(rhs);
    return lhs < rhs ? -1 : lhs > rhs ? 1 : 0;
  }, each:function(array, fn, scope, reverse) {
    array = ExtArray.from(array);
    var i, ln = array.length;
    if (reverse !== true) {
      for (i = 0; i < ln; i++) {
        if (fn.call(scope || array[i], array[i], i, array) === false) {
          return i;
        }
      }
    } else {
      for (i = ln - 1; i > -1; i--) {
        if (fn.call(scope || array[i], array[i], i, array) === false) {
          return i;
        }
      }
    }
    return true;
  }, findInsertionIndex:function(item, items, comparatorFn, index) {
    var len = items.length, beforeCheck, afterCheck;
    comparatorFn = comparatorFn || ExtArray.lexicalCompare;
    if (index < len) {
      beforeCheck = index > 0 ? comparatorFn(items[index - 1], item) : 0;
      afterCheck = index < len - 1 ? comparatorFn(item, items[index]) : 0;
      if (beforeCheck < 1 && afterCheck < 1) {
        return index;
      }
    }
    return ExtArray.binarySearch(items, item, comparatorFn);
  }, forEach:'forEach' in arrayPrototype ? function(array, fn, scope) {
    array.forEach(fn, scope);
  } : function(array, fn, scope) {
    for (var i = 0, ln = array.length; i < ln; i++) {
      fn.call(scope, array[i], i, array);
    }
  }, indexOf:supportsIndexOf ? function(array, item, from) {
    return array ? arrayPrototype.indexOf.call(array, item, from) : -1;
  } : function(array, item, from) {
    var i, length = array ? array.length : 0;
    for (i = from < 0 ? Math.max(0, length + from) : from || 0; i < length; i++) {
      if (array[i] === item) {
        return i;
      }
    }
    return -1;
  }, contains:supportsIndexOf ? function(array, item) {
    return arrayPrototype.indexOf.call(array, item) !== -1;
  } : function(array, item) {
    var i, ln;
    for (i = 0, ln = array.length; i < ln; i++) {
      if (array[i] === item) {
        return true;
      }
    }
    return false;
  }, toArray:function(iterable, start, end) {
    if (!iterable || !iterable.length) {
      return [];
    }
    if (typeof iterable === 'string') {
      iterable = iterable.split('');
    }
    if (supportsSliceOnNodeList) {
      return slice.call(iterable, start || 0, end || iterable.length);
    }
    var array = [], i;
    start = start || 0;
    end = end ? end < 0 ? iterable.length + end : end : iterable.length;
    for (i = start; i < end; i++) {
      array.push(iterable[i]);
    }
    return array;
  }, pluck:function(array, propertyName) {
    var ret = [], i, ln, item;
    for (i = 0, ln = array.length; i < ln; i++) {
      item = array[i];
      ret.push(item[propertyName]);
    }
    return ret;
  }, map:'map' in arrayPrototype ? function(array, fn, scope) {
    Ext.Assert.isFunction(fn, 'Ext.Array.map must have a callback function passed as second argument.');
    return array.map(fn, scope);
  } : function(array, fn, scope) {
    Ext.Assert.isFunction(fn, 'Ext.Array.map must have a callback function passed as second argument.');
    var len = array.length, results = new Array(len), i;
    for (i = 0; i < len; i++) {
      results[i] = fn.call(scope, array[i], i, array);
    }
    return results;
  }, every:'every' in arrayPrototype ? function(array, fn, scope) {
    Ext.Assert.isFunction(fn, 'Ext.Array.every must have a callback function passed as second argument.');
    return array.every(fn, scope);
  } : function(array, fn, scope) {
    Ext.Assert.isFunction(fn, 'Ext.Array.every must have a callback function passed as second argument.');
    var i = 0, ln = array.length;
    for (; i < ln; ++i) {
      if (!fn.call(scope, array[i], i, array)) {
        return false;
      }
    }
    return true;
  }, some:'some' in arrayPrototype ? function(array, fn, scope) {
    Ext.Assert.isFunction(fn, 'Ext.Array.some must have a callback function passed as second argument.');
    return array.some(fn, scope);
  } : function(array, fn, scope) {
    Ext.Assert.isFunction(fn, 'Ext.Array.some must have a callback function passed as second argument.');
    var i = 0, ln = array.length;
    for (; i < ln; ++i) {
      if (fn.call(scope, array[i], i, array)) {
        return true;
      }
    }
    return false;
  }, equals:function(array1, array2) {
    var len1 = array1.length, len2 = array2.length, i;
    if (array1 === array2) {
      return true;
    }
    if (len1 !== len2) {
      return false;
    }
    for (i = 0; i < len1; ++i) {
      if (array1[i] !== array2[i]) {
        return false;
      }
    }
    return true;
  }, clean:function(array) {
    var results = [], i = 0, ln = array.length, item;
    for (; i < ln; i++) {
      item = array[i];
      if (!Ext.isEmpty(item)) {
        results.push(item);
      }
    }
    return results;
  }, unique:function(array) {
    var clone = [], i = 0, ln = array.length, item;
    for (; i < ln; i++) {
      item = array[i];
      if (ExtArray.indexOf(clone, item) === -1) {
        clone.push(item);
      }
    }
    return clone;
  }, filter:'filter' in arrayPrototype ? function(array, fn, scope) {
    Ext.Assert.isFunction(fn, 'Ext.Array.filter must have a filter function passed as second argument.');
    return array.filter(fn, scope);
  } : function(array, fn, scope) {
    Ext.Assert.isFunction(fn, 'Ext.Array.filter must have a filter function passed as second argument.');
    var results = [], i = 0, ln = array.length;
    for (; i < ln; i++) {
      if (fn.call(scope, array[i], i, array)) {
        results.push(array[i]);
      }
    }
    return results;
  }, findBy:function(array, fn, scope) {
    var i = 0, len = array.length;
    for (; i < len; i++) {
      if (fn.call(scope || array, array[i], i)) {
        return array[i];
      }
    }
    return null;
  }, from:function(value, newReference) {
    if (value === undefined || value === null) {
      return [];
    }
    if (Ext.isArray(value)) {
      return newReference ? slice.call(value) : value;
    }
    var type = typeof value;
    if (value && value.length !== undefined && type !== 'string' && (type !== 'function' || !value.apply)) {
      return ExtArray.toArray(value);
    }
    return [value];
  }, remove:function(array, item) {
    var index = ExtArray.indexOf(array, item);
    if (index !== -1) {
      erase(array, index, 1);
    }
    return array;
  }, removeAt:function(array, index, count) {
    var len = array.length;
    if (index >= 0 && index < len) {
      count = count || 1;
      count = Math.min(count, len - index);
      erase(array, index, count);
    }
    return array;
  }, include:function(array, item) {
    if (!ExtArray.contains(array, item)) {
      array.push(item);
    }
  }, clone:function(array) {
    return slice.call(array);
  }, merge:function() {
    var args = slice.call(arguments), array = [], i, ln;
    for (i = 0, ln = args.length; i < ln; i++) {
      array = array.concat(args[i]);
    }
    return ExtArray.unique(array);
  }, intersect:function() {
    var intersection = [], arrays = slice.call(arguments), arraysLength, array, arrayLength, minArray, minArrayIndex, minArrayCandidate, minArrayLength, element, elementCandidate, elementCount, i, j, k;
    if (!arrays.length) {
      return intersection;
    }
    arraysLength = arrays.length;
    for (i = minArrayIndex = 0; i < arraysLength; i++) {
      minArrayCandidate = arrays[i];
      if (!minArray || minArrayCandidate.length < minArray.length) {
        minArray = minArrayCandidate;
        minArrayIndex = i;
      }
    }
    minArray = ExtArray.unique(minArray);
    erase(arrays, minArrayIndex, 1);
    minArrayLength = minArray.length;
    arraysLength = arrays.length;
    for (i = 0; i < minArrayLength; i++) {
      element = minArray[i];
      elementCount = 0;
      for (j = 0; j < arraysLength; j++) {
        array = arrays[j];
        arrayLength = array.length;
        for (k = 0; k < arrayLength; k++) {
          elementCandidate = array[k];
          if (element === elementCandidate) {
            elementCount++;
            break;
          }
        }
      }
      if (elementCount === arraysLength) {
        intersection.push(element);
      }
    }
    return intersection;
  }, difference:function(arrayA, arrayB) {
    var clone = slice.call(arrayA), ln = clone.length, i, j, lnB;
    for (i = 0, lnB = arrayB.length; i < lnB; i++) {
      for (j = 0; j < ln; j++) {
        if (clone[j] === arrayB[i]) {
          erase(clone, j, 1);
          j--;
          ln--;
        }
      }
    }
    return clone;
  }, reduce:Array.prototype.reduce ? function(array, reduceFn, initialValue) {
    if (arguments.length === 3) {
      return Array.prototype.reduce.call(array, reduceFn, initialValue);
    }
    return Array.prototype.reduce.call(array, reduceFn);
  } : function(array, reduceFn, initialValue) {
    array = Object(array);
    if (!Ext.isFunction(reduceFn)) {
      Ext.raise('Invalid parameter: expected a function.');
    }
    var index = 0, length = array.length >>> 0, reduced = initialValue;
    if (arguments.length < 3) {
      while (true) {
        if (index in array) {
          reduced = array[index++];
          break;
        }
        if (++index >= length) {
          throw new TypeError('Reduce of empty array with no initial value');
        }
      }
    }
    for (; index < length; ++index) {
      if (index in array) {
        reduced = reduceFn(reduced, array[index], index, array);
      }
    }
    return reduced;
  }, slice:[1, 2].slice(1, undefined).length ? function(array, begin, end) {
    return slice.call(array, begin, end);
  } : function(array, begin, end) {
    if (typeof begin === 'undefined') {
      return slice.call(array);
    }
    if (typeof end === 'undefined') {
      return slice.call(array, begin);
    }
    return slice.call(array, begin, end);
  }, sort:function(array, sortFn) {
    return stableSort(array, sortFn || ExtArray.lexicalCompare);
  }, flatten:function(array) {
    var worker = [];
    function rFlatten(a) {
      var i, ln, v;
      for (i = 0, ln = a.length; i < ln; i++) {
        v = a[i];
        if (Ext.isArray(v)) {
          rFlatten(v);
        } else {
          worker.push(v);
        }
      }
      return worker;
    }
    return rFlatten(array);
  }, min:function(array, comparisonFn) {
    var min = array[0], i, ln, item;
    for (i = 0, ln = array.length; i < ln; i++) {
      item = array[i];
      if (comparisonFn) {
        if (comparisonFn(min, item) === 1) {
          min = item;
        }
      } else {
        if (item < min) {
          min = item;
        }
      }
    }
    return min;
  }, max:function(array, comparisonFn) {
    var max = array[0], i, ln, item;
    for (i = 0, ln = array.length; i < ln; i++) {
      item = array[i];
      if (comparisonFn) {
        if (comparisonFn(max, item) === -1) {
          max = item;
        }
      } else {
        if (item > max) {
          max = item;
        }
      }
    }
    return max;
  }, mean:function(array) {
    return array.length > 0 ? ExtArray.sum(array) / array.length : undefined;
  }, sum:function(array) {
    var sum = 0, i, ln, item;
    for (i = 0, ln = array.length; i < ln; i++) {
      item = array[i];
      sum += item;
    }
    return sum;
  }, toMap:function(strings, getKey, scope) {
    if (!strings) {
      return null;
    }
    var map = {}, i = strings.length;
    if (typeof strings === 'string') {
      map[strings] = 1;
    } else {
      if (!getKey) {
        while (i--) {
          map[strings[i]] = i + 1;
        }
      } else {
        if (typeof getKey === 'string') {
          while (i--) {
            map[strings[i][getKey]] = i + 1;
          }
        } else {
          while (i--) {
            map[getKey.call(scope, strings[i])] = i + 1;
          }
        }
      }
    }
    return map;
  }, toValueMap:function(array, getKey, scope, arrayify) {
    var map = {}, i = array.length, autoArray, alwaysArray, entry, fn, key, value;
    if (!getKey) {
      while (i--) {
        value = array[i];
        map[value] = value;
      }
    } else {
      if (!(fn = typeof getKey !== 'string')) {
        arrayify = scope;
      }
      alwaysArray = arrayify === 1;
      autoArray = arrayify === 2;
      while (i--) {
        value = array[i];
        key = fn ? getKey.call(scope, value) : value[getKey];
        if (alwaysArray) {
          if (key in map) {
            map[key].push(value);
          } else {
            map[key] = [value];
          }
        } else {
          if (autoArray && key in map) {
            if ((entry = map[key]) instanceof Array) {
              entry.push(value);
            } else {
              map[key] = [entry, value];
            }
          } else {
            map[key] = value;
          }
        }
      }
    }
    return map;
  }, _replaceSim:replaceSim, _spliceSim:spliceSim, erase:erase, insert:function(array, index, items) {
    return replace(array, index, 0, items);
  }, move:function(array, fromIdx, toIdx) {
    if (toIdx === fromIdx) {
      return;
    }
    var item = array[fromIdx], incr = toIdx > fromIdx ? 1 : -1, i;
    for (i = fromIdx; i != toIdx; i += incr) {
      array[i] = array[i + incr];
    }
    array[toIdx] = item;
  }, replace:replace, splice:splice, push:function(target) {
    var args = arguments, len = args.length, i, newItem;
    if (target === undefined) {
      target = [];
    } else {
      if (!Ext.isArray(target)) {
        target = [target];
      }
    }
    for (i = 1; i < len; i++) {
      newItem = args[i];
      Array.prototype.push[Ext.isIterable(newItem) ? 'apply' : 'call'](target, newItem);
    }
    return target;
  }, numericSortFn:function(a, b) {
    return a - b;
  }};
  Ext.each = ExtArray.each;
  ExtArray.union = ExtArray.merge;
  Ext.min = ExtArray.min;
  Ext.max = ExtArray.max;
  Ext.sum = ExtArray.sum;
  Ext.mean = ExtArray.mean;
  Ext.flatten = ExtArray.flatten;
  Ext.clean = ExtArray.clean;
  Ext.unique = ExtArray.unique;
  Ext.pluck = ExtArray.pluck;
  Ext.toArray = function() {
    return ExtArray.toArray.apply(ExtArray, arguments);
  };
  return ExtArray;
}();
Ext.Assert = {falsey:function(b, msg) {
  if (b) {
    Ext.raise(msg || 'Expected a falsey value but was ' + b);
  }
}, falseyProp:function(object, property) {
  Ext.Assert.truthy(object);
  var b = object[property];
  if (b) {
    if (object.$className) {
      property = object.$className + '#' + property;
    }
    Ext.raise('Expected a falsey value for ' + property + ' but was ' + b);
  }
}, truthy:function(b, msg) {
  if (!b) {
    Ext.raise(msg || 'Expected a truthy value but was ' + typeof b);
  }
}, truthyProp:function(object, property) {
  Ext.Assert.truthy(object);
  var b = object[property];
  if (!b) {
    if (object.$className) {
      property = object.$className + '#' + property;
    }
    Ext.raise('Expected a truthy value for ' + property + ' but was ' + typeof b);
  }
}};
(function() {
  function makeAssert(name, kind) {
    var testFn = Ext[name], def;
    return function(value, msg) {
      if (!testFn(value)) {
        Ext.raise(msg || def || (def = 'Expected value to be ' + kind));
      }
    };
  }
  function makeAssertProp(name, kind) {
    var testFn = Ext[name], def;
    return function(object, prop) {
      Ext.Assert.truthy(object);
      if (!testFn(object[prop])) {
        Ext.raise(def || (def = 'Expected ' + (object.$className ? object.$className + '#' : '') + prop + ' to be ' + kind));
      }
    };
  }
  function makeNotAssert(name, kind) {
    var testFn = Ext[name], def;
    return function(value, msg) {
      if (testFn(value)) {
        Ext.raise(msg || def || (def = 'Expected value to NOT be ' + kind));
      }
    };
  }
  function makeNotAssertProp(name, kind) {
    var testFn = Ext[name], def;
    return function(object, prop) {
      Ext.Assert.truthy(object);
      if (testFn(object[prop])) {
        Ext.raise(def || (def = 'Expected ' + (object.$className ? object.$className + '#' : '') + prop + ' to NOT be ' + kind));
      }
    };
  }
  for (var name in Ext) {
    if (name.substring(0, 2) == 'is' && Ext.isFunction(Ext[name])) {
      var kind = name.substring(2);
      Ext.Assert[name] = makeAssert(name, kind);
      Ext.Assert[name + 'Prop'] = makeAssertProp(name, kind);
      Ext.Assert['isNot' + kind] = makeNotAssert(name, kind);
      Ext.Assert['isNot' + kind + 'Prop'] = makeNotAssertProp(name, kind);
    }
  }
})();
Ext.String = function() {
  var trimRegex = /^[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u2028\u2029\u202f\u205f\u3000]+|[\x09\x0a\x0b\x0c\x0d\x20\xa0\u1680\u180e\u2000\u2001\u2002\u2003\u2004\u2005\u2006\u2007\u2008\u2009\u200a\u2028\u2029\u202f\u205f\u3000]+$/g, escapeRe = /('|\\)/g, escapeRegexRe = /([-.*+?\^${}()|\[\]\/\\])/g, basicTrimRe = /^\s+|\s+$/g, whitespaceRe = /\s+/, varReplace = /(^[^a-z]*|[^\w])/gi, charToEntity, entityToChar, charToEntityRegex, 
  entityToCharRegex, htmlEncodeReplaceFn = function(match, capture) {
    return charToEntity[capture];
  }, htmlDecodeReplaceFn = function(match, capture) {
    return capture in entityToChar ? entityToChar[capture] : String.fromCharCode(parseInt(capture.substr(2), 10));
  }, boundsCheck = function(s, other) {
    if (s === null || s === undefined || other === null || other === undefined) {
      return false;
    }
    return other.length <= s.length;
  }, fromCharCode = String.fromCharCode, ExtString;
  return ExtString = {fromCodePoint:String.fromCodePoint || function() {
    var codePoint, result = '', codeUnits = [], index = -1, length = arguments.length;
    while (++index < length) {
      codePoint = Number(arguments[index]);
      if (!isFinite(codePoint) || codePoint < 0 || codePoint > 1114111 || Math.floor(codePoint) !== codePoint) {
        Ext.raise('Invalid code point: ' + codePoint);
      }
      if (codePoint <= 65535) {
        codeUnits.push(codePoint);
      } else {
        codePoint -= 65536;
        codeUnits.push((codePoint >> 10) + 55296, codePoint % 1024 + 56320);
      }
      if (index + 1 === length) {
        result += fromCharCode(codeUnits);
        codeUnits.length = 0;
      }
    }
    return result;
  }, insert:function(s, value, index) {
    if (!s) {
      return value;
    }
    if (!value) {
      return s;
    }
    var len = s.length;
    if (!index && index !== 0) {
      index = len;
    }
    if (index < 0) {
      index *= -1;
      if (index >= len) {
        index = 0;
      } else {
        index = len - index;
      }
    }
    if (index === 0) {
      s = value + s;
    } else {
      if (index >= s.length) {
        s += value;
      } else {
        s = s.substr(0, index) + value + s.substr(index);
      }
    }
    return s;
  }, startsWith:function(s, start, ignoreCase) {
    var result = boundsCheck(s, start);
    if (result) {
      if (ignoreCase) {
        s = s.toLowerCase();
        start = start.toLowerCase();
      }
      result = s.lastIndexOf(start, 0) === 0;
    }
    return result;
  }, endsWith:function(s, end, ignoreCase) {
    var result = boundsCheck(s, end);
    if (result) {
      if (ignoreCase) {
        s = s.toLowerCase();
        end = end.toLowerCase();
      }
      result = s.indexOf(end, s.length - end.length) !== -1;
    }
    return result;
  }, createVarName:function(s) {
    return s.replace(varReplace, '');
  }, htmlEncode:function(value) {
    return !value ? value : String(value).replace(charToEntityRegex, htmlEncodeReplaceFn);
  }, htmlDecode:function(value) {
    return !value ? value : String(value).replace(entityToCharRegex, htmlDecodeReplaceFn);
  }, hasHtmlCharacters:function(s) {
    return charToEntityRegex.test(s);
  }, addCharacterEntities:function(newEntities) {
    var charKeys = [], entityKeys = [], key, echar;
    for (key in newEntities) {
      echar = newEntities[key];
      entityToChar[key] = echar;
      charToEntity[echar] = key;
      charKeys.push(echar);
      entityKeys.push(key);
    }
    charToEntityRegex = new RegExp('(' + charKeys.join('|') + ')', 'g');
    entityToCharRegex = new RegExp('(' + entityKeys.join('|') + '|\x26#[0-9]{1,5};' + ')', 'g');
  }, resetCharacterEntities:function() {
    charToEntity = {};
    entityToChar = {};
    this.addCharacterEntities({'\x26amp;':'\x26', '\x26gt;':'\x3e', '\x26lt;':'\x3c', '\x26quot;':'"', '\x26#39;':"'"});
  }, urlAppend:function(url, string) {
    if (!Ext.isEmpty(string)) {
      return url + (url.indexOf('?') === -1 ? '?' : '\x26') + string;
    }
    return url;
  }, trim:function(string) {
    if (string) {
      string = string.replace(trimRegex, '');
    }
    return string || '';
  }, capitalize:function(string) {
    if (string) {
      string = string.charAt(0).toUpperCase() + string.substr(1);
    }
    return string || '';
  }, uncapitalize:function(string) {
    if (string) {
      string = string.charAt(0).toLowerCase() + string.substr(1);
    }
    return string || '';
  }, ellipsis:function(value, length, word) {
    if (value && value.length > length) {
      if (word) {
        var vs = value.substr(0, length - 2), index = Math.max(vs.lastIndexOf(' '), vs.lastIndexOf('.'), vs.lastIndexOf('!'), vs.lastIndexOf('?'));
        if (index !== -1 && index >= length - 15) {
          return vs.substr(0, index) + '...';
        }
      }
      return value.substr(0, length - 3) + '...';
    }
    return value;
  }, escapeRegex:function(string) {
    return string.replace(escapeRegexRe, '\\$1');
  }, createRegex:function(value, startsWith, endsWith, ignoreCase) {
    var ret = value;
    if (value != null && !value.exec) {
      ret = ExtString.escapeRegex(String(value));
      if (startsWith !== false) {
        ret = '^' + ret;
      }
      if (endsWith !== false) {
        ret += '$';
      }
      ret = new RegExp(ret, ignoreCase !== false ? 'i' : '');
    }
    return ret;
  }, escape:function(string) {
    return string.replace(escapeRe, '\\$1');
  }, toggle:function(string, value, other) {
    return string === value ? other : value;
  }, leftPad:function(string, size, character) {
    var result = String(string);
    character = character || ' ';
    while (result.length < size) {
      result = character + result;
    }
    return result;
  }, repeat:function(pattern, count, sep) {
    if (count < 1) {
      count = 0;
    }
    for (var buf = [], i = count; i--;) {
      buf.push(pattern);
    }
    return buf.join(sep || '');
  }, splitWords:function(words) {
    if (words && typeof words == 'string') {
      return words.replace(basicTrimRe, '').split(whitespaceRe);
    }
    return words || [];
  }};
}();
Ext.String.resetCharacterEntities();
Ext.htmlEncode = Ext.String.htmlEncode;
Ext.htmlDecode = Ext.String.htmlDecode;
Ext.urlAppend = Ext.String.urlAppend;
Ext.Date = function() {
  var utilDate, nativeDate = Date, stripEscapeRe = /(\\.)/g, hourInfoRe = /([gGhHisucUOPZ]|MS)/, dateInfoRe = /([djzmnYycU]|MS)/, slashRe = /\\/gi, numberTokenRe = /\{(\d+)\}/g, MSFormatRe = new RegExp('\\/Date\\(([-+])?(\\d+)(?:[+-]\\d{4})?\\)\\/'), pad = Ext.String.leftPad, monthInfo = {F:true, m:true, M:true, n:true}, yearInfo = {o:true, Y:true, y:true}, code = ['var me \x3d this, dt, y, m, d, h, i, s, ms, o, O, z, zz, u, v, W, year, jan4, week1monday, daysInMonth, dayMatched,', 'def \x3d me.defaults,', 
  'from \x3d Ext.Number.from,', 'results \x3d String(input).match(me.parseRegexes[{0}]);', 'if(results){', '{1}', 'if(u !\x3d null){', 'v \x3d new Date(u * 1000);', '}else{', 'dt \x3d me.clearTime(new Date);', 'y \x3d from(y, from(def.y, dt.getFullYear()));', 'm \x3d from(m, from(def.m - 1, dt.getMonth()));', 'dayMatched \x3d d !\x3d\x3d undefined;', 'd \x3d from(d, from(def.d, dt.getDate()));', 'if (!dayMatched) {', 'dt.setDate(1);', 'dt.setMonth(m);', 'dt.setFullYear(y);', 'daysInMonth \x3d me.getDaysInMonth(dt);', 
  'if (d \x3e daysInMonth) {', 'd \x3d daysInMonth;', '}', '}', 'h  \x3d from(h, from(def.h, dt.getHours()));', 'i  \x3d from(i, from(def.i, dt.getMinutes()));', 's  \x3d from(s, from(def.s, dt.getSeconds()));', 'ms \x3d from(ms, from(def.ms, dt.getMilliseconds()));', 'if(z \x3e\x3d 0 \x26\x26 y \x3e\x3d 0){', 'v \x3d me.add(new Date(y \x3c 100 ? 100 : y, 0, 1, h, i, s, ms), me.YEAR, y \x3c 100 ? y - 100 : 0);', 'v \x3d !strict? v : (strict \x3d\x3d\x3d true \x26\x26 (z \x3c\x3d 364 || (me.isLeapYear(v) \x26\x26 z \x3c\x3d 365))? me.add(v, me.DAY, z) : null);', 
  '}else if(strict \x3d\x3d\x3d true \x26\x26 !me.isValid(y, m + 1, d, h, i, s, ms)){', 'v \x3d null;', '}else{', 'if (W) {', 'year \x3d y || (new Date()).getFullYear();', 'jan4 \x3d new Date(year, 0, 4, 0, 0, 0);', 'd \x3d jan4.getDay();', 'week1monday \x3d new Date(jan4.getTime() - ((d \x3d\x3d\x3d 0 ? 6 : d - 1) * 86400000));', 'v \x3d Ext.Date.clearTime(new Date(week1monday.getTime() + ((W - 1) * 604800000 + 43200000)));', '} else {', 'v \x3d me.add(new Date(y \x3c 100 ? 100 : y, m, d, h, i, s, ms), me.YEAR, y \x3c 100 ? y - 100 : 0);', 
  '}', '}', '}', '}', 'if(v){', 'if(zz !\x3d null){', 'v \x3d me.add(v, me.SECOND, -v.getTimezoneOffset() * 60 - zz);', '}else if(o){', "v \x3d me.add(v, me.MINUTE, -v.getTimezoneOffset() + (sn \x3d\x3d '+'? -1 : 1) * (hr * 60 + mn));", '}', '}', 'return (v !\x3d null) ? v : null;'].join('\n');
  if (!Date.prototype.toISOString) {
    Date.prototype.toISOString = function() {
      var me = this;
      return pad(me.getUTCFullYear(), 4, '0') + '-' + pad(me.getUTCMonth() + 1, 2, '0') + '-' + pad(me.getUTCDate(), 2, '0') + 'T' + pad(me.getUTCHours(), 2, '0') + ':' + pad(me.getUTCMinutes(), 2, '0') + ':' + pad(me.getUTCSeconds(), 2, '0') + '.' + pad(me.getUTCMilliseconds(), 3, '0') + 'Z';
    };
  }
  function xf(format) {
    var args = Array.prototype.slice.call(arguments, 1);
    return format.replace(numberTokenRe, function(m, i) {
      return args[i];
    });
  }
  utilDate = {now:nativeDate.now, toString:function(date) {
    if (!date) {
      date = new nativeDate;
    }
    return date.getFullYear() + '-' + pad(date.getMonth() + 1, 2, '0') + '-' + pad(date.getDate(), 2, '0') + 'T' + pad(date.getHours(), 2, '0') + ':' + pad(date.getMinutes(), 2, '0') + ':' + pad(date.getSeconds(), 2, '0');
  }, getElapsed:function(dateA, dateB) {
    return Math.abs(dateA - (dateB || utilDate.now()));
  }, useStrict:false, formatCodeToRegex:function(character, currentGroup) {
    var p = utilDate.parseCodes[character];
    if (p) {
      p = typeof p === 'function' ? p() : p;
      utilDate.parseCodes[character] = p;
    }
    return p ? Ext.applyIf({c:p.c ? xf(p.c, currentGroup || '{0}') : p.c}, p) : {g:0, c:null, s:Ext.String.escapeRegex(character)};
  }, parseFunctions:{'MS':function(input, strict) {
    var r = (input || '').match(MSFormatRe);
    return r ? new nativeDate(((r[1] || '') + r[2]) * 1) : null;
  }, 'time':function(input, strict) {
    var num = parseInt(input, 10);
    if (num || num === 0) {
      return new nativeDate(num);
    }
    return null;
  }, 'timestamp':function(input, strict) {
    var num = parseInt(input, 10);
    if (num || num === 0) {
      return new nativeDate(num * 1000);
    }
    return null;
  }}, parseRegexes:[], formatFunctions:{'MS':function() {
    return '\\/Date(' + this.getTime() + ')\\/';
  }, 'time':function() {
    return this.getTime().toString();
  }, 'timestamp':function() {
    return utilDate.format(this, 'U');
  }}, y2kYear:50, MILLI:'ms', SECOND:'s', MINUTE:'mi', HOUR:'h', DAY:'d', MONTH:'mo', YEAR:'y', DAYS_IN_WEEK:7, MONTHS_IN_YEAR:12, MAX_DAYS_IN_MONTH:31, SUNDAY:0, MONDAY:1, TUESDAY:2, WEDNESDAY:3, THURSDAY:4, FRIDAY:5, SATURDAY:6, defaults:{}, dayNames:['Sunday', 'Monday', 'Tuesday', 'Wednesday', 'Thursday', 'Friday', 'Saturday'], monthNames:['January', 'February', 'March', 'April', 'May', 'June', 'July', 'August', 'September', 'October', 'November', 'December'], monthNumbers:{January:0, Jan:0, February:1, 
  Feb:1, March:2, Mar:2, April:3, Apr:3, May:4, June:5, Jun:5, July:6, Jul:6, August:7, Aug:7, September:8, Sep:8, October:9, Oct:9, November:10, Nov:10, December:11, Dec:11}, defaultFormat:'m/d/Y', defaultTimeFormat:'h:i A', firstDayOfWeek:0, weekendDays:[0, 6], getShortMonthName:function(month) {
    return utilDate.monthNames[month].substring(0, 3);
  }, getShortDayName:function(day) {
    return utilDate.dayNames[day].substring(0, 3);
  }, getMonthNumber:function(name) {
    return utilDate.monthNumbers[name.substring(0, 1).toUpperCase() + name.substring(1, 3).toLowerCase()];
  }, formatContainsHourInfo:function(format) {
    return hourInfoRe.test(format.replace(stripEscapeRe, ''));
  }, formatContainsDateInfo:function(format) {
    return dateInfoRe.test(format.replace(stripEscapeRe, ''));
  }, isMonthFormat:function(format) {
    return !!monthInfo[format];
  }, isYearFormat:function(format) {
    return !!yearInfo[format];
  }, unescapeFormat:function(format) {
    return format.replace(slashRe, '');
  }, formatCodes:{d:"Ext.String.leftPad(m.getDate(), 2, '0')", D:'Ext.Date.getShortDayName(m.getDay())', j:'m.getDate()', l:'Ext.Date.dayNames[m.getDay()]', N:'(m.getDay() ? m.getDay() : 7)', S:'Ext.Date.getSuffix(m)', w:'m.getDay()', z:'Ext.Date.getDayOfYear(m)', W:"Ext.String.leftPad(Ext.Date.getWeekOfYear(m), 2, '0')", F:'Ext.Date.monthNames[m.getMonth()]', m:"Ext.String.leftPad(m.getMonth() + 1, 2, '0')", M:'Ext.Date.getShortMonthName(m.getMonth())', n:'(m.getMonth() + 1)', t:'Ext.Date.getDaysInMonth(m)', 
  L:'(Ext.Date.isLeapYear(m) ? 1 : 0)', o:'(m.getFullYear() + (Ext.Date.getWeekOfYear(m) \x3d\x3d 1 \x26\x26 m.getMonth() \x3e 0 ? +1 : (Ext.Date.getWeekOfYear(m) \x3e\x3d 52 \x26\x26 m.getMonth() \x3c 11 ? -1 : 0)))', Y:"Ext.String.leftPad(m.getFullYear(), 4, '0')", y:"('' + m.getFullYear()).substring(2, 4)", a:"(m.getHours() \x3c 12 ? 'am' : 'pm')", A:"(m.getHours() \x3c 12 ? 'AM' : 'PM')", g:'((m.getHours() % 12) ? m.getHours() % 12 : 12)', G:'m.getHours()', h:"Ext.String.leftPad((m.getHours() % 12) ? m.getHours() % 12 : 12, 2, '0')", 
  H:"Ext.String.leftPad(m.getHours(), 2, '0')", i:"Ext.String.leftPad(m.getMinutes(), 2, '0')", s:"Ext.String.leftPad(m.getSeconds(), 2, '0')", u:"Ext.String.leftPad(m.getMilliseconds(), 3, '0')", O:'Ext.Date.getGMTOffset(m)', P:'Ext.Date.getGMTOffset(m, true)', T:'Ext.Date.getTimezone(m)', Z:'(m.getTimezoneOffset() * -60)', c:function() {
    var c = 'Y-m-dTH:i:sP', code = [], i, l = c.length, e;
    for (i = 0; i < l; ++i) {
      e = c.charAt(i);
      code.push(e === 'T' ? "'T'" : utilDate.getFormatCode(e));
    }
    return code.join(' + ');
  }, C:function() {
    return 'm.toISOString()';
  }, U:'Math.round(m.getTime() / 1000)'}, isValid:function(year, month, day, hour, minute, second, millisecond) {
    hour = hour || 0;
    minute = minute || 0;
    second = second || 0;
    millisecond = millisecond || 0;
    var dt = utilDate.add(new nativeDate(year < 100 ? 100 : year, month - 1, day, hour, minute, second, millisecond), utilDate.YEAR, year < 100 ? year - 100 : 0);
    return year === dt.getFullYear() && month === dt.getMonth() + 1 && day === dt.getDate() && hour === dt.getHours() && minute === dt.getMinutes() && second === dt.getSeconds() && millisecond === dt.getMilliseconds();
  }, parse:function(input, format, strict) {
    var p = utilDate.parseFunctions;
    if (p[format] == null) {
      utilDate.createParser(format);
    }
    return p[format].call(utilDate, input, Ext.isDefined(strict) ? strict : utilDate.useStrict);
  }, parseDate:function(input, format, strict) {
    return utilDate.parse(input, format, strict);
  }, getFormatCode:function(character) {
    var f = utilDate.formatCodes[character];
    if (f) {
      f = typeof f === 'function' ? f() : f;
      utilDate.formatCodes[character] = f;
    }
    return f || "'" + Ext.String.escape(character) + "'";
  }, createFormat:function(format) {
    var code = [], special = false, ch = '', i;
    for (i = 0; i < format.length; ++i) {
      ch = format.charAt(i);
      if (!special && ch === '\\') {
        special = true;
      } else {
        if (special) {
          special = false;
          code.push("'" + Ext.String.escape(ch) + "'");
        } else {
          if (ch === '\n') {
            code.push("'\\n'");
          } else {
            code.push(utilDate.getFormatCode(ch));
          }
        }
      }
    }
    utilDate.formatFunctions[format] = Ext.functionFactory('var m\x3dthis;return ' + code.join('+'));
  }, createParser:function(format) {
    var regexNum = utilDate.parseRegexes.length, currentGroup = 1, calc = [], regex = [], special = false, ch = '', i = 0, len = format.length, atEnd = [], obj;
    for (; i < len; ++i) {
      ch = format.charAt(i);
      if (!special && ch === '\\') {
        special = true;
      } else {
        if (special) {
          special = false;
          regex.push(Ext.String.escape(ch));
        } else {
          obj = utilDate.formatCodeToRegex(ch, currentGroup);
          currentGroup += obj.g;
          regex.push(obj.s);
          if (obj.g && obj.c) {
            if (obj.calcAtEnd) {
              atEnd.push(obj.c);
            } else {
              calc.push(obj.c);
            }
          }
        }
      }
    }
    calc = calc.concat(atEnd);
    utilDate.parseRegexes[regexNum] = new RegExp('^' + regex.join('') + '$', 'i');
    utilDate.parseFunctions[format] = Ext.functionFactory('input', 'strict', xf(code, regexNum, calc.join('')));
  }, parseCodes:{d:{g:1, c:'d \x3d parseInt(results[{0}], 10);\n', s:'(3[0-1]|[1-2][0-9]|0[1-9])'}, j:{g:1, c:'d \x3d parseInt(results[{0}], 10);\n', s:'(3[0-1]|[1-2][0-9]|[1-9])'}, D:function() {
    for (var a = [], i = 0; i < 7; a.push(utilDate.getShortDayName(i)), ++i) {
    }
    return {g:0, c:null, s:'(?:' + a.join('|') + ')'};
  }, l:function() {
    return {g:0, c:null, s:'(?:' + utilDate.dayNames.join('|') + ')'};
  }, N:{g:0, c:null, s:'[1-7]'}, S:{g:0, c:null, s:'(?:st|nd|rd|th)'}, w:{g:0, c:null, s:'[0-6]'}, z:{g:1, c:'z \x3d parseInt(results[{0}], 10);\n', s:'(\\d{1,3})'}, W:{g:1, c:'W \x3d parseInt(results[{0}], 10);\n', s:'(\\d{2})'}, F:function() {
    return {g:1, c:'m \x3d parseInt(me.getMonthNumber(results[{0}]), 10);\n', s:'(' + utilDate.monthNames.join('|') + ')'};
  }, M:function() {
    for (var a = [], i = 0; i < 12; a.push(utilDate.getShortMonthName(i)), ++i) {
    }
    return Ext.applyIf({s:'(' + a.join('|') + ')'}, utilDate.formatCodeToRegex('F'));
  }, m:{g:1, c:'m \x3d parseInt(results[{0}], 10) - 1;\n', s:'(1[0-2]|0[1-9])'}, n:{g:1, c:'m \x3d parseInt(results[{0}], 10) - 1;\n', s:'(1[0-2]|[1-9])'}, t:{g:0, c:null, s:'(?:\\d{2})'}, L:{g:0, c:null, s:'(?:1|0)'}, o:{g:1, c:'y \x3d parseInt(results[{0}], 10);\n', s:'(\\d{4})'}, Y:{g:1, c:'y \x3d parseInt(results[{0}], 10);\n', s:'(\\d{4})'}, y:{g:1, c:'var ty \x3d parseInt(results[{0}], 10);\n' + 'y \x3d ty \x3e me.y2kYear ? 1900 + ty : 2000 + ty;\n', s:'(\\d{2})'}, a:{g:1, c:'if (/(am)/i.test(results[{0}])) {\n' + 
  'if (!h || h \x3d\x3d 12) { h \x3d 0; }\n' + '} else { if (!h || h \x3c 12) { h \x3d (h || 0) + 12; }}', s:'(am|pm|AM|PM)', calcAtEnd:true}, A:{g:1, c:'if (/(am)/i.test(results[{0}])) {\n' + 'if (!h || h \x3d\x3d 12) { h \x3d 0; }\n' + '} else { if (!h || h \x3c 12) { h \x3d (h || 0) + 12; }}', s:'(AM|PM|am|pm)', calcAtEnd:true}, g:{g:1, c:'h \x3d parseInt(results[{0}], 10);\n', s:'(1[0-2]|[1-9])'}, G:{g:1, c:'h \x3d parseInt(results[{0}], 10);\n', s:'(2[0-3]|1[0-9]|[0-9])'}, h:{g:1, c:'h \x3d parseInt(results[{0}], 10);\n', 
  s:'(1[0-2]|0[1-9])'}, H:{g:1, c:'h \x3d parseInt(results[{0}], 10);\n', s:'(2[0-3]|[0-1][0-9])'}, i:{g:1, c:'i \x3d parseInt(results[{0}], 10);\n', s:'([0-5][0-9])'}, s:{g:1, c:'s \x3d parseInt(results[{0}], 10);\n', s:'([0-5][0-9])'}, u:{g:1, c:'ms \x3d results[{0}]; ms \x3d parseInt(ms, 10)/Math.pow(10, ms.length - 3);\n', s:'(\\d+)'}, O:{g:1, c:['o \x3d results[{0}];', 'var sn \x3d o.substring(0,1),', 'hr \x3d o.substring(1,3)*1 + Math.floor(o.substring(3,5) / 60),', 'mn \x3d o.substring(3,5) % 60;', 
  "o \x3d ((-12 \x3c\x3d (hr*60 + mn)/60) \x26\x26 ((hr*60 + mn)/60 \x3c\x3d 14))? (sn + Ext.String.leftPad(hr, 2, '0') + Ext.String.leftPad(mn, 2, '0')) : null;\n"].join('\n'), s:'([+-]\\d{4})'}, P:{g:1, c:['o \x3d results[{0}];', 'var sn \x3d o.substring(0,1),', 'hr \x3d o.substring(1,3)*1 + Math.floor(o.substring(4,6) / 60),', 'mn \x3d o.substring(4,6) % 60;', "o \x3d ((-12 \x3c\x3d (hr*60 + mn)/60) \x26\x26 ((hr*60 + mn)/60 \x3c\x3d 14))? (sn + Ext.String.leftPad(hr, 2, '0') + Ext.String.leftPad(mn, 2, '0')) : null;\n"].join('\n'), 
  s:'([+-]\\d{2}:\\d{2})'}, T:{g:0, c:null, s:'[A-Z]{1,5}'}, Z:{g:1, c:'zz \x3d results[{0}] * 1;\n' + 'zz \x3d (-43200 \x3c\x3d zz \x26\x26 zz \x3c\x3d 50400)? zz : null;\n', s:'([+-]?\\d{1,5})'}, c:function() {
    var calc = [], arr = [utilDate.formatCodeToRegex('Y', 1), utilDate.formatCodeToRegex('m', 2), utilDate.formatCodeToRegex('d', 3), utilDate.formatCodeToRegex('H', 4), utilDate.formatCodeToRegex('i', 5), utilDate.formatCodeToRegex('s', 6), {c:"ms \x3d results[7] || '0'; ms \x3d parseInt(ms, 10)/Math.pow(10, ms.length - 3);\n"}, {c:['if(results[8]) {', "if(results[8] \x3d\x3d 'Z'){", 'zz \x3d 0;', "}else if (results[8].indexOf(':') \x3e -1){", utilDate.formatCodeToRegex('P', 8).c, '}else{', utilDate.formatCodeToRegex('O', 
    8).c, '}', '}'].join('\n')}], i, l;
    for (i = 0, l = arr.length; i < l; ++i) {
      calc.push(arr[i].c);
    }
    return {g:1, c:calc.join(''), s:[arr[0].s, '(?:', '-', arr[1].s, '(?:', '-', arr[2].s, '(?:', '(?:T| )?', arr[3].s, ':', arr[4].s, '(?::', arr[5].s, ')?', '(?:(?:\\.|,)(\\d+))?', '(Z|(?:[-+]\\d{2}(?::)?\\d{2}))?', ')?', ')?', ')?'].join('')};
  }, U:{g:1, c:'u \x3d parseInt(results[{0}], 10);\n', s:'(-?\\d+)'}}, dateFormat:function(date, format) {
    return utilDate.format(date, format);
  }, isEqual:function(date1, date2) {
    if (date1 && date2) {
      return date1.getTime() === date2.getTime();
    }
    return !(date1 || date2);
  }, format:function(date, format) {
    var formatFunctions = utilDate.formatFunctions;
    if (!Ext.isDate(date)) {
      return '';
    }
    if (formatFunctions[format] == null) {
      utilDate.createFormat(format);
    }
    return formatFunctions[format].call(date) + '';
  }, getTimezone:function(date) {
    return date.toString().replace(/^.* (?:\((.*)\)|([A-Z]{1,5})(?:[\-+][0-9]{4})?(?: -?\d+)?)$/, '$1$2').replace(/[^A-Z]/g, '');
  }, getGMTOffset:function(date, colon) {
    var offset = date.getTimezoneOffset();
    return (offset > 0 ? '-' : '+') + Ext.String.leftPad(Math.floor(Math.abs(offset) / 60), 2, '0') + (colon ? ':' : '') + Ext.String.leftPad(Math.abs(offset % 60), 2, '0');
  }, getDayOfYear:function(date) {
    var num = 0, d = utilDate.clone(date), m = date.getMonth(), i;
    for (i = 0, d.setDate(1), d.setMonth(0); i < m; d.setMonth(++i)) {
      num += utilDate.getDaysInMonth(d);
    }
    return num + date.getDate() - 1;
  }, getWeekOfYear:function() {
    var ms1d = 86400000, ms7d = 7 * ms1d;
    return function(date) {
      var DC3 = nativeDate.UTC(date.getFullYear(), date.getMonth(), date.getDate() + 3) / ms1d, AWN = Math.floor(DC3 / 7), Wyr = (new nativeDate(AWN * ms7d)).getUTCFullYear();
      return AWN - Math.floor(nativeDate.UTC(Wyr, 0, 7) / ms7d) + 1;
    };
  }(), isLeapYear:function(date) {
    var year = date.getFullYear();
    return !!((year & 3) === 0 && (year % 100 || year % 400 === 0 && year));
  }, getFirstDayOfMonth:function(date) {
    var day = (date.getDay() - (date.getDate() - 1)) % 7;
    return day < 0 ? day + 7 : day;
  }, getLastDayOfMonth:function(date) {
    return utilDate.getLastDateOfMonth(date).getDay();
  }, getFirstDateOfMonth:function(date) {
    return new nativeDate(date.getFullYear(), date.getMonth(), 1);
  }, getLastDateOfMonth:function(date) {
    return new nativeDate(date.getFullYear(), date.getMonth(), utilDate.getDaysInMonth(date));
  }, getDaysInMonth:function() {
    var daysInMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
    return function(date) {
      var m = date.getMonth();
      return m === 1 && utilDate.isLeapYear(date) ? 29 : daysInMonth[m];
    };
  }(), getSuffix:function(date) {
    switch(date.getDate()) {
      case 1:
      case 21:
      case 31:
        return 'st';
      case 2:
      case 22:
        return 'nd';
      case 3:
      case 23:
        return 'rd';
      default:
        return 'th';
    }
  }, clone:function(date) {
    return new nativeDate(date.getTime());
  }, isDST:function(date) {
    return (new nativeDate(date.getFullYear(), 0, 1)).getTimezoneOffset() !== date.getTimezoneOffset();
  }, clearTime:function(date, clone) {
    if (isNaN(date.getTime())) {
      return date;
    }
    if (clone) {
      return utilDate.clearTime(utilDate.clone(date));
    }
    var d = date.getDate(), hr, c;
    date.setHours(0);
    date.setMinutes(0);
    date.setSeconds(0);
    date.setMilliseconds(0);
    if (date.getDate() !== d) {
      for (hr = 1, c = utilDate.add(date, utilDate.HOUR, hr); c.getDate() !== d; hr++, c = utilDate.add(date, utilDate.HOUR, hr)) {
      }
      date.setDate(d);
      date.setHours(c.getHours());
    }
    return date;
  }, add:function(date, interval, value, preventDstAdjust) {
    var d = utilDate.clone(date), base = 0, day, decimalValue;
    if (!interval || value === 0) {
      return d;
    }
    decimalValue = value - parseInt(value, 10);
    value = parseInt(value, 10);
    if (value) {
      switch(interval.toLowerCase()) {
        case utilDate.MILLI:
          if (preventDstAdjust) {
            d.setMilliseconds(d.getMilliseconds() + value);
          } else {
            d.setTime(d.getTime() + value);
          }
          break;
        case utilDate.SECOND:
          if (preventDstAdjust) {
            d.setSeconds(d.getSeconds() + value);
          } else {
            d.setTime(d.getTime() + value * 1000);
          }
          break;
        case utilDate.MINUTE:
          if (preventDstAdjust) {
            d.setMinutes(d.getMinutes() + value);
          } else {
            d.setTime(d.getTime() + value * 60 * 1000);
          }
          break;
        case utilDate.HOUR:
          if (preventDstAdjust) {
            d.setHours(d.getHours() + value);
          } else {
            d.setTime(d.getTime() + value * 60 * 60 * 1000);
          }
          break;
        case utilDate.DAY:
          if (preventDstAdjust) {
            d.setDate(d.getDate() + value);
          } else {
            d.setTime(d.getTime() + value * 24 * 60 * 60 * 1000);
          }
          break;
        case utilDate.MONTH:
          day = date.getDate();
          if (day > 28) {
            day = Math.min(day, utilDate.getLastDateOfMonth(utilDate.add(utilDate.getFirstDateOfMonth(date), utilDate.MONTH, value)).getDate());
          }
          d.setDate(day);
          d.setMonth(date.getMonth() + value);
          break;
        case utilDate.YEAR:
          day = date.getDate();
          if (day > 28) {
            day = Math.min(day, utilDate.getLastDateOfMonth(utilDate.add(utilDate.getFirstDateOfMonth(date), utilDate.YEAR, value)).getDate());
          }
          d.setDate(day);
          d.setFullYear(date.getFullYear() + value);
          break;
      }
    }
    if (decimalValue) {
      switch(interval.toLowerCase()) {
        case utilDate.MILLI:
          base = 1;
          break;
        case utilDate.SECOND:
          base = 1000;
          break;
        case utilDate.MINUTE:
          base = 1000 * 60;
          break;
        case utilDate.HOUR:
          base = 1000 * 60 * 60;
          break;
        case utilDate.DAY:
          base = 1000 * 60 * 60 * 24;
          break;
        case utilDate.MONTH:
          day = utilDate.getDaysInMonth(d);
          base = 1000 * 60 * 60 * 24 * day;
          break;
        case utilDate.YEAR:
          day = utilDate.isLeapYear(d) ? 366 : 365;
          base = 1000 * 60 * 60 * 24 * day;
          break;
      }
      if (base) {
        d.setTime(d.getTime() + base * decimalValue);
      }
    }
    return d;
  }, subtract:function(date, interval, value, preventDstAdjust) {
    return utilDate.add(date, interval, -value, preventDstAdjust);
  }, between:function(date, start, end) {
    var t = date.getTime();
    return start.getTime() <= t && t <= end.getTime();
  }, isWeekend:function(date) {
    return Ext.Array.indexOf(this.weekendDays, date.getDay()) > -1;
  }, utcToLocal:function(d) {
    return new Date(d.getUTCFullYear(), d.getUTCMonth(), d.getUTCDate(), d.getUTCHours(), d.getUTCMinutes(), d.getUTCSeconds(), d.getUTCMilliseconds());
  }, localToUtc:function(d) {
    return utilDate.utc(d.getFullYear(), d.getMonth(), d.getDate(), d.getHours(), d.getMinutes(), d.getSeconds(), d.getMilliseconds());
  }, utc:function(year, month, day, hour, min, s, ms) {
    return new Date(Date.UTC(year, month, day, hour || 0, min || 0, s || 0, ms || 0));
  }, compat:function() {
    var p, statics = ['useStrict', 'formatCodeToRegex', 'parseFunctions', 'parseRegexes', 'formatFunctions', 'y2kYear', 'MILLI', 'SECOND', 'MINUTE', 'HOUR', 'DAY', 'MONTH', 'YEAR', 'defaults', 'dayNames', 'monthNames', 'monthNumbers', 'getShortMonthName', 'getShortDayName', 'getMonthNumber', 'formatCodes', 'isValid', 'parseDate', 'getFormatCode', 'createFormat', 'createParser', 'parseCodes'], proto = ['dateFormat', 'format', 'getTimezone', 'getGMTOffset', 'getDayOfYear', 'getWeekOfYear', 'isLeapYear', 
    'getFirstDayOfMonth', 'getLastDayOfMonth', 'getDaysInMonth', 'getSuffix', 'clone', 'isDST', 'clearTime', 'add', 'between'], sLen = statics.length, pLen = proto.length, stat, prot, s;
    for (s = 0; s < sLen; s++) {
      stat = statics[s];
      nativeDate[stat] = utilDate[stat];
    }
    for (p = 0; p < pLen; p++) {
      prot = proto[p];
      nativeDate.prototype[prot] = function() {
        var args = Array.prototype.slice.call(arguments);
        args.unshift(this);
        return utilDate[prot].apply(utilDate, args);
      };
    }
  }, diff:function(min, max, unit) {
    var est, diff = +max - min;
    switch(unit) {
      case utilDate.MILLI:
        return diff;
      case utilDate.SECOND:
        return Math.floor(diff / 1000);
      case utilDate.MINUTE:
        return Math.floor(diff / 60000);
      case utilDate.HOUR:
        return Math.floor(diff / 3600000);
      case utilDate.DAY:
        return Math.floor(diff / 86400000);
      case 'w':
        return Math.floor(diff / 604800000);
      case utilDate.MONTH:
        est = max.getFullYear() * 12 + max.getMonth() - (min.getFullYear() * 12 + min.getMonth());
        if (utilDate.add(min, unit, est) > max) {
          return est - 1;
        }
        return est;
      case utilDate.YEAR:
        est = max.getFullYear() - min.getFullYear();
        if (utilDate.add(min, unit, est) > max) {
          return est - 1;
        } else {
          return est;
        }
    }
  }, align:function(date, unit, step) {
    var num = new nativeDate(+date);
    switch(unit.toLowerCase()) {
      case utilDate.MILLI:
        return num;
      case utilDate.SECOND:
        num.setUTCSeconds(num.getUTCSeconds() - num.getUTCSeconds() % step);
        num.setUTCMilliseconds(0);
        return num;
      case utilDate.MINUTE:
        num.setUTCMinutes(num.getUTCMinutes() - num.getUTCMinutes() % step);
        num.setUTCSeconds(0);
        num.setUTCMilliseconds(0);
        return num;
      case utilDate.HOUR:
        num.setUTCHours(num.getUTCHours() - num.getUTCHours() % step);
        num.setUTCMinutes(0);
        num.setUTCSeconds(0);
        num.setUTCMilliseconds(0);
        return num;
      case utilDate.DAY:
        if (step === 7 || step === 14) {
          num.setUTCDate(num.getUTCDate() - num.getUTCDay() + 1);
        }
        num.setUTCHours(0);
        num.setUTCMinutes(0);
        num.setUTCSeconds(0);
        num.setUTCMilliseconds(0);
        return num;
      case utilDate.MONTH:
        num.setUTCMonth(num.getUTCMonth() - (num.getUTCMonth() - 1) % step, 1);
        num.setUTCHours(0);
        num.setUTCMinutes(0);
        num.setUTCSeconds(0);
        num.setUTCMilliseconds(0);
        return num;
      case utilDate.YEAR:
        num.setUTCFullYear(num.getUTCFullYear() - num.getUTCFullYear() % step, 1, 1);
        num.setUTCHours(0);
        num.setUTCMinutes(0);
        num.setUTCSeconds(0);
        num.setUTCMilliseconds(0);
        return date;
    }
  }};
  utilDate.parseCodes.C = utilDate.parseCodes.c;
  return utilDate;
}();
Ext.Function = function() {
  var lastTime = 0, animFrameId, animFrameHandlers = [], animFrameNoArgs = [], idSource = 0, animFrameMap = {}, slice = Array.prototype.slice, win = window, global = Ext.global, hasImmediate = !Ext.disableImmediate && !!(global.setImmediate && global.clearImmediate), requestAnimFrame = win.requestAnimationFrame || win.webkitRequestAnimationFrame || win.mozRequestAnimationFrame || win.oRequestAnimationFrame || function(callback) {
    var currTime = Ext.now(), timeToCall = Math.max(0, 16 - (currTime - lastTime)), timerFn = function() {
      callback(currTime + timeToCall);
    }, id;
    timerFn.$origFn = callback.$origFn || callback;
    timerFn.$skipTimerCheck = timerFn.$origFn.$skipTimerCheck;
    id = win.setTimeout(timerFn, timeToCall);
    lastTime = currTime + timeToCall;
    return id;
  }, fireHandlers = function() {
    var len = animFrameHandlers.length, id, i, handler;
    animFrameId = null;
    var timer;
    for (i = 0; i < len; i++) {
      handler = animFrameHandlers[i];
      id = handler[3];
      if (animFrameMap[id]) {
        delete animFrameMap[id];
        timer = Ext.Timer.get(id, 'raf');
        if (timer) {
          timer.tick();
        }
        handler[0].apply(handler[1] || global, handler[2] || animFrameNoArgs);
        if (timer) {
          timer.tock();
        }
      }
    }
    animFrameHandlers = animFrameHandlers.slice(len);
  }, fireElevatedHandlers = function() {
    Ext.elevate(fireHandlers);
  }, ExtFunction = {flexSetter:function(setter) {
    return function(name, value) {
      var k, i;
      if (name !== null) {
        if (typeof name !== 'string') {
          for (k in name) {
            if (name.hasOwnProperty(k)) {
              setter.call(this, k, name[k]);
            }
          }
          if (Ext.enumerables) {
            for (i = Ext.enumerables.length; i--;) {
              k = Ext.enumerables[i];
              if (name.hasOwnProperty(k)) {
                setter.call(this, k, name[k]);
              }
            }
          }
        } else {
          setter.call(this, name, value);
        }
      }
      return this;
    };
  }, bind:function(fn, scope, args, appendArgs) {
    if (arguments.length <= 2) {
      return fn.bind(scope);
    }
    var method = fn;
    return function() {
      var callArgs = args || arguments;
      if (appendArgs === true) {
        callArgs = slice.call(arguments, 0);
        callArgs = callArgs.concat(args);
      } else {
        if (typeof appendArgs === 'number') {
          callArgs = slice.call(arguments, 0);
          Ext.Array.insert(callArgs, appendArgs, args);
        }
      }
      return method.apply(scope || global, callArgs);
    };
  }, bindCallback:function(callback, scope, args, delay, caller) {
    return function() {
      var a = slice.call(arguments);
      return Ext.callback(callback, scope, args ? args.concat(a) : a, delay, caller);
    };
  }, pass:function(fn, args, scope) {
    if (!Ext.isArray(args)) {
      if (Ext.isIterable(args)) {
        args = Ext.Array.clone(args);
      } else {
        args = args !== undefined ? [args] : [];
      }
    }
    return function() {
      var fnArgs = args.slice();
      fnArgs.push.apply(fnArgs, arguments);
      return fn.apply(scope || this, fnArgs);
    };
  }, alias:function(object, methodName) {
    return function() {
      return object[methodName].apply(object, arguments);
    };
  }, clone:function(method) {
    var newMethod, prop;
    newMethod = function() {
      return method.apply(this, arguments);
    };
    for (prop in method) {
      if (method.hasOwnProperty(prop)) {
        newMethod[prop] = method[prop];
      }
    }
    return newMethod;
  }, createInterceptor:function(origFn, newFn, scope, returnValue) {
    if (!Ext.isFunction(newFn)) {
      return origFn;
    } else {
      returnValue = Ext.isDefined(returnValue) ? returnValue : null;
      return function() {
        var me = this, args = arguments;
        return newFn.apply(scope || me || global, args) !== false ? origFn.apply(me || global, args) : returnValue;
      };
    }
  }, createDelayed:function(fn, delay, scope, args, appendArgs) {
    var boundFn = fn;
    if (scope || args) {
      boundFn = Ext.Function.bind(fn, scope, args, appendArgs);
    }
    return function() {
      var me = this, args = slice.call(arguments), timerFn, timerId;
      var timer;
      timerFn = function() {
        Ext.elevate(boundFn, me, args, timer);
      };
      timerId = setTimeout(timerFn, delay);
      timerFn.$origFn = fn.$origFn || fn;
      timerFn.$skipTimerCheck = timerFn.$origFn.$skipTimerCheck;
      timer = Ext.Timer.created('timeout', timerId, {type:'createDelayed', fn:fn, timerFn:timerFn});
    };
  }, defer:function(fn, millis, scope, args, appendArgs) {
    var timerId = 0, timerFn, boundFn;
    var timer;
    if (!scope && !args && !appendArgs) {
      boundFn = fn;
    } else {
      boundFn = Ext.Function.bind(fn, scope, args, appendArgs);
    }
    if (millis > 0) {
      timerFn = function() {
        Ext.elevate(boundFn, null, null, timer);
      };
      timerId = setTimeout(timerFn, millis);
      timerFn.$origFn = fn.$origFn || fn;
      timerFn.$skipTimerCheck = timerFn.$origFn.$skipTimerCheck;
      timer = Ext.Timer.created('timeout', timerId, {type:'defer', fn:fn, timerFn:timerFn});
    } else {
      boundFn();
    }
    return timerId;
  }, interval:function(fn, millis, scope, args, appendArgs) {
    var timerFn, timerId, boundFn;
    var timer;
    boundFn = Ext.Function.bind(fn, scope, args, appendArgs);
    timerFn = function() {
      Ext.elevate(boundFn, null, null, timer);
    };
    timerId = setInterval(timerFn, millis);
    timerFn.$origFn = boundFn.$origFn || fn;
    timerFn.$skipTimerCheck = timerFn.$origFn.$skipTimerCheck;
    timer = Ext.Timer.created('interval', timerId, {type:'interval', fn:fn, timerFn:timerFn});
    return timerId;
  }, createSequence:function(originalFn, newFn, scope) {
    if (!newFn) {
      return originalFn;
    } else {
      return function() {
        var result = originalFn.apply(this, arguments);
        newFn.apply(scope || this, arguments);
        return result;
      };
    }
  }, createBuffered:function(fn, buffer, scope, args) {
    var timerId, result = function() {
      var callArgs = args || slice.call(arguments, 0), me = scope || this, timerFn;
      var timer;
      if (timerId) {
        Ext.undefer(timerId);
      }
      timerFn = function() {
        Ext.elevate(fn, me, callArgs, timer);
      };
      result.timer = timerId = setTimeout(timerFn, buffer);
      timerFn.$origFn = fn.$origFn || fn;
      timerFn.$skipTimerCheck = timerFn.$origFn.$skipTimerCheck;
      timer = Ext.Timer.created('timeout', timerId, {type:'createBuffered', fn:fn, timerFn:timerFn});
    };
    return result;
  }, createAnimationFrame:function(fn, scope, args, queueStrategy) {
    var boundFn, timerId;
    queueStrategy = queueStrategy || 3;
    boundFn = function() {
      var timerFn, callArgs = args || slice.call(arguments, 0);
      scope = scope || this;
      if (queueStrategy === 3 && timerId) {
        ExtFunction.cancelAnimationFrame(timerId);
      }
      if (queueStrategy & 1 || !timerId) {
        timerFn = function() {
          timerId = boundFn.timerId = null;
          fn.apply(scope, callArgs);
        };
        timerFn.$origFn = fn.$origFn || fn;
        timerFn.$skipTimerCheck = timerFn.$origFn.$skipTimerCheck;
        timerId = boundFn.timerId = ExtFunction.requestAnimationFrame(timerFn);
      }
    };
    return boundFn;
  }, requestAnimationFrame:function(fn, scope, args) {
    var id = ++idSource, handler = slice.call(arguments, 0);
    handler[3] = id;
    animFrameMap[id] = 1;
    Ext.Timer.created('raf', id, {type:'raf', fn:fn});
    animFrameHandlers.push(handler);
    if (!animFrameId) {
      animFrameId = requestAnimFrame(fireElevatedHandlers);
    }
    return id;
  }, cancelAnimationFrame:function(id) {
    delete animFrameMap[id];
    Ext.Timer.cancel('raf', id);
  }, createThrottled:function(fn, interval, scope) {
    var lastCallTime = 0, elapsed, lastArgs, timerId, execute = function() {
      fn.apply(scope, lastArgs);
      lastCallTime = Ext.now();
      lastArgs = timerId = null;
    };
    execute.$origFn = fn.$origFn || fn;
    execute.$skipTimerCheck = execute.$origFn.$skipTimerCheck;
    return function() {
      if (!scope) {
        scope = this;
      }
      elapsed = Ext.now() - lastCallTime;
      lastArgs = Ext.Array.slice(arguments);
      if (elapsed >= interval) {
        Ext.undefer(timerId);
        execute();
      } else {
        if (!timerId) {
          timerId = Ext.defer(execute, interval - elapsed);
        }
      }
    };
  }, createBarrier:function(count, fn, scope) {
    var barrierFn = function() {
      if (!--count) {
        fn.apply(scope, arguments);
      }
    };
    barrierFn.$origFn = fn.$origFn || fn;
    barrierFn.$skipTimerCheck = barrierFn.$origFn.$skipTimerCheck;
    return barrierFn;
  }, interceptBefore:function(object, methodName, fn, scope) {
    var method = object[methodName] || Ext.emptyFn;
    return object[methodName] = function() {
      var ret = fn.apply(scope || this, arguments);
      method.apply(this, arguments);
      return ret;
    };
  }, interceptAfter:function(object, methodName, fn, scope) {
    var method = object[methodName] || Ext.emptyFn;
    return object[methodName] = function() {
      method.apply(this, arguments);
      return fn.apply(scope || this, arguments);
    };
  }, interceptAfterOnce:function(object, methodName, fn, scope) {
    var origMethod = object[methodName], newMethod;
    newMethod = function() {
      var ret;
      if (origMethod) {
        origMethod.apply(this, arguments);
      }
      ret = fn.apply(scope || this, arguments);
      object[methodName] = origMethod;
      object = methodName = fn = scope = origMethod = newMethod = null;
      return ret;
    };
    object[methodName] = newMethod;
    return newMethod;
  }, makeCallback:function(callback, scope) {
    if (!scope[callback]) {
      if (scope.$className) {
        Ext.raise('No method "' + callback + '" on ' + scope.$className);
      }
      Ext.raise('No method "' + callback + '"');
    }
    return function() {
      return scope[callback].apply(scope, arguments);
    };
  }, memoize:function(fn, scope, hashFn) {
    var memo = {}, isFunc = hashFn && Ext.isFunction(hashFn);
    return function(value) {
      var key = isFunc ? hashFn.apply(scope, arguments) : value;
      if (!(key in memo)) {
        memo[key] = fn.apply(scope, arguments);
      }
      return memo[key];
    };
  }, _stripCommentRe:/(\/\*([^*]|[\r\n]|(\*+([^*/]|[\r\n])))*\*+\/)|(\/\/.*)/g, toCode:function(fn) {
    var s = fn ? fn.toString() : '';
    s = s.replace(ExtFunction._stripCommentRe, '');
    return s;
  }, fireElevatedHandlers:function() {
    fireElevatedHandlers();
  }};
  Ext.asap = hasImmediate ? function(fn, scope, parameters) {
    var boundFn = fn, timerFn, timerId;
    var timer;
    if (scope != null || parameters != null) {
      boundFn = ExtFunction.bind(fn, scope, parameters);
    }
    timerFn = function() {
      Ext.elevate(boundFn, null, null, timer);
    };
    timerId = setImmediate(timerFn);
    timerFn.$origFn = fn.$origFn || fn;
    timerFn.$skipTimerCheck = timerFn.$origFn.$skipTimerCheck;
    timer = Ext.Timer.created('asap', timerId, {type:'asap', fn:fn, timerFn:timerFn});
    return timerId;
  } : function(fn, scope, parameters) {
    var boundFn = fn, timerFn, timerId;
    var timer;
    if (scope != null || parameters != null) {
      boundFn = ExtFunction.bind(fn, scope, parameters);
    }
    timerFn = function() {
      Ext.elevate(boundFn, null, null, timer);
    };
    timerId = setTimeout(timerFn, 0, true);
    timerFn.$origFn = fn.$origFn || fn;
    timerFn.$skipTimerCheck = timerFn.$origFn.$skipTimerCheck;
    timer = Ext.Timer.created('timeout', timerId, {type:'asap', fn:fn, timerFn:timerFn});
    return timerId;
  };
  Ext.unasap = hasImmediate ? function(id) {
    if (id) {
      clearImmediate(id);
      Ext.Timer.cancel('asap', id);
    }
    return null;
  } : function(id) {
    return Ext.undefer(id);
  };
  Ext.asapCancel = function(id) {
    return Ext.unasap(id);
  };
  Ext.defer = ExtFunction.defer;
  Ext.undefer = function(id) {
    if (id) {
      clearTimeout(id);
      Ext.Timer.cancel('timeout', id);
    }
    return null;
  };
  Ext.interval = ExtFunction.interval;
  Ext.uninterval = function(id) {
    if (id) {
      clearInterval(id);
      Ext.Timer.cancel('interval', id);
    }
    return null;
  };
  Ext.pass = ExtFunction.pass;
  Ext.bind = ExtFunction.bind;
  Ext.raf = function() {
    return ExtFunction.requestAnimationFrame.apply(ExtFunction, arguments);
  };
  Ext.unraf = function(id) {
    ExtFunction.cancelAnimationFrame(id);
  };
  return ExtFunction;
}();
Ext.Number = new function() {
  var ExtNumber = this, isToFixedBroken = (0.9).toFixed() !== '1', math = Math, ClipDefault = {count:false, inclusive:false, wrap:true};
  Number.MIN_SAFE_INTEGER = Number.MIN_SAFE_INTEGER || -(math.pow(2, 53) - 1);
  Number.MAX_SAFE_INTEGER = Number.MAX_SAFE_INTEGER || math.pow(2, 53) - 1;
  Ext.apply(ExtNumber, {MIN_SAFE_INTEGER:Number.MIN_SAFE_INTEGER, MAX_SAFE_INTEGER:Number.MAX_SAFE_INTEGER, floatRe:/^[-+]?(?:\d+|\d*\.\d*)(?:[Ee][+-]?\d+)?$/, intRe:/^[-+]?\d+(?:[Ee]\+?\d+)?$/, Clip:{DEFAULT:ClipDefault, COUNT:Ext.applyIf({count:true}, ClipDefault), INCLUSIVE:Ext.applyIf({inclusive:true}, ClipDefault), NOWRAP:Ext.applyIf({wrap:false}, ClipDefault)}, parseFloat:function(value) {
    if (value === undefined) {
      value = null;
    }
    if (value !== null && typeof value !== 'number') {
      value = String(value);
      value = ExtNumber.floatRe.test(value) ? +value : null;
      if (isNaN(value)) {
        value = null;
      }
    }
    return value;
  }, parseInt:function(value) {
    if (value === undefined) {
      value = null;
    }
    if (typeof value === 'number') {
      value = Math.floor(value);
    } else {
      if (value !== null) {
        value = String(value);
        value = ExtNumber.intRe.test(value) ? +value : null;
      }
    }
    return value;
  }, binarySearch:function(array, value, begin, end) {
    if (begin === undefined) {
      begin = 0;
    }
    if (end === undefined) {
      end = array.length;
    }
    --end;
    var middle, midVal;
    while (begin <= end) {
      middle = begin + end >>> 1;
      midVal = array[middle];
      if (value === midVal) {
        return middle;
      }
      if (midVal < value) {
        begin = middle + 1;
      } else {
        end = middle - 1;
      }
    }
    return begin;
  }, bisectTuples:function(array, value, index, begin, end) {
    if (begin === undefined) {
      begin = 0;
    }
    if (end === undefined) {
      end = array.length;
    }
    --end;
    var middle, midVal;
    while (begin <= end) {
      middle = begin + end >>> 1;
      midVal = array[middle][index];
      if (value === midVal) {
        return middle;
      }
      if (midVal < value) {
        begin = middle + 1;
      } else {
        end = middle - 1;
      }
    }
    return begin;
  }, clipIndices:function(length, indices, options) {
    options = options || ClipDefault;
    var defaultValue = 0, wrap = options.wrap, begin, end, i;
    indices = indices || [];
    for (i = 0; i < 2; ++i) {
      begin = end;
      end = indices[i];
      if (end == null) {
        end = defaultValue;
      } else {
        if (i && options.count) {
          end += begin;
          end = end > length ? length : end;
        } else {
          if (wrap) {
            end = end < 0 ? length + end : end;
          }
          if (i && options.inclusive) {
            ++end;
          }
          end = end < 0 ? 0 : end > length ? length : end;
        }
      }
      defaultValue = length;
    }
    indices[0] = begin;
    indices[1] = end < begin ? begin : end;
    return indices;
  }, constrain:function(number, min, max) {
    var x = parseFloat(number);
    if (min === null) {
      min = number;
    }
    if (max === null) {
      max = number;
    }
    return x < min ? min : x > max ? max : x;
  }, snap:function(value, increment, minValue, maxValue) {
    var m;
    if (value === undefined || value < minValue) {
      return minValue || 0;
    }
    if (increment) {
      m = value % increment;
      if (m !== 0) {
        value -= m;
        if (m * 2 >= increment) {
          value += increment;
        } else {
          if (m * 2 < -increment) {
            value -= increment;
          }
        }
      }
    }
    return ExtNumber.constrain(value, minValue, maxValue);
  }, snapInRange:function(value, increment, minValue, maxValue) {
    var tween;
    minValue = minValue || 0;
    if (value === undefined || value < minValue) {
      return minValue;
    }
    if (increment && (tween = (value - minValue) % increment)) {
      value -= tween;
      tween *= 2;
      if (tween >= increment) {
        value += increment;
      }
    }
    if (maxValue !== undefined) {
      if (value > (maxValue = ExtNumber.snapInRange(maxValue, increment, minValue))) {
        value = maxValue;
      }
    }
    return value;
  }, roundToNearest:function(value, interval) {
    interval = interval || 1;
    return interval * math.round(value / interval);
  }, roundToPrecision:function(value, precision) {
    var factor = math.pow(10, precision || 1);
    return math.round(value * factor) / factor;
  }, truncateToPrecision:function(value, precision) {
    var factor = math.pow(10, precision || 1);
    return parseInt(value * factor, 10) / factor;
  }, sign:math.sign || function(x) {
    x = +x;
    if (x === 0 || isNaN(x)) {
      return x;
    }
    return x > 0 ? 1 : -1;
  }, log10:math.log10 || function(x) {
    return math.log(x) * math.LOG10E;
  }, isEqual:function(n1, n2, epsilon) {
    if (!(typeof n1 === 'number' && typeof n2 === 'number' && typeof epsilon === 'number')) {
      Ext.raise('All parameters should be valid numbers.');
    }
    return math.abs(n1 - n2) < epsilon;
  }, isFinite:Number.isFinite || function(value) {
    return typeof value === 'number' && isFinite(value);
  }, isInteger:Number.isInteger || function(value) {
    return ~~(value + 0) === value;
  }, toFixed:isToFixedBroken ? function(value, precision) {
    precision = precision || 0;
    var pow = math.pow(10, precision);
    return (math.round(value * pow) / pow).toFixed(precision);
  } : function(value, precision) {
    return value.toFixed(precision);
  }, from:function(value, defaultValue) {
    if (isFinite(value)) {
      value = parseFloat(value);
    }
    return !isNaN(value) ? value : defaultValue;
  }, randomInt:function(from, to) {
    return math.floor(math.random() * (to - from + 1) + from);
  }, correctFloat:function(n) {
    return parseFloat(n.toPrecision(14));
  }});
  Ext.num = function() {
    return ExtNumber.from.apply(this, arguments);
  };
};
(function() {
  var TemplateClass = function() {
  }, queryRe = /^\?/, keyRe = /(\[):?([^\]]*)\]/g, nameRe = /^([^\[]+)/, plusRe = /\+/g, ExtObject = Ext.Object = {chain:Object.create || function(object) {
    TemplateClass.prototype = object;
    var result = new TemplateClass;
    TemplateClass.prototype = null;
    return result;
  }, clear:function(object) {
    for (var key in object) {
      delete object[key];
    }
    return object;
  }, freeze:Object.freeze ? function(obj, deep) {
    if (obj && typeof obj === 'object' && !Object.isFrozen(obj)) {
      Object.freeze(obj);
      if (deep) {
        for (var name in obj) {
          ExtObject.freeze(obj[name], deep);
        }
      }
    }
    return obj;
  } : Ext.identityFn, toQueryObjects:function(name, value, recursive) {
    var self = ExtObject.toQueryObjects, objects = [], i, ln;
    if (Ext.isArray(value)) {
      for (i = 0, ln = value.length; i < ln; i++) {
        if (recursive) {
          objects = objects.concat(self(name + '[' + i + ']', value[i], true));
        } else {
          objects.push({name:name, value:value[i]});
        }
      }
    } else {
      if (Ext.isObject(value)) {
        for (i in value) {
          if (value.hasOwnProperty(i)) {
            if (recursive) {
              objects = objects.concat(self(name + '[' + i + ']', value[i], true));
            } else {
              objects.push({name:name, value:value[i]});
            }
          }
        }
      } else {
        objects.push({name:name, value:value});
      }
    }
    return objects;
  }, toQueryString:function(object, recursive) {
    var paramObjects = [], params = [], i, j, ln, paramObject, value;
    for (i in object) {
      if (object.hasOwnProperty(i)) {
        paramObjects = paramObjects.concat(ExtObject.toQueryObjects(i, object[i], recursive));
      }
    }
    for (j = 0, ln = paramObjects.length; j < ln; j++) {
      paramObject = paramObjects[j];
      value = paramObject.value;
      if (Ext.isEmpty(value)) {
        value = '';
      } else {
        if (Ext.isDate(value)) {
          value = Ext.Date.toString(value);
        }
      }
      params.push(encodeURIComponent(paramObject.name) + '\x3d' + encodeURIComponent(String(value)));
    }
    return params.join('\x26');
  }, fromQueryString:function(queryString, recursive) {
    var parts = queryString.replace(queryRe, '').split('\x26'), object = {}, temp, components, name, value, i, ln, part, j, subLn, matchedKeys, matchedName, keys, key, nextKey;
    for (i = 0, ln = parts.length; i < ln; i++) {
      part = parts[i];
      if (part.length > 0) {
        components = part.split('\x3d');
        name = components[0];
        name = name.replace(plusRe, '%20');
        name = decodeURIComponent(name);
        value = components[1];
        if (value !== undefined) {
          value = value.replace(plusRe, '%20');
          value = decodeURIComponent(value);
        } else {
          value = '';
        }
        if (!recursive) {
          if (object.hasOwnProperty(name)) {
            if (!Ext.isArray(object[name])) {
              object[name] = [object[name]];
            }
            object[name].push(value);
          } else {
            object[name] = value;
          }
        } else {
          matchedKeys = name.match(keyRe);
          matchedName = name.match(nameRe);
          if (!matchedName) {
            throw new Error('[Ext.Object.fromQueryString] Malformed query string given, failed parsing name from "' + part + '"');
          }
          name = matchedName[0];
          keys = [];
          if (matchedKeys === null) {
            object[name] = value;
            continue;
          }
          for (j = 0, subLn = matchedKeys.length; j < subLn; j++) {
            key = matchedKeys[j];
            key = key.length === 2 ? '' : key.substring(1, key.length - 1);
            keys.push(key);
          }
          keys.unshift(name);
          temp = object;
          for (j = 0, subLn = keys.length; j < subLn; j++) {
            key = keys[j];
            if (j === subLn - 1) {
              if (Ext.isArray(temp) && key === '') {
                temp.push(value);
              } else {
                temp[key] = value;
              }
            } else {
              if (temp[key] === undefined || typeof temp[key] === 'string') {
                nextKey = keys[j + 1];
                temp[key] = Ext.isNumeric(nextKey) || nextKey === '' ? [] : {};
              }
              temp = temp[key];
            }
          }
        }
      }
    }
    return object;
  }, each:function(object, fn, scope) {
    var enumerables = Ext.enumerables, i, property;
    if (object) {
      scope = scope || object;
      for (property in object) {
        if (object.hasOwnProperty(property)) {
          if (fn.call(scope, property, object[property], object) === false) {
            return;
          }
        }
      }
      if (enumerables) {
        for (i = enumerables.length; i--;) {
          if (object.hasOwnProperty(property = enumerables[i])) {
            if (fn.call(scope, property, object[property], object) === false) {
              return;
            }
          }
        }
      }
    }
  }, eachValue:function(object, fn, scope) {
    var enumerables = Ext.enumerables, i, property;
    scope = scope || object;
    for (property in object) {
      if (object.hasOwnProperty(property)) {
        if (fn.call(scope, object[property]) === false) {
          return;
        }
      }
    }
    if (enumerables) {
      for (i = enumerables.length; i--;) {
        if (object.hasOwnProperty(property = enumerables[i])) {
          if (fn.call(scope, object[property]) === false) {
            return;
          }
        }
      }
    }
  }, merge:function(destination) {
    var i = 1, args = arguments, ln = args.length, mergeFn = ExtObject.merge, cloneFn = Ext.clone, object, key, value, sourceKey;
    for (; i < ln; i++) {
      object = args[i];
      for (key in object) {
        value = object[key];
        if (value && value.constructor === Object) {
          sourceKey = destination[key];
          if (sourceKey && sourceKey.constructor === Object) {
            mergeFn(sourceKey, value);
          } else {
            destination[key] = cloneFn(value);
          }
        } else {
          destination[key] = value;
        }
      }
    }
    return destination;
  }, mergeIf:function(destination) {
    var i = 1, ln = arguments.length, cloneFn = Ext.clone, object, key, value;
    for (; i < ln; i++) {
      object = arguments[i];
      for (key in object) {
        if (!(key in destination)) {
          value = object[key];
          if (value && value.constructor === Object) {
            destination[key] = cloneFn(value);
          } else {
            destination[key] = value;
          }
        }
      }
    }
    return destination;
  }, getAllKeys:function(object) {
    var keys = [], property;
    for (property in object) {
      keys.push(property);
    }
    return keys;
  }, getKey:function(object, value) {
    for (var property in object) {
      if (object.hasOwnProperty(property) && object[property] === value) {
        return property;
      }
    }
    return null;
  }, getValues:function(object) {
    var values = [], property;
    for (property in object) {
      if (object.hasOwnProperty(property)) {
        values.push(object[property]);
      }
    }
    return values;
  }, getKeys:typeof Object.keys == 'function' ? function(object) {
    if (!object) {
      return [];
    }
    return Object.keys(object);
  } : function(object) {
    var keys = [], property;
    for (property in object) {
      if (object.hasOwnProperty(property)) {
        keys.push(property);
      }
    }
    return keys;
  }, getSize:function(object) {
    var size = 0, property;
    for (property in object) {
      if (object.hasOwnProperty(property)) {
        size++;
      }
    }
    return size;
  }, isEmpty:function(object) {
    for (var key in object) {
      if (object.hasOwnProperty(key)) {
        return false;
      }
    }
    return true;
  }, equals:function() {
    var check = function(o1, o2) {
      var key;
      for (key in o1) {
        if (o1.hasOwnProperty(key)) {
          if (o1[key] !== o2[key]) {
            return false;
          }
        }
      }
      return true;
    };
    return function(object1, object2) {
      if (object1 === object2) {
        return true;
      }
      if (object1 && object2) {
        return check(object1, object2) && check(object2, object1);
      } else {
        if (!object1 && !object2) {
          return object1 === object2;
        } else {
          return false;
        }
      }
    };
  }(), fork:function(obj) {
    var ret, key, value;
    if (obj && obj.constructor === Object) {
      ret = ExtObject.chain(obj);
      for (key in obj) {
        value = obj[key];
        if (value) {
          if (value.constructor === Object) {
            ret[key] = ExtObject.fork(value);
          } else {
            if (value instanceof Array) {
              ret[key] = Ext.Array.clone(value);
            }
          }
        }
      }
    } else {
      ret = obj;
    }
    return ret;
  }, defineProperty:'defineProperty' in Object ? Object.defineProperty : function(object, name, descriptor) {
    if (!Object.prototype.__defineGetter__) {
      return;
    }
    if (descriptor.get) {
      object.__defineGetter__(name, descriptor.get);
    }
    if (descriptor.set) {
      object.__defineSetter__(name, descriptor.set);
    }
  }, classify:function(object) {
    var prototype = object, objectProperties = [], propertyClassesMap = {}, objectClass = function() {
      var i = 0, ln = objectProperties.length, property;
      for (; i < ln; i++) {
        property = objectProperties[i];
        this[property] = new propertyClassesMap[property];
      }
    }, key, value;
    for (key in object) {
      if (object.hasOwnProperty(key)) {
        value = object[key];
        if (value && value.constructor === Object) {
          objectProperties.push(key);
          propertyClassesMap[key] = ExtObject.classify(value);
        }
      }
    }
    objectClass.prototype = prototype;
    return objectClass;
  }};
  Ext.merge = Ext.Object.merge;
  Ext.mergeIf = Ext.Object.mergeIf;
})();
Ext.apply(Ext, {_namedScopes:{'this':{isThis:1}, controller:{isController:1}, owner:{isOwner:1}, self:{isSelf:1}, 'self.controller':{isSelf:1, isController:1}}, escapeId:function() {
  var validIdRe = /^[a-zA-Z_][a-zA-Z0-9_\-]*$/i, escapeRx = /([\W]{1})/g, leadingNumRx = /^(\d)/g, escapeFn = function(match, capture) {
    return '\\' + capture;
  }, numEscapeFn = function(match, capture) {
    return '\\00' + capture.charCodeAt(0).toString(16) + ' ';
  };
  return function(id) {
    return validIdRe.test(id) ? id : id.replace(escapeRx, escapeFn).replace(leadingNumRx, numEscapeFn);
  };
}(), callback:function(callback, scope, args, delay, caller, defaultScope) {
  if (!callback) {
    return;
  }
  var namedScope = scope in Ext._namedScopes;
  if (callback.charAt) {
    if (callback[2] === '.') {
      if (callback.substr(0, 2) !== 'up') {
        Ext.raise('Invalid callback method name "' + callback + '"');
      }
      if (scope) {
        Ext.raise('Callback "up" syntax is incompatible with scopes');
      }
      if (!caller || !Ext.isFunction(caller.up)) {
        Ext.raise('Callback "up" syntax requires a caller with "up" method');
      }
      callback = callback.substr(3);
      for (scope = caller.up(); scope && !scope[callback]; scope = scope.up()) {
      }
      if (!scope || !Ext.isFunction(scope[callback])) {
        Ext.raise('No such method "' + callback + '" found up() from ' + scope.getId ? scope.getId() : scope.id);
      }
    } else {
      if ((!scope || namedScope) && caller) {
        scope = caller.resolveListenerScope(namedScope ? scope : defaultScope);
      }
    }
    if (!scope || !Ext.isObject(scope)) {
      Ext.raise('Named method "' + callback + '" requires a scope object');
    }
    if (!Ext.isFunction(scope[callback])) {
      Ext.raise('No method named "' + callback + '" on ' + (scope.$className || 'scope object'));
    }
    callback = scope[callback];
  } else {
    if (namedScope) {
      scope = defaultScope || caller;
    } else {
      if (!scope) {
        scope = caller;
      }
    }
  }
  var ret;
  if (callback && Ext.isFunction(callback)) {
    scope = scope || Ext.global;
    if (delay) {
      Ext.defer(callback, delay, scope, args);
    } else {
      ret = args ? callback.apply(scope, args) : callback.call(scope);
    }
  }
  return ret;
}, coerce:function(from, to) {
  var fromType = Ext.typeOf(from), toType = Ext.typeOf(to), isString = typeof from === 'string';
  if (fromType !== toType) {
    switch(toType) {
      case 'string':
        return String(from);
      case 'number':
        return Number(from);
      case 'boolean':
        return isString && (!from || from === 'false' || from === '0') ? false : Boolean(from);
      case 'null':
        return isString && (!from || from === 'null') ? null : false;
      case 'undefined':
        return isString && (!from || from === 'undefined') ? undefined : false;
      case 'date':
        return isString && isNaN(from) ? Ext.Date.parse(from, Ext.Date.defaultFormat) : Date(Number(from));
    }
  }
  return from;
}, copyTo:function(dest, source, names, usePrototypeKeys) {
  if (typeof names === 'string') {
    names = names.split(Ext.propertyNameSplitRe);
  }
  for (var name, i = 0, n = names ? names.length : 0; i < n; i++) {
    name = names[i];
    if (usePrototypeKeys || source.hasOwnProperty(name)) {
      dest[name] = source[name];
    }
  }
  return dest;
}, copy:function(dest, source, names, usePrototypeKeys) {
  if (typeof names === 'string') {
    names = names.split(Ext.propertyNameSplitRe);
  }
  for (var name, i = 0, n = names ? names.length : 0; i < n; i++) {
    name = names[i];
    if (source.hasOwnProperty(name) || usePrototypeKeys && name in source) {
      dest[name] = source[name];
    }
  }
  return dest;
}, propertyNameSplitRe:/[,;\s]+/, copyToIf:function(destination, source, names) {
  if (typeof names === 'string') {
    names = names.split(Ext.propertyNameSplitRe);
  }
  for (var name, i = 0, n = names ? names.length : 0; i < n; i++) {
    name = names[i];
    if (destination[name] === undefined) {
      destination[name] = source[name];
    }
  }
  return destination;
}, copyIf:function(destination, source, names) {
  if (typeof names === 'string') {
    names = names.split(Ext.propertyNameSplitRe);
  }
  for (var name, i = 0, n = names ? names.length : 0; i < n; i++) {
    name = names[i];
    if (!(name in destination) && name in source) {
      destination[name] = source[name];
    }
  }
  return destination;
}, extend:function() {
  var objectConstructor = Object.prototype.constructor, inlineOverrides = function(o) {
    var m;
    for (m in o) {
      if (!o.hasOwnProperty(m)) {
        continue;
      }
      this[m] = o[m];
    }
  };
  return function(subclass, superclass, overrides) {
    if (Ext.isObject(superclass)) {
      overrides = superclass;
      superclass = subclass;
      subclass = overrides.constructor !== objectConstructor ? overrides.constructor : function() {
        superclass.apply(this, arguments);
      };
    }
    if (!superclass) {
      Ext.raise({sourceClass:'Ext', sourceMethod:'extend', msg:'Attempting to extend from a class which has not been loaded on the page.'});
    }
    var F = function() {
    }, subclassProto, superclassProto = superclass.prototype;
    F.prototype = superclassProto;
    subclassProto = subclass.prototype = new F;
    subclassProto.constructor = subclass;
    subclass.superclass = superclassProto;
    if (superclassProto.constructor === objectConstructor) {
      superclassProto.constructor = superclass;
    }
    subclass.override = function(overrides) {
      Ext.override(subclass, overrides);
    };
    subclassProto.override = inlineOverrides;
    subclassProto.proto = subclassProto;
    subclass.override(overrides);
    subclass.extend = function(o) {
      return Ext.extend(subclass, o);
    };
    return subclass;
  };
}(), isOnline:function() {
  return Ext.global.navigator.onLine;
}, iterate:function(object, fn, scope) {
  if (Ext.isEmpty(object)) {
    return;
  }
  if (scope === undefined) {
    scope = object;
  }
  if (Ext.isIterable(object)) {
    Ext.Array.each.call(Ext.Array, object, fn, scope);
  } else {
    Ext.Object.each.call(Ext.Object, object, fn, scope);
  }
}, _resourcePoolRe:/^[<]([^<>@:]*)(?:[@]([^<>@:]+))?[>](.+)$/, resolveResource:function(url) {
  var ret = url, m;
  if (url && url.charAt(0) === '\x3c') {
    m = Ext._resourcePoolRe.exec(url);
    if (m) {
      ret = Ext.getResourcePath(m[3], m[1], m[2]);
    }
  }
  return ret;
}, urlEncode:function() {
  var args = Ext.Array.from(arguments), prefix = '';
  if (Ext.isString(args[1])) {
    prefix = args[1] + '\x26';
    args[1] = false;
  }
  return prefix + Ext.Object.toQueryString.apply(Ext.Object, args);
}, urlDecode:function() {
  return Ext.Object.fromQueryString.apply(Ext.Object, arguments);
}, getScrollbarSize:function(force) {
  if (!Ext.isDomReady) {
    Ext.raise('getScrollbarSize called before DomReady');
  }
  var scrollbarSize = Ext._scrollbarSize;
  if (force || !scrollbarSize) {
    var db = document.body, div = document.createElement('div'), h, w;
    div.style.width = div.style.height = '100px';
    div.style.overflow = 'scroll';
    div.style.position = 'absolute';
    db.appendChild(div);
    Ext._scrollbarSize = scrollbarSize = {width:w = div.offsetWidth - div.clientWidth, height:h = div.offsetHeight - div.clientHeight};
    scrollbarSize.reservedWidth = w ? 'calc(100% - ' + w + 'px)' : '';
    scrollbarSize.reservedHeight = h ? 'calc(100% - ' + h + 'px)' : '';
    db.removeChild(div);
  }
  return scrollbarSize;
}, typeOf:function() {
  var nonWhitespaceRe = /\S/, toString = Object.prototype.toString, typeofTypes = {number:1, string:1, 'boolean':1, 'undefined':1}, toStringTypes = {'[object Array]':'array', '[object Date]':'date', '[object Boolean]':'boolean', '[object Number]':'number', '[object RegExp]':'regexp'};
  return function(value) {
    if (value === null) {
      return 'null';
    }
    var type = typeof value, ret, typeToString;
    if (typeofTypes[type]) {
      return type;
    }
    ret = toStringTypes[typeToString = toString.call(value)];
    if (ret) {
      return ret;
    }
    if (type === 'function') {
      return 'function';
    }
    if (type === 'object') {
      if (value.nodeType !== undefined) {
        if (value.nodeType === 3) {
          return nonWhitespaceRe.test(value.nodeValue) ? 'textnode' : 'whitespace';
        } else {
          return 'element';
        }
      }
      return 'object';
    }
    Ext.raise({sourceClass:'Ext', sourceMethod:'typeOf', msg:'Failed to determine the type of "' + value + '".'});
    return typeToString;
  };
}(), factory:function(config, classReference, instance, aliasNamespace) {
  var manager = Ext.ClassManager, newInstance;
  if (!config || config.isInstance) {
    if (instance && instance !== config) {
      instance.destroy();
    }
    return config;
  }
  if (aliasNamespace) {
    if (typeof config === 'string') {
      return manager.instantiateByAlias(aliasNamespace + '.' + config);
    } else {
      if (Ext.isObject(config) && 'type' in config) {
        return manager.instantiateByAlias(aliasNamespace + '.' + config.type, config);
      }
    }
  }
  if (config === true) {
    if (!instance && !classReference) {
      Ext.raise('[Ext.factory] Cannot determine type of class to create');
    }
    return instance || Ext.create(classReference);
  }
  if (!Ext.isObject(config)) {
    Ext.raise('Invalid config, must be a valid config object');
  }
  if ('xtype' in config) {
    newInstance = manager.instantiateByAlias('widget.' + config.xtype, config);
  } else {
    if ('xclass' in config) {
      newInstance = Ext.create(config.xclass, config);
    }
  }
  if (newInstance) {
    if (instance) {
      instance.destroy();
    }
    return newInstance;
  }
  if (instance) {
    return instance.setConfig(config);
  }
  return Ext.create(classReference, config);
}, convertKeyedItems:function(items, defaultProperty, functionProperty) {
  if (items && !items.isInstance && Ext.isObject(items)) {
    var obj = items, item, itemId, value;
    items = [];
    if (obj.xtype || obj.xclass || obj.itemId || obj.id) {
      items.push(obj);
    } else {
      for (itemId in obj) {
        item = obj[itemId];
        if (item) {
          if (item === true) {
            item = {};
          } else {
            if (typeof item === 'function') {
              if (!functionProperty) {
                Ext.raise('Function not expected here');
              }
              value = item;
              item = {};
              item[functionProperty] = value;
            } else {
              if (typeof item === 'string') {
                value = item;
                item = {};
                item[defaultProperty || 'xtype'] = value;
              } else {
                item = Ext.apply({}, item);
              }
            }
          }
          item.itemId = itemId;
          items.push(item);
        }
      }
    }
  }
  return items;
}, weightSortFn:function(lhs, rhs) {
  return (lhs.weight || 0) - (rhs.weight || 0);
}, concat:function(a, b) {
  var noB = b == null, E = Ext.emptyArray;
  return a == null ? noB ? a : E.concat(b) : noB ? E.concat(a) : E.concat(a, b);
}, log:function() {
  var primitiveRe = /string|number|boolean/;
  function dumpObject(object, level, maxLevel, withFunctions) {
    var member, type, value, name, prefix, suffix, members = [];
    if (Ext.isArray(object)) {
      prefix = '[';
      suffix = ']';
    } else {
      if (Ext.isObject(object)) {
        prefix = '{';
        suffix = '}';
      }
    }
    if (!maxLevel) {
      maxLevel = 3;
    }
    if (level > maxLevel) {
      return prefix + '...' + suffix;
    }
    level = level || 1;
    var spacer = (new Array(level)).join('    ');
    for (name in object) {
      if (object.hasOwnProperty(name)) {
        value = object[name];
        type = typeof value;
        if (type === 'function') {
          if (!withFunctions) {
            continue;
          }
          member = type;
        } else {
          if (type === 'undefined') {
            member = type;
          } else {
            if (value === null || primitiveRe.test(type) || Ext.isDate(value)) {
              member = Ext.encode(value);
            } else {
              if (Ext.isArray(value)) {
                member = dumpObject(value, level + 1, maxLevel, withFunctions);
              } else {
                if (Ext.isObject(value)) {
                  member = dumpObject(value, level + 1, maxLevel, withFunctions);
                } else {
                  member = type;
                }
              }
            }
          }
        }
        members.push(spacer + name + ': ' + member);
      }
    }
    if (members.length) {
      return prefix + '\n    ' + members.join(',\n    ') + '\n' + spacer + suffix;
    }
    return prefix + suffix;
  }
  function log(message) {
    var options, dump, con = Ext.global.console, level = 'log', indent = log.indent || 0, prefix, stack, fn, out, max;
    log.indent = indent;
    if (typeof message !== 'string') {
      options = message;
      message = options.msg || '';
      level = options.level || level;
      dump = options.dump;
      stack = options.stack;
      prefix = options.prefix;
      fn = options.fn;
      if (options.indent) {
        ++log.indent;
      } else {
        if (options.outdent) {
          log.indent = indent = Math.max(indent - 1, 0);
        }
      }
      if (dump && !(con && con.dir)) {
        message += dumpObject(dump);
        dump = null;
      }
    }
    if (arguments.length > 1) {
      message += Array.prototype.slice.call(arguments, 1).join('');
    }
    if (prefix) {
      message = prefix + ' - ' + message;
    }
    message = indent ? Ext.String.repeat(' ', log.indentSize * indent) + message : message;
    if (level !== 'log') {
      message = '[' + level.charAt(0).toUpperCase() + '] ' + message;
    }
    if (fn) {
      message += '\nCaller: ' + fn.toString();
    }
    if (con) {
      if (con[level]) {
        con[level](message);
      } else {
        con.log(message);
      }
      if (dump) {
        con.dir(dump);
      }
      if (stack && con.trace) {
        if (!con.firebug || level !== 'error') {
          con.trace();
        }
      }
    } else {
      if (Ext.isOpera) {
        opera.postError(message);
      } else {
        out = log.out;
        max = log.max;
        if (out.length >= max) {
          Ext.Array.erase(out, 0, out.length - 3 * Math.floor(max / 4));
        }
        out.push(message);
      }
    }
    ++log.count;
    ++log.counters[level];
  }
  function logx(level, args) {
    if (typeof args[0] === 'string') {
      args.unshift({});
    }
    args[0].level = level;
    log.apply(this, args);
  }
  log.error = function() {
    logx('error', Array.prototype.slice.call(arguments));
  };
  log.info = function() {
    logx('info', Array.prototype.slice.call(arguments));
  };
  log.warn = function() {
    logx('warn', Array.prototype.slice.call(arguments));
  };
  log.count = 0;
  log.counters = {error:0, warn:0, info:0, log:0};
  log.indentSize = 2;
  log.out = [];
  log.max = 750;
  return log;
}() || function() {
  var nullLog = function() {
  };
  nullLog.info = nullLog.warn = nullLog.error = Ext.emptyFn;
  return nullLog;
}()});
(function() {
  var checkVerTemp = [''], endOfVersionRe = /([^\d\.])/, notDigitsRe = /[^\d]/g, plusMinusRe = /[\-+]/g, stripRe = /\s/g, underscoreRe = /_/g, toolkitNames = {classic:1, modern:1}, Version;
  Ext.Version = Version = function(version, defaultMode) {
    var me = this, padModes = me.padModes, ch, i, pad, parts, release, releaseStartIndex, ver;
    if (version.isVersion) {
      version = version.version;
    }
    me.version = ver = String(version).toLowerCase().replace(underscoreRe, '.').replace(plusMinusRe, '');
    ch = ver.charAt(0);
    if (ch in padModes) {
      ver = ver.substring(1);
      pad = padModes[ch];
    } else {
      pad = defaultMode ? padModes[defaultMode] : 0;
    }
    me.pad = pad;
    releaseStartIndex = ver.search(endOfVersionRe);
    me.shortVersion = ver;
    if (releaseStartIndex !== -1) {
      me.release = release = ver.substr(releaseStartIndex, version.length);
      me.shortVersion = ver.substr(0, releaseStartIndex);
      release = Version.releaseValueMap[release] || release;
    }
    me.releaseValue = release || pad;
    me.shortVersion = me.shortVersion.replace(notDigitsRe, '');
    me.parts = parts = ver.split('.');
    for (i = parts.length; i--;) {
      parts[i] = parseInt(parts[i], 10);
    }
    if (pad === Infinity) {
      parts.push(pad);
    }
    me.major = parts[0] || pad;
    me.minor = parts[1] || pad;
    me.patch = parts[2] || pad;
    me.build = parts[3] || pad;
    return me;
  };
  Version.prototype = {isVersion:true, padModes:{'~':NaN, '^':Infinity}, release:'', compareTo:function(other) {
    var me = this, lhsPad = me.pad, lhsParts = me.parts, lhsLength = lhsParts.length, rhsVersion = other.isVersion ? other : new Version(other), rhsPad = rhsVersion.pad, rhsParts = rhsVersion.parts, rhsLength = rhsParts.length, length = Math.max(lhsLength, rhsLength), i, lhs, rhs;
    for (i = 0; i < length; i++) {
      lhs = i < lhsLength ? lhsParts[i] : lhsPad;
      rhs = i < rhsLength ? rhsParts[i] : rhsPad;
      if (lhs < rhs) {
        return -1;
      }
      if (lhs > rhs) {
        return 1;
      }
    }
    lhs = me.releaseValue;
    rhs = rhsVersion.releaseValue;
    if (lhs < rhs) {
      return -1;
    }
    if (lhs > rhs) {
      return 1;
    }
    return 0;
  }, toString:function() {
    return this.version;
  }, valueOf:function() {
    return this.version;
  }, getMajor:function() {
    return this.major;
  }, getMinor:function() {
    return this.minor;
  }, getPatch:function() {
    return this.patch;
  }, getBuild:function() {
    return this.build;
  }, getRelease:function() {
    return this.release;
  }, getReleaseValue:function() {
    return this.releaseValue;
  }, isGreaterThan:function(target) {
    return this.compareTo(target) > 0;
  }, isGreaterThanOrEqual:function(target) {
    return this.compareTo(target) >= 0;
  }, isLessThan:function(target) {
    return this.compareTo(target) < 0;
  }, isLessThanOrEqual:function(target) {
    return this.compareTo(target) <= 0;
  }, equals:function(target) {
    return this.compareTo(target) === 0;
  }, match:function(target) {
    target = String(target);
    return this.version.substr(0, target.length) === target;
  }, toArray:function() {
    var me = this;
    return [me.getMajor(), me.getMinor(), me.getPatch(), me.getBuild(), me.getRelease()];
  }, getShortVersion:function() {
    return this.shortVersion;
  }, gt:function(target) {
    return this.compareTo(target) > 0;
  }, lt:function(target) {
    return this.compareTo(target) < 0;
  }, gtEq:function(target) {
    return this.compareTo(target) >= 0;
  }, ltEq:function(target) {
    return this.compareTo(target) <= 0;
  }};
  Ext.apply(Version, {aliases:{from:{extjs:'ext', core:'core', touch:'modern'}, to:{ext:['extjs'], 'core':['core'], modern:['touch']}}, releaseValueMap:{dev:-6, alpha:-5, a:-5, beta:-4, b:-4, rc:-3, '#':-2, p:-1, pl:-1}, getComponentValue:function(value) {
    return !value ? 0 : isNaN(value) ? this.releaseValueMap[value] || value : parseInt(value, 10);
  }, compare:function(current, target) {
    var ver = current.isVersion ? current : new Version(current);
    return ver.compareTo(target);
  }, set:function(collection, packageName, version) {
    var aliases = Version.aliases.to[packageName], ver = version.isVersion ? version : new Version(version), i;
    collection[packageName] = ver;
    if (aliases) {
      for (i = aliases.length; i-- > 0;) {
        collection[aliases[i]] = ver;
      }
    }
    return ver;
  }});
  Ext.apply(Ext, {compatVersions:{}, versions:{}, lastRegisteredVersion:null, getCompatVersion:function(packageName) {
    var versions = Ext.compatVersions, compat;
    if (!packageName) {
      compat = versions.ext || versions.touch || versions.core;
    } else {
      compat = versions[Version.aliases.from[packageName] || packageName];
    }
    return compat || Ext.getVersion(packageName);
  }, setCompatVersion:function(packageName, version) {
    Version.set(Ext.compatVersions, packageName, version);
  }, setVersion:function(packageName, version) {
    if (packageName in toolkitNames) {
      Ext.toolkit = packageName;
    }
    Ext.lastRegisteredVersion = Version.set(Ext.versions, packageName, version);
    return this;
  }, getVersion:function(packageName) {
    var versions = Ext.versions;
    if (!packageName) {
      return versions.ext || versions.touch || versions.core;
    }
    return versions[Version.aliases.from[packageName] || packageName];
  }, checkVersion:function(specs, matchAll) {
    var isArray = Ext.isArray(specs), aliases = Version.aliases.from, compat = isArray ? specs : checkVerTemp, length = compat.length, versions = Ext.versions, frameworkVer = versions.ext || versions.touch, i, index, matches, minVer, maxVer, packageName, spec, range, ver;
    if (!isArray) {
      checkVerTemp[0] = specs;
    }
    for (i = 0; i < length; ++i) {
      if (!Ext.isString(spec = compat[i])) {
        matches = Ext.checkVersion(spec.and || spec.or, !spec.or);
        if (spec.not) {
          matches = !matches;
        }
      } else {
        if (spec.indexOf(' ') >= 0) {
          spec = spec.replace(stripRe, '');
        }
        index = spec.indexOf('@');
        if (index < 0) {
          range = spec;
          ver = frameworkVer;
        } else {
          packageName = spec.substring(0, index);
          if (!(ver = versions[aliases[packageName] || packageName])) {
            if (matchAll) {
              return false;
            }
            continue;
          }
          range = spec.substring(index + 1);
        }
        index = range.indexOf('-');
        if (index < 0) {
          if (range.charAt(index = range.length - 1) === '+') {
            minVer = range.substring(0, index);
            maxVer = null;
          } else {
            minVer = maxVer = range;
          }
        } else {
          if (index > 0) {
            minVer = range.substring(0, index);
            maxVer = range.substring(index + 1);
          } else {
            minVer = null;
            maxVer = range.substring(index + 1);
          }
        }
        matches = true;
        if (minVer) {
          minVer = new Version(minVer, '~');
          matches = minVer.ltEq(ver);
        }
        if (matches && maxVer) {
          maxVer = new Version(maxVer, '~');
          matches = maxVer.gtEq(ver);
        }
      }
      if (matches) {
        if (!matchAll) {
          return true;
        }
      } else {
        if (matchAll) {
          return false;
        }
      }
    }
    return !!matchAll;
  }, deprecate:function(packageName, since, closure, scope) {
    if (Version.compare(Ext.getVersion(packageName), since) < 1) {
      closure.call(scope);
    }
  }});
})();
(function(manifest) {
  var packages = manifest && manifest.packages || {}, compat = manifest && manifest.compatibility, name, pkg;
  for (name in packages) {
    pkg = packages[name];
    if (pkg && pkg.version) {
      Ext.setVersion(name, pkg.version);
    }
  }
  if (compat) {
    if (Ext.isString(compat)) {
      Ext.setCompatVersion('core', compat);
    } else {
      for (name in compat) {
        Ext.setCompatVersion(name, compat[name]);
      }
    }
  }
  if (!packages.ext && !packages.touch) {
    Ext.setVersion('ext', '6.6.0.258');
    Ext.setVersion('core', '6.6.0.258');
  }
})(Ext.manifest);
Ext.Config = function(name) {
  var me = this, capitalizedName = name.charAt(0).toUpperCase() + name.substr(1);
  me.name = name;
  me.names = {internal:'_' + name, initializing:'is' + capitalizedName + 'Initializing', apply:'apply' + capitalizedName, update:'update' + capitalizedName, get:'get' + capitalizedName, set:'set' + capitalizedName, initGet:'initGet' + capitalizedName, changeEvent:name.toLowerCase() + 'change'};
  me.root = me;
};
Ext.Config.map = {};
Ext.Config.get = function(name) {
  var map = Ext.Config.map, ret = map[name] || (map[name] = new Ext.Config(name));
  return ret;
};
Ext.Config.prototype = {self:Ext.Config, isConfig:true, getGetter:function() {
  return this.getter || (this.root.getter = this.makeGetter());
}, getInitGetter:function() {
  return this.initGetter || (this.root.initGetter = this.makeInitGetter());
}, getSetter:function() {
  return this.setter || (this.root.setter = this.makeSetter());
}, getEventedSetter:function() {
  return this.eventedSetter || (this.root.eventedSetter = this.makeEventedSetter());
}, getInternalName:function(target) {
  return target.$configPrefixed ? this.names.internal : this.name;
}, mergeNew:function(newValue, oldValue, target, mixinClass) {
  var ret, key;
  if (!oldValue) {
    ret = newValue;
  } else {
    if (!newValue) {
      ret = oldValue;
    } else {
      ret = Ext.Object.chain(oldValue);
      for (key in newValue) {
        if (!mixinClass || !(key in ret)) {
          ret[key] = newValue[key];
        }
      }
    }
  }
  return ret;
}, mergeSets:function(newValue, oldValue, preserveExisting) {
  var ret = oldValue ? Ext.Object.chain(oldValue) : {}, i, val;
  if (newValue instanceof Array) {
    for (i = newValue.length; i--;) {
      val = newValue[i];
      if (!preserveExisting || !(val in ret)) {
        ret[val] = true;
      }
    }
  } else {
    if (newValue) {
      if (newValue.constructor === Object) {
        for (i in newValue) {
          val = newValue[i];
          if (!preserveExisting || !(i in ret)) {
            ret[i] = val;
          }
        }
      } else {
        if (!preserveExisting || !(newValue in ret)) {
          ret[newValue] = true;
        }
      }
    }
  }
  return ret;
}, makeGetter:function() {
  var name = this.name, prefixedName = this.names.internal;
  return function() {
    var internalName = this.$configPrefixed ? prefixedName : name;
    return this[internalName];
  };
}, makeInitGetter:function() {
  var name = this.name, names = this.names, setName = names.set, getName = names.get, initializingName = names.initializing;
  return function() {
    var me = this;
    me[initializingName] = true;
    delete me[getName];
    me[setName](me.config[name]);
    delete me[initializingName];
    return me[getName].apply(me, arguments);
  };
}, makeSetter:function() {
  var name = this.name, names = this.names, prefixedName = names.internal, getName = names.get, applyName = names.apply, updateName = names.update, setter;
  setter = function(value) {
    var me = this, internalName = me.$configPrefixed ? prefixedName : name, oldValue = me[internalName];
    delete me[getName];
    if (!me[applyName] || (value = me[applyName](value, oldValue)) !== undefined) {
      if (value !== (oldValue = me[internalName])) {
        me[internalName] = value;
        if (me[updateName]) {
          me[updateName](value, oldValue);
        }
      }
    }
    return me;
  };
  setter.$isDefault = true;
  return setter;
}, makeEventedSetter:function() {
  var name = this.name, names = this.names, prefixedName = names.internal, getName = names.get, applyName = names.apply, updateName = names.update, changeEventName = names.changeEvent, updateFn = function(me, value, oldValue, internalName) {
    me[internalName] = value;
    if (me[updateName]) {
      me[updateName](value, oldValue);
    }
  }, setter;
  setter = function(value) {
    var me = this, internalName = me.$configPrefixed ? prefixedName : name, oldValue = me[internalName];
    delete me[getName];
    if (!me[applyName] || (value = me[applyName](value, oldValue)) !== undefined) {
      if (value !== (oldValue = me[internalName])) {
        if (me.isConfiguring) {
          me[internalName] = value;
          if (me[updateName]) {
            me[updateName](value, oldValue);
          }
        } else {
          me.fireEventedAction(changeEventName, [me, value, oldValue], updateFn, me, [me, value, oldValue, internalName]);
        }
      }
    }
    return me;
  };
  setter.$isDefault = true;
  return setter;
}};
(function() {
  var ExtConfig = Ext.Config, configPropMap = ExtConfig.map, ExtObject = Ext.Object;
  Ext.Configurator = function(cls) {
    var me = this, prototype = cls.prototype, superCfg = cls.superclass ? cls.superclass.self.$config : null;
    me.cls = cls;
    me.superCfg = superCfg;
    if (superCfg) {
      me.configs = ExtObject.chain(superCfg.configs);
      me.cachedConfigs = ExtObject.chain(superCfg.cachedConfigs);
      me.initMap = ExtObject.chain(superCfg.initMap);
      me.values = ExtObject.chain(superCfg.values);
      me.needsFork = superCfg.needsFork;
      me.deprecations = ExtObject.chain(superCfg.deprecations);
    } else {
      me.configs = {};
      me.cachedConfigs = {};
      me.initMap = {};
      me.values = {};
      me.deprecations = {};
    }
    prototype.config = prototype.defaultConfig = me.values;
    cls.$config = me;
  };
  Ext.Configurator.prototype = {self:Ext.Configurator, needsFork:false, initList:null, add:function(config, mixinClass) {
    var me = this, Cls = me.cls, configs = me.configs, cachedConfigs = me.cachedConfigs, initMap = me.initMap, prototype = Cls.prototype, mixinConfigs = mixinClass && mixinClass.$config.configs, values = me.values, isObject, meta, isCached, merge, cfg, currentValue, name, names, s, value;
    for (name in config) {
      value = config[name];
      isObject = value && value.constructor === Object;
      meta = isObject && '$value' in value ? value : null;
      isCached = false;
      if (meta) {
        isCached = !!meta.cached;
        value = meta.$value;
        isObject = value && value.constructor === Object;
      }
      merge = meta && meta.merge;
      cfg = configs[name];
      if (cfg) {
        if (mixinClass) {
          merge = cfg.merge;
          if (!merge) {
            continue;
          }
          meta = null;
        } else {
          merge = merge || cfg.merge;
        }
        if (!mixinClass && isCached && !cachedConfigs[name]) {
          Ext.raise('Redefining config as cached: ' + name + ' in class: ' + Cls.$className);
        }
        currentValue = values[name];
        if (merge) {
          value = merge.call(cfg, value, currentValue, Cls, mixinClass);
        } else {
          if (isObject) {
            if (currentValue && currentValue.constructor === Object) {
              value = ExtObject.merge({}, currentValue, value);
            }
          }
        }
      } else {
        if (mixinConfigs) {
          cfg = mixinConfigs[name];
          meta = null;
        } else {
          cfg = ExtConfig.get(name);
        }
        configs[name] = cfg;
        if (cfg.cached || isCached) {
          cachedConfigs[name] = true;
        }
        names = cfg.names;
        if (!prototype[s = names.get]) {
          prototype[s] = cfg.getter || cfg.getGetter();
        }
        if (!prototype[s = names.set]) {
          prototype[s] = meta && meta.evented ? cfg.eventedSetter || cfg.getEventedSetter() : cfg.setter || cfg.getSetter();
        }
      }
      if (meta) {
        if (cfg.owner !== Cls) {
          configs[name] = cfg = Ext.Object.chain(cfg);
          cfg.owner = Cls;
        }
        Ext.apply(cfg, meta);
        delete cfg.$value;
      }
      if (!me.needsFork && value && (value.constructor === Object || value instanceof Array)) {
        me.needsFork = true;
      }
      if (value !== null) {
        initMap[name] = true;
      } else {
        if (prototype.$configPrefixed) {
          prototype[configs[name].names.internal] = null;
        } else {
          prototype[configs[name].name] = null;
        }
        if (name in initMap) {
          initMap[name] = false;
        }
      }
      values[name] = value;
    }
  }, addDeprecations:function(configs) {
    var me = this, deprecations = me.deprecations, className = (me.cls.$className || '') + '#', message, newName, oldName;
    for (oldName in configs) {
      newName = configs[oldName];
      if (!newName) {
        message = 'This config has been removed.';
      } else {
        if (!(message = newName.message)) {
          message = 'This config has been renamed to "' + newName + '"';
        }
      }
      deprecations[oldName] = className + oldName + ': ' + message;
    }
  }, configure:function(instance, instanceConfig) {
    var me = this, configs = me.configs, deprecations = me.deprecations, initMap = me.initMap, initListMap = me.initListMap, initList = me.initList, prototype = me.cls.prototype, values = me.values, remaining = 0, firstInstance = !initList, cachedInitList, cfg, getter, i, internalName, ln, names, name, value, isCached, valuesKey, field;
    values = me.needsFork ? ExtObject.fork(values) : ExtObject.chain(values);
    instance.isConfiguring = true;
    if (firstInstance) {
      me.initList = initList = [];
      me.initListMap = initListMap = {};
      instance.isFirstInstance = true;
      for (name in initMap) {
        cfg = configs[name];
        isCached = cfg.cached;
        if (initMap[name]) {
          names = cfg.names;
          value = values[name];
          if (!prototype[names.set].$isDefault || prototype[names.apply] || prototype[names.update] || typeof value === 'object') {
            if (isCached) {
              (cachedInitList || (cachedInitList = [])).push(cfg);
            } else {
              initList.push(cfg);
              initListMap[name] = true;
            }
            instance[names.get] = cfg.initGetter || cfg.getInitGetter();
          } else {
            prototype[cfg.getInternalName(prototype)] = value;
          }
        } else {
          if (isCached) {
            prototype[cfg.getInternalName(prototype)] = undefined;
          }
        }
      }
    }
    ln = cachedInitList && cachedInitList.length;
    if (ln) {
      for (i = 0; i < ln; ++i) {
        internalName = cachedInitList[i].getInternalName(prototype);
        instance[internalName] = null;
      }
      for (i = 0; i < ln; ++i) {
        names = (cfg = cachedInitList[i]).names;
        getter = names.get;
        if (instance.hasOwnProperty(getter)) {
          instance[names.set](values[cfg.name]);
          delete instance[getter];
        }
      }
      for (i = 0; i < ln; ++i) {
        internalName = cachedInitList[i].getInternalName(prototype);
        prototype[internalName] = instance[internalName];
        delete instance[internalName];
      }
    }
    if (instanceConfig && instanceConfig.platformConfig) {
      instanceConfig = me.resolvePlatformConfig(instance, instanceConfig);
    }
    if (firstInstance) {
      if (instance.afterCachedConfig && !instance.afterCachedConfig.$nullFn) {
        instance.afterCachedConfig(instanceConfig);
      }
    }
    instance.config = values;
    for (i = 0, ln = initList.length; i < ln; ++i) {
      cfg = initList[i];
      instance[cfg.names.get] = cfg.initGetter || cfg.getInitGetter();
    }
    if (instance.transformInstanceConfig) {
      instanceConfig = instance.transformInstanceConfig(instanceConfig);
    }
    if (instanceConfig) {
      for (name in instanceConfig) {
        value = instanceConfig[name];
        cfg = configs[name];
        if (deprecations[name]) {
          Ext.log.warn(deprecations[name]);
          if (!cfg) {
            continue;
          }
        }
        if (!cfg) {
          field = instance.self.prototype[name];
          if (instance.$configStrict && typeof field === 'function' && !field.$nullFn) {
            Ext.raise('Cannot override method ' + name + ' on ' + instance.$className + ' instance.');
          }
          instance[name] = value;
        } else {
          if (!cfg.lazy) {
            ++remaining;
          }
          if (!initListMap[name]) {
            instance[cfg.names.get] = cfg.initGetter || cfg.getInitGetter();
          }
          if (cfg.merge) {
            value = cfg.merge(value, values[name], instance);
          } else {
            if (value && value.constructor === Object) {
              valuesKey = values[name];
              if (valuesKey && valuesKey.constructor === Object) {
                value = ExtObject.merge(values[name], value);
              } else {
                value = Ext.clone(value, false);
              }
            }
          }
        }
        values[name] = value;
      }
    }
    if (instance.beforeInitConfig && !instance.beforeInitConfig.$nullFn) {
      if (instance.beforeInitConfig(instanceConfig) === false) {
        return;
      }
    }
    if (instanceConfig) {
      for (name in instanceConfig) {
        if (!remaining) {
          break;
        }
        cfg = configs[name];
        if (cfg && !cfg.lazy) {
          --remaining;
          names = cfg.names;
          getter = names.get;
          if (instance.hasOwnProperty(getter)) {
            instance[names.set](values[name]);
            delete instance[names.get];
          }
        }
      }
    }
    for (i = 0, ln = initList.length; i < ln; ++i) {
      cfg = initList[i];
      names = cfg.names;
      getter = names.get;
      if (!cfg.lazy && instance.hasOwnProperty(getter)) {
        instance[names.set](values[cfg.name]);
        delete instance[getter];
      }
    }
    delete instance.isConfiguring;
  }, getCurrentConfig:function(instance) {
    var defaultConfig = instance.defaultConfig, config = {}, name;
    for (name in defaultConfig) {
      config[name] = instance[configPropMap[name].names.get]();
    }
    return config;
  }, merge:function(instance, baseConfig, config) {
    var configs = this.configs, name, value, baseValue, cfg;
    for (name in config) {
      value = config[name];
      cfg = configs[name];
      if (cfg) {
        if (cfg.merge) {
          value = cfg.merge(value, baseConfig[name], instance);
        } else {
          if (value && value.constructor === Object) {
            baseValue = baseConfig[name];
            if (baseValue && baseValue.constructor === Object) {
              value = Ext.Object.merge(baseValue, value);
            } else {
              value = Ext.clone(value, false);
            }
          }
        }
      }
      baseConfig[name] = value;
    }
    return baseConfig;
  }, reconfigure:function(instance, instanceConfig, options) {
    var currentConfig = instance.config, configList = [], strict = instance.$configStrict && !(options && options.strict === false), configs = this.configs, defaults = options && options.defaults, cfg, getter, i, len, name, names, prop;
    for (name in instanceConfig) {
      cfg = configs[name];
      if (defaults && instance.hasOwnProperty(cfg && instance.$configPrefixed ? cfg.names.internal : name)) {
        continue;
      }
      currentConfig[name] = instanceConfig[name];
      if (this.deprecations[name]) {
        Ext.log.warn(this.deprecations[name]);
        if (!cfg) {
          continue;
        }
      }
      if (cfg) {
        instance[cfg.names.get] = cfg.initGetter || cfg.getInitGetter();
      } else {
        prop = instance.self.prototype[name];
        if (strict) {
          if (typeof prop === 'function' && !prop.$nullFn) {
            Ext.Error.raise('Cannot override method ' + name + ' on ' + instance.$className + ' instance.');
            continue;
          } else {
            if (name !== 'type') {
              Ext.log.warn('No such config "' + name + '" for class ' + instance.$className);
            }
          }
        }
      }
      configList.push(name);
    }
    for (i = 0, len = configList.length; i < len; i++) {
      name = configList[i];
      cfg = configs[name];
      if (cfg) {
        names = cfg.names;
        getter = names.get;
        if (instance.hasOwnProperty(getter)) {
          instance[names.set](instanceConfig[name]);
          delete instance[getter];
        }
      } else {
        cfg = configPropMap[name] || Ext.Config.get(name);
        names = cfg.names;
        if (instance[names.set]) {
          instance[names.set](instanceConfig[name]);
        } else {
          instance[name] = instanceConfig[name];
        }
      }
    }
  }, resolvePlatformConfig:function(instance, instanceConfig) {
    var platformConfig = instanceConfig && instanceConfig.platformConfig, ret = instanceConfig, i, keys, n;
    if (platformConfig) {
      keys = Ext.getPlatformConfigKeys(platformConfig);
      n = keys.length;
      if (n) {
        ret = Ext.merge({}, ret);
        for (i = 0, n = keys.length; i < n; ++i) {
          this.merge(instance, ret, platformConfig[keys[i]]);
        }
      }
    }
    return ret;
  }};
})();
Ext.Base = function(flexSetter) {
  var noArgs = [], baseStaticMember, baseStaticMembers = [], makeDeprecatedMethod = function(oldName, newName, msg) {
    var message = '"' + oldName + '" is deprecated.';
    if (msg) {
      message += ' ' + msg;
    } else {
      if (newName) {
        message += ' Please use "' + newName + '" instead.';
      }
    }
    return function() {
      Ext.raise(message);
    };
  }, addDeprecatedProperty = function(object, oldName, newName, message) {
    if (!message) {
      message = '"' + oldName + '" is deprecated.';
    }
    if (newName) {
      message += ' Please use "' + newName + '" instead.';
    }
    if (message) {
      Ext.Object.defineProperty(object, oldName, {get:function() {
        Ext.raise(message);
      }, set:function(value) {
        Ext.raise(message);
      }, configurable:true});
    }
  }, makeAliasFn = function(name) {
    return function() {
      return this[name].apply(this, arguments);
    };
  }, Version = Ext.Version, leadingDigitRe = /^\d/, oneMember = {}, aliasOneMember = {}, Base = function() {
  }, BasePrototype = Base.prototype, Reaper;
  Ext.Reaper = Reaper = {delay:100, queue:[], timer:null, add:function(obj) {
    if (!Reaper.timer) {
      Reaper.timer = Ext.defer(Reaper.tick, Reaper.delay);
    }
    Reaper.queue.push(obj);
  }, flush:function() {
    if (Reaper.timer) {
      Ext.undefer(Reaper.timer);
      Reaper.timer = null;
    }
    var queue = Reaper.queue, n = queue.length, i, obj;
    Reaper.queue = [];
    for (i = 0; i < n; ++i) {
      obj = queue[i];
      if (obj && obj.$reap) {
        obj.$reap();
      }
    }
  }, tick:function() {
    Reaper.timer = null;
    Reaper.flush();
  }};
  Ext.apply(Base, {$className:'Ext.Base', $isClass:true, create:function() {
    return Ext.create.apply(Ext, [this].concat(Array.prototype.slice.call(arguments, 0)));
  }, addDeprecations:function(deprecations) {
    var me = this, all = [], compatVersion = Ext.getCompatVersion(deprecations.name), configurator = me.getConfigurator(), displayName = (me.$className || '') + '#', deprecate, versionSpec, index, message, target, enabled, existing, fn, names, oldName, newName, member, statics, version;
    for (versionSpec in deprecations) {
      if (leadingDigitRe.test(versionSpec)) {
        version = new Ext.Version(versionSpec);
        version.deprecations = deprecations[versionSpec];
        all.push(version);
      }
    }
    all.sort(Version.compare);
    for (index = all.length; index--;) {
      deprecate = (version = all[index]).deprecations;
      target = me.prototype;
      statics = deprecate.statics;
      enabled = compatVersion && compatVersion.lt(version);
      if (!enabled) {
      } else {
        if (!enabled) {
          break;
        }
      }
      while (deprecate) {
        names = deprecate.methods;
        if (names) {
          for (oldName in names) {
            member = names[oldName];
            fn = null;
            if (!member) {
              Ext.Assert.isNotDefinedProp(target, oldName);
              fn = makeDeprecatedMethod(displayName + oldName);
            } else {
              if (Ext.isString(member)) {
                Ext.Assert.isNotDefinedProp(target, oldName);
                Ext.Assert.isDefinedProp(target, member);
                if (enabled) {
                  fn = makeAliasFn(member);
                } else {
                  fn = makeDeprecatedMethod(displayName + oldName, member);
                }
              } else {
                message = '';
                if (member.message || member.fn) {
                  message = member.message;
                  member = member.fn;
                }
                existing = target.hasOwnProperty(oldName) && target[oldName];
                if (enabled && member) {
                  member.$owner = me;
                  member.$name = oldName;
                  member.name = displayName + oldName;
                  if (existing) {
                    member.$previous = existing;
                  }
                  fn = member;
                } else {
                  if (!existing) {
                    fn = makeDeprecatedMethod(displayName + oldName, null, message);
                  }
                }
              }
            }
            if (fn) {
              target[oldName] = fn;
            }
          }
        }
        names = deprecate.configs;
        if (names) {
          configurator.addDeprecations(names);
        }
        names = deprecate.properties;
        if (names && !enabled) {
          for (oldName in names) {
            newName = names[oldName];
            if (Ext.isString(newName)) {
              addDeprecatedProperty(target, displayName + oldName, newName);
            } else {
              if (newName && newName.message) {
                addDeprecatedProperty(target, displayName + oldName, null, newName.message);
              } else {
                addDeprecatedProperty(target, displayName + oldName);
              }
            }
          }
        }
        deprecate = statics;
        statics = null;
        target = me;
      }
    }
  }, extend:function(parentClass) {
    var me = this, parentPrototype = parentClass.prototype, prototype, name, statics;
    prototype = me.prototype = Ext.Object.chain(parentPrototype);
    prototype.self = me;
    me.superclass = prototype.superclass = parentPrototype;
    if (!parentClass.$isClass) {
      for (name in BasePrototype) {
        if (name in prototype) {
          prototype[name] = BasePrototype[name];
        }
      }
    }
    statics = parentPrototype.$inheritableStatics;
    if (statics) {
      for (name in statics) {
        if (!me.hasOwnProperty(name)) {
          me[name] = parentClass[name];
        }
      }
    }
    if (parentClass.$onExtended) {
      me.$onExtended = parentClass.$onExtended.slice();
    }
    me.getConfigurator();
  }, $onExtended:[], triggerExtended:function() {
    Ext.classSystemMonitor && Ext.classSystemMonitor(this, 'Ext.Base#triggerExtended', arguments);
    var callbacks = this.$onExtended, ln = callbacks.length, i, callback;
    if (ln > 0) {
      for (i = 0; i < ln; i++) {
        callback = callbacks[i];
        callback.fn.apply(callback.scope || this, arguments);
      }
    }
  }, onExtended:function(fn, scope) {
    this.$onExtended.push({fn:fn, scope:scope});
    return this;
  }, addStatics:function(members) {
    this.addMembers(members, true);
    return this;
  }, addInheritableStatics:function(members) {
    var me = this, proto = me.prototype, inheritableStatics = me.$inheritableStatics, name, member, current;
    if (!inheritableStatics) {
      inheritableStatics = Ext.apply({}, proto.$inheritableStatics);
      me.$inheritableStatics = proto.$inheritableStatics = inheritableStatics;
    }
    var className = Ext.getClassName(me) + '.';
    for (name in members) {
      if (members.hasOwnProperty(name)) {
        member = members[name];
        current = me[name];
        if (typeof member == 'function') {
          member.name = className + name;
        }
        if (typeof current === 'function' && !current.$isClass && !current.$nullFn) {
          member.$previous = current;
        }
        me[name] = member;
        inheritableStatics[name] = true;
      }
    }
    return me;
  }, addMembers:function(members, isStatic, privacy) {
    var me = this, cloneFunction = Ext.Function.clone, target = isStatic ? me : me.prototype, defaultConfig = !isStatic && target.defaultConfig, enumerables = Ext.enumerables, privates = members.privates, configs, i, ln, member, name, subPrivacy, privateStatics;
    var displayName = (me.$className || '') + '#';
    if (privates) {
      delete members.privates;
      if (!isStatic) {
        privateStatics = privates.statics;
        delete privates.statics;
      }
      subPrivacy = privates.privacy || privacy || 'framework';
      me.addMembers(privates, isStatic, subPrivacy);
      if (privateStatics) {
        me.addMembers(privateStatics, true, subPrivacy);
      }
    }
    for (name in members) {
      if (members.hasOwnProperty(name)) {
        member = members[name];
        if (privacy === true) {
          privacy = 'framework';
        }
        if (member && member.$nullFn && privacy !== member.$privacy) {
          Ext.raise('Cannot use stock function for private method ' + (me.$className ? me.$className + '#' : '') + name);
        }
        if (typeof member === 'function' && !member.$isClass && !member.$nullFn) {
          if (member.$owner) {
            member = cloneFunction(member);
          }
          if (target.hasOwnProperty(name)) {
            member.$previous = target[name];
          }
          member.$owner = me;
          member.$name = name;
          member.name = displayName + name;
          var existing = target[name];
          if (privacy) {
            member.$privacy = privacy;
            if (existing && existing.$privacy && existing.$privacy !== privacy) {
              Ext.privacyViolation(me, existing, member, isStatic);
            }
          } else {
            if (existing && existing.$privacy) {
              Ext.privacyViolation(me, existing, member, isStatic);
            }
          }
        } else {
          if (defaultConfig && name in defaultConfig && !target.config.hasOwnProperty(name)) {
            (configs || (configs = {}))[name] = member;
            continue;
          }
        }
        target[name] = member;
      }
    }
    if (configs) {
      me.addConfig(configs);
    }
    if (enumerables) {
      for (i = 0, ln = enumerables.length; i < ln; ++i) {
        if (members.hasOwnProperty(name = enumerables[i])) {
          member = members[name];
          if (member && !member.$nullFn) {
            if (member.$owner) {
              member = cloneFunction(member);
            }
            member.$owner = me;
            member.$name = name;
            member.name = displayName + name;
            if (target.hasOwnProperty(name)) {
              member.$previous = target[name];
            }
          }
          target[name] = member;
        }
      }
    }
    return this;
  }, addMember:function(name, member) {
    oneMember[name] = member;
    this.addMembers(oneMember);
    delete oneMember[name];
    return this;
  }, borrow:function(fromClass, members) {
    Ext.classSystemMonitor && Ext.classSystemMonitor(this, 'Ext.Base#borrow', arguments);
    var prototype = fromClass.prototype, membersObj = {}, i, ln, name;
    members = Ext.Array.from(members);
    for (i = 0, ln = members.length; i < ln; i++) {
      name = members[i];
      membersObj[name] = prototype[name];
    }
    return this.addMembers(membersObj);
  }, override:function(members) {
    var me = this, statics = members.statics, inheritableStatics = members.inheritableStatics, config = members.config, mixins = members.mixins, cachedConfig = members.cachedConfig;
    if (statics || inheritableStatics || config) {
      members = Ext.apply({}, members);
    }
    if (statics) {
      me.addMembers(statics, true);
      delete members.statics;
    }
    if (inheritableStatics) {
      me.addInheritableStatics(inheritableStatics);
      delete members.inheritableStatics;
    }
    if (members.platformConfig) {
      me.addPlatformConfig(members);
    }
    if (config) {
      me.addConfig(config);
      delete members.config;
    }
    if (cachedConfig) {
      me.addCachedConfig(cachedConfig);
      delete members.cachedConfig;
    }
    delete members.mixins;
    me.addMembers(members);
    if (mixins) {
      me.mixin(mixins);
    }
    return me;
  }, addPlatformConfig:function(data) {
    var me = this, prototype = me.prototype, platformConfigs = data.platformConfig, added, classConfigs, configs, configurator, keys, name, value, i, ln;
    delete prototype.platformConfig;
    if (platformConfigs instanceof Array) {
      throw new Error('platformConfigs must be specified as an object.');
    }
    configurator = me.getConfigurator();
    classConfigs = configurator.configs;
    keys = Ext.getPlatformConfigKeys(platformConfigs);
    for (i = 0, ln = keys.length; i < ln; ++i) {
      configs = platformConfigs[keys[i]];
      added = null;
      for (name in configs) {
        value = configs[name];
        if (name in classConfigs) {
          (added || (added = {}))[name] = value;
        } else {
          prototype[name] = value;
        }
      }
      if (added) {
        configurator.add(added);
      }
    }
  }, callParent:function(args) {
    var method;
    return (method = this.callParent.caller) && (method.$previous || (method = method.$owner ? method : method.caller) && method.$owner.superclass.self[method.$name]).apply(this, args || noArgs);
  }, callSuper:function(args) {
    var method;
    return (method = this.callSuper.caller) && ((method = method.$owner ? method : method.caller) && method.$owner.superclass.self[method.$name]).apply(this, args || noArgs);
  }, mixin:function(name, mixinClass) {
    var me = this, mixin, prototype, key, statics, i, ln, mixinName, mixinValue, mixins, mixinStatics, staticName;
    if (typeof name !== 'string') {
      mixins = name;
      if (mixins instanceof Array) {
        for (i = 0, ln = mixins.length; i < ln; i++) {
          mixin = mixins[i];
          me.mixin(mixin.prototype.mixinId || mixin.$className, mixin);
        }
      } else {
        for (mixinName in mixins) {
          me.mixin(mixinName, mixins[mixinName]);
        }
      }
      return;
    }
    mixin = mixinClass.prototype;
    prototype = me.prototype;
    if (mixin.onClassMixedIn) {
      mixin.onClassMixedIn.call(mixinClass, me);
    }
    if (!prototype.hasOwnProperty('mixins')) {
      if ('mixins' in prototype) {
        prototype.mixins = Ext.Object.chain(prototype.mixins);
      } else {
        prototype.mixins = {};
      }
    }
    for (key in mixin) {
      mixinValue = mixin[key];
      if (key === 'mixins') {
        Ext.applyIf(prototype.mixins, mixinValue);
      } else {
        if (!(key === 'mixinId' || key === 'config' || key === '$inheritableStatics') && prototype[key] === undefined) {
          prototype[key] = mixinValue;
        }
      }
    }
    statics = mixin.$inheritableStatics;
    if (statics) {
      mixinStatics = {};
      for (staticName in statics) {
        if (!me.hasOwnProperty(staticName)) {
          mixinStatics[staticName] = mixinClass[staticName];
        }
      }
      me.addInheritableStatics(mixinStatics);
    }
    if ('config' in mixin) {
      me.addConfig(mixin.config, mixinClass);
    }
    prototype.mixins[name] = mixin;
    if (mixin.afterClassMixedIn) {
      mixin.afterClassMixedIn.call(mixinClass, me);
    }
    return me;
  }, addConfig:function(config, mixinClass) {
    var cfg = this.$config || this.getConfigurator();
    cfg.add(config, mixinClass);
  }, addCachedConfig:function(config, isMixin) {
    var cached = {}, key;
    for (key in config) {
      cached[key] = {cached:true, $value:config[key]};
    }
    this.addConfig(cached, isMixin);
  }, getConfigurator:function() {
    return this.$config || new Ext.Configurator(this);
  }, getName:function() {
    return Ext.getClassName(this);
  }, createAlias:flexSetter(function(alias, origin) {
    aliasOneMember[alias] = function() {
      return this[origin].apply(this, arguments);
    };
    this.override(aliasOneMember);
    delete aliasOneMember[alias];
  })});
  for (baseStaticMember in Base) {
    if (Base.hasOwnProperty(baseStaticMember)) {
      baseStaticMembers.push(baseStaticMember);
    }
  }
  Base.$staticMembers = baseStaticMembers;
  Base.getConfigurator();
  Base.addMembers({$className:'Ext.Base', isInstance:true, $configPrefixed:true, $configStrict:true, isConfiguring:false, isFirstInstance:false, destroyed:false, clearPropertiesOnDestroy:true, clearPrototypeOnDestroy:false, statics:function() {
    var method = this.statics.caller, self = this.self;
    if (!method) {
      return self;
    }
    return method.$owner;
  }, callParent:function(args) {
    var method, superMethod = (method = this.callParent.caller) && (method.$previous || (method = method.$owner ? method : method.caller) && method.$owner.superclass[method.$name]);
    if (!superMethod) {
      method = this.callParent.caller;
      var parentClass, methodName;
      if (!method.$owner) {
        if (!method.caller) {
          throw new Error('Attempting to call a protected method from the public scope, which is not allowed');
        }
        method = method.caller;
      }
      parentClass = method.$owner.superclass;
      methodName = method.$name;
      if (!(methodName in parentClass)) {
        throw new Error("this.callParent() was called but there's no such method (" + methodName + ') found in the parent class (' + (Ext.getClassName(parentClass) || 'Object') + ')');
      }
    }
    return superMethod.apply(this, args || noArgs);
  }, callSuper:function(args) {
    var method, superMethod = (method = this.callSuper.caller) && ((method = method.$owner ? method : method.caller) && method.$owner.superclass[method.$name]);
    if (!superMethod) {
      method = this.callSuper.caller;
      var parentClass, methodName;
      if (!method.$owner) {
        if (!method.caller) {
          throw new Error('Attempting to call a protected method from the public scope, which is not allowed');
        }
        method = method.caller;
      }
      parentClass = method.$owner.superclass;
      methodName = method.$name;
      if (!(methodName in parentClass)) {
        throw new Error("this.callSuper() was called but there's no such method (" + methodName + ') found in the parent class (' + (Ext.getClassName(parentClass) || 'Object') + ')');
      }
    }
    return superMethod.apply(this, args || noArgs);
  }, self:Base, constructor:function() {
    return this;
  }, initConfig:function(instanceConfig) {
    var me = this, cfg = me.self.getConfigurator();
    me.initConfig = Ext.emptyFn;
    me.initialConfig = instanceConfig || {};
    cfg.configure(me, instanceConfig);
    return me;
  }, beforeInitConfig:Ext.emptyFn, getConfig:function(name, peek, ifInitialized) {
    var me = this, ret, cfg, propName;
    if (name) {
      cfg = me.self.$config.configs[name];
      if (cfg) {
        propName = me.$configPrefixed ? cfg.names.internal : name;
        if (ifInitialized) {
          ret = me.hasOwnProperty(propName) ? me[propName] : null;
        } else {
          if (peek) {
            ret = me.hasOwnProperty(propName) ? me[propName] : me.config[name];
          } else {
            ret = me[cfg.names.get]();
          }
        }
      } else {
        ret = me[name];
      }
    } else {
      ret = me.getCurrentConfig();
    }
    return ret;
  }, destroyMembers:function() {
    var me = this, configs = me.self.$config.configs, len = arguments.length, cfg, name, value, i;
    for (i = 0; i < len; i++) {
      name = arguments[i];
      cfg = configs[name];
      name = cfg && me.$configPrefixed ? cfg.names.internal : name;
      value = me.hasOwnProperty(name) && me[name];
      if (value) {
        Ext.destroy(value);
        me[name] = null;
      }
    }
  }, freezeConfig:function(name) {
    var me = this, config = Ext.Config.get(name), names = config.names, value = me[names.get]();
    me[names.set] = function(v) {
      if (v !== value) {
        Ext.raise('Cannot change frozen config "' + name + '"');
      }
      return me;
    };
    if (!Ext.isIE8) {
      Object.defineProperty(me, me.$configPrefixed ? names.internal : name, {get:function() {
        return value;
      }, set:function(v) {
        if (v !== value) {
          Ext.raise('Cannot change frozen config "' + name + '"');
        }
      }});
    }
  }, setConfig:function(name, value, options) {
    var me = this, configurator, config, prop;
    if (name) {
      configurator = me.self.getConfigurator();
      if (typeof name === 'string') {
        config = configurator.configs[name];
        if (!config) {
          if (me.$configStrict) {
            prop = me.self.prototype[name];
            if (typeof prop === 'function' && !prop.$nullFn) {
              Ext.Error.raise('Cannot override method ' + name + ' on ' + me.$className + ' instance.');
              return me;
            } else {
              if (name !== 'type') {
                Ext.log.warn('No such config "' + name + '" for class ' + me.$className);
              }
            }
          }
          config = Ext.Config.map[name] || Ext.Config.get(name);
        }
        if (me[config.names.set]) {
          me[config.names.set](value);
        } else {
          me[name] = value;
        }
      } else {
        configurator.reconfigure(me, name, options || value);
      }
    }
    return me;
  }, getCurrentConfig:function() {
    var cfg = this.self.getConfigurator();
    return cfg.getCurrentConfig(this);
  }, hasConfig:function(name) {
    return name in this.defaultConfig;
  }, getInitialConfig:function(name) {
    var config = this.config;
    if (!name) {
      return config;
    }
    return config[name];
  }, $links:null, link:function(name, value) {
    var me = this, links = me.$links || (me.$links = {});
    links[name] = true;
    me[name] = value;
    return value;
  }, unlink:function(names) {
    var me = this, i, ln, link, value;
    if (!Ext.isArray(names)) {
      Ext.raise('Invalid argument - expected array of strings');
    }
    for (i = 0, ln = names.length; i < ln; i++) {
      link = names[i];
      value = me[link];
      if (value) {
        if (value.isInstance && !value.destroyed) {
          value.destroy();
        } else {
          if (value.parentNode && 'nodeType' in value) {
            value.parentNode.removeChild(value);
          }
        }
      }
      me[link] = null;
    }
    return me;
  }, $reap:function() {
    var me = this, protectedProps = me.$noClearOnDestroy, props, prop, value, type, i, len;
    props = Ext.Object.getKeys(me);
    for (i = 0, len = props.length; i < len; i++) {
      prop = props[i];
      if (!protectedProps || !protectedProps[prop]) {
        value = me[prop];
        type = typeof value;
        if (type === 'object' || type === 'function' && !value.$noClearOnDestroy) {
          me[prop] = null;
        }
      }
    }
    me.$nulled = true;
    if (Object.setPrototypeOf) {
      if (me.clearPrototypeOnDestroy && !me.$vetoClearingPrototypeOnDestroy) {
        props = me.$preservePrototypeProperties;
        if (props) {
          for (i = 0, len = props.length; i < len; i++) {
            prop = props[i];
            if (!me.hasOwnProperty(prop)) {
              me[prop] = me[prop];
            }
          }
        }
        Object.setPrototypeOf(me, null);
      }
    }
  }, destroy:function() {
    var me = this, links = me.$links, clearPropertiesOnDestroy = me.clearPropertiesOnDestroy;
    if (links) {
      me.$links = null;
      me.unlink(Ext.Object.getKeys(links));
    }
    me.destroy = Ext.emptyFn;
    me.isDestroyed = me.destroyed = true;
    if (clearPropertiesOnDestroy === true) {
      if (!me.isObservable) {
        me.$reap();
      }
    } else {
      if (clearPropertiesOnDestroy) {
        if (clearPropertiesOnDestroy !== 'async') {
          Ext.raise('Invalid value for clearPropertiesOnDestroy');
        }
        Reaper.add(me);
      }
    }
  }});
  BasePrototype.callOverridden = BasePrototype.callParent;
  Ext.privacyViolation = function(cls, existing, member, isStatic) {
    var name = member.$name, conflictCls = existing.$owner && existing.$owner.$className, s = isStatic ? 'static ' : '', msg = member.$privacy ? 'Private ' + s + member.$privacy + ' method "' + name + '"' : 'Public ' + s + 'method "' + name + '"';
    if (cls.$className) {
      msg = cls.$className + ': ' + msg;
    }
    if (!existing.$privacy) {
      msg += conflictCls ? ' hides public method inherited from ' + conflictCls : ' hides inherited public method.';
    } else {
      msg += conflictCls ? ' conflicts with private ' + existing.$privacy + ' method declared by ' + conflictCls : ' conflicts with inherited private ' + existing.$privacy + ' method.';
    }
    var compat = Ext.getCompatVersion();
    var ver = Ext.getVersion();
    if (ver && compat && compat.lt(ver)) {
      Ext.log.error(msg);
    } else {
      Ext.raise(msg);
    }
  };
  Ext.Reaper.tick.$skipTimerCheck = true;
  return Base;
}(Ext.Function.flexSetter);
(function(LRU, prototype) {
  (Ext.util || (Ext.util = {})).LRU = LRU = function(config) {
    var me = this, head;
    if (config) {
      Ext.apply(me, config);
    }
    me.head = head = {id:me.seed = 0, key:null, value:null};
    me.map = {};
    head.next = head.prev = head;
  };
  LRU.prototype = prototype = {count:0, add:function(key, value) {
    var me = this, map = me.map, entry = map[key];
    if (entry) {
      me.unlink(entry);
      --me.count;
    }
    map[key] = entry = {id:++me.seed, key:key, value:value};
    me.link(entry);
    ++me.count;
    return entry;
  }, clear:function(fn, scope) {
    var me = this, head = me.head, entry = head.next;
    head.next = head.prev = head;
    me.count = 0;
    if (fn && !fn.$nullFn) {
      for (; entry !== head; entry = entry.next) {
        fn.call(scope || me, entry.key, entry.value);
      }
    }
  }, each:function(fn, scope) {
    scope = scope || this;
    for (var head = this.head, ent = head.next; ent !== head; ent = ent.next) {
      if (fn.call(scope, ent.key, ent.value)) {
        break;
      }
    }
  }, prune:function(fn, scope) {
    var me = this, entry = me.head.prev, ret;
    if (me.count) {
      ret = entry.value;
      me.unlink(entry);
      --me.count;
      if (fn) {
        fn.call(scope || me, entry.key, ret);
      }
    }
    return ret;
  }, remove:function(key) {
    var me = this, map = me.map, entry = map[key], value;
    if (entry) {
      me.unlink(entry);
      value = entry.value;
      delete map[key];
      --me.count;
    }
    return value;
  }, touch:function(key) {
    var me = this, head = me.head, entry = me.map[key];
    if (entry && entry.prev !== head) {
      me.unlink(entry);
      me.link(entry);
    }
  }, trim:function(size, fn, scope) {
    while (this.count > size) {
      this.prune(fn, scope);
    }
  }, link:function(entry) {
    var head = this.head, first = head.next;
    entry.next = first;
    entry.prev = head;
    head.next = entry;
    first.prev = entry;
  }, unlink:function(entry) {
    var next = entry.next, prev = entry.prev;
    prev.next = next;
    next.prev = prev;
  }};
  prototype.destroy = function() {
    this.clear.apply(this, arguments);
  };
})();
(function(LRU, fn, Cache) {
  Ext.util.Cache = Cache = function(config) {
    LRU.call(this, config);
  };
  fn.prototype = LRU.prototype;
  Cache.prototype = Ext.apply(new fn, {maxSize:100, clear:function() {
    LRU.prototype.clear.call(this, this.evict);
  }, get:function(key) {
    var me = this, entry = me.map[key], value;
    if (entry) {
      value = entry.value;
      me.touch(key);
    } else {
      value = me.miss.apply(me, arguments);
      me.add(key, value);
      me.trim(me.maxSize, me.evict);
    }
    return value;
  }, evict:Ext.emptyFn});
})(Ext.util.LRU, function() {
});
(function() {
  var ExtClass, Base = Ext.Base, baseStaticMembers = Base.$staticMembers, ruleKeySortFn = function(a, b) {
    return a.length - b.length || (a < b ? -1 : a > b ? 1 : 0);
  };
  function makeCtor(className) {
    function constructor() {
      return this.constructor.apply(this, arguments) || null;
    }
    if (className) {
      constructor.name = className;
    }
    return constructor;
  }
  Ext.Class = ExtClass = function(Class, data, onCreated) {
    if (typeof Class != 'function') {
      onCreated = data;
      data = Class;
      Class = null;
    }
    if (!data) {
      data = {};
    }
    Class = ExtClass.create(Class, data);
    ExtClass.process(Class, data, onCreated);
    return Class;
  };
  Ext.apply(ExtClass, {makeCtor:makeCtor, onBeforeCreated:function(Class, data, hooks) {
    Ext.classSystemMonitor && Ext.classSystemMonitor(Class, '\x3e\x3e Ext.Class#onBeforeCreated', arguments);
    Class.addMembers(data);
    hooks.onCreated.call(Class, Class);
    Ext.classSystemMonitor && Ext.classSystemMonitor(Class, '\x3c\x3c Ext.Class#onBeforeCreated', arguments);
  }, create:function(Class, data) {
    var i = baseStaticMembers.length, name;
    if (!Class) {
      Class = makeCtor(data.$className);
    }
    while (i--) {
      name = baseStaticMembers[i];
      Class[name] = Base[name];
    }
    return Class;
  }, process:function(Class, data, onCreated) {
    var preprocessorStack = data.preprocessors || ExtClass.defaultPreprocessors, registeredPreprocessors = this.preprocessors, hooks = {onBeforeCreated:this.onBeforeCreated}, preprocessors = [], preprocessor, preprocessorsProperties, i, ln, j, subLn, preprocessorProperty;
    delete data.preprocessors;
    Class._classHooks = hooks;
    for (i = 0, ln = preprocessorStack.length; i < ln; i++) {
      preprocessor = preprocessorStack[i];
      if (typeof preprocessor == 'string') {
        preprocessor = registeredPreprocessors[preprocessor];
        preprocessorsProperties = preprocessor.properties;
        if (preprocessorsProperties === true) {
          preprocessors.push(preprocessor.fn);
        } else {
          if (preprocessorsProperties) {
            for (j = 0, subLn = preprocessorsProperties.length; j < subLn; j++) {
              preprocessorProperty = preprocessorsProperties[j];
              if (data.hasOwnProperty(preprocessorProperty)) {
                preprocessors.push(preprocessor.fn);
                break;
              }
            }
          }
        }
      } else {
        preprocessors.push(preprocessor);
      }
    }
    hooks.onCreated = onCreated ? onCreated : Ext.emptyFn;
    hooks.preprocessors = preprocessors;
    this.doProcess(Class, data, hooks);
  }, doProcess:function(Class, data, hooks) {
    var me = this, preprocessors = hooks.preprocessors, preprocessor = preprocessors.shift(), doProcess = me.doProcess;
    for (; preprocessor; preprocessor = preprocessors.shift()) {
      if (preprocessor.call(me, Class, data, hooks, doProcess) === false) {
        return;
      }
    }
    hooks.onBeforeCreated.apply(me, arguments);
  }, preprocessors:{}, registerPreprocessor:function(name, fn, properties, position, relativeTo) {
    if (!position) {
      position = 'last';
    }
    if (!properties) {
      properties = [name];
    }
    this.preprocessors[name] = {name:name, properties:properties || false, fn:fn};
    this.setDefaultPreprocessorPosition(name, position, relativeTo);
    return this;
  }, getPreprocessor:function(name) {
    return this.preprocessors[name];
  }, getPreprocessors:function() {
    return this.preprocessors;
  }, defaultPreprocessors:[], getDefaultPreprocessors:function() {
    return this.defaultPreprocessors;
  }, setDefaultPreprocessors:function(preprocessors) {
    this.defaultPreprocessors = Ext.Array.from(preprocessors);
    return this;
  }, setDefaultPreprocessorPosition:function(name, offset, relativeName) {
    var defaultPreprocessors = this.defaultPreprocessors, index;
    if (typeof offset == 'string') {
      if (offset === 'first') {
        defaultPreprocessors.unshift(name);
        return this;
      } else {
        if (offset === 'last') {
          defaultPreprocessors.push(name);
          return this;
        }
      }
      offset = offset === 'after' ? 1 : -1;
    }
    index = Ext.Array.indexOf(defaultPreprocessors, relativeName);
    if (index !== -1) {
      Ext.Array.splice(defaultPreprocessors, Math.max(0, index + offset), 0, name);
    }
    return this;
  }});
  ExtClass.registerPreprocessor('extend', function(Class, data, hooks) {
    Ext.classSystemMonitor && Ext.classSystemMonitor(Class, 'Ext.Class#extendPreProcessor', arguments);
    var Base = Ext.Base, basePrototype = Base.prototype, extend = data.extend, Parent, parentPrototype, i;
    delete data.extend;
    if (extend && extend !== Object) {
      Parent = extend;
    } else {
      Parent = Base;
    }
    parentPrototype = Parent.prototype;
    if (!Parent.$isClass) {
      for (i in basePrototype) {
        if (!parentPrototype[i]) {
          parentPrototype[i] = basePrototype[i];
        }
      }
    }
    Class.extend(Parent);
    Class.triggerExtended.apply(Class, arguments);
    if (data.onClassExtended) {
      Class.onExtended(data.onClassExtended, Class);
      delete data.onClassExtended;
    }
  }, true);
  ExtClass.registerPreprocessor('privates', function(Class, data) {
    Ext.classSystemMonitor && Ext.classSystemMonitor(Class, 'Ext.Class#privatePreprocessor', arguments);
    var privates = data.privates, statics = privates.statics, privacy = privates.privacy || true;
    delete data.privates;
    delete privates.statics;
    Class.addMembers(privates, false, privacy);
    if (statics) {
      Class.addMembers(statics, true, privacy);
    }
  });
  ExtClass.registerPreprocessor('statics', function(Class, data) {
    Ext.classSystemMonitor && Ext.classSystemMonitor(Class, 'Ext.Class#staticsPreprocessor', arguments);
    Class.addStatics(data.statics);
    delete data.statics;
  });
  ExtClass.registerPreprocessor('inheritableStatics', function(Class, data) {
    Ext.classSystemMonitor && Ext.classSystemMonitor(Class, 'Ext.Class#inheritableStaticsPreprocessor', arguments);
    Class.addInheritableStatics(data.inheritableStatics);
    delete data.inheritableStatics;
  });
  Ext.createRuleFn = function(code) {
    return new Function('$c', 'with($c) { try { return (' + code + '); } catch(e) { return false;}}');
  };
  Ext.expressionCache = new Ext.util.Cache({miss:Ext.createRuleFn});
  Ext.ruleKeySortFn = ruleKeySortFn;
  Ext.getPlatformConfigKeys = function(platformConfig) {
    var ret = [], platform, rule;
    for (platform in platformConfig) {
      rule = Ext.expressionCache.get(platform);
      if (rule(Ext.platformTags)) {
        ret.push(platform);
      }
    }
    ret.sort(ruleKeySortFn);
    return ret;
  };
  ExtClass.registerPreprocessor('config', function(Class, data) {
    if (data.hasOwnProperty('$configPrefixed')) {
      Class.prototype.$configPrefixed = data.$configPrefixed;
    }
    Class.addConfig(data.config);
    delete data.config;
  });
  ExtClass.registerPreprocessor('cachedConfig', function(Class, data) {
    if (data.hasOwnProperty('$configPrefixed')) {
      Class.prototype.$configPrefixed = data.$configPrefixed;
    }
    Class.addCachedConfig(data.cachedConfig);
    delete data.cachedConfig;
  });
  ExtClass.registerPreprocessor('mixins', function(Class, data, hooks) {
    Ext.classSystemMonitor && Ext.classSystemMonitor(Class, 'Ext.Class#mixinsPreprocessor', arguments);
    var mixins = data.mixins, onCreated = hooks.onCreated;
    delete data.mixins;
    hooks.onCreated = function() {
      Ext.classSystemMonitor && Ext.classSystemMonitor(Class, 'Ext.Class#mixinsPreprocessor#beforeCreated', arguments);
      hooks.onCreated = onCreated;
      Class.mixin(mixins);
      return hooks.onCreated.apply(this, arguments);
    };
  });
  Ext.extend = function(Class, Parent, members) {
    Ext.classSystemMonitor && Ext.classSystemMonitor(Class, 'Ext.Class#extend-backwards-compatible', arguments);
    if (arguments.length === 2 && Ext.isObject(Parent)) {
      members = Parent;
      Parent = Class;
      Class = null;
    }
    var cls;
    if (!Parent) {
      throw new Error('[Ext.extend] Attempting to extend from a class which has not been loaded on the page.');
    }
    members.extend = Parent;
    members.preprocessors = ['extend', 'statics', 'inheritableStatics', 'mixins', 'config'];
    if (Class) {
      cls = new ExtClass(Class, members);
      cls.prototype.constructor = Class;
    } else {
      cls = new ExtClass(members);
    }
    cls.prototype.override = function(o) {
      for (var m in o) {
        if (o.hasOwnProperty(m)) {
          this[m] = o[m];
        }
      }
    };
    return cls;
  };
})();
Ext.Inventory = function() {
  var me = this;
  me.names = [];
  me.paths = {};
  me.alternateToName = {};
  me.aliasToName = {};
  me.nameToAliases = {};
  me.nameToAlternates = {};
  me.nameToPrefix = {};
};
Ext.Inventory.prototype = {_array1:[0], prefixes:null, dotRe:/\./g, wildcardRe:/\*/g, addAlias:function(className, alias, update) {
  return this.addMapping(className, alias, this.aliasToName, this.nameToAliases, update);
}, addAlternate:function(className, alternate) {
  return this.addMapping(className, alternate, this.alternateToName, this.nameToAlternates);
}, addMapping:function(className, alternate, toName, nameTo, update) {
  var name = className.$className || className, mappings = name, array = this._array1, a, aliases, cls, i, length, nameMapping;
  if (Ext.isString(name)) {
    mappings = {};
    mappings[name] = alternate;
  }
  for (cls in mappings) {
    aliases = mappings[cls];
    if (Ext.isString(aliases)) {
      array[0] = aliases;
      aliases = array;
    }
    length = aliases.length;
    nameMapping = nameTo[cls] || (nameTo[cls] = []);
    for (i = 0; i < length; ++i) {
      if (!(a = aliases[i])) {
        continue;
      }
      if (toName[a] !== cls) {
        if (!update && toName[a] && 'Ext.Gadget' !== a) {
          Ext.log.warn("Overriding existing mapping: '" + a + "' From '" + toName[a] + "' to '" + cls + "'. Is this intentional?");
        }
        toName[a] = cls;
        nameMapping.push(a);
      }
    }
  }
}, getAliasesByName:function(name) {
  return this.nameToAliases[name] || null;
}, getAlternatesByName:function(name) {
  return this.nameToAlternates[name] || null;
}, getNameByAlias:function(alias) {
  return this.aliasToName[alias] || '';
}, getNameByAlternate:function(alternate) {
  return this.alternateToName[alternate] || '';
}, getNamesByExpression:function(expression, exclude, accumulate) {
  var me = this, aliasToName = me.aliasToName, alternateToName = me.alternateToName, nameToAliases = me.nameToAliases, nameToAlternates = me.nameToAlternates, map = accumulate ? exclude : {}, names = [], expressions = Ext.isString(expression) ? [expression] : expression, length = expressions.length, wildcardRe = me.wildcardRe, expr, i, list, match, n, name, regex;
  for (i = 0; i < length; ++i) {
    if ((expr = expressions[i]).indexOf('*') < 0) {
      if (!(name = aliasToName[expr])) {
        if (!(name = alternateToName[expr])) {
          name = expr;
        }
      }
      if (!(name in map) && !(exclude && name in exclude)) {
        map[name] = 1;
        names.push(name);
      }
    } else {
      regex = new RegExp('^' + expr.replace(wildcardRe, '(.*?)') + '$');
      for (name in nameToAliases) {
        if (!(name in map) && !(exclude && name in exclude)) {
          if (!(match = regex.test(name))) {
            n = (list = nameToAliases[name]).length;
            while (!match && n-- > 0) {
              match = regex.test(list[n]);
            }
            list = nameToAlternates[name];
            if (list && !match) {
              n = list.length;
              while (!match && n-- > 0) {
                match = regex.test(list[n]);
              }
            }
          }
          if (match) {
            map[name] = 1;
            names.push(name);
          }
        }
      }
    }
  }
  return names;
}, getPath:function(className) {
  var me = this, paths = me.paths, ret = '', prefix;
  if (className in paths) {
    ret = paths[className];
  } else {
    prefix = me.nameToPrefix[className] || (me.nameToPrefix[className] = me.getPrefix(className));
    if (prefix) {
      className = className.substring(prefix.length + 1);
      ret = paths[prefix];
      if (ret) {
        ret += '/';
      }
    }
    ret += className.replace(me.dotRe, '/') + '.js';
  }
  return ret;
}, getPrefix:function(className) {
  if (className in this.paths) {
    return className;
  } else {
    if (className in this.nameToPrefix) {
      return this.nameToPrefix[className];
    }
  }
  var prefixes = this.getPrefixes(), length = className.length, items, currChar, currSubstr, prefix, j, jlen;
  while (length-- > 0) {
    items = prefixes[length];
    if (items) {
      currChar = className.charAt(length);
      if (currChar !== '.') {
        continue;
      }
      currSubstr = className.substring(0, length);
      for (j = 0, jlen = items.length; j < jlen; j++) {
        prefix = items[j];
        if (prefix === className.substring(0, length)) {
          return prefix;
        }
      }
    }
  }
  return '';
}, getPrefixes:function() {
  var me = this, prefixes = me.prefixes, names, name, nameLength, items, i, len;
  if (!prefixes) {
    names = me.names.slice(0);
    me.prefixes = prefixes = [];
    for (i = 0, len = names.length; i < len; i++) {
      name = names[i];
      nameLength = name.length;
      items = prefixes[nameLength] || (prefixes[nameLength] = []);
      items.push(name);
    }
  }
  return prefixes;
}, removeName:function(name) {
  var me = this, aliasToName = me.aliasToName, alternateToName = me.alternateToName, nameToAliases = me.nameToAliases, nameToAlternates = me.nameToAlternates, aliases = nameToAliases[name], alternates = nameToAlternates[name], i, a;
  delete nameToAliases[name];
  delete nameToAlternates[name];
  delete me.nameToPrefix[name];
  if (aliases) {
    for (i = aliases.length; i--;) {
      if (name === aliasToName[a = aliases[i]]) {
        delete aliasToName[a];
      }
    }
  }
  if (alternates) {
    for (i = alternates.length; i--;) {
      if (name === alternateToName[a = alternates[i]]) {
        delete alternateToName[a];
      }
    }
  }
}, resolveName:function(name) {
  var me = this, trueName;
  if (!(name in me.nameToAliases)) {
    if (!(trueName = me.aliasToName[name])) {
      trueName = me.alternateToName[name];
    }
  }
  return trueName || name;
}, select:function(receiver, scope) {
  var me = this, excludes = {}, ret = {excludes:excludes, exclude:function() {
    me.getNamesByExpression(arguments[0], excludes, true);
    return this;
  }}, name;
  for (name in receiver) {
    ret[name] = me.selectMethod(excludes, receiver[name], scope || receiver);
  }
  return ret;
}, selectMethod:function(excludes, fn, scope) {
  var me = this;
  return function(include) {
    var args = Ext.Array.slice(arguments, 1);
    args.unshift(me.getNamesByExpression(include, excludes));
    return fn.apply(scope, args);
  };
}, setPath:Ext.Function.flexSetter(function(name, path) {
  var me = this;
  me.paths[name] = path;
  me.names.push(name);
  me.prefixes = null;
  me.nameToPrefix = {};
  return me;
})};
Ext.ClassManager = function(Class, alias, arraySlice, arrayFrom, global) {
  var makeCtor = Ext.Class.makeCtor, nameLookupStack = [], namespaceCache = {Ext:{name:'Ext', value:Ext}}, Manager = Ext.apply(new Ext.Inventory, {classes:{}, classCount:0, classState:{}, existCache:{}, instantiators:[], isCreated:function(className) {
    if (typeof className !== 'string' || className.length < 1) {
      throw new Error('[Ext.ClassManager] Invalid classname, must be a string and must not be empty');
    }
    if (Manager.classes[className] || Manager.existCache[className]) {
      return true;
    }
    if (!Manager.lookupName(className, false)) {
      return false;
    }
    Manager.triggerCreated(className);
    return true;
  }, createdListeners:[], nameCreatedListeners:{}, existsListeners:[], nameExistsListeners:{}, overrideMap:{}, triggerCreated:function(className, state) {
    Manager.existCache[className] = state || 1;
    Manager.classState[className] += 40;
    Manager.notify(className, Manager.createdListeners, Manager.nameCreatedListeners);
  }, onCreated:function(fn, scope, className) {
    Manager.addListener(fn, scope, className, Manager.createdListeners, Manager.nameCreatedListeners);
  }, notify:function(className, listeners, nameListeners) {
    var alternateNames = Manager.getAlternatesByName(className), names = [className], i, ln, j, subLn, listener, name;
    for (i = 0, ln = listeners.length; i < ln; i++) {
      listener = listeners[i];
      listener.fn.call(listener.scope, className);
    }
    while (names) {
      for (i = 0, ln = names.length; i < ln; i++) {
        name = names[i];
        listeners = nameListeners[name];
        if (listeners) {
          for (j = 0, subLn = listeners.length; j < subLn; j++) {
            listener = listeners[j];
            listener.fn.call(listener.scope, name);
          }
          delete nameListeners[name];
        }
      }
      names = alternateNames;
      alternateNames = null;
    }
  }, addListener:function(fn, scope, className, listeners, nameListeners) {
    if (Ext.isArray(className)) {
      fn = Ext.Function.createBarrier(className.length, fn, scope);
      for (i = 0; i < className.length; i++) {
        this.addListener(fn, null, className[i], listeners, nameListeners);
      }
      return;
    }
    var i, listener = {fn:fn, scope:scope};
    if (className) {
      if (this.isCreated(className)) {
        fn.call(scope, className);
        return;
      }
      if (!nameListeners[className]) {
        nameListeners[className] = [];
      }
      nameListeners[className].push(listener);
    } else {
      listeners.push(listener);
    }
  }, $namespaceCache:namespaceCache, addRootNamespaces:function(namespaces) {
    for (var name in namespaces) {
      namespaceCache[name] = {name:name, value:namespaces[name]};
    }
  }, clearNamespaceCache:function() {
    nameLookupStack.length = 0;
    for (var name in namespaceCache) {
      if (!namespaceCache[name].value) {
        delete namespaceCache[name];
      }
    }
  }, getNamespaceEntry:function(namespace) {
    if (typeof namespace !== 'string') {
      return namespace;
    }
    var entry = namespaceCache[namespace], i;
    if (!entry) {
      i = namespace.lastIndexOf('.');
      if (i < 0) {
        entry = {name:namespace};
      } else {
        entry = {name:namespace.substring(i + 1), parent:Manager.getNamespaceEntry(namespace.substring(0, i))};
      }
      namespaceCache[namespace] = entry;
    }
    return entry;
  }, lookupName:function(namespace, autoCreate) {
    var entry = Manager.getNamespaceEntry(namespace), scope = Ext.global, i = 0, e, parent;
    for (e = entry; e; e = e.parent) {
      nameLookupStack[i++] = e;
    }
    while (scope && i-- > 0) {
      e = nameLookupStack[i];
      parent = scope;
      scope = e.value || scope[e.name];
      if (!scope && autoCreate) {
        parent[e.name] = scope = {};
      }
    }
    return scope;
  }, setNamespace:function(namespace, value) {
    var entry = Manager.getNamespaceEntry(namespace), scope = Ext.global;
    if (entry.parent) {
      scope = Manager.lookupName(entry.parent, true);
    }
    scope[entry.name] = value;
    return value;
  }, setXType:function(cls, xtype) {
    var className = cls.$className, C = className ? cls : Manager.get(className = cls), proto = C.prototype, xtypes = proto.xtypes, xtypesChain = proto.xtypesChain, xtypesMap = proto.xtypesMap;
    if (!proto.hasOwnProperty('xtypes')) {
      proto.xtypes = xtypes = [];
      proto.xtypesChain = xtypesChain = xtypesChain ? xtypesChain.slice(0) : [];
      proto.xtypesMap = xtypesMap = Ext.apply({}, xtypesMap);
    }
    Manager.addAlias(className, 'widget.' + xtype, true);
    xtypes.push(xtype);
    xtypesChain.push(xtype);
    xtypesMap[xtype] = true;
  }, set:function(name, value) {
    var targetName = Manager.getName(value);
    Manager.classes[name] = Manager.setNamespace(name, value);
    Manager.classCount++;
    if (targetName && targetName !== name) {
      Manager.addAlternate(targetName, name);
    }
    return Manager;
  }, get:function(name) {
    return Manager.classes[name] || Manager.lookupName(name, false);
  }, addNameAliasMappings:function(aliases) {
    Manager.addAlias(aliases);
  }, addNameAlternateMappings:function(alternates) {
    Manager.addAlternate(alternates);
  }, getByAlias:function(alias) {
    return Manager.get(Manager.getNameByAlias(alias));
  }, getByConfig:function(config, aliasPrefix) {
    var xclass = config.xclass, name;
    if (xclass) {
      name = xclass;
    } else {
      name = config.xtype;
      if (name) {
        aliasPrefix = 'widget.';
      } else {
        name = config.type;
      }
      name = Manager.getNameByAlias(aliasPrefix + name);
    }
    return Manager.get(name);
  }, getName:function(object) {
    return object && object.$className || '';
  }, getClass:function(object) {
    return object && object.self || null;
  }, create:function(className, data, createdFn) {
    if (className != null && typeof className !== 'string') {
      throw new Error("[Ext.define] Invalid class name '" + className + "' specified, must be a non-empty string");
    }
    var ctor = makeCtor(className);
    if (typeof data === 'function') {
      data = data(ctor);
    }
    if (className) {
      if (Manager.classes[className]) {
        Ext.log.warn("[Ext.define] Duplicate class name '" + className + "' specified, must be a non-empty string");
      }
      ctor.name = className;
    }
    data.$className = className;
    return new Class(ctor, data, function() {
      var postprocessorStack = data.postprocessors || Manager.defaultPostprocessors, registeredPostprocessors = Manager.postprocessors, postprocessors = [], postprocessor, i, ln, j, subLn, postprocessorProperties, postprocessorProperty;
      delete data.postprocessors;
      for (i = 0, ln = postprocessorStack.length; i < ln; i++) {
        postprocessor = postprocessorStack[i];
        if (typeof postprocessor === 'string') {
          postprocessor = registeredPostprocessors[postprocessor];
          postprocessorProperties = postprocessor.properties;
          if (postprocessorProperties === true) {
            postprocessors.push(postprocessor.fn);
          } else {
            if (postprocessorProperties) {
              for (j = 0, subLn = postprocessorProperties.length; j < subLn; j++) {
                postprocessorProperty = postprocessorProperties[j];
                if (data.hasOwnProperty(postprocessorProperty)) {
                  postprocessors.push(postprocessor.fn);
                  break;
                }
              }
            }
          }
        } else {
          postprocessors.push(postprocessor);
        }
      }
      data.postprocessors = postprocessors;
      data.createdFn = createdFn;
      Manager.processCreate(className, this, data);
    });
  }, processCreate:function(className, cls, clsData) {
    var me = this, postprocessor = clsData.postprocessors.shift(), createdFn = clsData.createdFn;
    if (!postprocessor) {
      Ext.classSystemMonitor && Ext.classSystemMonitor(className, 'Ext.ClassManager#classCreated', arguments);
      if (className) {
        me.set(className, cls);
      }
      delete cls._classHooks;
      if (createdFn) {
        createdFn.call(cls, cls);
      }
      if (className) {
        me.triggerCreated(className);
      }
      return;
    }
    if (postprocessor.call(me, className, cls, clsData, me.processCreate) !== false) {
      me.processCreate(className, cls, clsData);
    }
  }, createOverride:function(className, data, createdFn) {
    var me = this, overriddenClassName = data.override, requires = data.requires, uses = data.uses, mixins = data.mixins, mixinsIsArray, compat = 1, dependenciesLoaded, classReady = function() {
      var cls, dependencies, i, key, temp;
      if (!dependenciesLoaded) {
        dependencies = requires ? requires.slice(0) : [];
        if (mixins) {
          if (!(mixinsIsArray = mixins instanceof Array)) {
            for (key in mixins) {
              if (Ext.isString(cls = mixins[key])) {
                dependencies.push(cls);
              }
            }
          } else {
            for (i = 0, temp = mixins.length; i < temp; ++i) {
              if (Ext.isString(cls = mixins[i])) {
                dependencies.push(cls);
              }
            }
          }
        }
        dependenciesLoaded = true;
        if (dependencies.length) {
          Ext.require(dependencies, classReady);
          return;
        }
      }
      if (mixinsIsArray) {
        for (i = 0, temp = mixins.length; i < temp; ++i) {
          if (Ext.isString(cls = mixins[i])) {
            mixins[i] = Ext.ClassManager.get(cls);
          }
        }
      } else {
        if (mixins) {
          for (key in mixins) {
            if (Ext.isString(cls = mixins[key])) {
              mixins[key] = Ext.ClassManager.get(cls);
            }
          }
        }
      }
      cls = overriddenClassName.$isClass ? overriddenClassName : me.get(overriddenClassName);
      delete data.override;
      delete data.compatibility;
      delete data.requires;
      delete data.uses;
      Ext.override(cls, data);
      Ext.Loader.history.push(className);
      if (uses) {
        Ext['Loader'].addUsedClasses(uses);
      }
      if (createdFn) {
        createdFn.call(cls, cls);
      }
    };
    if (className) {
      Manager.overrideMap[className] = true;
    }
    if ('compatibility' in data) {
      compat = data.compatibility;
      if (!compat) {
        compat = false;
      } else {
        if (typeof compat === 'number') {
          compat = true;
        } else {
          if (typeof compat !== 'boolean') {
            compat = Ext.checkVersion(compat);
          }
        }
      }
    }
    if (compat) {
      if (overriddenClassName.$isClass) {
        classReady();
      } else {
        me.onCreated(classReady, me, overriddenClassName);
      }
    }
    me.triggerCreated(className, 2);
    return me;
  }, instantiateByAlias:function() {
    var alias = arguments[0], args = arraySlice.call(arguments), className = this.getNameByAlias(alias);
    if (!className) {
      throw new Error('[Ext.createByAlias] Unrecognized alias: ' + alias);
    }
    args[0] = className;
    return Ext.create.apply(Ext, args);
  }, instantiate:function() {
    Ext.log.warn('Ext.ClassManager.instantiate() is deprecated.  Use Ext.create() instead.');
    return Ext.create.apply(Ext, arguments);
  }, dynInstantiate:function(name, args) {
    args = arrayFrom(args, true);
    args.unshift(name);
    return Ext.create.apply(Ext, args);
  }, getInstantiator:function(length) {
    var instantiators = this.instantiators, instantiator, i, args;
    instantiator = instantiators[length];
    if (!instantiator) {
      i = length;
      args = [];
      for (i = 0; i < length; i++) {
        args.push('a[' + i + ']');
      }
      instantiator = instantiators[length] = new Function('c', 'a', 'return new c(' + args.join(',') + ')');
      instantiator.name = 'Ext.create' + length;
    }
    return instantiator;
  }, postprocessors:{}, defaultPostprocessors:[], registerPostprocessor:function(name, fn, properties, position, relativeTo) {
    if (!position) {
      position = 'last';
    }
    if (!properties) {
      properties = [name];
    }
    this.postprocessors[name] = {name:name, properties:properties || false, fn:fn};
    this.setDefaultPostprocessorPosition(name, position, relativeTo);
    return this;
  }, setDefaultPostprocessors:function(postprocessors) {
    this.defaultPostprocessors = arrayFrom(postprocessors);
    return this;
  }, setDefaultPostprocessorPosition:function(name, offset, relativeName) {
    var defaultPostprocessors = this.defaultPostprocessors, index;
    if (typeof offset === 'string') {
      if (offset === 'first') {
        defaultPostprocessors.unshift(name);
        return this;
      } else {
        if (offset === 'last') {
          defaultPostprocessors.push(name);
          return this;
        }
      }
      offset = offset === 'after' ? 1 : -1;
    }
    index = Ext.Array.indexOf(defaultPostprocessors, relativeName);
    if (index !== -1) {
      Ext.Array.splice(defaultPostprocessors, Math.max(0, index + offset), 0, name);
    }
    return this;
  }});
  Manager.registerPostprocessor('platformConfig', function(name, Class, data) {
    Class.addPlatformConfig(data);
  });
  Manager.registerPostprocessor('alias', function(name, cls, data) {
    Ext.classSystemMonitor && Ext.classSystemMonitor(name, 'Ext.ClassManager#aliasPostProcessor', arguments);
    var aliases = Ext.Array.from(data.alias), i, ln;
    for (i = 0, ln = aliases.length; i < ln; i++) {
      alias = aliases[i];
      this.addAlias(cls, alias);
    }
  }, ['xtype', 'alias']);
  Manager.registerPostprocessor('singleton', function(name, cls, data, fn) {
    Ext.classSystemMonitor && Ext.classSystemMonitor(name, 'Ext.ClassManager#singletonPostProcessor', arguments);
    if (data.singleton) {
      fn.call(this, name, new cls, data);
    } else {
      return true;
    }
    return false;
  });
  Manager.registerPostprocessor('alternateClassName', function(name, cls, data) {
    Ext.classSystemMonitor && Ext.classSystemMonitor(name, 'Ext.ClassManager#alternateClassNamePostprocessor', arguments);
    var alternates = data.alternateClassName, i, ln, alternate;
    if (!(alternates instanceof Array)) {
      alternates = [alternates];
    }
    for (i = 0, ln = alternates.length; i < ln; i++) {
      alternate = alternates[i];
      if (typeof alternate !== 'string') {
        throw new Error("[Ext.define] Invalid alternate of: '" + alternate + "' for class: '" + name + "'; must be a valid string");
      }
      this.set(alternate, cls);
    }
  });
  Manager.registerPostprocessor('debugHooks', function(name, Class, data) {
    Ext.classSystemMonitor && Ext.classSystemMonitor(Class, 'Ext.Class#debugHooks', arguments);
    if (Ext.isDebugEnabled(Class.$className, data.debugHooks.$enabled)) {
      delete data.debugHooks.$enabled;
      Ext.override(Class, data.debugHooks);
    }
    var target = Class.isInstance ? Class.self : Class;
    delete target.prototype.debugHooks;
  });
  Manager.registerPostprocessor('deprecated', function(name, Class, data) {
    Ext.classSystemMonitor && Ext.classSystemMonitor(Class, 'Ext.Class#deprecated', arguments);
    var target = Class.isInstance ? Class.self : Class;
    target.addDeprecations(data.deprecated);
    delete target.prototype.deprecated;
  });
  Ext.apply(Ext, {create:function() {
    var name = arguments[0], nameType = typeof name, args = arraySlice.call(arguments, 1), cls;
    if (nameType === 'function') {
      cls = name;
    } else {
      if (nameType !== 'string' && args.length === 0) {
        args = [name];
        if (!(name = name.xclass)) {
          name = args[0].xtype;
          if (name) {
            name = 'widget.' + name;
          }
        }
      }
      if (typeof name !== 'string' || name.length < 1) {
        throw new Error("[Ext.create] Invalid class name or alias '" + name + "' specified, must be a non-empty string");
      }
      name = Manager.resolveName(name);
      cls = Manager.get(name);
    }
    if (!cls) {
      Ext.log.warn("[Ext.Loader] Synchronously loading '" + name + "'; consider adding " + "Ext.require('" + name + "') above Ext.onReady");
      Ext.syncRequire(name);
      cls = Manager.get(name);
    }
    if (!cls) {
      throw new Error('[Ext.create] Unrecognized class name / alias: ' + name);
    }
    if (typeof cls !== 'function') {
      throw new Error("[Ext.create] Singleton '" + name + "' cannot be instantiated.");
    }
    return Manager.getInstantiator(args.length)(cls, args);
  }, widget:function(name, config) {
    var xtype = name, alias, className, T;
    if (typeof xtype !== 'string') {
      config = name;
      xtype = config.xtype;
      className = config.xclass;
    } else {
      config = config || {};
    }
    if (config.isComponent) {
      return config;
    }
    if (!className) {
      alias = 'widget.' + xtype;
      className = Manager.getNameByAlias(alias);
    }
    if (className) {
      T = Manager.get(className);
    }
    if (!T) {
      return Ext.create(className || alias, config);
    }
    return new T(config);
  }, createByAlias:alias(Manager, 'instantiateByAlias'), define:function(className, data, createdFn) {
    Ext.classSystemMonitor && Ext.classSystemMonitor(className, 'ClassManager#define', arguments);
    if (data.override) {
      Manager.classState[className] = 20;
      return Manager.createOverride.apply(Manager, arguments);
    }
    Manager.classState[className] = 10;
    return Manager.create.apply(Manager, arguments);
  }, undefine:function(className) {
    Ext.classSystemMonitor && Ext.classSystemMonitor(className, 'Ext.ClassManager#undefine', arguments);
    var classes = Manager.classes;
    if (classes[className]) {
      Manager.classCount--;
    }
    delete classes[className];
    delete Manager.existCache[className];
    delete Manager.classState[className];
    Manager.removeName(className);
    Ext.Factory.clearCaches();
    var entry = Manager.getNamespaceEntry(className), scope = entry.parent ? Manager.lookupName(entry.parent, false) : Ext.global, entryName;
    if (scope) {
      entryName = entry.name;
      try {
        delete scope[entryName];
      } catch (e$1) {
        scope[entryName] = undefined;
      }
    }
    return entryName;
  }, getClassName:alias(Manager, 'getName'), getDisplayName:function(object) {
    if (object) {
      if (object.displayName) {
        return object.displayName;
      }
      if (object.$name && object.$class) {
        return Ext.getClassName(object.$class) + '#' + object.$name;
      }
      if (object.$className) {
        return object.$className;
      }
    }
    return 'Anonymous';
  }, getClass:alias(Manager, 'getClass'), namespace:function() {
    var root = global, i;
    for (i = arguments.length; i-- > 0;) {
      root = Manager.lookupName(arguments[i], true);
    }
    return root;
  }});
  Ext.addRootNamespaces = Manager.addRootNamespaces;
  Ext.createWidget = Ext.widget;
  Ext.ns = Ext.namespace;
  Class.registerPreprocessor('className', function(cls, data) {
    if ('$className' in data) {
      cls.$className = data.$className;
      cls.displayName = cls.$className;
    }
    Ext.classSystemMonitor && Ext.classSystemMonitor(cls, 'Ext.ClassManager#classNamePreprocessor', arguments);
  }, true, 'first');
  Class.registerPreprocessor('alias', function(cls, data) {
    Ext.classSystemMonitor && Ext.classSystemMonitor(cls, 'Ext.ClassManager#aliasPreprocessor', arguments);
    var prototype = cls.prototype, xtypes = arrayFrom(data.xtype), aliases = arrayFrom(data.alias), widgetPrefix = 'widget.', widgetPrefixLength = widgetPrefix.length, xtypesChain = Array.prototype.slice.call(prototype.xtypesChain || []), xtypesMap = Ext.merge({}, prototype.xtypesMap || {}), i, ln, alias, xtype;
    for (i = 0, ln = aliases.length; i < ln; i++) {
      alias = aliases[i];
      if (typeof alias !== 'string' || alias.length < 1) {
        throw new Error("[Ext.define] Invalid alias of: '" + alias + "' for class: '" + name + "'; must be a valid string");
      }
      if (alias.substring(0, widgetPrefixLength) === widgetPrefix) {
        xtype = alias.substring(widgetPrefixLength);
        Ext.Array.include(xtypes, xtype);
      }
    }
    cls.xtype = data.xtype = xtypes[0];
    data.xtypes = xtypes;
    for (i = 0, ln = xtypes.length; i < ln; i++) {
      xtype = xtypes[i];
      if (!xtypesMap[xtype]) {
        xtypesMap[xtype] = true;
        xtypesChain.push(xtype);
      }
    }
    data.xtypesChain = xtypesChain;
    data.xtypesMap = xtypesMap;
    Ext.Function.interceptAfterOnce(cls, 'onClassCreated', function() {
      var cls = this, prototype = cls.prototype, mixins = prototype.mixins, key, mixin;
      Ext.classSystemMonitor && Ext.classSystemMonitor(cls, 'Ext.ClassManager#aliasPreprocessor#afterClassCreated', arguments);
      for (key in mixins) {
        if (mixins.hasOwnProperty(key)) {
          mixin = mixins[key];
          xtypes = mixin.xtypes;
          if (xtypes) {
            for (i = 0, ln = xtypes.length; i < ln; i++) {
              xtype = xtypes[i];
              if (!xtypesMap[xtype]) {
                xtypesMap[xtype] = true;
                xtypesChain.push(xtype);
              }
            }
          }
        }
      }
    });
    for (i = 0, ln = xtypes.length; i < ln; i++) {
      xtype = xtypes[i];
      if (typeof xtype !== 'string' || xtype.length < 1) {
        throw new Error("[Ext.define] Invalid xtype of: '" + xtype + "' for class: '" + name + "'; must be a valid non-empty string");
      }
      Ext.Array.include(aliases, widgetPrefix + xtype);
    }
    data.alias = aliases;
  }, ['xtype', 'alias']);
  if (Ext.manifest) {
    var manifest = Ext.manifest, classes = manifest.classes, paths = manifest.paths, aliases = {}, alternates = {}, className, obj, name, path, baseUrl;
    if (paths) {
      if (manifest.bootRelative) {
        baseUrl = Ext.Boot.baseUrl;
        for (path in paths) {
          if (paths.hasOwnProperty(path)) {
            paths[path] = baseUrl + paths[path];
          }
        }
      }
      Manager.setPath(paths);
    }
    if (classes) {
      for (className in classes) {
        alternates[className] = [];
        aliases[className] = [];
        obj = classes[className];
        if (obj.alias) {
          aliases[className] = obj.alias;
        }
        if (obj.alternates) {
          alternates[className] = obj.alternates;
        }
      }
    }
    Manager.addAlias(aliases);
    Manager.addAlternate(alternates);
  }
  return Manager;
}(Ext.Class, Ext.Function.alias, Array.prototype.slice, Ext.Array.from, Ext.global);
(Ext.env || (Ext.env = {})).Browser = function(userAgent, publish) {
  var me = this, browserPrefixes = Ext.Boot.browserPrefixes, browserNames = Ext.Boot.browserNames, enginePrefixes = me.enginePrefixes, engineNames = me.engineNames, browserMatch = userAgent.match(new RegExp('((?:' + Ext.Object.getValues(browserPrefixes).join(')|(?:') + '))([\\w\\._]+)')), engineMatch = userAgent.match(new RegExp('((?:' + Ext.Object.getValues(enginePrefixes).join(')|(?:') + '))([\\w\\._]+)')), browserName = browserNames.other, engineName = engineNames.other, browserVersion = '', engineVersion = 
  '', majorVer = '', isWebView = false, edgeRE = /(Edge\/)([\w.]+)/, ripple = '', i, prefix, name;
  me.userAgent = userAgent;
  this.is = function(name) {
    return !!this.is[name];
  };
  if (/Edge\//.test(userAgent)) {
    browserMatch = userAgent.match(edgeRE);
    engineMatch = userAgent.match(edgeRE);
  }
  if (browserMatch) {
    browserName = browserNames[Ext.Object.getKey(browserPrefixes, browserMatch[1])];
    if (browserName === 'Safari' && /^Opera/.test(userAgent)) {
      browserName = 'Opera';
    }
    browserVersion = new Ext.Version(browserMatch[2]);
  }
  if (engineMatch) {
    engineName = engineNames[Ext.Object.getKey(enginePrefixes, engineMatch[1])];
    engineVersion = new Ext.Version(engineMatch[2]);
  }
  if (engineName === 'Trident' && browserName !== 'IE') {
    browserName = 'IE';
    var version = userAgent.match(/.*rv:(\d+.\d+)/);
    if (version && version.length) {
      version = version[1];
      browserVersion = new Ext.Version(version);
    }
  }
  if (browserName && browserVersion) {
    Ext.setVersion(browserName, browserVersion);
  }
  if (userAgent.match(/FB/) && browserName === 'Other') {
    browserName = browserNames.safari;
    engineName = engineNames.webkit;
  } else {
    if (userAgent.match(/Android.*Chrome/g)) {
      browserName = 'ChromeMobile';
    } else {
      browserMatch = userAgent.match(/OPR\/(\d+.\d+)/);
      if (browserMatch) {
        browserName = 'Opera';
        browserVersion = new Ext.Version(browserMatch[1]);
      }
    }
  }
  Ext.apply(this, {engineName:engineName, engineVersion:engineVersion, name:browserName, version:browserVersion});
  this.setFlag(browserName, true, publish);
  if (browserVersion) {
    majorVer = browserVersion.getMajor() || '';
    if (me.is.IE) {
      majorVer = document.documentMode || parseInt(majorVer, 10);
      for (i = 7; i <= 11; ++i) {
        prefix = 'isIE' + i;
        Ext[prefix] = majorVer === i;
        Ext[prefix + 'm'] = majorVer <= i;
        Ext[prefix + 'p'] = majorVer >= i;
      }
    }
    if (me.is.Opera && parseInt(majorVer, 10) <= 12) {
      Ext.isOpera12m = true;
    }
    Ext.chromeVersion = Ext.isChrome ? majorVer : 0;
    Ext.firefoxVersion = Ext.isFirefox ? majorVer : 0;
    Ext.ieVersion = Ext.isIE ? majorVer : 0;
    Ext.operaVersion = Ext.isOpera ? majorVer : 0;
    Ext.safariVersion = Ext.isSafari ? majorVer : 0;
    Ext.webKitVersion = Ext.isWebKit ? majorVer : 0;
    this.setFlag(browserName + majorVer, true, publish);
    this.setFlag(browserName + browserVersion.getShortVersion());
  }
  for (i in browserNames) {
    if (browserNames.hasOwnProperty(i)) {
      name = browserNames[i];
      this.setFlag(name, browserName === name);
    }
  }
  this.setFlag(name);
  if (engineVersion) {
    this.setFlag(engineName + (engineVersion.getMajor() || ''));
    this.setFlag(engineName + engineVersion.getShortVersion());
  }
  for (i in engineNames) {
    if (engineNames.hasOwnProperty(i)) {
      name = engineNames[i];
      this.setFlag(name, engineName === name, publish);
    }
  }
  this.setFlag('Standalone', !!navigator.standalone);
  try {
    ripple = window.top.ripple;
  } catch (e$2) {
  }
  this.setFlag('Ripple', !!document.getElementById('tinyhippos-injected') && !Ext.isEmpty(ripple));
  this.setFlag('WebWorks', !!window.blackberry);
  if (window.PhoneGap !== undefined || window.Cordova !== undefined || window.cordova !== undefined) {
    isWebView = true;
    this.setFlag('PhoneGap');
    this.setFlag('Cordova');
  }
  if (/(iPhone|iPod|iPad).*AppleWebKit(?!.*Safari)(?!.*FBAN)/i.test(userAgent)) {
    isWebView = true;
  }
  this.setFlag('WebView', isWebView);
  this.isStrict = Ext.isStrict = document.compatMode === 'CSS1Compat';
  this.isSecure = Ext.isSecure;
  this.identity = browserName + majorVer + (this.isStrict ? 'Strict' : 'Quirks');
};
Ext.env.Browser.prototype = {constructor:Ext.env.Browser, engineNames:{edge:'Edge', webkit:'WebKit', gecko:'Gecko', presto:'Presto', trident:'Trident', other:'Other'}, enginePrefixes:{edge:'Edge/', webkit:'AppleWebKit/', gecko:'Gecko/', presto:'Presto/', trident:'Trident/'}, styleDashPrefixes:{WebKit:'-webkit-', Gecko:'-moz-', Trident:'-ms-', Presto:'-o-', Other:''}, stylePrefixes:{WebKit:'Webkit', Gecko:'Moz', Trident:'ms', Presto:'O', Other:''}, propertyPrefixes:{WebKit:'webkit', Gecko:'moz', Trident:'ms', 
Presto:'o', Other:''}, name:null, version:null, engineName:null, engineVersion:null, setFlag:function(name, value, publish) {
  if (value === undefined) {
    value = true;
  }
  this.is[name] = value;
  this.is[name.toLowerCase()] = value;
  if (publish) {
    Ext['is' + name] = value;
  }
  return this;
}, getStyleDashPrefix:function() {
  return this.styleDashPrefixes[this.engineName];
}, getStylePrefix:function() {
  return this.stylePrefixes[this.engineName];
}, getVendorProperyName:function(name) {
  var prefix = this.propertyPrefixes[this.engineName];
  if (prefix.length > 0) {
    return prefix + Ext.String.capitalize(name);
  }
  return name;
}};
(function(userAgent) {
  Ext.browser = new Ext.env.Browser(userAgent, true);
  Ext.userAgent = userAgent.toLowerCase();
  Ext.SSL_SECURE_URL = Ext.isSecure && Ext.isIE ? "javascript:''" : 'about:blank';
})(Ext.global.navigator.userAgent);
Ext.env.OS = function(userAgent, platform, browserScope) {
  var me = this, names = Ext.Boot.osNames, prefixes = Ext.Boot.osPrefixes, name, version = '', is = me.is, i, prefix, match, item, match1;
  browserScope = browserScope || Ext.browser;
  for (i in prefixes) {
    if (prefixes.hasOwnProperty(i)) {
      prefix = prefixes[i];
      match = userAgent.match(new RegExp('(?:' + prefix + ')([^\\s;]+)'));
      if (match) {
        name = names[i];
        match1 = match[1];
        if (match1 && match1 === 'HTC_') {
          version = new Ext.Version('2.3');
        } else {
          if (match1 && match1 === 'Silk/') {
            version = new Ext.Version('2.3');
          } else {
            version = new Ext.Version(match[match.length - 1]);
          }
        }
        break;
      }
    }
  }
  if (!name) {
    name = names[(userAgent.toLowerCase().match(/mac|win|linux/) || ['other'])[0]];
    version = new Ext.Version('');
  }
  this.name = name;
  this.version = version;
  if (userAgent.match(/ipad/i)) {
    platform = 'iPad';
  }
  if (platform) {
    this.setFlag(platform.replace(/ simulator$/i, ''));
  }
  this.setFlag(name);
  if (version) {
    this.setFlag(name + (version.getMajor() || ''));
    this.setFlag(name + version.getShortVersion());
  }
  for (i in names) {
    if (names.hasOwnProperty(i)) {
      item = names[i];
      if (!is.hasOwnProperty(name)) {
        this.setFlag(item, name === item);
      }
    }
  }
  if (this.name === 'iOS' && window.screen.height === 568) {
    this.setFlag('iPhone5');
  }
  if (browserScope.is.Safari || browserScope.is.Silk) {
    if (this.is.Android2 || this.is.Android3 || browserScope.version.shortVersion === 501) {
      browserScope.setFlag('AndroidStock');
    }
    if (this.is.Android4) {
      browserScope.setFlag('AndroidStock');
      browserScope.setFlag('AndroidStock4');
    }
  }
};
Ext.env.OS.prototype = {constructor:Ext.env.OS, is:function(name) {
  return !!this[name];
}, name:null, version:null, setFlag:function(name, value) {
  if (value === undefined) {
    value = true;
  }
  if (this.flags) {
    this.flags[name] = value;
  }
  this.is[name] = value;
  this.is[name.toLowerCase()] = value;
  return this;
}};
(function() {
  var navigation = Ext.global.navigator, userAgent = navigation.userAgent, OS = Ext.env.OS, is = Ext.is || (Ext.is = {}), osEnv, osName, deviceType;
  OS.prototype.flags = is;
  Ext.os = osEnv = new OS(userAgent, navigation.platform);
  osName = osEnv.name;
  Ext['is' + osName] = true;
  Ext.isMac = is.Mac = is.MacOS;
  Ext.isApple = Ext.isMac || Ext.isiOS;
  var search = window.location.search.match(/deviceType=(Tablet|Phone)/), nativeDeviceType = window.deviceType;
  if (search && search[1]) {
    deviceType = search[1];
  } else {
    if (nativeDeviceType === 'iPhone') {
      deviceType = 'Phone';
    } else {
      if (nativeDeviceType === 'iPad') {
        deviceType = 'Tablet';
      } else {
        if (!osEnv.is.Android && !osEnv.is.iOS && !osEnv.is.WindowsPhone && /Windows|Linux|MacOS|ChromeOS/.test(osName)) {
          deviceType = 'Desktop';
          Ext.browser.is.WebView = !!Ext.browser.is.Ripple;
        } else {
          if (osEnv.is.iPad || osEnv.is.RIMTablet || osEnv.is.Android3 || Ext.browser.is.Silk || osEnv.is.Android && userAgent.search(/mobile/i) === -1) {
            deviceType = 'Tablet';
          } else {
            deviceType = 'Phone';
          }
        }
      }
    }
  }
  osEnv.setFlag(deviceType, true);
  osEnv.deviceType = deviceType;
  delete OS.prototype.flags;
})();
Ext.feature = {has:function(name) {
  return !!this.has[name];
}, testElements:{}, getTestElement:function(tag, createNew) {
  if (tag === undefined) {
    tag = 'div';
  } else {
    if (typeof tag !== 'string') {
      return tag;
    }
  }
  if (createNew) {
    return document.createElement(tag);
  }
  if (!this.testElements[tag]) {
    this.testElements[tag] = document.createElement(tag);
  }
  return this.testElements[tag];
}, isStyleSupported:function(name, tag) {
  var elementStyle = this.getTestElement(tag).style, cName = Ext.String.capitalize(name);
  if (typeof elementStyle[name] !== 'undefined' || typeof elementStyle[Ext.browser.getStylePrefix(name) + cName] !== 'undefined') {
    return true;
  }
  return false;
}, isStyleSupportedWithoutPrefix:function(name, tag) {
  var elementStyle = this.getTestElement(tag).style;
  if (typeof elementStyle[name] !== 'undefined') {
    return true;
  }
  return false;
}, isEventSupported:function(name, tag) {
  if (tag === undefined) {
    tag = window;
  }
  var element = this.getTestElement(tag), eventName = 'on' + name.toLowerCase(), isSupported = eventName in element;
  if (!isSupported) {
    if (element.setAttribute && element.removeAttribute) {
      element.setAttribute(eventName, '');
      isSupported = typeof element[eventName] === 'function';
      if (typeof element[eventName] !== 'undefined') {
        element[eventName] = undefined;
      }
      element.removeAttribute(eventName);
    }
  }
  return isSupported;
}, getStyle:function(element, styleName) {
  var view = element.ownerDocument.defaultView, style = view ? view.getComputedStyle(element, null) : element.currentStyle;
  return (style || element.style)[styleName];
}, getSupportedPropertyName:function(object, name) {
  var vendorName = Ext.browser.getVendorProperyName(name);
  if (vendorName in object) {
    return vendorName;
  } else {
    if (name in object) {
      return name;
    }
  }
  return null;
}, detect:function(isReady) {
  var me = this, doc = document, toRun = me.toRun || me.tests, n = toRun.length, div = doc.createElement('div'), notRun = [], supports = Ext.supports, has = me.has, name, names, test, vector, value;
  div.innerHTML = '\x3cdiv style\x3d"height:30px;width:50px;"\x3e' + '\x3cdiv style\x3d"height:20px;width:20px;"\x3e\x3c/div\x3e' + '\x3c/div\x3e' + '\x3cdiv style\x3d"width: 200px; height: 200px; position: relative; padding: 5px;"\x3e' + '\x3cdiv style\x3d"position: absolute; top: 0; left: 0; width: 100%; height: 100%;"\x3e\x3c/div\x3e' + '\x3c/div\x3e' + '\x3cdiv style\x3d"position: absolute; left: 10%; top: 10%;"\x3e\x3c/div\x3e' + '\x3cdiv style\x3d"float:left; background-color:transparent;"\x3e\x3c/div\x3e';
  if (isReady) {
    doc.body.appendChild(div);
  }
  vector = me.preDetected[Ext.browser.identity] || [];
  while (n--) {
    test = toRun[n];
    value = vector[n];
    name = test.name;
    names = test.names;
    if (value === undefined) {
      if (!isReady && test.ready) {
        notRun.push(test);
        continue;
      }
      value = test.fn.call(me, doc, div);
    }
    if (name) {
      supports[name] = has[name] = value;
    } else {
      if (names) {
        while (names.length) {
          name = names.pop();
          supports[name] = has[name] = value;
        }
      }
    }
  }
  if (isReady) {
    doc.body.removeChild(div);
  }
  me.toRun = notRun;
}, report:function() {
  var values = [], len = this.tests.length, i;
  for (i = 0; i < len; ++i) {
    values.push(this.has[this.tests[i].name] ? 1 : 0);
  }
  Ext.log(Ext.browser.identity + ': [' + values.join(',') + ']');
}, preDetected:{}, tests:[{name:'CloneNodeCopiesExpando', fn:function() {
  var el = document.createElement('div');
  el.expandoProp = {};
  return el.cloneNode().expandoProp === el.expandoProp;
}}, {name:'CSSPointerEvents', fn:function(doc) {
  return 'pointerEvents' in doc.documentElement.style;
}}, {name:'CSS3BoxShadow', fn:function(doc) {
  return 'boxShadow' in doc.documentElement.style || 'WebkitBoxShadow' in doc.documentElement.style || 'MozBoxShadow' in doc.documentElement.style;
}}, {name:'CSS3NegationSelector', fn:function(doc) {
  try {
    doc.querySelectorAll('foo:not(bar)');
  } catch (e$3) {
    return false;
  }
  return true;
}}, {name:'ClassList', fn:function(doc) {
  return !!doc.documentElement.classList;
}}, {name:'Canvas', fn:function() {
  var element = this.getTestElement('canvas');
  return !!(element && element.getContext && element.getContext('2d'));
}}, {name:'Svg', fn:function(doc) {
  return !!(doc.createElementNS && !!doc.createElementNS('http:/' + '/www.w3.org/2000/svg', 'svg').createSVGRect);
}}, {name:'Vml', fn:function() {
  var element = this.getTestElement(), ret = false;
  element.innerHTML = '\x3c!--[if vml]\x3e\x3cbr\x3e\x3c![endif]--\x3e';
  ret = element.childNodes.length === 1;
  element.innerHTML = '';
  return ret;
}}, {name:'Touch', fn:function() {
  var maxTouchPoints = navigator.msMaxTouchPoints || navigator.maxTouchPoints;
  if (Ext.browser.is.Chrome && Ext.browser.version.isLessThanOrEqual(39)) {
    return Ext.supports.TouchEvents && maxTouchPoints !== 1 || maxTouchPoints > 1;
  } else {
    return Ext.supports.TouchEvents || maxTouchPoints > 0;
  }
}}, {name:'PointerEvents', fn:function() {
  return !!(window.PointerEvent && !Ext.supports.TouchEvents);
}}, {name:'MSPointerEvents', fn:function() {
  return Ext.isIE10;
}}, {name:'TouchEvents', fn:function() {
  return this.isEventSupported('touchend');
}}, {name:'TouchAction', ready:true, fn:function(doc, div) {
  if (!window.getComputedStyle) {
    return 0;
  }
  var values = ['pan-x', 'pan-y', 'pinch-zoom', 'double-tap-zoom'], flags = [1, 2, 4, 8], ln = values.length, flag = 0, i, value;
  for (i = 0; i < ln; i++) {
    value = values[i];
    div.style.touchAction = value;
    if (getComputedStyle(div).touchAction === value) {
      flag |= flags[i];
    }
  }
  return flag;
}}, {name:'Orientation', fn:function() {
  return 'orientation' in window && this.isEventSupported('orientationchange');
}}, {name:'OrientationChange', fn:function() {
  return this.isEventSupported('orientationchange');
}}, {name:'DeviceMotion', fn:function() {
  return this.isEventSupported('devicemotion');
}}, {names:['Geolocation', 'GeoLocation'], fn:function() {
  return 'geolocation' in window.navigator;
}}, {name:'SqlDatabase', fn:function() {
  return 'openDatabase' in window;
}}, {name:'WebSockets', fn:function() {
  return 'WebSocket' in window;
}}, {name:'Range', fn:function() {
  return !!document.createRange;
}}, {name:'CreateContextualFragment', fn:function() {
  var range = !!document.createRange ? document.createRange() : false;
  return range && !!range.createContextualFragment;
}}, {name:'History', fn:function() {
  return 'history' in window && 'pushState' in window.history;
}}, {name:'Css3dTransforms', fn:function() {
  return this.has('CssTransforms') && this.isStyleSupported('perspective');
}}, {name:'CssTransforms', fn:function() {
  return this.isStyleSupported('transform');
}}, {name:'CssTransformNoPrefix', fn:function() {
  return this.isStyleSupportedWithoutPrefix('transform');
}}, {name:'CssAnimations', fn:function() {
  return this.isStyleSupported('animationName');
}}, {names:['CssTransitions', 'Transitions'], fn:function() {
  return this.isStyleSupported('transitionProperty');
}}, {names:['Audio', 'AudioTag'], fn:function() {
  return !!this.getTestElement('audio').canPlayType;
}}, {name:'Video', fn:function() {
  return !!this.getTestElement('video').canPlayType;
}}, {name:'LocalStorage', fn:function() {
  try {
    if ('localStorage' in window && window['localStorage'] !== null) {
      localStorage.setItem('sencha-localstorage-test', 'test success');
      localStorage.removeItem('sencha-localstorage-test');
      return true;
    }
  } catch (e$4) {
  }
  return false;
}}, {name:'XmlQuerySelector', fn:function() {
  var xmlString = '\x3c?xml version\x3d"1.0" encoding\x3d"UTF-8" standalone\x3d"yes" ?\x3e\x3croot\x3e\x3c/root\x3e', xmlDoc;
  if (window.ActiveXObject) {
    xmlDoc = new ActiveXObject('Microsoft.xmlDOM');
    xmlDoc.async = false;
    xmlDoc.loadXML(xmlString);
  } else {
    if (window.DOMParser) {
      var parser = new DOMParser;
      xmlDoc = parser.parseFromString(xmlString, 'text/xml');
    }
  }
  return xmlDoc ? !!xmlDoc.lastChild.querySelector : false;
}}, {name:'XHR2', fn:function() {
  return window.ProgressEvent && window.FormData && window.XMLHttpRequest && 'withCredentials' in new XMLHttpRequest;
}}, {name:'XHRUploadProgress', fn:function() {
  if (window.XMLHttpRequest && !Ext.browser.is.AndroidStock) {
    var xhr = new XMLHttpRequest;
    return xhr && 'upload' in xhr && 'onprogress' in xhr.upload;
  }
  return false;
}}, {name:'NumericInputPlaceHolder', fn:function() {
  return !(Ext.browser.is.AndroidStock4 && Ext.os.version.getMinor() < 2);
}}, {name:'matchesSelector', fn:function() {
  var el = document.documentElement, w3 = 'matches', wk = 'webkitMatchesSelector', ms = 'msMatchesSelector', mz = 'mozMatchesSelector';
  return el[w3] ? w3 : el[wk] ? wk : el[ms] ? ms : el[mz] ? mz : null;
}}, {name:'RightMargin', ready:true, fn:function(doc, div) {
  var view = doc.defaultView;
  return !(view && view.getComputedStyle(div.firstChild.firstChild, null).marginRight !== '0px');
}}, {name:'DisplayChangeInputSelectionBug', fn:function() {
  var webKitVersion = Ext.webKitVersion;
  return 0 < webKitVersion && webKitVersion < 533;
}}, {name:'DisplayChangeTextAreaSelectionBug', fn:function() {
  var webKitVersion = Ext.webKitVersion;
  return 0 < webKitVersion && webKitVersion < 534.24;
}}, {name:'TransparentColor', ready:true, fn:function(doc, div, view) {
  view = doc.defaultView;
  return !(view && view.getComputedStyle(div.lastChild, null).backgroundColor !== 'transparent');
}}, {name:'ComputedStyle', ready:true, fn:function(doc, div, view) {
  view = doc.defaultView;
  return !!(view && view.getComputedStyle);
}}, {name:'Float', fn:function(doc) {
  return 'cssFloat' in doc.documentElement.style;
}}, {name:'CSS3BorderRadius', ready:true, fn:function(doc) {
  var domPrefixes = ['borderRadius', 'BorderRadius', 'MozBorderRadius', 'WebkitBorderRadius', 'OBorderRadius', 'KhtmlBorderRadius'], pass = false, i;
  for (i = 0; i < domPrefixes.length; i++) {
    if (doc.documentElement.style[domPrefixes[i]] !== undefined) {
      pass = true;
    }
  }
  return pass && !Ext.isIE9;
}}, {name:'CSS3LinearGradient', fn:function(doc, div) {
  var property = 'background-image:', webkit = '-webkit-gradient(linear, left top, right bottom, from(black), to(white))', w3c = 'linear-gradient(left top, black, white)', moz = '-moz-' + w3c, ms = '-ms-' + w3c, opera = '-o-' + w3c, options = [property + webkit, property + w3c, property + moz, property + ms, property + opera];
  div.style.cssText = options.join(';');
  return ('' + div.style.backgroundImage).indexOf('gradient') !== -1 && !Ext.isIE9;
}}, {name:'MouseEnterLeave', fn:function(doc) {
  return 'onmouseenter' in doc.documentElement && 'onmouseleave' in doc.documentElement;
}}, {name:'MouseWheel', fn:function(doc) {
  return 'onmousewheel' in doc.documentElement;
}}, {name:'Opacity', fn:function(doc, div) {
  if (Ext.isIE8) {
    return false;
  }
  div.firstChild.style.cssText = 'opacity:0.73';
  return div.firstChild.style.opacity == '0.73';
}}, {name:'Placeholder', fn:function(doc) {
  return 'placeholder' in doc.createElement('input');
}}, {name:'Direct2DBug', fn:function(doc) {
  return Ext.isString(doc.documentElement.style.msTransformOrigin) && Ext.isIE9m;
}}, {name:'BoundingClientRect', fn:function(doc) {
  return 'getBoundingClientRect' in doc.documentElement;
}}, {name:'RotatedBoundingClientRect', ready:true, fn:function(doc) {
  var body = doc.body, supports = false, el = doc.createElement('div'), style = el.style;
  if (el.getBoundingClientRect) {
    style.position = 'absolute';
    style.top = '0';
    style.WebkitTransform = style.MozTransform = style.msTransform = style.OTransform = style.transform = 'rotate(90deg)';
    style.width = '100px';
    style.height = '30px';
    body.appendChild(el);
    supports = el.getBoundingClientRect().height !== 100;
    body.removeChild(el);
  }
  return supports;
}}, {name:'ChildContentClearedWhenSettingInnerHTML', ready:true, fn:function() {
  var el = this.getTestElement(), child;
  el.innerHTML = '\x3cdiv\x3ea\x3c/div\x3e';
  child = el.firstChild;
  el.innerHTML = '\x3cdiv\x3eb\x3c/div\x3e';
  return child.innerHTML !== 'a';
}}, {name:'IncludePaddingInWidthCalculation', ready:true, fn:function(doc, div) {
  return div.childNodes[1].firstChild.offsetWidth === 210;
}}, {name:'IncludePaddingInHeightCalculation', ready:true, fn:function(doc, div) {
  return div.childNodes[1].firstChild.offsetHeight === 210;
}}, {name:'TextAreaMaxLength', fn:function(doc) {
  return 'maxlength' in doc.createElement('textarea');
}}, {name:'GetPositionPercentage', ready:true, fn:function(doc, div) {
  return Ext.feature.getStyle(div.childNodes[2], 'left') === '10%';
}}, {name:'PercentageHeightOverflowBug', ready:true, fn:function(doc) {
  var hasBug = false, style, el;
  if (Ext.getScrollbarSize().height) {
    el = this.getTestElement('div', true);
    style = el.style;
    style.height = '50px';
    style.width = '50px';
    style.overflow = 'auto';
    style.position = 'absolute';
    el.innerHTML = ['\x3cdiv style\x3d"display:table;height:100%;"\x3e', '\x3cdiv style\x3d"width:51px;"\x3e\x3c/div\x3e', '\x3c/div\x3e'].join('');
    doc.body.appendChild(el);
    if (el.firstChild.offsetHeight === 50) {
      hasBug = true;
    }
    doc.body.removeChild(el);
  }
  return hasBug;
}}, {name:'xOriginBug', ready:true, fn:function(doc, div) {
  div.innerHTML = '\x3cdiv id\x3d"b1" style\x3d"height:100px;width:100px;direction:rtl;position:relative;overflow:scroll"\x3e' + '\x3cdiv id\x3d"b2" style\x3d"position:relative;width:100%;height:20px;"\x3e\x3c/div\x3e' + '\x3cdiv id\x3d"b3" style\x3d"position:absolute;width:20px;height:20px;top:0px;right:0px"\x3e\x3c/div\x3e' + '\x3c/div\x3e';
  var outerBox = document.getElementById('b1').getBoundingClientRect(), b2 = document.getElementById('b2').getBoundingClientRect(), b3 = document.getElementById('b3').getBoundingClientRect();
  return b2.left !== outerBox.left && b3.right !== outerBox.right;
}}, {name:'ScrollWidthInlinePaddingBug', ready:true, fn:function(doc) {
  var hasBug = false, style, el;
  el = doc.createElement('div');
  style = el.style;
  style.height = '50px';
  style.width = '50px';
  style.padding = '10px';
  style.overflow = 'hidden';
  style.position = 'absolute';
  el.innerHTML = '\x3cspan style\x3d"display:inline-block;zoom:1;height:60px;width:60px;"\x3e\x3c/span\x3e';
  doc.body.appendChild(el);
  if (el.scrollWidth === 70) {
    hasBug = true;
  }
  doc.body.removeChild(el);
  return hasBug;
}}, {name:'rtlVertScrollbarOnRight', ready:true, fn:function(doc, div) {
  div.innerHTML = '\x3cdiv style\x3d"height:100px;width:100px;direction:rtl;overflow:scroll"\x3e' + '\x3cdiv style\x3d"width:20px;height:200px;"\x3e\x3c/div\x3e' + '\x3c/div\x3e';
  var outerBox = div.firstChild, innerBox = outerBox.firstChild;
  return innerBox.offsetLeft + innerBox.offsetWidth !== outerBox.offsetLeft + outerBox.offsetWidth;
}}, {name:'rtlVertScrollbarOverflowBug', ready:true, fn:function(doc, div) {
  div.innerHTML = '\x3cdiv style\x3d"height:100px;width:100px;direction:rtl;overflow:auto"\x3e' + '\x3cdiv style\x3d"width:95px;height:200px;"\x3e\x3c/div\x3e' + '\x3c/div\x3e';
  var outerBox = div.firstChild, style = div.style, pos = style.position;
  style.position = 'absolute';
  outerBox.offsetHeight;
  style.position = pos;
  return outerBox.clientHeight === outerBox.offsetHeight;
}}, {identity:'defineProperty', fn:function() {
  if (Ext.isIE8m) {
    Ext.Object.defineProperty = Ext.emptyFn;
    return false;
  }
  return true;
}}, {identify:'nativeXhr', fn:function() {
  if (typeof XMLHttpRequest !== 'undefined') {
    return true;
  }
  XMLHttpRequest = function() {
    try {
      return new ActiveXObject('MSXML2.XMLHTTP.3.0');
    } catch (ex) {
      return null;
    }
  };
  return false;
}}, {name:'SpecialKeyDownRepeat', fn:function() {
  return Ext.isWebKit ? parseInt(navigator.userAgent.match(/AppleWebKit\/(\d+)/)[1], 10) >= 525 : !(!(Ext.isGecko || Ext.isIE || Ext.isEdge) || Ext.isOpera && Ext.operaVersion < 12);
}}, {name:'EmulatedMouseOver', fn:function() {
  return Ext.os.is.iOS;
}}, {name:'Hashchange', fn:function() {
  var docMode = document.documentMode;
  return 'onhashchange' in window && (docMode === undefined || docMode > 7);
}}, {name:'FixedTableWidthBug', ready:true, fn:function() {
  if (Ext.isIE8) {
    return false;
  }
  var outer = document.createElement('div'), inner = document.createElement('div'), width;
  outer.setAttribute('style', 'display:table;table-layout:fixed;');
  inner.setAttribute('style', 'display:table-cell;min-width:50px;');
  outer.appendChild(inner);
  document.body.appendChild(outer);
  outer.offsetWidth;
  outer.style.width = '25px';
  width = outer.offsetWidth;
  document.body.removeChild(outer);
  return width === 50;
}}, {name:'FocusinFocusoutEvents', fn:function() {
  return !(Ext.isGecko && Ext.firefoxVersion < 52);
}}, {name:'AsyncFocusEvents', fn:function() {
  return Ext.asyncFocus = !!Ext.isIE;
}}, {name:'accessibility', ready:true, fn:function(doc) {
  var body = doc.body, div, img, style, supports, bgImg;
  function getColor(colorTxt) {
    var values = [], colorValue = 0, regex, match;
    if (colorTxt.indexOf('rgb(') !== -1) {
      values = colorTxt.replace('rgb(', '').replace(')', '').split(', ');
    } else {
      if (colorTxt.indexOf('#') !== -1) {
        regex = colorTxt.length === 7 ? /^#(\S\S)(\S\S)(\S\S)$/ : /^#(\S)(\S)(\S)$/;
        match = colorTxt.match(regex);
        if (match) {
          values = ['0x' + match[1], '0x' + match[2], '0x' + match[3]];
        }
      }
    }
    for (var i = 0; i < values.length; i++) {
      colorValue += parseInt(values[i]);
    }
    return colorValue;
  }
  div = doc.createElement('div');
  img = doc.createElement('img');
  style = div.style;
  Ext.apply(style, {width:'2px', position:'absolute', clip:'rect(1px,1px,1px,1px)', borderWidth:'1px', borderStyle:'solid', borderTopTolor:'#f00', borderRightColor:'#ff0', backgroundColor:'#fff', backgroundImage:'url(' + Ext.BLANK_IMAGE_URL + ')'});
  img.alt = '';
  img.src = Ext.BLANK_IMAGE_URL;
  div.appendChild(img);
  body.appendChild(div);
  style = div.currentStyle || div.style;
  bgImg = style.backgroundImage;
  supports = {Images:img.offsetWidth === 1 && img.readyState !== 'uninitialized', BackgroundImages:!(bgImg !== null && (bgImg === 'none' || bgImg === 'url(invalid-url:)')), BorderColors:style.borderTopColor !== style.borderRightColor, LightOnDark:getColor(style.color) - getColor(style.backgroundColor) > 0};
  Ext.supports.HighContrastMode = !supports.BackgroundImages;
  body.removeChild(div);
  div = img = null;
  return supports;
}}, {name:'ViewportUnits', ready:true, fn:function(doc) {
  if (Ext.isIE8) {
    return false;
  }
  var body = doc.body, div = document.createElement('div'), style = div.currentStyle || div.style, width, divWidth;
  body.appendChild(div);
  Ext.apply(style, {width:'50vw'});
  width = parseInt(window.innerWidth / 2, 10);
  divWidth = parseInt((window.getComputedStyle ? getComputedStyle(div, null) : div.currentStyle).width, 10);
  body.removeChild(div);
  div = null;
  return width === divWidth;
}}, {name:'CSSVariables', ready:false, fn:function() {
  if (!window.getComputedStyle) {
    return false;
  }
  return window.CSS && window.CSS.supports && window.CSS.supports('--test-var', 0);
}}, {name:'Selectors2', ready:false, fn:function(doc) {
  try {
    return !!doc.querySelectorAll(':scope');
  } catch (e$5) {
    return false;
  }
}}, {name:'CSSScrollSnap', ready:false, fn:function(doc) {
  var style = doc.documentElement.style;
  return 'scrollSnapType' in style || 'webkitScrollSnapType' in style || 'msScrollSnapType' in style;
}}, {name:'TranslateYCausesHorizontalScroll', ready:true, fn:function(doc, div) {
  div.innerHTML = '\x3cdiv style\x3d"position: relative; overflow: auto; height: 200px; width: 200px;"\x3e' + '\x3cdiv\x3e' + '\x3cdiv style\x3d"transform: translateY(260px); width: 50px;"\x3ea\x3c/div\x3e' + '\x3c/div\x3e' + '\x3c/div\x3e';
  return div.firstChild.scrollWidth > div.firstChild.clientWidth;
}}, {name:'FlexBoxBasisBug', ready:true, fn:function() {
  if (Ext.isIE11 || Ext.os.is.iOS && Ext.os.version.major <= 10 || Ext.isSafari && Ext.browser.version.isLessThan(11) || Ext.os.is.Android && Ext.os.version.isLessThan(6)) {
    return true;
  }
  return false;
}}, {name:'PercentageSizeFlexBug', ready:true, fn:function(doc, div) {
  if (Ext.isIE9m) {
    return false;
  }
  var style = div.style;
  style.display = 'flex';
  style.flexDirection = 'column';
  style.height = style.width = '100px';
  div.innerHTML = '\x3cdiv style\x3d"flex: 1 1;"\x3e\x3cdiv style\x3d"height:50%"\x3e\x3c/div\x3e\x3c/div\x3e';
  return div.firstChild.firstChild.offsetHeight !== 50;
}}, {name:'CannotScrollExactHeight', fn:function() {
  return Ext.isIE10p;
}}, {name:'WebKitInputTableBoxModelBug', ready:true, fn:function(doc, div) {
  var table = document.createElement('div'), cell = document.createElement('div'), input = document.createElement('input'), tableStyle = table.style, cellStyle = cell.style, inputStyle = input.style, body = doc.body, hasBug;
  input.type = 'text';
  tableStyle.display = 'table';
  tableStyle.height = '100px';
  cellStyle.display = 'table-cell';
  inputStyle.border = '0';
  inputStyle.padding = '10px';
  inputStyle.boxSizing = 'border-box';
  inputStyle.height = '100%';
  cell.appendChild(input);
  table.appendChild(cell);
  body.appendChild(table);
  hasBug = input.offsetHeight === 80;
  body.removeChild(table);
  return hasBug;
}}, {name:'PassiveEventListener', fn:function(doc, div) {
  var supportsPassive = false, options;
  try {
    options = Object.defineProperty({}, 'passive', {get:function() {
      supportsPassive = true;
    }});
    window.addEventListener('e', null, options);
    window.removeEventListener('e', null, options);
  } catch (e$6) {
  }
  return supportsPassive;
}}, {name:'CSSMinContent', ready:true, fn:function(doc, div) {
  div.innerHTML = '\x3cdiv style\x3d"height:4px;width:4px;min-height:-webkit-min-content;min-height:-moz-min-content;min-height:min-content"\x3e\x3cdiv style\x3d"height:8px;width:8px"\x3e\x3c/div\x3e\x3c/div\x3e';
  return div.firstChild.offsetHeight === 8;
}}, {name:'ComputedSizeIncludesPadding', ready:true, fn:function(doc, div) {
  var ret = false, bd = document.body, el, w;
  if (window.getComputedStyle) {
    el = document.createElement('div');
    el.style.cssText = 'width:10px;padding:2px;' + '-webkit-box-sizing:border-box;box-sizing:border-box;';
    bd.appendChild(el);
    w = window.getComputedStyle(el, null).width;
    ret = w === '10px';
    bd.removeChild(el);
  }
  return ret;
}}, 0]};
Ext.feature.tests.pop();
Ext.supports = {};
Ext.feature.detect();
Ext.env.Ready = {blocks:(location.search || '').indexOf('ext-pauseReadyFire') > 0 ? 1 : 0, bound:0, delay:1, events:[], firing:false, generation:0, listeners:[], nextId:0, sortGeneration:0, state:0, timer:null, bind:function() {
  var me = Ext.env.Ready, doc = document;
  if (!me.bound) {
    if (doc.readyState === 'complete') {
      me.onReadyEvent({type:doc.readyState || 'body'});
    } else {
      me.bound = 1;
      if (Ext.browser.is.PhoneGap && !Ext.os.is.Desktop) {
        me.bound = 2;
        doc.addEventListener('deviceready', me.onReadyEvent, false);
      }
      doc.addEventListener('DOMContentLoaded', me.onReadyEvent, false);
      window.addEventListener('load', me.onReadyEvent, false);
    }
  }
}, block:function() {
  ++this.blocks;
  Ext.isReady = false;
}, fireReady:function() {
  var me = Ext.env.Ready;
  if (!me.state) {
    Ext._readyTime = Ext.ticks();
    Ext.isDomReady = true;
    me.state = 1;
    Ext.feature.detect(true);
    if (!me.delay) {
      me.handleReady();
    } else {
      if (navigator.standalone) {
        me.timer = Ext.defer(function() {
          me.timer = null;
          me.handleReadySoon();
        }, 1);
      } else {
        me.handleReadySoon();
      }
    }
  }
}, handleReady:function() {
  var me = this;
  if (me.state === 1) {
    me.state = 2;
    Ext._beforeReadyTime = Ext.ticks();
    me.invokeAll();
    Ext._afterReadyTime = Ext.ticks();
  }
}, handleReadySoon:function(delay) {
  var me = this;
  if (!me.timer) {
    me.timer = Ext.defer(function() {
      me.timer = null;
      me.handleReady();
    }, delay || me.delay);
  }
}, invoke:function(listener) {
  var delay = listener.delay;
  if (delay) {
    Ext.defer(listener.fn, delay, listener.scope);
  } else {
    if (Ext.elevateFunction) {
      Ext.elevateFunction(listener.fn, listener.scope);
    } else {
      listener.fn.call(listener.scope);
    }
  }
}, invokeAll:function() {
  if (Ext.elevateFunction) {
    Ext.elevateFunction(this.doInvokeAll, this);
  } else {
    this.doInvokeAll();
  }
}, doInvokeAll:function() {
  var me = this, listeners = me.listeners, listener;
  if (!me.blocks) {
    Ext.isReady = true;
  }
  me.firing = true;
  while (listeners.length) {
    if (me.sortGeneration !== me.generation) {
      me.sortGeneration = me.generation;
      listeners.sort(me.sortFn);
    }
    listener = listeners.pop();
    if (me.blocks && !listener.dom) {
      listeners.push(listener);
      break;
    }
    me.invoke(listener);
  }
  me.firing = false;
}, makeListener:function(fn, scope, options) {
  var ret = {fn:fn, id:++this.nextId, scope:scope, dom:false, priority:0};
  if (options) {
    Ext.apply(ret, options);
  }
  ret.phase = ret.dom ? 0 : 1;
  return ret;
}, on:function(fn, scope, options) {
  var me = Ext.env.Ready, listener = me.makeListener(fn, scope, options);
  if (me.state === 2 && !me.firing && (listener.dom || !me.blocks)) {
    me.invoke(listener);
  } else {
    me.listeners.push(listener);
    ++me.generation;
    if (!me.bound) {
      me.bind();
    }
  }
}, onReadyEvent:function(ev) {
  var me = Ext.env.Ready;
  if (Ext.elevateFunction) {
    Ext.elevateFunction(me.doReadyEvent, me, arguments);
  } else {
    me.doReadyEvent(ev);
  }
}, doReadyEvent:function(ev) {
  var me = this;
  if (ev && ev.type) {
    me.events.push(ev);
  }
  if (me.bound > 0) {
    me.unbind();
    me.bound = -1;
  }
  if (!me.state) {
    me.fireReady();
  }
}, sortFn:function(a, b) {
  return -(a.phase - b.phase || b.priority - a.priority || a.id - b.id);
}, unblock:function() {
  var me = this;
  if (me.blocks) {
    if (!--me.blocks) {
      if (me.state === 2 && !me.firing) {
        me.invokeAll();
      }
    }
  }
}, unbind:function() {
  var me = this, doc = document;
  if (me.bound > 1) {
    doc.removeEventListener('deviceready', me.onReadyEvent, false);
  }
  doc.removeEventListener('DOMContentLoaded', me.onReadyEvent, false);
  window.removeEventListener('load', me.onReadyEvent, false);
}};
(function() {
  var Ready = Ext.env.Ready;
  if (Ext.isIE9m) {
    Ext.apply(Ready, {scrollTimer:null, readyStatesRe:/complete/i, pollScroll:function() {
      var scrollable = true;
      try {
        document.documentElement.doScroll('left');
      } catch (e$7) {
        scrollable = false;
      }
      if (scrollable && document.body) {
        Ready.onReadyEvent({type:'doScroll'});
      } else {
        Ready.scrollTimer = Ext.defer(Ready.pollScroll, 20);
      }
      return scrollable;
    }, bind:function() {
      if (Ready.bound) {
        return;
      }
      var doc = document, topContext;
      try {
        topContext = window.frameElement === undefined;
      } catch (e$8) {
      }
      if (!topContext || !doc.documentElement.doScroll) {
        Ready.pollScroll = Ext.emptyFn;
      } else {
        if (Ready.pollScroll()) {
          return;
        }
      }
      if (doc.readyState === 'complete') {
        Ready.onReadyEvent({type:'already ' + (doc.readyState || 'body')});
      } else {
        doc.attachEvent('onreadystatechange', Ready.onReadyStateChange);
        window.attachEvent('onload', Ready.onReadyEvent);
        Ready.bound = 1;
      }
    }, unbind:function() {
      document.detachEvent('onreadystatechange', Ready.onReadyStateChange);
      window.detachEvent('onload', Ready.onReadyEvent);
      if (Ext.isNumber(Ready.scrollTimer)) {
        Ext.undefer(Ready.scrollTimer);
        Ready.scrollTimer = null;
      }
    }, onReadyStateChange:function() {
      var state = document.readyState;
      if (Ready.readyStatesRe.test(state)) {
        Ready.onReadyEvent({type:state});
      }
    }});
  }
  Ext.onDocumentReady = function(fn, scope, options) {
    var opt = {dom:true};
    if (options) {
      Ext.apply(opt, options);
    }
    Ready.on(fn, scope, opt);
  };
  Ext.onReady = function(fn, scope, options) {
    Ready.on(fn, scope, options);
  };
  Ext.onInternalReady = function(fn, scope, options) {
    Ready.on(fn, scope, Ext.apply({priority:1000}, options));
  };
  Ready.bind();
})();
Ext.Loader = new function() {
  var Loader = this, Manager = Ext.ClassManager, Boot = Ext.Boot, Class = Ext.Class, Ready = Ext.env.Ready, alias = Ext.Function.alias, dependencyProperties = ['extend', 'mixins', 'requires'], isInHistory = {}, history = [], readyListeners = [], usedClasses = [], _requiresMap = {}, _config = {enabled:true, scriptChainDelay:false, disableCaching:true, disableCachingParam:'_dc', paths:Manager.paths, preserveScripts:true, scriptCharset:undefined}, delegatedConfigs = {disableCaching:true, disableCachingParam:true, 
  preserveScripts:true, scriptChainDelay:'loadDelay'};
  Ext.apply(Loader, {isInHistory:isInHistory, isLoading:false, history:history, config:_config, readyListeners:readyListeners, optionalRequires:usedClasses, requiresMap:_requiresMap, hasFileLoadError:false, scriptsLoading:0, classesLoading:{}, missingCount:0, missingQueue:{}, syncModeEnabled:false, init:function() {
    var scripts = document.getElementsByTagName('script'), src = scripts[scripts.length - 1].src, path = src.substring(0, src.lastIndexOf('/') + 1), meta = Ext._classPathMetadata, microloader = Ext.Microloader, manifest = Ext.manifest, loadOrder, classes, className, idx, baseUrl, loadlen, l, loadItem;
    if (src.indexOf('packages/core/src/') !== -1) {
      path = path + '../../';
    } else {
      if (src.indexOf('/core/src/class/') !== -1) {
        path = path + '../../../';
      }
    }
    if (!Manager.getPath('Ext')) {
      Manager.setPath('Ext', path + 'src');
    }
    if (meta) {
      Ext._classPathMetadata = null;
      Loader.addClassPathMappings(meta);
    }
    if (manifest) {
      loadOrder = manifest.loadOrder;
      baseUrl = Ext.Boot.baseUrl;
      if (loadOrder && manifest.bootRelative) {
        for (loadlen = loadOrder.length, l = 0; l < loadlen; l++) {
          loadItem = loadOrder[l];
          loadItem.path = baseUrl + loadItem.path;
          loadItem.canonicalPath = true;
        }
      }
    }
    if (microloader) {
      Ready.block();
      microloader.onMicroloaderReady(function() {
        Ready.unblock();
      });
    }
  }, setConfig:Ext.Function.flexSetter(function(name, value) {
    if (name === 'paths') {
      Loader.setPath(value);
    } else {
      _config[name] = value;
      var delegated = delegatedConfigs[name];
      if (delegated) {
        Boot.setConfig(delegated === true ? name : delegated, value);
      }
    }
    return Loader;
  }), getConfig:function(name) {
    return name ? _config[name] : _config;
  }, setPath:function() {
    Manager.setPath.apply(Manager, arguments);
    return Loader;
  }, addClassPathMappings:function(paths) {
    Manager.setPath(paths);
    return Loader;
  }, addBaseUrlClassPathMappings:function(pathConfig) {
    for (var name in pathConfig) {
      pathConfig[name] = Boot.baseUrl + pathConfig[name];
    }
    Ext.Loader.addClassPathMappings(pathConfig);
  }, getPath:function(className) {
    return Manager.getPath(className);
  }, require:function(expressions, fn, scope, excludes) {
    if (excludes) {
      return Loader.exclude(excludes).require(expressions, fn, scope);
    }
    var classNames = Manager.getNamesByExpression(expressions);
    return Loader.load(classNames, fn, scope);
  }, syncRequire:function() {
    var wasEnabled = Loader.syncModeEnabled;
    Loader.syncModeEnabled = true;
    var ret = Loader.require.apply(Loader, arguments);
    Loader.syncModeEnabled = wasEnabled;
    return ret;
  }, exclude:function(excludes) {
    var selector = Manager.select({require:function(classNames, fn, scope) {
      return Loader.load(classNames, fn, scope);
    }, syncRequire:function(classNames, fn, scope) {
      var wasEnabled = Loader.syncModeEnabled;
      Loader.syncModeEnabled = true;
      var ret = Loader.load(classNames, fn, scope);
      Loader.syncModeEnabled = wasEnabled;
      return ret;
    }});
    selector.exclude(excludes);
    return selector;
  }, load:function(classNames, callback, scope) {
    if (callback) {
      if (callback.length) {
        callback = Loader.makeLoadCallback(classNames, callback);
      }
      callback = callback.bind(scope || Ext.global);
    }
    var state = Manager.classState, missingClassNames = [], urls = [], urlByClass = {}, numClasses = classNames.length, url, className, i, numMissing;
    for (i = 0; i < numClasses; ++i) {
      className = Manager.resolveName(classNames[i]);
      if (!Manager.isCreated(className)) {
        missingClassNames.push(className);
        if (!state[className]) {
          urlByClass[className] = Loader.getPath(className);
          urls.push(urlByClass[className]);
        }
      }
    }
    numMissing = missingClassNames.length;
    if (numMissing) {
      Loader.missingCount += numMissing;
      Manager.onCreated(function() {
        if (callback) {
          Ext.callback(callback, scope, arguments);
        }
        Loader.checkReady();
      }, Loader, missingClassNames);
      if (!_config.enabled) {
        Ext.raise('Ext.Loader is not enabled, so dependencies cannot be resolved dynamically. ' + 'Missing required class' + (missingClassNames.length > 1 ? 'es' : '') + ': ' + missingClassNames.join(', '));
      }
      if (urls.length) {
        Loader.loadScripts({url:urls, _classNames:missingClassNames, _urlByClass:urlByClass});
      } else {
        Loader.checkReady();
      }
    } else {
      if (callback) {
        callback.call(scope);
      }
      Loader.checkReady();
    }
    if (Loader.syncModeEnabled) {
      if (numClasses === 1) {
        return Manager.get(classNames[0]);
      }
    }
    return Loader;
  }, makeLoadCallback:function(classNames, callback) {
    return function() {
      var classes = [], i = classNames.length;
      while (i-- > 0) {
        classes[i] = Manager.get(classNames[i]);
      }
      return callback.apply(this, classes);
    };
  }, onLoadFailure:function(request) {
    var options = this, entries = request.entries || [], onError = options.onError, error, entry, i;
    Loader.hasFileLoadError = true;
    --Loader.scriptsLoading;
    if (onError) {
      for (i = 0; i < entries.length; i++) {
        entry = entries[i];
        if (entry.error) {
          error = new Error('Failed to load: ' + entry.url);
          break;
        }
      }
      error = error || new Error('Failed to load');
      onError.call(options.userScope, options, error, request);
    } else {
      Ext.log.error('[Ext.Loader] Some requested files failed to load.');
    }
    Loader.checkReady();
  }, onLoadSuccess:function() {
    var options = this, onLoad = options.onLoad, classNames = options._classNames, urlByClass = options._urlByClass, state = Manager.classState, missingQueue = Loader.missingQueue, className, i, len;
    --Loader.scriptsLoading;
    if (onLoad) {
      onLoad.call(options.userScope, options);
    }
    for (i = 0, len = classNames.length; i < len; i++) {
      className = classNames[i];
      if (!state[className]) {
        missingQueue[className] = urlByClass[className];
      }
    }
    Loader.checkReady();
  }, reportMissingClasses:function() {
    if (!Loader.syncModeEnabled && !Loader.scriptsLoading && Loader.isLoading && !Loader.hasFileLoadError) {
      var missingQueue = Loader.missingQueue, missingClasses = [], missingPaths = [];
      for (var missingClassName in missingQueue) {
        missingClasses.push(missingClassName);
        missingPaths.push(missingQueue[missingClassName]);
      }
      if (missingClasses.length) {
        throw new Error('The following classes are not declared even if their files have been ' + "loaded: '" + missingClasses.join("', '") + "'. Please check the source code of their " + "corresponding files for possible typos: '" + missingPaths.join("', '"));
      }
    }
  }, onReady:function(fn, scope, withDomReady, options) {
    if (withDomReady) {
      Ready.on(fn, scope, options);
    } else {
      var listener = Ready.makeListener(fn, scope, options);
      if (Loader.isLoading) {
        readyListeners.push(listener);
      } else {
        Ready.invoke(listener);
      }
    }
  }, addUsedClasses:function(classes) {
    var cls, i, ln;
    if (classes) {
      classes = typeof classes === 'string' ? [classes] : classes;
      for (i = 0, ln = classes.length; i < ln; i++) {
        cls = classes[i];
        if (typeof cls === 'string' && !Ext.Array.contains(usedClasses, cls)) {
          usedClasses.push(cls);
        }
      }
    }
    return Loader;
  }, triggerReady:function() {
    var listener, refClasses = usedClasses;
    if (Loader.isLoading && refClasses.length) {
      usedClasses = [];
      Loader.require(refClasses);
    } else {
      Loader.isLoading = false;
      readyListeners.sort(Ready.sortFn);
      while (readyListeners.length && !Loader.isLoading) {
        listener = readyListeners.pop();
        Ready.invoke(listener);
      }
      Ready.unblock();
    }
  }, historyPush:function(className) {
    if (className && !isInHistory[className] && !Manager.overrideMap[className]) {
      isInHistory[className] = true;
      history.push(className);
    }
    return Loader;
  }, loadScripts:function(params) {
    var manifest = Ext.manifest, loadOrder = manifest && manifest.loadOrder, loadOrderMap = manifest && manifest.loadOrderMap, options;
    ++Loader.scriptsLoading;
    if (loadOrder && !loadOrderMap) {
      manifest.loadOrderMap = loadOrderMap = Boot.createLoadOrderMap(loadOrder);
    }
    Loader.checkReady();
    options = Ext.apply({loadOrder:loadOrder, loadOrderMap:loadOrderMap, charset:_config.scriptCharset, success:Loader.onLoadSuccess, failure:Loader.onLoadFailure, sync:Loader.syncModeEnabled, _classNames:[]}, params);
    options.userScope = options.scope;
    options.scope = options;
    Boot.load(options);
  }, loadScriptsSync:function(urls) {
    var syncwas = Loader.syncModeEnabled;
    Loader.syncModeEnabled = true;
    Loader.loadScripts({url:urls});
    Loader.syncModeEnabled = syncwas;
  }, loadScriptsSyncBasePrefix:function(urls) {
    var syncwas = Loader.syncModeEnabled;
    Loader.syncModeEnabled = true;
    Loader.loadScripts({url:urls, prependBaseUrl:true});
    Loader.syncModeEnabled = syncwas;
  }, loadScript:function(options) {
    var isString = typeof options === 'string', isArray = options instanceof Array, isObject = !isArray && !isString, url = isObject ? options.url : options, onError = isObject && options.onError, onLoad = isObject && options.onLoad, scope = isObject && options.scope, request = {url:url, scope:scope, onLoad:onLoad, onError:onError, _classNames:[]};
    Loader.loadScripts(request);
  }, checkMissingQueue:function() {
    var missingQueue = Loader.missingQueue, newQueue = {}, name, missing = 0;
    for (name in missingQueue) {
      if (!(Manager.classState[name] || Manager.isCreated(name))) {
        newQueue[name] = missingQueue[name];
        missing++;
      }
    }
    Loader.missingCount = missing;
    Loader.missingQueue = newQueue;
  }, checkReady:function() {
    var wasLoading = Loader.isLoading, isLoading;
    Loader.checkMissingQueue();
    isLoading = Loader.missingCount + Loader.scriptsLoading;
    if (isLoading && !wasLoading) {
      Ready.block();
      Loader.isLoading = !!isLoading;
    } else {
      if (!isLoading && wasLoading) {
        Loader.triggerReady();
      }
    }
    if (!Loader.scriptsLoading && Loader.missingCount) {
      Ext.defer(function() {
        if (!Loader.scriptsLoading && Loader.missingCount) {
          Ext.log.error('[Loader] The following classes failed to load:');
          for (var name in Loader.missingQueue) {
            Ext.log.error('[Loader] ' + name + ' from ' + Loader.missingQueue[name]);
          }
        }
      }, 1000);
    }
  }});
  Ext.require = alias(Loader, 'require');
  Ext.syncRequire = alias(Loader, 'syncRequire');
  Ext.exclude = alias(Loader, 'exclude');
  Class.registerPreprocessor('loader', function(cls, data, hooks, continueFn) {
    Ext.classSystemMonitor && Ext.classSystemMonitor(cls, 'Ext.Loader#loaderPreprocessor', arguments);
    var me = this, dependencies = [], dependency, className = Manager.getName(cls), i, j, ln, subLn, value, propertyName, propertyValue, requiredMap;
    for (i = 0, ln = dependencyProperties.length; i < ln; i++) {
      propertyName = dependencyProperties[i];
      if (data.hasOwnProperty(propertyName)) {
        propertyValue = data[propertyName];
        if (typeof propertyValue === 'string') {
          dependencies.push(propertyValue);
        } else {
          if (propertyValue instanceof Array) {
            for (j = 0, subLn = propertyValue.length; j < subLn; j++) {
              value = propertyValue[j];
              if (typeof value === 'string') {
                dependencies.push(value);
              }
            }
          } else {
            if (typeof propertyValue !== 'function') {
              for (j in propertyValue) {
                if (propertyValue.hasOwnProperty(j)) {
                  value = propertyValue[j];
                  if (typeof value === 'string') {
                    dependencies.push(value);
                  }
                }
              }
            }
          }
        }
      }
    }
    if (dependencies.length === 0) {
      return;
    }
    if (className) {
      _requiresMap[className] = dependencies;
    }
    var manifestClasses = Ext.manifest && Ext.manifest.classes, deadlockPath = [], detectDeadlock;
    if (className && (!manifestClasses || !manifestClasses[className])) {
      requiredMap = Loader.requiredByMap || (Loader.requiredByMap = {});
      for (i = 0, ln = dependencies.length; i < ln; i++) {
        dependency = dependencies[i];
        (requiredMap[dependency] || (requiredMap[dependency] = [])).push(className);
      }
      detectDeadlock = function(cls) {
        deadlockPath.push(cls);
        var requires = _requiresMap[cls], dep, i, ln;
        if (requires) {
          if (Ext.Array.contains(requires, className)) {
            Ext.Error.raise("Circular requirement detected! '" + className + "' and '" + deadlockPath[1] + "' mutually require each other. Path: " + deadlockPath.join(' -\x3e ') + ' -\x3e ' + deadlockPath[0]);
          }
          for (i = 0, ln = requires.length; i < ln; i++) {
            dep = requires[i];
            if (!isInHistory[dep]) {
              detectDeadlock(requires[i]);
            }
          }
        }
      };
      detectDeadlock(className);
    }
    (className ? Loader.exclude(className) : Loader).require(dependencies, function() {
      for (i = 0, ln = dependencyProperties.length; i < ln; i++) {
        propertyName = dependencyProperties[i];
        if (data.hasOwnProperty(propertyName)) {
          propertyValue = data[propertyName];
          if (typeof propertyValue === 'string') {
            data[propertyName] = Manager.get(propertyValue);
          } else {
            if (propertyValue instanceof Array) {
              for (j = 0, subLn = propertyValue.length; j < subLn; j++) {
                value = propertyValue[j];
                if (typeof value === 'string') {
                  data[propertyName][j] = Manager.get(value);
                }
              }
            } else {
              if (typeof propertyValue !== 'function') {
                for (var k in propertyValue) {
                  if (propertyValue.hasOwnProperty(k)) {
                    value = propertyValue[k];
                    if (typeof value === 'string') {
                      data[propertyName][k] = Manager.get(value);
                    }
                  }
                }
              }
            }
          }
        }
      }
      continueFn.call(me, cls, data, hooks);
    });
    return false;
  }, true, 'after', 'className');
  Manager.registerPostprocessor('uses', function(name, cls, data) {
    Ext.classSystemMonitor && Ext.classSystemMonitor(cls, 'Ext.Loader#usesPostprocessor', arguments);
    var uses = data.uses, classNames;
    if (uses) {
      classNames = Manager.getNamesByExpression(data.uses);
      Loader.addUsedClasses(classNames);
    }
  });
  Manager.onCreated(Loader.historyPush);
  Loader.init();
};
Ext._endTime = Ext.ticks();
if (Ext._beforereadyhandler) {
  Ext._beforereadyhandler();
}
Ext.define('Ext.Mixin', function(Mixin) {
  return {statics:{addHook:function(hookFn, targetClass, methodName, mixinClassPrototype) {
    var isFunc = Ext.isFunction(hookFn), hook = function() {
      var a = arguments, fn = isFunc ? hookFn : mixinClassPrototype[hookFn], result = this.callParent(a);
      fn.apply(this, a);
      return result;
    }, existingFn = targetClass.hasOwnProperty(methodName) && targetClass[methodName];
    if (isFunc) {
      hookFn.$previous = Ext.emptyFn;
    }
    hook.$name = methodName;
    hook.$owner = targetClass.self;
    if (existingFn) {
      hook.$previous = existingFn.$previous;
      existingFn.$previous = hook;
    } else {
      targetClass[methodName] = hook;
    }
  }}, onClassExtended:function(cls, data) {
    var mixinConfig = data.mixinConfig, hooks = data.xhooks, superclass = cls.superclass, onClassMixedIn = data.onClassMixedIn, parentMixinConfig, befores, afters, extended;
    if (hooks) {
      delete data.xhooks;
      (mixinConfig || (data.mixinConfig = mixinConfig = {})).on = hooks;
    }
    if (mixinConfig) {
      parentMixinConfig = superclass.mixinConfig;
      if (parentMixinConfig) {
        data.mixinConfig = mixinConfig = Ext.merge({}, parentMixinConfig, mixinConfig);
      }
      data.mixinId = mixinConfig.id;
      if (mixinConfig.beforeHooks) {
        Ext.raise('Use of "beforeHooks" is deprecated - use "before" instead');
      }
      if (mixinConfig.hooks) {
        Ext.raise('Use of "hooks" is deprecated - use "after" instead');
      }
      if (mixinConfig.afterHooks) {
        Ext.raise('Use of "afterHooks" is deprecated - use "after" instead');
      }
      befores = mixinConfig.before;
      afters = mixinConfig.after;
      hooks = mixinConfig.on;
      extended = mixinConfig.extended;
    }
    if (befores || afters || hooks || extended) {
      data.onClassMixedIn = function(targetClass) {
        var mixin = this.prototype, targetProto = targetClass.prototype, key;
        if (befores) {
          Ext.Object.each(befores, function(key, value) {
            targetClass.addMember(key, function() {
              if (mixin[value].apply(this, arguments) !== false) {
                return this.callParent(arguments);
              }
            });
          });
        }
        if (afters) {
          Ext.Object.each(afters, function(key, value) {
            targetClass.addMember(key, function() {
              var ret = this.callParent(arguments);
              mixin[value].apply(this, arguments);
              return ret;
            });
          });
        }
        if (hooks) {
          for (key in hooks) {
            Mixin.addHook(hooks[key], targetProto, key, mixin);
          }
        }
        if (extended) {
          targetClass.onExtended(function() {
            var args = Ext.Array.slice(arguments, 0);
            args.unshift(targetClass);
            return extended.apply(this, args);
          }, this);
        }
        if (onClassMixedIn) {
          onClassMixedIn.apply(this, arguments);
        }
      };
    }
  }};
});
Ext.util = Ext.util || {};
Ext.util.DelayedTask = function(fn, scope, args, cancelOnDelay, fireIdleEvent) {
  var me = this, delay, call = function() {
    me.id = null;
    if (!(scope && scope.destroyed)) {
      args ? fn.apply(scope, args) : fn.call(scope);
    }
    if (fireIdleEvent === false) {
      Ext._suppressIdle = true;
    }
  };
  if (fn) {
    call.$origFn = fn.$origFn || fn;
    call.$skipTimerCheck = call.$origFn.$skipTimerCheck;
  }
  cancelOnDelay = typeof cancelOnDelay === 'boolean' ? cancelOnDelay : true;
  me.id = null;
  me.delay = function(newDelay, newFn, newScope, newArgs) {
    if (cancelOnDelay) {
      me.cancel();
    }
    if (typeof newDelay === 'number') {
      delay = newDelay;
    }
    fn = newFn || fn;
    scope = newScope || scope;
    args = newArgs || args;
    me.delayTime = delay;
    if (fn) {
      call.$origFn = fn.$origFn || fn;
      call.$skipTimerCheck = call.$origFn.$skipTimerCheck;
    }
    if (!me.id) {
      if (delay === -1) {
        me.id = Ext.raf(call);
      } else {
        me.id = Ext.defer(call, delay || 1);
      }
    }
    return me.id;
  };
  me.cancel = function() {
    if (me.id) {
      if (me.delayTime === -1) {
        Ext.unraf(me.id);
      } else {
        Ext.undefer(me.id);
      }
      me.id = null;
    }
  };
  me.flush = function() {
    if (me.id) {
      me.cancel();
      var was = fireIdleEvent;
      fireIdleEvent = true;
      call();
      fireIdleEvent = was;
    }
  };
  me.stop = function(stopFn, stopScope) {
    if (stopFn && stopFn === fn && (!stopScope || stopScope === scope)) {
      me.cancel();
    }
  };
};
Ext.define('Ext.util.Event', function() {
  var arraySlice = Array.prototype.slice, arrayInsert = Ext.Array.insert, toArray = Ext.Array.toArray, fireArgs = {};
  return {isEvent:true, suspended:0, noOptions:{}, constructor:function(observable, name) {
    this.name = name;
    this.observable = observable;
    this.listeners = [];
  }, addListener:function(fn, scope, options, caller, manager) {
    var me = this, added = false, observable = me.observable, eventName = me.name, listeners, listener, priority, isNegativePriority, highestNegativePriorityIndex, hasNegativePriorityIndex, length, index, i, listenerPriority, managedListeners;
    if (scope && !Ext._namedScopes[scope] && typeof fn === 'string' && typeof scope[fn] !== 'function') {
      Ext.raise("No method named '" + fn + "' found on scope object");
    }
    if (me.findListener(fn, scope) === -1) {
      listener = me.createListener(fn, scope, options, caller, manager);
      if (me.firing) {
        me.listeners = me.listeners.slice(0);
      }
      listeners = me.listeners;
      index = length = listeners.length;
      priority = options && options.priority;
      highestNegativePriorityIndex = me._highestNegativePriorityIndex;
      hasNegativePriorityIndex = highestNegativePriorityIndex !== undefined;
      if (priority) {
        isNegativePriority = priority < 0;
        if (!isNegativePriority || hasNegativePriorityIndex) {
          for (i = isNegativePriority ? highestNegativePriorityIndex : 0; i < length; i++) {
            listenerPriority = listeners[i].o ? listeners[i].o.priority || 0 : 0;
            if (listenerPriority < priority) {
              index = i;
              break;
            }
          }
        } else {
          me._highestNegativePriorityIndex = index;
        }
      } else {
        if (hasNegativePriorityIndex) {
          index = highestNegativePriorityIndex;
        }
      }
      if (!isNegativePriority && index <= highestNegativePriorityIndex) {
        me._highestNegativePriorityIndex++;
      }
      if (index === length) {
        listeners[length] = listener;
      } else {
        arrayInsert(listeners, index, [listener]);
      }
      if (observable.isElement) {
        observable._getPublisher(eventName, options.translate === false).subscribe(observable, eventName, options.delegated !== false, options.capture);
      }
      if (manager) {
        managedListeners = manager.managedListeners || (manager.managedListeners = []);
        managedListeners.push({item:me.observable, ename:options && options.managedName || me.name, fn:fn, scope:scope, options:options});
      }
      added = true;
    }
    return added;
  }, createListener:function(fn, scope, o, caller, manager) {
    var me = this, namedScope = Ext._namedScopes[scope], listener = {fn:fn, scope:scope, ev:me, caller:caller, manager:manager, namedScope:namedScope, defaultScope:namedScope ? scope || me.observable : undefined, lateBound:typeof fn === 'string'}, handler = fn, wrapped = false, type;
    if (o) {
      listener.o = o;
      if (o.single) {
        handler = me.createSingle(handler, listener, o, scope);
        wrapped = true;
      }
      if (o.target) {
        handler = me.createTargeted(handler, listener, o, scope, wrapped);
        wrapped = true;
      }
      if (o.onFrame) {
        handler = me.createAnimFrame(handler, listener, o, scope, wrapped);
        wrapped = true;
      }
      if (o.delay) {
        handler = me.createDelayed(handler, listener, o, scope, wrapped);
        wrapped = true;
      }
      if (o.buffer) {
        handler = me.createBuffered(handler, listener, o, scope, wrapped);
        wrapped = true;
      }
      if (me.observable.isElement) {
        type = o.type;
        if (type) {
          listener.type = type;
        }
      }
    }
    listener.fireFn = handler;
    listener.wrapped = wrapped;
    return listener;
  }, findListener:function(fn, scope) {
    var listeners = this.listeners, i = listeners.length, listener;
    while (i--) {
      listener = listeners[i];
      if (listener) {
        if (listener.fn === fn && listener.scope == scope) {
          return i;
        }
      }
    }
    return -1;
  }, removeListener:function(fn, scope, index) {
    var me = this, removed = false, observable = me.observable, eventName = me.name, listener, options, manager, managedListeners, managedListener, i;
    index = index != null ? index : me.findListener(fn, scope);
    if (index !== -1) {
      listener = me.listeners[index];
      if (me.firing) {
        me.listeners = me.listeners.slice(0);
      }
      me.listeners.splice(index, 1);
      if (me._highestNegativePriorityIndex) {
        if (index < me._highestNegativePriorityIndex) {
          me._highestNegativePriorityIndex--;
        } else {
          if (index === me._highestNegativePriorityIndex && index === me.listeners.length) {
            delete me._highestNegativePriorityIndex;
          }
        }
      }
      if (listener) {
        options = listener.o;
        if (listener.task) {
          listener.task.cancel();
          delete listener.task;
        }
        i = listener.tasks && listener.tasks.length;
        if (i) {
          while (i--) {
            listener.tasks[i].cancel();
          }
          delete listener.tasks;
        }
        listener.fireFn.timerId = Ext.undefer(listener.fireFn.timerId);
        manager = listener.manager;
        if (manager) {
          managedListeners = manager.managedListeners;
          if (managedListeners) {
            for (i = managedListeners.length; i--;) {
              managedListener = managedListeners[i];
              if (managedListener.item === me.observable && managedListener.ename === eventName && managedListener.fn === fn && managedListener.scope === scope) {
                managedListeners.splice(i, 1);
              }
            }
          }
        }
        if (observable.isElement) {
          observable._getPublisher(eventName, options.translate === false).unsubscribe(observable, eventName, options.delegated !== false, options.capture);
        }
      }
      removed = true;
    }
    return removed;
  }, clearListeners:function() {
    var listeners = this.listeners, i = listeners.length, listener;
    while (i--) {
      listener = listeners[i];
      this.removeListener(listener.fn, listener.scope);
    }
  }, suspend:function() {
    ++this.suspended;
  }, resume:function() {
    if (this.suspended) {
      --this.suspended;
    }
  }, isSuspended:function() {
    return this.suspended > 0;
  }, fireDelegated:function(firingObservable, args) {
    this.firingObservable = firingObservable;
    return this.fire.apply(this, args);
  }, fire:function() {
    var me = this, CQ = Ext.ComponentQuery, listeners = me.listeners, count = listeners.length, observable = me.observable, isElement = observable.isElement, isComponent = observable.isComponent, firingObservable = me.firingObservable, options, delegate, fireInfo, i, args, listener, len, delegateEl, currentTarget, type, chained, firingArgs, e, fireFn, fireScope;
    if (!me.suspended && count > 0) {
      me.firing = true;
      args = arguments.length ? arraySlice.call(arguments, 0) : [];
      len = args.length;
      if (isElement) {
        e = args[0];
      }
      for (i = 0; i < count; i++) {
        listener = listeners[i];
        if (!listener) {
          continue;
        }
        options = listener.o;
        if (isElement) {
          if (currentTarget) {
            e.setCurrentTarget(currentTarget);
          }
          type = listener.type;
          if (type) {
            chained = e;
            e = args[0] = chained.chain({type:type, isGesture:false});
          }
          Ext.EventObject = e;
        }
        firingArgs = args;
        if (options) {
          delegate = options.delegate;
          if (delegate) {
            if (isElement) {
              delegateEl = e.getTarget(typeof delegate === 'function' ? delegate : '#' + e.currentTarget.id + ' ' + delegate);
              if (delegateEl) {
                args[1] = delegateEl;
                currentTarget = e.currentTarget;
                e.setCurrentTarget(delegateEl);
              } else {
                continue;
              }
            } else {
              if (isComponent && !CQ.is(firingObservable, delegate, observable)) {
                continue;
              }
            }
          }
          if (isElement) {
            if (options.preventDefault) {
              e.preventDefault();
            }
            if (options.stopPropagation) {
              e.stopPropagation();
            }
            if (options.stopEvent) {
              e.stopEvent();
            }
          }
          args[len] = options;
          if (options.args) {
            firingArgs = options.args.concat(args);
          }
        }
        fireInfo = me.getFireInfo(listener);
        fireFn = fireInfo.fn;
        fireScope = fireInfo.scope;
        fireInfo.fn = fireInfo.scope = null;
        if (fireScope && fireScope.destroyed) {
          me.removeListener(fireFn, fireScope, i);
          fireFn = null;
          if (fireScope.$className !== 'Ext.container.Monitor') {
            (Ext.raiseOnDestroyed ? Ext.raise : Ext.log.warn)({msg:'Attempting to fire "' + me.name + '" event on destroyed ' + (fireScope.$className || 'object') + ' instance with id: ' + (fireScope.id || 'unknown'), instance:fireScope});
          }
        }
        if (fireFn && fireFn.apply(fireScope, firingArgs) === false) {
          Ext.EventObject = null;
          return me.firing = false;
        }
        if (options) {
          args.length--;
        }
        if (chained) {
          e = args[0] = chained;
          chained = null;
        }
        Ext.EventObject = null;
      }
    }
    me.firing = false;
    return true;
  }, getFireInfo:function(listener, fromWrapped) {
    var observable = this.observable, fireFn = listener.fireFn, scope = listener.scope, namedScope = listener.namedScope, fn;
    if (!fromWrapped && listener.wrapped) {
      fireArgs.fn = fireFn;
      return fireArgs;
    }
    fn = fromWrapped ? listener.fn : fireFn;
    var name = fn;
    if (listener.lateBound) {
      if (!scope || namedScope) {
        scope = (listener.caller || observable).resolveListenerScope(listener.defaultScope);
      }
      if (!scope) {
        Ext.raise('Unable to dynamically resolve scope for "' + listener.ev.name + '" listener on ' + this.observable.id);
      }
      if (!Ext.isFunction(scope[fn])) {
        Ext.raise('No method named "' + fn + '" on ' + (scope.$className || 'scope object.'));
      }
      fn = scope[fn];
    } else {
      if (namedScope && namedScope.isController) {
        scope = (listener.caller || observable).resolveListenerScope(listener.defaultScope);
        if (!scope) {
          Ext.raise('Unable to dynamically resolve scope for "' + listener.ev.name + '" listener on ' + this.observable.id);
        }
      } else {
        if (!scope || namedScope) {
          scope = observable;
        }
      }
    }
    fireArgs.fn = fn;
    fireArgs.scope = scope;
    if (!fn) {
      Ext.raise('Unable to dynamically resolve method "' + name + '" on ' + this.observable.$className);
    }
    return fireArgs;
  }, createAnimFrame:function(handler, listener, o, scope, wrapped) {
    var fireInfo;
    if (!wrapped) {
      fireInfo = listener.ev.getFireInfo(listener, true);
      handler = fireInfo.fn;
      scope = fireInfo.scope;
      fireInfo.fn = fireInfo.scope = null;
    }
    return Ext.Function.createAnimationFrame(handler, scope, o.args);
  }, createTargeted:function(handler, listener, o, scope, wrapped) {
    return function() {
      if (o.target === arguments[0]) {
        var fireInfo;
        if (!wrapped) {
          fireInfo = listener.ev.getFireInfo(listener, true);
          handler = fireInfo.fn;
          scope = fireInfo.scope;
          fireInfo.fn = fireInfo.scope = null;
        }
        return handler.apply(scope, arguments);
      }
    };
  }, createBuffered:function(handler, listener, o, scope, wrapped) {
    listener.task = new Ext.util.DelayedTask;
    return function() {
      if (listener.task) {
        var fireInfo;
        if (Ext.Timer.track) {
          o.$delayedTask = listener.task;
        }
        if (!wrapped) {
          fireInfo = listener.ev.getFireInfo(listener, true);
          handler = fireInfo.fn;
          scope = fireInfo.scope;
          fireInfo.fn = fireInfo.scope = null;
        }
        listener.task.delay(o.buffer, handler, scope, toArray(arguments));
      }
    };
  }, createDelayed:function(handler, listener, o, scope, wrapped) {
    return function() {
      var task = new Ext.util.DelayedTask, fireInfo;
      if (!wrapped) {
        fireInfo = listener.ev.getFireInfo(listener, true);
        handler = fireInfo.fn;
        scope = fireInfo.scope;
        fireInfo.fn = fireInfo.scope = null;
      }
      if (!listener.tasks) {
        listener.tasks = [];
      }
      listener.tasks.push(task);
      if (Ext.Timer.track) {
        o.$delayedTask = task;
      }
      task.delay(o.delay || 10, handler, scope, toArray(arguments));
    };
  }, createSingle:function(handler, listener, o, scope, wrapped) {
    return function() {
      var event = listener.ev, observable = event.observable, fn = listener.fn, fireInfo;
      if (observable) {
        if (!observable.destroyed) {
          observable.removeListener(event.name, fn, scope);
        }
      } else {
        event.removeListener(fn, scope);
      }
      if (!wrapped) {
        fireInfo = event.getFireInfo(listener, true);
        handler = fireInfo.fn;
        scope = fireInfo.scope;
        fireInfo.fn = fireInfo.scope = null;
      }
      return handler.apply(scope, arguments);
    };
  }};
});
Ext.define('Ext.mixin.Identifiable', {statics:{uniqueIds:{}}, isIdentifiable:true, mixinId:'identifiable', idCleanRegex:/\.|[^\w\-]/g, defaultIdPrefix:'ext-', defaultIdSeparator:'-', getOptimizedId:function() {
  return this.id;
}, getUniqueId:function() {
  var id = this.id, prototype, separator, xtype, uniqueIds, prefix;
  if (!(id || id === 0)) {
    prototype = this.self.prototype;
    separator = this.defaultIdSeparator;
    uniqueIds = Ext.mixin.Identifiable.uniqueIds;
    if (!prototype.hasOwnProperty('identifiablePrefix')) {
      xtype = this.xtype;
      if (xtype) {
        prefix = this.defaultIdPrefix + xtype.replace(this.idCleanRegex, separator) + separator;
      } else {
        if (!(prefix = prototype.$className)) {
          prefix = this.defaultIdPrefix + 'anonymous' + separator;
        } else {
          prefix = prefix.replace(this.idCleanRegex, separator).toLowerCase() + separator;
        }
      }
      prototype.identifiablePrefix = prefix;
    }
    prefix = this.identifiablePrefix;
    if (!uniqueIds.hasOwnProperty(prefix)) {
      uniqueIds[prefix] = 0;
    }
    id = this.id = this.id = prefix + ++uniqueIds[prefix];
  }
  this.getUniqueId = this.getOptimizedId;
  return id;
}, setId:function(id) {
  this.id = this.id = id;
}, getId:function() {
  var id = this.id;
  if (!id) {
    id = this.getUniqueId();
  }
  this.getId = this.getOptimizedId;
  return id;
}});
Ext.define('Ext.mixin.Observable', function(Observable) {
  var emptyFn = Ext.emptyFn, emptyArray = [], arrayProto = Array.prototype, arraySlice = arrayProto.slice, ListenerRemover = function(observable) {
    if (observable instanceof ListenerRemover) {
      return observable;
    }
    this.observable = observable;
    if (arguments[1].isObservable) {
      this.managedListeners = true;
    }
    this.args = arraySlice.call(arguments, 1);
  }, protectedProps = ['events', 'hasListeners', 'managedListeners', 'eventedBeforeEventNames'];
  ListenerRemover.prototype.destroy = function() {
    var me = this, args = me.args, observable = me.observable, elementName = args[0].element || args[3] && args[3].element;
    if (elementName) {
      if (Ext.Array.indexOf(observable.referenceList, elementName) === -1) {
        Ext.Logger.error("Destroying event listener with an invalid element reference of '" + elementName + "' for this component. Available values are: '" + observable.referenceList.join("', '") + "'", observable);
      }
      observable = observable[elementName];
    }
    if (!observable.destroyed) {
      observable[me.managedListeners ? 'mun' : 'un'].apply(observable, me.args);
    }
    me.destroy = Ext.emptyFn;
  };
  return {extend:Ext.Mixin, mixinConfig:{id:'observable', after:{destroy:'destroyObservable'}}, mixins:[Ext.mixin.Identifiable], statics:{releaseCapture:function(o) {
    o.fireEventArgs = this.prototype.fireEventArgs;
  }, capture:function(o, fn, scope) {
    var newFn = function(eventName, args) {
      return fn.apply(scope, [eventName].concat(args));
    };
    this.captureArgs(o, newFn, scope);
  }, captureArgs:function(o, fn, scope) {
    o.fireEventArgs = Ext.Function.createInterceptor(o.fireEventArgs, fn, scope);
  }, observe:function(cls, listeners) {
    if (cls) {
      if (!cls.isObservable) {
        Ext.applyIf(cls, new this);
        this.captureArgs(cls.prototype, cls.fireEventArgs, cls);
      }
      if (Ext.isObject(listeners)) {
        cls.on(listeners);
      }
    }
    return cls;
  }, prepareClass:function(T, mixin, data) {
    var listeners = T.listeners = [], target = data || T.prototype, targetListeners = target.listeners, superListeners = mixin ? mixin.listeners : T.superclass.self.listeners, name, scope, namedScope, i, len;
    if (superListeners) {
      listeners.push(superListeners);
    }
    if (targetListeners) {
      scope = targetListeners.scope;
      if (!scope) {
        targetListeners.scope = 'self';
      } else {
        namedScope = Ext._namedScopes[scope];
        if (namedScope && namedScope.isController) {
          targetListeners.scope = 'self.controller';
        }
      }
      listeners.push(targetListeners);
      target.listeners = null;
    }
    if (!T.HasListeners) {
      var HasListeners = function() {
      }, SuperHL = T.superclass.HasListeners || mixin && mixin.HasListeners || Observable.HasListeners;
      T.prototype.HasListeners = T.HasListeners = HasListeners;
      HasListeners.prototype = T.hasListeners = new SuperHL;
    }
    scope = T.prototype.$noClearOnDestroy || {};
    for (i = 0, len = protectedProps.length; i < len; i++) {
      scope[protectedProps[i]] = true;
    }
    T.prototype.$noClearOnDestroy = scope;
  }}, isObservable:true, $vetoClearingPrototypeOnDestroy:true, eventsSuspended:0, constructor:function(config) {
    var me = this, self = me.self, declaredListeners, listeners, bubbleEvents, len, i;
    if (me.$observableInitialized) {
      return;
    }
    me.$observableInitialized = true;
    me.hasListeners = me.hasListeners = new me.HasListeners;
    me.eventedBeforeEventNames = {};
    me.events = me.events || {};
    declaredListeners = self.listeners;
    if (declaredListeners && !me._addDeclaredListeners(declaredListeners)) {
      self.listeners = null;
    }
    listeners = config && config.listeners || me.listeners;
    if (listeners) {
      if (listeners instanceof Array) {
        for (i = 0, len = listeners.length; i < len; ++i) {
          me.addListener(listeners[i]);
        }
      } else {
        me.addListener(listeners);
      }
    }
    bubbleEvents = config && config.bubbleEvents || me.bubbleEvents;
    if (bubbleEvents) {
      me.enableBubble(bubbleEvents);
    }
    if (me.$applyConfigs) {
      if (config) {
        Ext.apply(me, config);
      }
    } else {
      me.initConfig(config);
    }
    if (listeners) {
      me.listeners = null;
    }
  }, onClassExtended:function(T, data) {
    if (!T.HasListeners) {
      Observable.prepareClass(T, T.prototype.$observableMixedIn ? undefined : data);
    }
  }, $eventOptions:{scope:1, delay:1, buffer:1, onFrame:1, single:1, args:1, destroyable:1, priority:1, order:1}, $orderToPriority:{before:100, current:0, after:-100}, _addDeclaredListeners:function(listeners) {
    var me = this;
    if (listeners instanceof Array) {
      Ext.each(listeners, me._addDeclaredListeners, me);
    } else {
      me._addedDeclaredListeners = true;
      me.addListener(listeners);
    }
    return me._addedDeclaredListeners;
  }, addManagedListener:function(item, ename, fn, scope, options, noDestroy) {
    var me = this, managedListeners = me.managedListeners = me.managedListeners || [], config, passedOptions;
    if (typeof ename !== 'string') {
      passedOptions = arguments.length > 4 ? options : ename;
      options = ename;
      for (ename in options) {
        if (options.hasOwnProperty(ename)) {
          config = options[ename];
          if (!item.$eventOptions[ename]) {
            me.addManagedListener(item, ename, config.fn || config, config.scope || options.scope || scope, config.fn ? config : passedOptions, true);
          }
        }
      }
      if (options && options.destroyable) {
        return new ListenerRemover(me, item, options);
      }
    } else {
      if (fn !== emptyFn) {
        item.doAddListener(ename, fn, scope, options, null, me, me);
        if (!noDestroy && options && options.destroyable) {
          return new ListenerRemover(me, item, ename, fn, scope);
        }
      }
    }
  }, removeManagedListener:function(item, ename, fn, scope) {
    var me = this, options, config, managedListeners, length, i;
    if (item.$observableDestroyed) {
      return;
    }
    if (typeof ename !== 'string') {
      options = ename;
      for (ename in options) {
        if (options.hasOwnProperty(ename)) {
          config = options[ename];
          if (!item.$eventOptions[ename]) {
            me.removeManagedListener(item, ename, config.fn || config, config.scope || options.scope || scope);
          }
        }
      }
    } else {
      managedListeners = me.managedListeners ? me.managedListeners.slice() : [];
      ename = Ext.canonicalEventName(ename);
      for (i = 0, length = managedListeners.length; i < length; i++) {
        me.removeManagedListenerItem(false, managedListeners[i], item, ename, fn, scope);
      }
    }
  }, fireEvent:function(eventName) {
    return this.fireEventArgs(eventName, arraySlice.call(arguments, 1));
  }, resolveListenerScope:function(defaultScope) {
    var namedScope = Ext._namedScopes[defaultScope];
    if (namedScope) {
      if (namedScope.isController) {
        Ext.raise('scope: "controller" can only be specified on classes that derive from Ext.Component or Ext.Widget');
      }
      if (namedScope.isSelf || namedScope.isThis) {
        defaultScope = null;
      }
    }
    return defaultScope || this;
  }, fireEventArgs:function(eventName, args) {
    eventName = Ext.canonicalEventName(eventName);
    var me = this, events = me.events, event = events && events[eventName], ret = true;
    if (me.hasListeners[eventName]) {
      ret = me.doFireEvent(eventName, args || emptyArray, event ? event.bubble : false);
    }
    return ret;
  }, fireAction:function(eventName, args, fn, scope, options, order) {
    if (typeof fn === 'string' && !scope) {
      fn = this[fn];
    }
    options = options ? Ext.Object.chain(options) : {};
    options.single = true;
    options.priority = order === 'after' ? -99.5 : 99.5;
    this.doAddListener(eventName, fn, scope, options);
    this.fireEventArgs(eventName, args);
  }, $eventedController:{_paused:1, pause:function() {
    ++this._paused;
  }, resume:function() {
    var me = this, fn = me.fn, scope = me.scope, fnArgs = me.fnArgs, owner = me.owner, args, ret;
    if (!--me._paused) {
      if (fn) {
        args = Ext.Array.slice(fnArgs || me.args);
        if (fnArgs === false) {
          args.shift();
        }
        me.fn = null;
        args.push(me);
        if (Ext.isFunction(fn)) {
          ret = fn.apply(scope, args);
        } else {
          if (scope && Ext.isString(fn) && Ext.isFunction(scope[fn])) {
            ret = scope[fn].apply(scope, args);
          }
        }
        if (ret === false) {
          return false;
        }
      }
      if (!me._paused) {
        return me.owner.fireEventArgs(me.eventName, me.args);
      }
    }
  }}, fireEventedAction:function(eventName, args, fn, scope, fnArgs) {
    var me = this, eventedBeforeEventNames = me.eventedBeforeEventNames, beforeEventName = eventedBeforeEventNames[eventName] || (eventedBeforeEventNames[eventName] = 'before' + eventName), controller = Ext.apply({owner:me, eventName:eventName, fn:fn, scope:scope, fnArgs:fnArgs, args:args}, me.$eventedController), value;
    args.push(controller);
    value = me.fireEventArgs(beforeEventName, args);
    args.pop();
    if (value === false) {
      return false;
    }
    return controller.resume();
  }, doFireEvent:function(eventName, args, bubbles) {
    var target = this, queue, event, ret = true;
    do {
      if (target.eventsSuspended) {
        if (queue = target.eventQueue) {
          queue.push([eventName, args]);
        }
        return ret;
      } else {
        event = target.events && target.events[eventName];
        if (event && event !== true) {
          if ((ret = event.fire.apply(event, args)) === false) {
            break;
          }
        }
      }
    } while (bubbles && (target = target.getBubbleParent()));
    return ret;
  }, getBubbleParent:function() {
    var me = this, parent = me.getBubbleTarget && me.getBubbleTarget();
    if (parent && parent.isObservable) {
      return parent;
    }
    return null;
  }, addListener:function(eventName, fn, scope, options, order, caller) {
    var me = this, namedScopes = Ext._namedScopes, config, namedScope, isClassListener, innerScope, eventOptions;
    if (typeof eventName !== 'string') {
      options = eventName;
      scope = options.scope;
      namedScope = scope && namedScopes[scope];
      isClassListener = namedScope && namedScope.isSelf;
      eventOptions = (me.isComponent || me.isWidget) && options.element ? me.$elementEventOptions : me.$eventOptions;
      for (eventName in options) {
        config = options[eventName];
        if (!eventOptions[eventName]) {
          innerScope = config.scope;
          if (innerScope && isClassListener) {
            namedScope = namedScopes[innerScope];
            if (namedScope && namedScope.isController) {
              innerScope = 'self.controller';
            }
          }
          me.doAddListener(eventName, config.fn || config, innerScope || scope, config.fn ? config : options, order, caller);
        }
      }
      if (options && options.destroyable) {
        return new ListenerRemover(me, options);
      }
    } else {
      me.doAddListener(eventName, fn, scope, options, order, caller);
      if (options && options.destroyable) {
        return new ListenerRemover(me, eventName, fn, scope, options);
      }
    }
    return me;
  }, removeListener:function(eventName, fn, scope, eventOptions) {
    var me = this, config, options;
    if (typeof eventName !== 'string') {
      options = eventName;
      eventOptions = eventOptions || me.$eventOptions;
      for (eventName in options) {
        if (options.hasOwnProperty(eventName)) {
          config = options[eventName];
          if (!me.$eventOptions[eventName]) {
            me.doRemoveListener(eventName, config.fn || config, config.scope || options.scope);
          }
        }
      }
    } else {
      me.doRemoveListener(eventName, fn, scope);
    }
    return me;
  }, onBefore:function(eventName, fn, scope, options) {
    return this.addListener(eventName, fn, scope, options, 'before');
  }, onAfter:function(eventName, fn, scope, options) {
    return this.addListener(eventName, fn, scope, options, 'after');
  }, unBefore:function(eventName, fn, scope, options) {
    return this.removeListener(eventName, fn, scope, options, 'before');
  }, unAfter:function(eventName, fn, scope, options) {
    return this.removeListener(eventName, fn, scope, options, 'after');
  }, addBeforeListener:function() {
    return this.onBefore.apply(this, arguments);
  }, addAfterListener:function() {
    return this.onAfter.apply(this, arguments);
  }, removeBeforeListener:function() {
    return this.unBefore.apply(this, arguments);
  }, removeAfterListener:function() {
    return this.unAfter.apply(this, arguments);
  }, clearListeners:function() {
    var me = this, events = me.events, hasListeners = me.hasListeners, event, key;
    if (events) {
      for (key in events) {
        if (events.hasOwnProperty(key)) {
          event = events[key];
          if (event.isEvent) {
            delete hasListeners[key];
            event.clearListeners();
          }
        }
      }
      me.events = null;
    }
    me.clearManagedListeners();
  }, purgeListeners:function() {
    if (Ext.global.console) {
      Ext.global.console.warn('Observable: purgeListeners has been deprecated. Please use clearListeners.');
    }
    return this.clearListeners.apply(this, arguments);
  }, clearManagedListeners:function() {
    var me = this, managedListeners = me.managedListeners, i, len;
    if (managedListeners) {
      me.managedListeners = null;
      for (i = 0, len = managedListeners.length; i < len; i++) {
        me.removeManagedListenerItem(true, managedListeners[i]);
      }
      managedListeners.length = 0;
    }
    me.managedListeners = managedListeners;
  }, removeManagedListenerItem:function(isClear, managedListener, item, ename, fn, scope) {
    if (isClear || managedListener.item === item && managedListener.ename === ename && (!fn || managedListener.fn === fn) && (!scope || managedListener.scope === scope)) {
      if (!managedListener.item.destroyed) {
        managedListener.item.doRemoveListener(managedListener.ename, managedListener.fn, managedListener.scope, managedListener.options);
      }
      if (!isClear) {
        Ext.Array.remove(this.managedListeners, managedListener);
      }
    }
  }, purgeManagedListeners:function() {
    if (Ext.global.console) {
      Ext.global.console.warn('Observable: purgeManagedListeners has been deprecated. Please use clearManagedListeners.');
    }
    return this.clearManagedListeners.apply(this, arguments);
  }, hasListener:function(eventName) {
    eventName = Ext.canonicalEventName(eventName);
    return !!this.hasListeners[eventName];
  }, isSuspended:function(event) {
    var suspended = this.eventsSuspended > 0, events = this.events;
    if (!suspended && event && events) {
      event = events[event];
      if (event && event.isEvent) {
        return event.isSuspended();
      }
    }
    return suspended;
  }, suspendEvents:function(queueSuspended) {
    ++this.eventsSuspended;
    if (queueSuspended && !this.eventQueue) {
      this.eventQueue = [];
    }
  }, suspendEvent:function() {
    var me = this, events = me.events, len = arguments.length, i, event, ename;
    for (i = 0; i < len; i++) {
      ename = arguments[i];
      ename = Ext.canonicalEventName(ename);
      event = events[ename];
      if (!event || !event.isEvent) {
        event = me._initEvent(ename);
      }
      event.suspend();
    }
  }, resumeEvent:function() {
    var events = this.events || 0, len = events && arguments.length, i, event, ename;
    for (i = 0; i < len; i++) {
      ename = Ext.canonicalEventName(arguments[i]);
      event = events[ename];
      if (event && event.resume) {
        event.resume();
      }
    }
  }, resumeEvents:function(discardQueue) {
    var me = this, queued = me.eventQueue, qLen, q;
    if (me.eventsSuspended && !--me.eventsSuspended) {
      delete me.eventQueue;
      if (!discardQueue && queued) {
        qLen = queued.length;
        for (q = 0; q < qLen; q++) {
          me.fireEventArgs.apply(me, queued[q]);
        }
      }
    }
  }, relayEvents:function(origin, events, prefix) {
    var me = this, len = events.length, i = 0, oldName, newName, relayers = {};
    if (Ext.isObject(events)) {
      for (i in events) {
        newName = events[i];
        relayers[i] = me.createRelayer(newName);
      }
    } else {
      for (; i < len; i++) {
        oldName = events[i];
        relayers[oldName] = me.createRelayer(prefix ? prefix + oldName : oldName);
      }
    }
    me.mon(origin, relayers, null, null, undefined);
    return new ListenerRemover(me, origin, relayers);
  }, createRelayer:function(newName, beginEnd) {
    var me = this;
    return function() {
      return me.fireEventArgs.call(me, newName, beginEnd ? arraySlice.apply(arguments, beginEnd) : arguments);
    };
  }, enableBubble:function(eventNames) {
    if (eventNames) {
      var me = this, names = typeof eventNames == 'string' ? arguments : eventNames, events = me.events, length = events && names.length, ename, event, i;
      for (i = 0; i < length; ++i) {
        ename = names[i];
        ename = Ext.canonicalEventName(ename);
        event = events[ename];
        if (!event || !event.isEvent) {
          event = me._initEvent(ename);
        }
        me.hasListeners._incr_(ename);
        event.bubble = true;
      }
    }
  }, destroy:function() {
    this.clearListeners();
    this.callParent();
    this.destroyObservable(true);
  }, destroyObservable:function(skipClearListeners) {
    var me = this, clearPropertiesOnDestroy = me.clearPropertiesOnDestroy;
    if (me.$observableDestroyed) {
      return;
    }
    if (!skipClearListeners) {
      me.clearListeners();
    }
    if (me.destroyed) {
      if (clearPropertiesOnDestroy) {
        if (clearPropertiesOnDestroy === true && !me.$nulled) {
          me.$reap();
        }
        if (!me.clearPrototypeOnDestroy) {
          me.fireEvent = me.fireEventArgs = me.fireAction = me.fireEventedAction = Ext.emptyFn;
        }
        me.events = me.managedListeners = me.eventedBeforeEventNames = null;
        me.$observableDestroyed = true;
      }
      if (me.clearPrototypeOnDestroy && Object.setPrototypeOf && !me.$alreadyNulled) {
        Object.setPrototypeOf(me, null);
        me.$alreadyNulled = true;
      }
    }
  }, privates:{doAddListener:function(ename, fn, scope, options, order, caller, manager) {
    var me = this, ret = false, event, priority;
    order = order || options && options.order;
    if (order) {
      priority = options && options.priority;
      if (!priority) {
        options = options ? Ext.Object.chain(options) : {};
        options.priority = me.$orderToPriority[order];
      }
    }
    ename = Ext.canonicalEventName(ename);
    if (!fn) {
      Ext.raise("Cannot add '" + ename + "' listener to " + me.$className + ' instance.  No function specified.');
    }
    event = (me.events || (me.events = {}))[ename];
    if (!event || !event.isEvent) {
      event = me._initEvent(ename);
    }
    if (fn !== emptyFn) {
      if (!manager && (scope && scope.isObservable && scope !== me)) {
        manager = scope;
      }
      if (event.addListener(fn, scope, options, caller, manager)) {
        me.hasListeners._incr_(ename);
        ret = true;
      }
    }
    return ret;
  }, doRemoveListener:function(ename, fn, scope) {
    var me = this, ret = false, events = me.events, event;
    ename = Ext.canonicalEventName(ename);
    event = events && events[ename];
    if (!fn) {
      Ext.raise("Cannot remove '" + ename + "' listener to " + me.$className + ' instance.  No function specified.');
    }
    if (event && event.isEvent) {
      if (event.removeListener(fn, scope)) {
        me.hasListeners._decr_(ename);
        ret = true;
      }
    }
    return ret;
  }, _initEvent:function(eventName) {
    return this.events[eventName] = new Ext.util.Event(this, eventName);
  }}, deprecated:{'5.0':{methods:{addEvents:null}}}};
}, function() {
  var Observable = this, proto = Observable.prototype, HasListeners = function() {
  }, prepareMixin = function(T) {
    if (!T.HasListeners) {
      var proto = T.prototype;
      proto.$observableMixedIn = 1;
      Observable.prepareClass(T, this);
      T.onExtended(function(U, data) {
        Ext.classSystemMonitor && Ext.classSystemMonitor('extend mixin', arguments);
        Observable.prepareClass(U, null, data);
      });
      if (proto.onClassMixedIn) {
        Ext.override(T, {onClassMixedIn:function(U) {
          prepareMixin.call(this, U);
          this.callParent(arguments);
        }});
      } else {
        proto.onClassMixedIn = function(U) {
          prepareMixin.call(this, U);
        };
      }
    }
    superOnClassMixedIn.call(this, T);
  }, superOnClassMixedIn = proto.onClassMixedIn;
  HasListeners.prototype = {_decr_:function(ev, count) {
    if (count == null) {
      count = 1;
    }
    if (!(this[ev] -= count)) {
      delete this[ev];
    }
  }, _incr_:function(ev) {
    if (this.hasOwnProperty(ev)) {
      ++this[ev];
    } else {
      this[ev] = 1;
    }
  }};
  proto.HasListeners = Observable.HasListeners = HasListeners;
  Observable.createAlias({on:'addListener', un:'removeListener', mon:'addManagedListener', mun:'removeManagedListener', setListeners:'addListener'});
  Observable.observeClass = Observable.observe;
  function getMethodEvent(method) {
    var event = (this.methodEvents = this.methodEvents || {})[method], returnValue, v, cancel, me = this, makeCall;
    if (!event) {
      me.methodEvents[method] = event = {};
      event.originalFn = me[method];
      event.methodName = method;
      event.before = [];
      event.after = [];
      makeCall = function(fn, scope, args) {
        scope = scope || me;
        if (typeof fn === 'string') {
          fn = scope[fn];
        }
        if ((v = fn.apply(scope, args)) !== undefined) {
          if (typeof v == 'object') {
            if (v.returnValue !== undefined) {
              returnValue = v.returnValue;
            } else {
              returnValue = v;
            }
            cancel = !!v.cancel;
          } else {
            if (v === false) {
              cancel = true;
            } else {
              returnValue = v;
            }
          }
        }
      };
      me[method] = function() {
        var args = Array.prototype.slice.call(arguments, 0), argsLen = args.length, b, i, len;
        returnValue = v = undefined;
        cancel = false;
        for (i = 0, len = event.before.length; i < len; i++) {
          b = event.before[i];
          if (b.extraArgs) {
            args.push.apply(args, b.extraArgs);
          }
          makeCall(b.fn, b.scope, args);
          args.length = argsLen;
          if (cancel || b.preventDefault) {
            return returnValue;
          }
        }
        if ((v = event.originalFn.apply(me, args)) !== undefined) {
          returnValue = v;
        }
        for (i = 0, len = event.after.length; i < len; i++) {
          b = event.after[i];
          if (b.extraArgs) {
            args.push.apply(args, b.extraArgs);
          }
          makeCall(b.fn, b.scope, args);
          args.length = argsLen;
          if (cancel || b.preventDefault) {
            return returnValue;
          }
        }
        return returnValue;
      };
    }
    return event;
  }
  Ext.apply(proto, {onClassMixedIn:prepareMixin, beforeMethod:function(method, fn, scope, preventDefault, extraArgs) {
    getMethodEvent.call(this, method).before.push({fn:fn, scope:scope, extraArgs:extraArgs, preventDefault:preventDefault});
  }, afterMethod:function(method, fn, scope, preventDefault, extraArgs) {
    getMethodEvent.call(this, method).after.push({fn:fn, scope:scope, extraArgs:extraArgs, preventDefault:preventDefault});
  }, removeMethodListener:function(method, fn, scope) {
    var e = getMethodEvent.call(this, method), i, len;
    for (i = 0, len = e.before.length; i < len; i++) {
      if (e.before[i].fn == fn && e.before[i].scope == scope) {
        Ext.Array.erase(e.before, i, 1);
        return;
      }
    }
    for (i = 0, len = e.after.length; i < len; i++) {
      if (e.after[i].fn == fn && e.after[i].scope == scope) {
        Ext.Array.erase(e.after, i, 1);
        return;
      }
    }
  }, toggleEventLogging:function(toggle) {
    Ext.util.Observable[toggle ? 'capture' : 'releaseCapture'](this, function(en) {
      if (Ext.isDefined(Ext.global.console)) {
        Ext.global.console.log(en, arguments);
      }
    });
  }});
});
Ext.define('Ext.util.HashMap', {mixins:[Ext.mixin.Observable], generation:0, config:{keyFn:null}, constructor:function(config) {
  var me = this, fn;
  me.mixins.observable.constructor.call(me, config);
  me.clear(true);
  fn = me.getKeyFn();
  if (fn) {
    me.getKey = fn;
  }
}, getCount:function() {
  return this.length;
}, getData:function(key, value) {
  if (value === undefined) {
    value = key;
    key = this.getKey(value);
  }
  return [key, value];
}, getKey:function(o) {
  return o.id;
}, add:function(key, value) {
  var me = this;
  if (arguments.length === 1) {
    value = key;
    key = me.getKey(value);
  }
  if (me.containsKey(key)) {
    return me.replace(key, value);
  }
  me.map[key] = value;
  ++me.length;
  me.generation++;
  if (me.hasListeners.add) {
    me.fireEvent('add', me, key, value);
  }
  return value;
}, replace:function(key, value) {
  var me = this, map = me.map, old;
  if (arguments.length === 1) {
    value = key;
    key = me.getKey(value);
  }
  if (!me.containsKey(key)) {
    me.add(key, value);
  }
  old = map[key];
  map[key] = value;
  me.generation++;
  if (me.hasListeners.replace) {
    me.fireEvent('replace', me, key, value, old);
  }
  return value;
}, remove:function(o) {
  var key = this.findKey(o);
  if (key !== undefined) {
    return this.removeAtKey(key);
  }
  return false;
}, removeAtKey:function(key) {
  var me = this, value;
  if (me.containsKey(key)) {
    value = me.map[key];
    delete me.map[key];
    --me.length;
    me.generation++;
    if (me.hasListeners.remove) {
      me.fireEvent('remove', me, key, value);
    }
    return true;
  }
  return false;
}, get:function(key) {
  var map = this.map;
  return map.hasOwnProperty(key) ? map[key] : undefined;
}, clear:function(initial) {
  var me = this;
  if (initial || me.generation) {
    me.map = {};
    me.length = 0;
    me.generation = initial ? 0 : me.generation + 1;
  }
  if (initial !== true && me.hasListeners.clear) {
    me.fireEvent('clear', me);
  }
  return me;
}, containsKey:function(key) {
  var map = this.map;
  return map.hasOwnProperty(key) && map[key] !== undefined;
}, contains:function(value) {
  return this.containsKey(this.findKey(value));
}, getKeys:function() {
  return this.getArray(true);
}, getValues:function() {
  return this.getArray(false);
}, getArray:function(isKey) {
  var arr = [], key, map = this.map;
  for (key in map) {
    if (map.hasOwnProperty(key)) {
      arr.push(isKey ? key : map[key]);
    }
  }
  return arr;
}, each:function(fn, scope) {
  var items = Ext.apply({}, this.map), key, length = this.length;
  scope = scope || this;
  for (key in items) {
    if (items.hasOwnProperty(key)) {
      if (fn.call(scope, key, items[key], length) === false) {
        break;
      }
    }
  }
  return this;
}, clone:function() {
  var hash = new this.self(this.initialConfig), map = this.map, key;
  hash.suspendEvents();
  for (key in map) {
    if (map.hasOwnProperty(key)) {
      hash.add(key, map[key]);
    }
  }
  hash.resumeEvents();
  return hash;
}, findKey:function(value) {
  var key, map = this.map;
  for (key in map) {
    if (map.hasOwnProperty(key) && map[key] === value) {
      return key;
    }
  }
  return undefined;
}}, function(HashMap) {
  var prototype = HashMap.prototype;
  prototype.removeByKey = prototype.removeAtKey;
});
Ext.define('Ext.promise.Consequence', function(Consequence) {
  return {promise:null, deferred:null, onFulfilled:null, onRejected:null, onProgress:null, constructor:function(onFulfilled, onRejected, onProgress) {
    var me = this;
    me.onFulfilled = onFulfilled;
    me.onRejected = onRejected;
    me.onProgress = onProgress;
    me.deferred = new Ext.promise.Deferred;
    me.promise = me.deferred.promise;
  }, trigger:function(action, value) {
    var me = this, deferred = me.deferred;
    switch(action) {
      case 'fulfill':
        me.propagate(value, me.onFulfilled, deferred, deferred.resolve);
        break;
      case 'reject':
        me.propagate(value, me.onRejected, deferred, deferred.reject);
        break;
    }
  }, update:function(progress) {
    if (Ext.isFunction(this.onProgress)) {
      progress = this.onProgress(progress);
    }
    this.deferred.update(progress);
  }, propagate:function(value, callback, deferred, deferredMethod) {
    if (Ext.isFunction(callback)) {
      this.schedule(function() {
        try {
          deferred.resolve(callback(value));
        } catch (e$9) {
          deferred.reject(e$9);
        }
      });
    } else {
      deferredMethod.call(this.deferred, value);
    }
  }, schedule:function(callback) {
    var n = Consequence.queueSize++;
    Consequence.queue[n] = callback;
    if (!n) {
      Ext.asap(Consequence.dispatch);
    }
  }, statics:{queue:new Array(10000), queueSize:0, dispatch:function() {
    var queue = Consequence.queue, fn, i;
    for (i = 0; i < Consequence.queueSize; ++i) {
      fn = queue[i];
      queue[i] = null;
      fn();
    }
    Consequence.queueSize = 0;
  }}};
}, function(Consequence) {
  Consequence.dispatch.$skipTimerCheck = true;
});
Ext.define('Ext.promise.Deferred', {promise:null, consequences:[], completed:false, completionAction:null, completionValue:null, constructor:function() {
  var me = this;
  me.promise = new Ext.promise.Promise(me);
  me.consequences = [];
  me.completed = false;
  me.completionAction = null;
  me.completionValue = null;
}, then:function(onFulfilled, onRejected, onProgress) {
  var me = this, consequence = new Ext.promise.Consequence(onFulfilled, onRejected, onProgress);
  if (me.completed) {
    consequence.trigger(me.completionAction, me.completionValue);
  } else {
    me.consequences.push(consequence);
  }
  return consequence.promise;
}, resolve:function(value) {
  var me = this, isHandled, thenFn;
  if (me.completed) {
    return;
  }
  try {
    if (value === me.promise) {
      throw new TypeError('A Promise cannot be resolved with itself.');
    }
    if (value != null && (typeof value === 'object' || Ext.isFunction(value)) && Ext.isFunction(thenFn = value.then)) {
      isHandled = false;
      try {
        thenFn.call(value, function(value) {
          if (!isHandled) {
            isHandled = true;
            me.resolve(value);
          }
        }, function(error) {
          if (!isHandled) {
            isHandled = true;
            me.reject(error);
          }
        });
      } catch (e1) {
        if (!isHandled) {
          me.reject(e1);
        }
      }
    } else {
      me.complete('fulfill', value);
    }
  } catch (e2) {
    me.reject(e2);
  }
}, reject:function(reason) {
  if (this.completed) {
    return;
  }
  this.complete('reject', reason);
}, update:function(progress) {
  var consequences = this.consequences, consequence, i, len;
  if (this.completed) {
    return;
  }
  for (i = 0, len = consequences.length; i < len; i++) {
    consequence = consequences[i];
    consequence.update(progress);
  }
}, complete:function(action, value) {
  var me = this, consequences = me.consequences, consequence, i, len;
  me.completionAction = action;
  me.completionValue = value;
  me.completed = true;
  for (i = 0, len = consequences.length; i < len; i++) {
    consequence = consequences[i];
    consequence.trigger(me.completionAction, me.completionValue);
  }
  me.consequences = null;
}});
Ext.define('Ext.promise.Promise', function(ExtPromise) {
  var Deferred;
  return {statics:{CancellationError:Ext.global.CancellationError || Error, _ready:function() {
    Deferred = Ext.promise.Deferred;
  }, all:function(promisesOrValues) {
    if (!(Ext.isArray(promisesOrValues) || ExtPromise.is(promisesOrValues))) {
      Ext.raise('Invalid parameter: expected an Array or Promise of an Array.');
    }
    return ExtPromise.when(promisesOrValues).then(function(promisesOrValues) {
      var deferred = new Deferred, remainingToResolve = promisesOrValues.length, results = new Array(remainingToResolve), index, promiseOrValue, resolve, i, len;
      if (!remainingToResolve) {
        deferred.resolve(results);
      } else {
        resolve = function(item, index) {
          return ExtPromise.when(item).then(function(value) {
            results[index] = value;
            if (!--remainingToResolve) {
              deferred.resolve(results);
            }
            return value;
          }, function(reason) {
            return deferred.reject(reason);
          });
        };
        for (index = i = 0, len = promisesOrValues.length; i < len; index = ++i) {
          promiseOrValue = promisesOrValues[index];
          if (index in promisesOrValues) {
            resolve(promiseOrValue, index);
          } else {
            remainingToResolve--;
          }
        }
      }
      return deferred.promise;
    });
  }, is:function(value) {
    return value != null && (typeof value === 'object' || Ext.isFunction(value)) && Ext.isFunction(value.then);
  }, race:function(promises) {
    if (!Ext.isArray(promises)) {
      Ext.raise('Invalid parameter: expected an Array.');
    }
    var deferred = new Deferred, len = promises.length, i;
    for (i = 0; i < len; ++i) {
      deferred.resolve(promises[i]);
    }
    return deferred.promise;
  }, rethrowError:function(error) {
    Ext.asap(function() {
      throw error;
    });
  }, when:function(value) {
    var deferred = new Deferred;
    deferred.resolve(value);
    return deferred.promise;
  }}, owner:null, constructor:function(owner) {
    this.owner = owner;
  }, then:function(onFulfilled, onRejected, onProgress, scope) {
    var ref;
    if (arguments.length === 1 && Ext.isObject(arguments[0])) {
      ref = arguments[0];
      onFulfilled = ref.success;
      onRejected = ref.failure;
      onProgress = ref.progress;
      scope = ref.scope;
    }
    if (scope) {
      if (onFulfilled) {
        onFulfilled = onFulfilled.bind(scope);
      }
      if (onRejected) {
        onRejected = onRejected.bind(scope);
      }
      if (onProgress) {
        onProgress = onProgress.bind(scope);
      }
    }
    return this.owner.then(onFulfilled, onRejected, onProgress);
  }, 'catch':function(onRejected, scope) {
    var ref;
    if (arguments.length === 1 && Ext.isObject(arguments[0])) {
      ref = arguments[0];
      onRejected = ref.fn;
      scope = ref.scope;
    }
    if (scope != null) {
      onRejected = onRejected.bind(scope);
    }
    return this.owner.then(null, onRejected);
  }, otherwise:function(onRejected, scope) {
    return this['catch'].apply(this, arguments);
  }, always:function(onCompleted, scope) {
    var ref;
    if (arguments.length === 1 && Ext.isObject(arguments[0])) {
      ref = arguments[0];
      onCompleted = ref.fn;
      scope = ref.scope;
    }
    if (scope != null) {
      onCompleted = onCompleted.bind(scope);
    }
    return this.owner.then(function(value) {
      try {
        onCompleted();
      } catch (e$10) {
        ExtPromise.rethrowError(e$10);
      }
      return value;
    }, function(reason) {
      try {
        onCompleted();
      } catch (e$11) {
        ExtPromise.rethrowError(e$11);
      }
      throw reason;
    });
  }, done:function() {
    this.owner.then(null, ExtPromise.rethrowError);
  }, cancel:function(reason) {
    if (reason == null) {
      reason = null;
    }
    this.owner.reject(new this.self.CancellationError(reason));
  }, log:function(identifier) {
    if (identifier == null) {
      identifier = '';
    }
    return this.owner.then(function(value) {
      Ext.log('' + (identifier || 'Promise') + ' resolved with value: ' + value);
      return value;
    }, function(reason) {
      Ext.log('' + (identifier || 'Promise') + ' rejected with reason: ' + reason);
      throw reason;
    });
  }};
}, function(ExtPromise) {
  ExtPromise._ready();
});
Ext.define('Ext.Promise', function() {
  var Polyfiller;
  return {statics:{_ready:function() {
    Polyfiller = Ext.promise.Promise;
  }, all:function() {
    return Polyfiller.all.apply(Polyfiller, arguments);
  }, race:function() {
    return Polyfiller.race.apply(Polyfiller, arguments);
  }, reject:function(reason) {
    var deferred = new Ext.promise.Deferred;
    deferred.reject(reason);
    return deferred.promise;
  }, resolve:function(value) {
    var deferred = new Ext.promise.Deferred;
    deferred.resolve(value);
    return deferred.promise;
  }}, constructor:function(action) {
    var deferred = new Ext.promise.Deferred;
    action(deferred.resolve.bind(deferred), deferred.reject.bind(deferred));
    return deferred.promise;
  }};
}, function(ExtPromise) {
  var P = Ext.global.Promise;
  if (P && P.resolve && !Ext.useExtPromises) {
    Ext.Promise = P;
  } else {
    ExtPromise._ready();
  }
});
Ext.define('Ext.Deferred', function(Deferred) {
  var ExtPromise, rejected, resolved, when;
  return {extend:Ext.promise.Deferred, statics:{_ready:function() {
    ExtPromise = Ext.promise.Promise;
    when = Ext.Promise.resolve;
  }, all:function() {
    return ExtPromise.all.apply(ExtPromise, arguments);
  }, any:function(promisesOrValues) {
    if (!(Ext.isArray(promisesOrValues) || ExtPromise.is(promisesOrValues))) {
      Ext.raise('Invalid parameter: expected an Array or Promise of an Array.');
    }
    return Deferred.some(promisesOrValues, 1).then(function(array) {
      return array[0];
    }, function(error) {
      if (error instanceof Error && error.message === 'Too few Promises were resolved.') {
        Ext.raise('No Promises were resolved.');
      } else {
        throw error;
      }
    });
  }, delay:function(promiseOrValue, milliseconds) {
    var deferred;
    if (arguments.length === 1) {
      milliseconds = promiseOrValue;
      promiseOrValue = undefined;
    }
    milliseconds = Math.max(milliseconds, 1);
    deferred = new Deferred;
    deferred.timeoutId = Ext.defer(function() {
      delete deferred.timeoutId;
      deferred.resolve(promiseOrValue);
    }, milliseconds);
    return deferred.promise;
  }, getCachedRejected:function() {
    if (!rejected) {
      rejected = Ext.Promise.reject();
    }
    return rejected;
  }, getCachedResolved:function() {
    if (!resolved) {
      resolved = Ext.Promise.resolve();
    }
    return resolved;
  }, map:function(promisesOrValues, mapFn) {
    if (!(Ext.isArray(promisesOrValues) || ExtPromise.is(promisesOrValues))) {
      Ext.raise('Invalid parameter: expected an Array or Promise of an Array.');
    }
    if (!Ext.isFunction(mapFn)) {
      Ext.raise('Invalid parameter: expected a function.');
    }
    return Deferred.resolved(promisesOrValues).then(function(promisesOrValues) {
      var deferred, index, promiseOrValue, remainingToResolve, resolve, results, i, len;
      remainingToResolve = promisesOrValues.length;
      results = new Array(promisesOrValues.length);
      deferred = new Deferred;
      if (!remainingToResolve) {
        deferred.resolve(results);
      } else {
        resolve = function(item, index) {
          return Deferred.resolved(item).then(function(value) {
            return mapFn(value, index, results);
          }).then(function(value) {
            results[index] = value;
            if (!--remainingToResolve) {
              deferred.resolve(results);
            }
            return value;
          }, function(reason) {
            return deferred.reject(reason);
          });
        };
        for (index = i = 0, len = promisesOrValues.length; i < len; index = ++i) {
          promiseOrValue = promisesOrValues[index];
          if (index in promisesOrValues) {
            resolve(promiseOrValue, index);
          } else {
            remainingToResolve--;
          }
        }
      }
      return deferred.promise;
    });
  }, memoize:function(fn, scope, hashFn) {
    var memoizedFn = Ext.Function.memoize(fn, scope, hashFn);
    return function() {
      return Deferred.all(Ext.Array.slice(arguments)).then(function(values) {
        return memoizedFn.apply(scope, values);
      });
    };
  }, parallel:function(fns, scope) {
    if (scope == null) {
      scope = null;
    }
    var args = Ext.Array.slice(arguments, 2);
    return Deferred.map(fns, function(fn) {
      if (!Ext.isFunction(fn)) {
        throw new Error('Invalid parameter: expected a function.');
      }
      return fn.apply(scope, args);
    });
  }, pipeline:function(fns, initialValue, scope) {
    if (scope == null) {
      scope = null;
    }
    return Deferred.reduce(fns, function(value, fn) {
      if (!Ext.isFunction(fn)) {
        throw new Error('Invalid parameter: expected a function.');
      }
      return fn.call(scope, value);
    }, initialValue);
  }, race:function() {
    return ExtPromise.race.apply(ExtPromise, arguments);
  }, reduce:function(values, reduceFn, initialValue) {
    if (!(Ext.isArray(values) || ExtPromise.is(values))) {
      Ext.raise('Invalid parameter: expected an Array or Promise of an Array.');
    }
    if (!Ext.isFunction(reduceFn)) {
      Ext.raise('Invalid parameter: expected a function.');
    }
    var initialValueSpecified = arguments.length === 3;
    return Deferred.resolved(values).then(function(promisesOrValues) {
      var reduceArguments = [promisesOrValues, function(previousValueOrPromise, currentValueOrPromise, currentIndex) {
        return Deferred.resolved(previousValueOrPromise).then(function(previousValue) {
          return Deferred.resolved(currentValueOrPromise).then(function(currentValue) {
            return reduceFn(previousValue, currentValue, currentIndex, promisesOrValues);
          });
        });
      }];
      if (initialValueSpecified) {
        reduceArguments.push(initialValue);
      }
      return Ext.Array.reduce.apply(Ext.Array, reduceArguments);
    });
  }, rejected:function(reason) {
    var deferred = new Ext.Deferred;
    deferred.reject(reason);
    return deferred.promise;
  }, resolved:function(promiseOrValue) {
    var deferred = new Ext.Deferred;
    deferred.resolve(promiseOrValue);
    return deferred.promise;
  }, sequence:function(fns, scope) {
    if (scope == null) {
      scope = null;
    }
    var args = Ext.Array.slice(arguments, 2);
    return Deferred.reduce(fns, function(results, fn) {
      if (!Ext.isFunction(fn)) {
        throw new Error('Invalid parameter: expected a function.');
      }
      return Deferred.resolved(fn.apply(scope, args)).then(function(result) {
        results.push(result);
        return results;
      });
    }, []);
  }, some:function(promisesOrValues, howMany) {
    if (!(Ext.isArray(promisesOrValues) || ExtPromise.is(promisesOrValues))) {
      Ext.raise('Invalid parameter: expected an Array or Promise of an Array.');
    }
    if (!Ext.isNumeric(howMany) || howMany <= 0) {
      Ext.raise('Invalid parameter: expected a positive integer.');
    }
    return Deferred.resolved(promisesOrValues).then(function(promisesOrValues) {
      var deferred, index, onReject, onResolve, promiseOrValue, remainingToReject, remainingToResolve, values, i, len;
      values = [];
      remainingToResolve = howMany;
      remainingToReject = promisesOrValues.length - remainingToResolve + 1;
      deferred = new Deferred;
      if (promisesOrValues.length < howMany) {
        deferred.reject(new Error('Too few Promises were resolved.'));
      } else {
        onResolve = function(value) {
          if (remainingToResolve > 0) {
            values.push(value);
          }
          remainingToResolve--;
          if (remainingToResolve === 0) {
            deferred.resolve(values);
          }
          return value;
        };
        onReject = function(reason) {
          remainingToReject--;
          if (remainingToReject === 0) {
            deferred.reject(new Error('Too few Promises were resolved.'));
          }
          return reason;
        };
        for (index = i = 0, len = promisesOrValues.length; i < len; index = ++i) {
          promiseOrValue = promisesOrValues[index];
          if (index in promisesOrValues) {
            Deferred.resolved(promiseOrValue).then(onResolve, onReject);
          }
        }
      }
      return deferred.promise;
    });
  }, timeout:function(promiseOrValue, milliseconds) {
    var deferred = new Deferred, timeoutId;
    timeoutId = Ext.defer(function() {
      if (timeoutId) {
        deferred.reject(new Error('Promise timed out.'));
      }
    }, milliseconds);
    Deferred.resolved(promiseOrValue).then(function(value) {
      Ext.undefer(timeoutId);
      timeoutId = null;
      deferred.resolve(value);
    }, function(reason) {
      Ext.undefer(timeoutId);
      timeoutId = null;
      deferred.reject(reason);
    });
    return deferred.promise;
  }}};
}, function(Deferred) {
  Deferred._ready();
});
Ext.Factory = function(type) {
  var me = this;
  me.aliasPrefix = type + '.';
  me.cache = {};
  me.name = type.replace(me.fixNameRe, me.fixNameFn);
  me.type = type;
  me.creator = 'create' + Ext.String.capitalize(me.name);
};
Ext.Factory.prototype = {defaultProperty:'type', instanceProp:'isInstance', typeProperty:'type', create:function(config, defaultType) {
  var me = this, Manager = Ext.ClassManager, cache = me.cache, typeProperty = me.typeProperty, alias, className, klass, suffix;
  if (config) {
    if (config[me.instanceProp]) {
      return config;
    }
    if (typeof config === 'string') {
      suffix = config;
      config = {};
      config[me.defaultProperty] = suffix;
    }
    className = config.xclass;
    suffix = config[typeProperty];
  }
  if (defaultType && defaultType.constructor === Object) {
    config = Ext.apply({}, config, defaultType);
    defaultType = defaultType[typeProperty];
  }
  if (className) {
    if (!(klass = Manager.get(className))) {
      return Manager.instantiate(className, config);
    }
  } else {
    if (!(suffix = suffix || defaultType || me.defaultType)) {
      klass = me.defaultClass;
    }
    if (!suffix && !klass) {
      Ext.raise('No type specified for ' + me.type + '.create');
    }
    if (!klass && !(klass = cache[suffix])) {
      alias = me.aliasPrefix + suffix;
      className = Manager.getNameByAlias(alias);
      if (!(klass = className && Manager.get(className))) {
        return Manager.instantiateByAlias(alias, config);
      }
      cache[suffix] = klass;
    }
  }
  return klass.isInstance ? klass : new klass(config);
}, fixNameRe:/\.[a-z]/ig, fixNameFn:function(match) {
  return match.substring(1).toUpperCase();
}, clearCache:function() {
  this.cache = {};
  this.instanceCache = {};
}, hook:function(fn) {
  var me = this, original = me.create;
  me.create = function(config, defaultType) {
    var ret = fn.call(me, original, config, defaultType);
    if (ret === undefined) {
      ret = original.call(me, config, defaultType);
    }
    return ret;
  };
}, update:function(instance, config, creator, creatorMethod, defaultsConfig) {
  var me = this, aliases, defaults, reuse, type;
  if (!config || config.isInstance) {
    if (config && !config[me.instanceProp]) {
      Ext.raise('Config instance failed ' + me.instanceProp + ' requirement');
    }
    if (instance && instance !== config) {
      instance.destroy();
    }
    return config;
  }
  if (typeof config === 'string') {
    type = config;
    config = {};
    config[me.defaultProperty] = type;
  }
  if (instance) {
    if (config === true) {
      return instance;
    }
    if (!(type = config.xclass)) {
      if (!(type = config.xtype)) {
        type = config[me.typeProperty];
        if (type) {
          type = me.aliasPrefix + type;
          aliases = instance.self.prototype;
          if (aliases.hasOwnProperty('alias')) {
            aliases = aliases.alias;
            if (aliases) {
              reuse = aliases === type || aliases.indexOf(type) > -1;
            }
          }
        }
      } else {
        reuse = instance.isXType(type, true);
      }
    } else {
      reuse = instance.$className === type;
    }
    if (reuse) {
      instance.setConfig(config);
      return instance;
    }
    instance.destroy();
  }
  if (config === true) {
    config = {};
  }
  if (creator) {
    if (defaultsConfig) {
      defaults = Ext.Config.map[defaultsConfig];
      defaults = creator[defaults.names.get]();
      if (defaults) {
        config = Ext.merge(Ext.clone(defaults), config);
      }
    }
    creatorMethod = creatorMethod || me.creator;
    if (creator[creatorMethod]) {
      config = creator[creatorMethod](config);
      if (!config) {
        Ext.raise('Missing return value from ' + creatorMethod + ' on class ' + creator.$className);
      }
    }
  }
  return me.create(config);
}};
Ext.Factory.define = function(type, config) {
  var Factory = Ext.Factory, cacheable = config && config.cacheable, defaultClass, factory, fn;
  if (type.constructor === Object) {
    Ext.Object.each(type, Factory.define, Factory);
  } else {
    factory = new Ext.Factory(type);
    if (config) {
      if (config.constructor === Object) {
        Ext.apply(factory, config);
        if (typeof(defaultClass = factory.xclass) === 'string') {
          factory.defaultClass = Ext.ClassManager.get(defaultClass);
        }
      } else {
        factory.defaultType = config;
      }
    }
    Factory[factory.name] = fn = function(config, defaultType) {
      return factory.create(config, defaultType);
    };
    if (cacheable) {
      factory.instanceCache = {};
      factory.hook(function(original, config, defaultType) {
        var cache = this.instanceCache, v;
        if (typeof config === 'string' && !(v = cache[config])) {
          v = original.call(this, config, defaultType);
          if (v.cacheable !== false) {
            cache[config] = v;
            Ext.Object.freeze(v);
          }
        }
        return v;
      });
    }
    fn.instance = factory;
    fn.update = function(instance, config, creator, creatorMethod, defaultsConfig) {
      return factory.update(instance, config, creator, creatorMethod, defaultsConfig);
    };
  }
  return fn;
};
Ext.Factory.clearCaches = function() {
  var Factory = Ext.Factory, key, item;
  for (key in Factory) {
    item = Factory[key];
    item = item.instance;
    if (item) {
      item.clearCache();
    }
  }
};
Ext.Factory.on = function(name, fn) {
  Ext.Factory[name].instance.hook(fn);
};
Ext.define('Ext.mixin.Factoryable', {mixinId:'factoryable', onClassMixedIn:function(targetClass) {
  var proto = targetClass.prototype, factoryConfig = proto.factoryConfig, alias = proto.alias, config = {}, dot, createFn;
  alias = alias && alias.length && alias[0];
  if (alias && (dot = alias.lastIndexOf('.')) > 0) {
    config.type = alias.substring(0, dot);
    config.defaultType = alias.substring(dot + 1);
  }
  if (factoryConfig) {
    delete proto.factoryConfig;
    Ext.apply(config, factoryConfig);
  }
  createFn = Ext.Factory.define(config.type, config);
  if (targetClass.create === Ext.Base.create) {
    targetClass.create = createFn;
  }
}});
Ext.define('Ext.data.request.Base', {mixins:[Ext.mixin.Factoryable], factoryConfig:{type:'request', defaultType:'ajax'}, result:null, success:null, timer:null, constructor:function(config) {
  var me = this;
  Ext.apply(me, config.options || {}, config.ownerConfig);
  me.id = ++Ext.data.Connection.requestId;
  me.owner = config.owner;
  me.options = config.options;
  me.requestOptions = config.requestOptions;
}, start:function() {
  var me = this, timeout = me.getTimeout();
  if (timeout && me.async) {
    me.timer = Ext.defer(me.onTimeout, timeout, me);
  }
}, abort:function() {
  var me = this;
  me.clearTimer();
  if (!me.timedout) {
    me.aborted = true;
  }
  me.abort = Ext.emptyFn;
}, createDeferred:function() {
  var me = this, result = me.result, d = new Ext.Deferred;
  if (me.completed) {
    if (me.success) {
      d.resolve(result);
    } else {
      d.reject(result);
    }
  }
  me.deferred = d;
  return d;
}, getDeferred:function() {
  return this.deferred || this.createDeferred();
}, getPromise:function() {
  return this.getDeferred().promise;
}, then:function() {
  var promise = this.getPromise();
  return promise.then.apply(promise, arguments);
}, onComplete:function() {
  var me = this, deferred = me.deferred, result = me.result;
  me.clearTimer();
  if (deferred) {
    if (me.success) {
      deferred.resolve(result);
    } else {
      deferred.reject(result);
    }
  }
  me.completed = true;
}, onTimeout:function() {
  var me = this;
  me.timedout = true;
  me.timer = null;
  me.abort(true);
}, getTimeout:function() {
  return this.timeout;
}, clearTimer:function() {
  this.timer = Ext.undefer(this.timer);
}, destroy:function() {
  var me = this;
  me.abort();
  me.owner = me.options = me.requestOptions = me.result = null;
  me.callParent();
}, privates:{createException:function() {
  var me = this, result;
  result = {request:me, requestId:me.id, status:me.aborted ? -1 : 0, statusText:me.aborted ? 'transaction aborted' : 'communication failure', getResponseHeader:me._getHeader, getAllResponseHeaders:me._getHeaders};
  if (me.aborted) {
    result.aborted = true;
  }
  if (me.timedout) {
    result.timedout = true;
  }
  return result;
}, _getHeader:function(name) {
  var headers = this.headers;
  return headers && headers[name.toLowerCase()];
}, _getHeaders:function() {
  return this.headers;
}}});
Ext.define('Ext.data.flash.BinaryXhr', {statics:{flashPluginActivated:function() {
  Ext.data.flash.BinaryXhr.flashPluginActive = true;
  Ext.data.flash.BinaryXhr.flashPlugin = document.getElementById('ext-flash-polyfill');
  Ext.GlobalEvents.fireEvent('flashready');
}, flashPluginActive:false, flashPluginInjected:false, connectionIndex:1, liveConnections:{}, flashPlugin:null, onFlashStateChange:function(javascriptId, state, data) {
  var connection;
  connection = this.liveConnections[Number(javascriptId)];
  if (connection) {
    connection.onFlashStateChange(state, data);
  } else {
    Ext.warn.log('onFlashStateChange for unknown connection ID: ' + javascriptId);
  }
}, registerConnection:function(conn) {
  var i = this.connectionIndex;
  this.conectionIndex = this.connectionIndex + 1;
  this.liveConnections[i] = conn;
  return i;
}, injectFlashPlugin:function() {
  var me = this, flashLoaderPath, flashObjectPath;
  me.flashPolyfillEl = Ext.getBody().appendChild({id:'ext-flash-polyfill', cn:[{tag:'p', html:'To view this page ensure that Adobe Flash Player version 11.1.0 or greater is installed.'}, {tag:'a', href:'http://www.adobe.com/go/getflashplayer', cn:[{tag:'img', src:window.location.protocol + '//www.adobe.com/images/shared/download_buttons/get_flash_player.gif', alt:'Get Adobe Flash player'}]}]});
  flashLoaderPath = [Ext.Loader.getPath('Ext.data.Connection'), '../../../plugins/flash/swfobject.js'].join('/');
  flashObjectPath = '/plugins/flash/FlashPlugin.swf';
  flashObjectPath = [Ext.Loader.getPath('Ext.data.Connection'), '../../plugins/flash/FlashPlugin.swf'].join('/');
  if (Ext.flashPluginPath) {
    flashObjectPath = Ext.flashPluginPath;
  }
  Ext.Loader.loadScript({url:flashLoaderPath, onLoad:function() {
    var swfVersionStr = '11.4.0';
    var xiSwfUrlStr = 'playerProductInstall.swf';
    var flashvars = {};
    var params = {};
    params.quality = 'high';
    params.bgcolor = '#ffffff';
    params.allowscriptaccess = 'sameDomain';
    params.allowfullscreen = 'true';
    var attributes = {};
    attributes.id = 'ext-flash-polyfill';
    attributes.name = 'polyfill';
    attributes.align = 'middle';
    swfobject.embedSWF(flashObjectPath, 'ext-flash-polyfill', '0', '0', swfVersionStr, xiSwfUrlStr, flashvars, params, attributes);
  }, onError:function() {
    Ext.raise('Could not load flash-loader file swfobject.js from ' + flashLoader);
  }, scope:me});
  Ext.data.flash.BinaryXhr.flashPluginInjected = true;
}}, readyState:0, status:0, statusText:'', responseBytes:null, javascriptId:null, constructor:function(config) {
  if (!Ext.data.flash.BinaryXhr.flashPluginInjected) {
    Ext.data.flash.BinaryXhr.injectFlashPlugin();
  }
  var me = this;
  Ext.apply(me, config);
  me.requestHeaders = {};
}, abort:function() {
  var me = this;
  if (me.readyState == 4) {
    Ext.warn.log("Aborting a connection that's completed its transfer: " + this.url);
    return;
  }
  me.aborted = true;
  if (!Ext.data.flash.BinaryXhr.flashPluginActive) {
    Ext.GlobalEvents.removeListener('flashready', me.onFlashReady, me);
    return;
  }
  Ext.data.flash.BinaryXhr.flashPlugin.abortRequest(me.javascriptId);
  delete Ext.data.flash.BinaryXhr.liveConnections[me.javascriptId];
}, getAllResponseHeaders:function() {
  var headers = [];
  Ext.Object.each(this.responseHeaders, function(name, value) {
    headers.push(name + ': ' + value);
  });
  return headers.join('\r\n');
}, getResponseHeader:function(header) {
  var headers = this.responseHeaders;
  return headers && headers[header] || null;
}, open:function(method, url, async, user, password) {
  var me = this;
  me.method = method;
  me.url = url;
  me.async = async !== false;
  me.user = user;
  me.password = password;
  if (!me.async) {
    Ext.raise('Binary posts are only supported in async mode: ' + url);
  }
  if (me.method != 'POST') {
    Ext.log.warn('Binary data can only be sent as a POST request: ' + url);
  }
}, overrideMimeType:function(mimeType) {
  this.mimeType = mimeType;
}, send:function(body) {
  var me = this;
  me.body = body;
  if (!Ext.data.flash.BinaryXhr.flashPluginActive) {
    Ext.GlobalEvents.addListener('flashready', me.onFlashReady, me);
  } else {
    this.onFlashReady();
  }
}, onFlashReady:function() {
  var me = this, req, status;
  me.javascriptId = Ext.data.flash.BinaryXhr.registerConnection(me);
  req = {method:me.method, url:me.url, user:me.user, password:me.password, mimeType:me.mimeType, requestHeaders:me.requestHeaders, body:me.body, javascriptId:me.javascriptId};
  status = Ext.data.flash.BinaryXhr.flashPlugin.postBinary(req);
}, setReadyState:function(state) {
  var me = this;
  if (me.readyState != state) {
    me.readyState = state;
    me.onreadystatechange();
  }
}, setRequestHeader:function(header, value) {
  this.requestHeaders[header] = value;
}, onreadystatechange:Ext.emptyFn, parseData:function(data) {
  var me = this;
  this.status = data.status || 0;
  me.responseHeaders = {};
  if (me.mimeType) {
    me.responseHeaders['content-type'] = me.mimeType;
  }
  if (data.reason == 'complete') {
    this.responseBytes = data.data;
    me.responseHeaders['content-length'] = data.data.length;
  } else {
    if (data.reason == 'error' || data.reason == 'securityError') {
      this.statusText = data.text;
      me.responseHeaders['content-length'] = 0;
    } else {
      Ext.raise('Unkown reason code in data: ' + data.reason);
    }
  }
}, onFlashStateChange:function(state, data) {
  var me = this;
  if (state == 4) {
    me.parseData(data);
    delete Ext.data.flash.BinaryXhr.liveConnections[me.javascriptId];
  }
  me.setReadyState(state);
}});
Ext.define('Ext.data.request.Ajax', {extend:Ext.data.request.Base, alias:'request.ajax', statics:{parseStatus:function(status, response) {
  var type, len;
  if (response) {
    type = response.responseType;
    if (type === 'arraybuffer') {
      len = response.byteLength;
    } else {
      if (type === 'blob') {
        len = response.response.size;
      } else {
        if (type === 'json' || type === 'document') {
          len = 0;
        } else {
          if ((type === 'text' || type === '' || !type) && response.responseText) {
            len = response.responseText.length;
          }
        }
      }
    }
  }
  status = status == 1223 ? 204 : status;
  var success = status >= 200 && status < 300 || status == 304 || status == 0 && Ext.isNumber(len), isException = false;
  if (!success) {
    switch(status) {
      case 12002:
      case 12029:
      case 12030:
      case 12031:
      case 12152:
      case 13030:
        isException = true;
        break;
    }
  }
  return {success:success, isException:isException};
}}, start:function(data) {
  var me = this, options = me.options, requestOptions = me.requestOptions, isXdr = me.isXdr, xhr, headers;
  xhr = me.xhr = me.openRequest(options, requestOptions, me.async, me.username, me.password);
  if (!isXdr) {
    headers = me.setupHeaders(xhr, options, requestOptions.data, requestOptions.params);
  }
  if (me.async) {
    if (!isXdr) {
      xhr.onreadystatechange = me.bindStateChange();
    }
  }
  if (isXdr) {
    me.processXdrRequest(me, xhr);
  }
  me.callParent([data]);
  xhr.send(data);
  if (!me.async) {
    return me.onComplete();
  }
  return me;
}, abort:function(force) {
  var me = this, xhr = me.xhr;
  if (force || me.isLoading()) {
    try {
      xhr.onreadystatechange = null;
    } catch (e$12) {
      xhr.onreadystatechange = Ext.emptyFn;
    }
    xhr.abort();
    me.callParent([force]);
    me.onComplete();
    me.cleanup();
  }
}, cleanup:function() {
  this.xhr = null;
  delete this.xhr;
}, isLoading:function() {
  var me = this, xhr = me.xhr, state = xhr && xhr.readyState, C = Ext.data.flash && Ext.data.flash.BinaryXhr;
  if (!xhr || me.aborted || me.timedout) {
    return false;
  }
  if (C && xhr instanceof C) {
    return state !== 4;
  }
  return state !== 0 && state !== 4;
}, openRequest:function(options, requestOptions, async, username, password) {
  var me = this, xhr = me.newRequest(options);
  if (username) {
    xhr.open(requestOptions.method, requestOptions.url, async, username, password);
  } else {
    if (me.isXdr) {
      xhr.open(requestOptions.method, requestOptions.url);
    } else {
      xhr.open(requestOptions.method, requestOptions.url, async);
    }
  }
  if (options.binary || me.binary) {
    if (window.Uint8Array) {
      xhr.responseType = 'arraybuffer';
    } else {
      if (xhr.overrideMimeType) {
        xhr.overrideMimeType('text/plain; charset\x3dx-user-defined');
      } else {
        if (!Ext.isIE) {
          Ext.log.warn('Your browser does not support loading binary data using Ajax.');
        }
      }
    }
  }
  if (options.responseType) {
    xhr.responseType = options.responseType;
  }
  if (options.withCredentials || me.withCredentials) {
    xhr.withCredentials = true;
  }
  return xhr;
}, newRequest:function(options) {
  var me = this, xhr;
  if (options.binaryData) {
    if (window.Uint8Array) {
      xhr = me.getXhrInstance();
    } else {
      xhr = new Ext.data.flash.BinaryXhr;
    }
  } else {
    if (me.cors && Ext.isIE9m) {
      xhr = me.getXdrInstance();
      me.isXdr = true;
    } else {
      xhr = me.getXhrInstance();
      me.isXdr = false;
    }
  }
  return xhr;
}, setupHeaders:function(xhr, options, data, params) {
  var me = this, headers = Ext.apply({}, options.headers || {}, me.defaultHeaders), contentType = me.defaultPostHeader, jsonData = options.jsonData, xmlData = options.xmlData, type = 'Content-Type', useHeader = me.useDefaultXhrHeader, key, header;
  if (!headers.hasOwnProperty(type) && (data || params)) {
    if (data) {
      if (options.rawData) {
        contentType = 'text/plain';
      } else {
        if (xmlData && Ext.isDefined(xmlData)) {
          contentType = 'text/xml';
        } else {
          if (jsonData && Ext.isDefined(jsonData)) {
            contentType = 'application/json';
          }
        }
      }
    }
    headers[type] = contentType;
  }
  if (useHeader && !headers['X-Requested-With']) {
    headers['X-Requested-With'] = me.defaultXhrHeader;
  }
  if (headers[type] === undefined || headers[type] === null) {
    delete headers[type];
  }
  try {
    for (key in headers) {
      if (headers.hasOwnProperty(key)) {
        header = headers[key];
        xhr.setRequestHeader(key, header);
      }
    }
  } catch (e$13) {
    me.owner.fireEvent('exception', key, header);
  }
  return headers;
}, getXdrInstance:function() {
  var xdr;
  if (Ext.ieVersion >= 8) {
    xdr = new XDomainRequest;
  } else {
    Ext.raise({msg:'Your browser does not support CORS'});
  }
  return xdr;
}, getXhrInstance:function() {
  return new XMLHttpRequest;
}, processXdrRequest:function(request, xhr) {
  var me = this;
  delete request.headers;
  request.contentType = request.options.contentType || me.defaultXdrContentType;
  xhr.onload = me.bindStateChange(true);
  xhr.onerror = xhr.ontimeout = me.bindStateChange(false);
}, processXdrResponse:function(response, xhr) {
  response.getAllResponseHeaders = function() {
    return [];
  };
  response.getResponseHeader = function() {
    return '';
  };
  response.contentType = xhr.contentType || this.defaultXdrContentType;
}, bindStateChange:function(xdrResult) {
  var me = this;
  return function() {
    Ext.elevate(function() {
      me.onStateChange(xdrResult);
    });
  };
}, onStateChange:function(xdrResult) {
  var me = this, xhr = me.xhr;
  if (xhr && xhr.readyState == 4 || me.isXdr) {
    me.clearTimer();
    me.onComplete(xdrResult);
    me.cleanup();
  }
}, onComplete:function(xdrResult) {
  var me = this, owner = me.owner, options = me.options, xhr = me.xhr, failure = {success:false, isException:false}, result, success, response;
  if (!xhr || me.destroyed) {
    return me.result = failure;
  }
  try {
    result = Ext.data.request.Ajax.parseStatus(xhr.status, xhr);
    if (result.success) {
      result.success = xhr.readyState === 4;
    }
  } catch (e$14) {
    result = failure;
  }
  success = me.success = me.isXdr ? xdrResult : result.success;
  if (success) {
    response = me.createResponse(xhr);
    if (owner.hasListeners.requestcomplete) {
      owner.fireEvent('requestcomplete', owner, response, options);
    }
    if (options.success) {
      Ext.callback(options.success, options.scope, [response, options]);
    }
  } else {
    if (result.isException || me.aborted || me.timedout) {
      response = me.createException(xhr);
    } else {
      response = me.createResponse(xhr);
    }
    if (owner.hasListeners.requestexception) {
      owner.fireEvent('requestexception', owner, response, options);
    }
    if (options.failure) {
      Ext.callback(options.failure, options.scope, [response, options]);
    }
  }
  me.result = response;
  if (options.callback) {
    Ext.callback(options.callback, options.scope, [options, success, response]);
  }
  owner.onRequestComplete(me);
  me.callParent([xdrResult]);
  return response;
}, createResponse:function(xhr) {
  var me = this, isXdr = me.isXdr, headers = {}, lines = isXdr ? [] : xhr.getAllResponseHeaders().replace(/\r\n/g, '\n').split('\n'), count = lines.length, line, index, key, response, byteArray;
  while (count--) {
    line = lines[count];
    index = line.indexOf(':');
    if (index >= 0) {
      key = line.substr(0, index).toLowerCase();
      if (line.charAt(index + 1) == ' ') {
        ++index;
      }
      headers[key] = line.substr(index + 1);
    }
  }
  response = {request:me, requestId:me.id, status:xhr.status, statusText:xhr.statusText, getResponseHeader:function(header) {
    return headers[header.toLowerCase()];
  }, getAllResponseHeaders:function() {
    return headers;
  }};
  if (isXdr) {
    me.processXdrResponse(response, xhr);
  }
  if (me.binary) {
    response.responseBytes = me.getByteArray(xhr);
  } else {
    if (xhr.responseType) {
      response.responseType = xhr.responseType;
    }
    if (xhr.responseType === 'blob') {
      response.responseBlob = xhr.response;
    } else {
      if (xhr.responseType === 'json') {
        response.responseJson = xhr.response;
      } else {
        if (xhr.responseType === 'document') {
          response.responseXML = xhr.response;
        } else {
          response.responseText = xhr.responseText;
          response.responseXML = xhr.responseXML;
        }
      }
    }
  }
  return response;
}, destroy:function() {
  this.xhr = null;
  this.callParent();
}, privates:{getByteArray:function(xhr) {
  var response = xhr.response, responseBody = xhr.responseBody, Cls = Ext.data.flash && Ext.data.flash.BinaryXhr, byteArray, responseText, len, i;
  if (xhr instanceof Cls) {
    byteArray = xhr.responseBytes;
  } else {
    if (window.Uint8Array) {
      byteArray = response ? new Uint8Array(response) : [];
    } else {
      if (Ext.isIE9p) {
        try {
          byteArray = (new VBArray(responseBody)).toArray();
        } catch (e$15) {
          byteArray = [];
        }
      } else {
        if (Ext.isIE) {
          if (!this.self.vbScriptInjected) {
            this.injectVBScript();
          }
          getIEByteArray(xhr.responseBody, byteArray = []);
        } else {
          byteArray = [];
          responseText = xhr.responseText;
          len = responseText.length;
          for (i = 0; i < len; i++) {
            byteArray.push(responseText.charCodeAt(i) & 255);
          }
        }
      }
    }
  }
  return byteArray;
}, injectVBScript:function() {
  var scriptTag = document.createElement('script');
  scriptTag.type = 'text/vbscript';
  scriptTag.text = ['Function getIEByteArray(byteArray, out)', 'Dim len, i', 'len \x3d LenB(byteArray)', 'For i \x3d 1 to len', 'out.push(AscB(MidB(byteArray, i, 1)))', 'Next', 'End Function'].join('\n');
  Ext.getHead().dom.appendChild(scriptTag);
  this.self.vbScriptInjected = true;
}}});
Ext.define('Ext.data.request.Form', {extend:Ext.data.request.Base, alias:'request.form', start:function(data) {
  var me = this, options = me.options, requestOptions = me.requestOptions;
  me.callParent([data]);
  me.form = me.upload(options.form, requestOptions.url, requestOptions.data, options);
  return me;
}, abort:function(force) {
  var me = this, frame;
  if (me.isLoading()) {
    try {
      frame = me.frame.dom;
      if (frame.stop) {
        frame.stop();
      } else {
        frame.document.execCommand('Stop');
      }
    } catch (e$16) {
    }
  }
  me.callParent([force]);
  me.onComplete();
  me.cleanup();
}, cleanup:function() {
  var me = this, frame = me.frame;
  if (frame) {
    frame.un('load', me.onComplete, me);
    Ext.removeNode(frame);
  }
  me.frame = me.form = null;
}, isLoading:function() {
  return !!this.frame;
}, upload:function(form, url, params, options) {
  form = Ext.getDom(form);
  options = options || {};
  var frameDom = document.createElement('iframe'), frame = Ext.get(frameDom), id = frame.id, hiddens = [], encoding = 'multipart/form-data', buf = {target:form.target, method:form.method, encoding:form.encoding, enctype:form.enctype, action:form.action}, addField = function(name, value) {
    hiddenItem = document.createElement('input');
    Ext.fly(hiddenItem).set({type:'hidden', value:value, name:name});
    form.appendChild(hiddenItem);
    hiddens.push(hiddenItem);
  }, hiddenItem, obj, value, name, vLen, v, hLen, h;
  frame.set({name:id, cls:Ext.baseCSSPrefix + 'hidden-display', src:Ext.SSL_SECURE_URL, tabIndex:-1});
  document.body.appendChild(frameDom);
  document.body.appendChild(form);
  if (document.frames) {
    document.frames[id].name = id;
  }
  Ext.fly(form).set({target:id, method:'POST', enctype:encoding, encoding:encoding, action:url || buf.action});
  if (params) {
    obj = Ext.Object.fromQueryString(params) || {};
    for (name in obj) {
      if (obj.hasOwnProperty(name)) {
        value = obj[name];
        if (Ext.isArray(value)) {
          vLen = value.length;
          for (v = 0; v < vLen; v++) {
            addField(name, value[v]);
          }
        } else {
          addField(name, value);
        }
      }
    }
  }
  this.frame = frame;
  frame.on({load:this.onComplete, scope:this, single:!Ext.isOpera});
  form.submit();
  document.body.removeChild(form);
  Ext.fly(form).set(buf);
  for (hLen = hiddens.length, h = 0; h < hLen; h++) {
    Ext.removeNode(hiddens[h]);
  }
  return form;
}, getDoc:function() {
  var frame = this.frame.dom;
  return frame && (frame.contentWindow.document || frame.contentDocument) || (window.frames[frame.id] || {}).document;
}, getTimeout:function() {
  return this.options.timeout;
}, onComplete:function() {
  var me = this, frame = me.frame, owner = me.owner, options = me.options, callback, doc, success, contentNode, response;
  if (!frame) {
    return;
  }
  if (me.aborted || me.timedout) {
    me.result = response = me.createException();
    response.responseXML = null;
    response.responseText = Ext.encode({success:false, message:Ext.String.trim(response.statusText)});
    response.request = me;
    callback = options.failure;
    success = false;
  } else {
    try {
      doc = me.getDoc();
      me.result = response = {responseText:'', responseXML:null, request:me};
      if (doc) {
        if (Ext.isOpera && doc.location == Ext.SSL_SECURE_URL) {
          return;
        }
        if (doc.body) {
          if ((contentNode = doc.body.firstChild) && /pre/i.test(contentNode.tagName)) {
            response.responseText = contentNode.textContent || contentNode.innerText;
          } else {
            if (contentNode = doc.getElementsByTagName('textarea')[0]) {
              response.responseText = contentNode.value;
            } else {
              response.responseText = doc.body.textContent || doc.body.innerText;
            }
          }
        }
        response.responseXML = doc.XMLDocument || doc;
        callback = options.success;
        success = true;
        response.status = 200;
      } else {
        Ext.raise('Could not acquire a suitable connection for the file upload service.');
      }
    } catch (e$17) {
      me.result = response = me.createException();
      response.status = 400;
      response.statusText = (e$17.message || e$17.description) + '';
      response.responseText = Ext.encode({success:false, message:Ext.String.trim(response.statusText)});
      response.responseXML = null;
      callback = options.failure;
      success = false;
    }
  }
  me.frame = null;
  me.success = success;
  owner.fireEvent(success ? 'requestcomplete' : 'requestexception', owner, response, options);
  Ext.callback(callback, options.scope, [response, options]);
  Ext.callback(options.callback, options.scope, [options, success, response]);
  owner.onRequestComplete(me);
  Ext.asap(frame.destroy, frame);
  me.callParent();
}, destroy:function() {
  this.cleanup();
  this.callParent();
}});
Ext.define('Ext.data.Connection', {mixins:{observable:Ext.mixin.Observable}, statics:{requestId:0}, enctypeRe:/multipart\/form-data/i, config:{url:null, async:true, username:'', password:'', disableCaching:true, withCredentials:false, binary:false, cors:false, isXdr:false, defaultXdrContentType:'text/plain', disableCachingParam:'_dc', timeout:30000, extraParams:null, autoAbort:false, method:null, defaultHeaders:null, defaultPostHeader:'application/x-www-form-urlencoded; charset\x3dUTF-8', useDefaultXhrHeader:true, 
defaultXhrHeader:'XMLHttpRequest'}, constructor:function(config) {
  this.mixins.observable.constructor.call(this, config);
  this.requests = {};
}, request:function(options) {
  options = options || {};
  var me = this, requestOptions, request;
  if (me.fireEvent('beforerequest', me, options) !== false) {
    requestOptions = me.setOptions(options, options.scope || Ext.global);
    request = me.createRequest(options, requestOptions);
    return request.start(requestOptions.data);
  }
  request = {status:-1, statusText:'Request cancelled in beforerequest event handler'};
  Ext.callback(options.callback, options.scope, [options, false, request]);
  return Ext.Deferred.rejected([options, false, request]);
}, createRequest:function(options, requestOptions) {
  var me = this, type = options.type || requestOptions.type, request;
  if (!type) {
    type = me.isFormUpload(options) ? 'form' : 'ajax';
  }
  if (options.autoAbort || me.getAutoAbort()) {
    me.abort();
  }
  request = Ext.Factory.request({type:type, owner:me, options:options, requestOptions:requestOptions, ownerConfig:me.getConfig()});
  me.requests[request.id] = request;
  me.latestId = request.id;
  return request;
}, isFormUpload:function(options) {
  var form = this.getForm(options);
  if (form) {
    return options.isUpload || this.enctypeRe.test(form.getAttribute('enctype'));
  }
  return false;
}, getForm:function(options) {
  return Ext.getDom(options.form);
}, setOptions:function(options, scope) {
  var me = this, params = options.params || {}, extraParams = me.getExtraParams(), urlParams = options.urlParams, url = options.url || me.getUrl(), cors = options.cors, jsonData = options.jsonData, method, disableCache, data;
  if (cors !== undefined) {
    me.setCors(cors);
  }
  if (Ext.isFunction(params)) {
    params = params.call(scope, options);
  }
  if (Ext.isFunction(url)) {
    url = url.call(scope, options);
  }
  url = this.setupUrl(options, url);
  if (!url) {
    Ext.raise({options:options, msg:'No URL specified'});
  }
  data = options.rawData || options.binaryData || options.xmlData || jsonData || null;
  if (jsonData && !Ext.isPrimitive(jsonData)) {
    data = Ext.encode(data);
  }
  if (options.binaryData) {
    if (!Ext.isArray(options.binaryData)) {
      Ext.log.warn('Binary submission data must be an array of byte values! Instead got ' + typeof options.binaryData);
    }
    if (me.nativeBinaryPostSupport()) {
      data = new Uint8Array(options.binaryData);
      if (Ext.isChrome && Ext.chromeVersion < 22 || Ext.isSafari || Ext.isGecko) {
        data = data.buffer;
      }
    }
  }
  if (Ext.isObject(params)) {
    params = Ext.Object.toQueryString(params);
  }
  if (Ext.isObject(extraParams)) {
    extraParams = Ext.Object.toQueryString(extraParams);
  }
  params = params + (extraParams ? (params ? '\x26' : '') + extraParams : '');
  urlParams = Ext.isObject(urlParams) ? Ext.Object.toQueryString(urlParams) : urlParams;
  params = this.setupParams(options, params);
  method = (options.method || me.getMethod() || (params || data ? 'POST' : 'GET')).toUpperCase();
  this.setupMethod(options, method);
  disableCache = options.disableCaching !== false ? options.disableCaching || me.getDisableCaching() : false;
  if (method === 'GET' && disableCache) {
    url = Ext.urlAppend(url, (options.disableCachingParam || me.getDisableCachingParam()) + '\x3d' + (new Date).getTime());
  }
  if ((method == 'GET' || data) && params) {
    url = Ext.urlAppend(url, params);
    params = null;
  }
  if (urlParams) {
    url = Ext.urlAppend(url, urlParams);
  }
  return {url:url, method:method, data:data || params || null};
}, setupUrl:function(options, url) {
  var form = this.getForm(options);
  if (form) {
    url = url || form.action;
  }
  return url;
}, setupParams:function(options, params) {
  var form = this.getForm(options), serializedForm;
  if (form && !this.isFormUpload(options)) {
    serializedForm = Ext.Element.serializeForm(form);
    params = params ? params + '\x26' + serializedForm : serializedForm;
  }
  return params;
}, setupMethod:function(options, method) {
  if (this.isFormUpload(options)) {
    return 'POST';
  }
  return method;
}, isLoading:function(request) {
  if (!request) {
    request = this.getLatest();
  }
  return request ? request.isLoading() : false;
}, abort:function(request) {
  if (!request) {
    request = this.getLatest();
  }
  if (request && request.isLoading()) {
    request.abort();
  }
}, abortAll:function() {
  var requests = this.requests, id;
  for (id in requests) {
    this.abort(requests[id]);
  }
}, getLatest:function() {
  var id = this.latestId, request;
  if (id) {
    request = this.requests[id];
  }
  return request || null;
}, clearTimeout:function(request) {
  if (!request) {
    request = this.getLatest();
  }
  if (request) {
    request.clearTimer();
  }
}, onRequestComplete:function(request) {
  delete this.requests[request.id];
}, nativeBinaryPostSupport:function() {
  return Ext.isChrome || Ext.isSafari && Ext.isDefined(window.Uint8Array) || Ext.isGecko && Ext.isDefined(window.Uint8Array);
}});
Ext.define('Ext.Ajax', {extend:Ext.data.Connection, singleton:true, autoAbort:false});
Ext.define('Ext.AnimationQueue', {singleton:true, constructor:function() {
  var me = this;
  me.queue = [];
  me.taskQueue = [];
  me.runningQueue = [];
  me.idleQueue = [];
  me.isRunning = false;
  me.isIdle = true;
  me.run = me.run.bind(me);
  if (Ext.os.is.iOS) {
    me.watch.$skipTimerCheck = true;
    me.watchdogTimer = Ext.interval(me.watch, 500, me);
  }
}, start:function(fn, scope, args) {
  var me = this;
  me.queue.push(arguments);
  if (!me.isRunning) {
    if (me.hasOwnProperty('idleTimer')) {
      Ext.undefer(me.idleTimer);
      delete me.idleTimer;
    }
    if (me.hasOwnProperty('idleQueueTimer')) {
      Ext.undefer(me.idleQueueTimer);
      delete me.idleQueueTimer;
    }
    me.isIdle = false;
    me.isRunning = true;
    me.startCountTime = Ext.now();
    me.count = 0;
    me.doStart();
  }
}, clear:function() {
  var me = this;
  Ext.undefer(me.idleTimer);
  Ext.undefer(me.idleQueueTimer);
  Ext.unraf(me.animationFrameId);
  me.idleTimer = me.idleQueueTimer = me.animationFrameId = null;
  me.queue.length = me.taskQueue.length = me.runningQueue.length = me.idleQueue.length = 0;
  me.isRunning = false;
  me.isIdle = true;
  me.startCountTime = Ext.now();
  me.count = 0;
}, watch:function() {
  if (this.isRunning && Ext.now() - this.lastRunTime >= 500) {
    this.run();
  }
}, run:function() {
  var me = this, item, element;
  me.animationFrameId = null;
  if (!me.isRunning) {
    return;
  }
  var queue = me.runningQueue, now = Ext.now(), i, ln;
  me.lastRunTime = now;
  me.frameStartTime = now;
  i = me.queue.length;
  while (i--) {
    item = me.queue[i];
    element = item[1] && item[1].getElement && item[1].getElement();
    if (element && element.destroyed) {
      me.queue.splice(i, 1);
    }
  }
  queue.push.apply(queue, me.queue);
  for (i = 0, ln = queue.length; i < ln; i++) {
    me.invoke(queue[i]);
  }
  queue.length = 0;
  var elapse = me.frameStartTime - me.startCountTime, count = ++me.count;
  if (elapse >= 200) {
    me.onFpsChanged(count * 1000 / elapse, count, elapse);
    me.startCountTime = me.frameStartTime;
    me.count = 0;
  }
  if (!me.queue.length) {
    me.stop();
  }
  if (me.isRunning) {
    me.doIterate();
  }
}, onFpsChanged:Ext.emptyFn, onStop:Ext.emptyFn, doStart:function() {
  if (!this.animationFrameId) {
    this.animationFrameId = Ext.raf(this.run);
  }
  this.lastRunTime = Ext.now();
}, doIterate:function() {
  if (!this.animationFrameId) {
    this.animationFrameId = Ext.raf(this.run);
  }
}, doStop:function() {
  if (this.animationFrameId) {
    Ext.unraf(this.animationFrameId);
  }
  this.animationFrameId = null;
}, stop:function(fn, scope, args) {
  var me = this;
  if (!me.isRunning) {
    return;
  }
  var queue = me.queue, ln = queue.length, i, item;
  for (i = 0; i < ln; i++) {
    item = queue[i];
    if (item[0] === fn && item[1] === scope && item[2] === args) {
      queue.splice(i, 1);
      i--;
      ln--;
    }
  }
  if (ln === 0) {
    me.doStop();
    me.onStop();
    me.isRunning = false;
    if (me.idleQueue.length && !me.idleTimer) {
      me.idleTimer = Ext.defer(me.whenIdle, 100, me);
    }
  }
}, onIdle:function(fn, scope, args) {
  var me = this, listeners = me.idleQueue, i, ln, listener;
  for (i = 0, ln = listeners.length; i < ln; i++) {
    listener = listeners[i];
    if (fn === listener[0] && scope === listener[1] && args === listener[2]) {
      return;
    }
  }
  listeners.push(arguments);
  if (me.isIdle) {
    me.processIdleQueue();
  } else {
    if (!me.idleTimer) {
      me.idleTimer = Ext.defer(me.whenIdle, 100, me);
    }
  }
}, unIdle:function(fn, scope, args) {
  var me = this, listeners = me.idleQueue, i, ln, listener;
  for (i = 0, ln = listeners.length; i < ln; i++) {
    listener = listeners[i];
    if (fn === listener[0] && scope === listener[1] && args === listener[2]) {
      listeners.splice(i, 1);
      return true;
    }
  }
  if (!listeners.length && me.idleTimer) {
    Ext.undefer(me.idleTimer);
    delete me.idleTimer;
  }
  if (!listeners.length && me.idleQueueTimer) {
    Ext.undefer(me.idleQueueTimer);
    delete me.idleQueueTimer;
  }
  return false;
}, queueTask:function(fn, scope, args) {
  this.taskQueue.push(arguments);
  this.processTaskQueue();
}, dequeueTask:function(fn, scope, args) {
  var listeners = this.taskQueue, i, ln, listener;
  for (i = 0, ln = listeners.length; i < ln; i++) {
    listener = listeners[i];
    if (fn === listener[0] && scope === listener[1] && args === listener[2]) {
      listeners.splice(i, 1);
      i--;
      ln--;
    }
  }
}, invoke:function(listener) {
  var fn = listener[0], scope = listener[1], args = listener[2];
  fn = typeof fn == 'string' ? scope[fn] : fn;
  if (Ext.isArray(args)) {
    fn.apply(scope, args);
  } else {
    fn.call(scope, args);
  }
}, whenIdle:function() {
  delete this.idleTimer;
  this.isIdle = true;
  this.processIdleQueue();
}, processIdleQueue:function() {
  if (!this.hasOwnProperty('idleQueueTimer')) {
    this.idleQueueTimer = Ext.defer(this.processIdleQueueItem, 1, this);
  }
}, processIdleQueueItem:function() {
  delete this.idleQueueTimer;
  if (!this.isIdle) {
    return;
  }
  var listeners = this.idleQueue, listener;
  if (listeners.length > 0) {
    listener = listeners.shift();
    this.invoke(listener);
    this.processIdleQueue();
  }
}, processTaskQueue:function() {
  if (!this.hasOwnProperty('taskQueueTimer')) {
    this.taskQueueTimer = Ext.defer(this.processTaskQueueItem, 15, this);
  }
}, processTaskQueueItem:function() {
  delete this.taskQueueTimer;
  var listeners = this.taskQueue, listener;
  if (listeners.length > 0) {
    listener = listeners.shift();
    this.invoke(listener);
    this.processTaskQueue();
  }
}, showFps:function() {
  var styleTpl = {color:'white', 'background-color':'black', 'text-align':'center', 'font-family':'sans-serif', 'font-size':'8px', 'font-weight':'normal', 'font-style':'normal', 'line-height':'20px', '-webkit-font-smoothing':'antialiased', 'zIndex':100000, position:'absolute'};
  Ext.getBody().append([{style:Ext.applyIf({bottom:'50px', left:0, width:'50px', height:'20px'}, styleTpl), html:'Average'}, {style:Ext.applyIf({'background-color':'red', 'font-size':'18px', 'line-height':'50px', bottom:0, left:0, width:'50px', height:'50px'}, styleTpl), id:'__averageFps', html:'0'}, {style:Ext.applyIf({bottom:'50px', left:'50px', width:'50px', height:'20px'}, styleTpl), html:'Min (Last 1k)'}, {style:Ext.applyIf({'background-color':'orange', 'font-size':'18px', 'line-height':'50px', 
  bottom:0, left:'50px', width:'50px', height:'50px'}, styleTpl), id:'__minFps', html:'0'}, {style:Ext.applyIf({bottom:'50px', left:'100px', width:'50px', height:'20px'}, styleTpl), html:'Max (Last 1k)'}, {style:Ext.applyIf({'background-color':'maroon', 'font-size':'18px', 'line-height':'50px', bottom:0, left:'100px', width:'50px', height:'50px'}, styleTpl), id:'__maxFps', html:'0'}, {style:Ext.applyIf({bottom:'50px', left:'150px', width:'50px', height:'20px'}, styleTpl), html:'Current'}, {style:Ext.applyIf({'background-color':'green', 
  'font-size':'18px', 'line-height':'50px', bottom:0, left:'150px', width:'50px', height:'50px'}, styleTpl), id:'__currentFps', html:'0'}]);
  Ext.AnimationQueue.resetFps();
}, resetFps:function() {
  var currentFps = Ext.get('__currentFps'), averageFps = Ext.get('__averageFps'), minFps = Ext.get('__minFps'), maxFps = Ext.get('__maxFps'), min = 1000, max = 0, count = 0, sum = 0;
  if (!currentFps) {
    return;
  }
  Ext.AnimationQueue.onFpsChanged = function(fps) {
    count++;
    if (!(count % 10)) {
      min = 1000;
      max = 0;
    }
    sum += fps;
    min = Math.min(min, fps);
    max = Math.max(max, fps);
    currentFps.setHtml(Math.round(fps));
    averageFps.setHtml(Math.round(sum / count));
    minFps.setHtml(Math.round(min));
    maxFps.setHtml(Math.round(max));
  };
}}, function() {
  var paramsString = window.location.search.substr(1), paramsArray = paramsString.split('\x26');
  if (Ext.Array.contains(paramsArray, 'showfps')) {
    Ext.onReady(this.showFps.bind(this));
  }
});
Ext.define('Ext.mixin.Bufferable', function(Bufferable) {
  return {extend:Ext.Mixin, mixinConfig:{id:'bufferable', before:{destroy:'cancelAllCalls'}, extended:function(baseClass, derivedClass, classBody) {
    var bufferableMethods = classBody.bufferableMethods;
    if (bufferableMethods) {
      delete classBody.bufferableMethods;
      Bufferable.processClass(derivedClass, bufferableMethods);
    }
  }}, afterClassMixedIn:function(targetClass) {
    Bufferable.processClass(targetClass);
  }, privates:{cancelAllCalls:function() {
    var bufferables = this.bufferables, name;
    if (bufferables) {
      for (name in bufferables) {
        bufferables[name].cancel();
        delete bufferables[name];
      }
    }
  }, cancelBufferedCall:function(name, invoke) {
    var bufferables = this.bufferables, timer = bufferables && bufferables[name];
    if (timer) {
      timer[invoke ? 'invoke' : 'cancel']();
    }
    return !!timer;
  }, flushBufferedCall:function(name) {
    return this.cancelBufferedCall(name, true);
  }, initBufferables:function() {
    var me = this, methods = me.hasOwnProperty('bufferableMethods') && me.bufferableMethods, classMethods;
    if (methods) {
      Bufferable._canonicalize(methods);
      classMethods = me.self.prototype.bufferableMethods;
      me.bufferableMethods = Ext.merge(Ext.clone(classMethods), methods);
    }
    return me.bufferables = {};
  }, isCallPending:function(name) {
    var bufferables = this.bufferables, timer = bufferables && bufferables[name];
    return !!timer;
  }, statics:{SINGLE:{single:true}, _canonicalize:function(methods) {
    var t, def, s, name;
    for (name in methods) {
      s = Ext.String.capitalize(name);
      def = methods[name];
      t = typeof def;
      if (t === 'number' || t === 'string') {
        methods[name] = def = {delay:def};
      }
      if (typeof(t = def.delay) === 'string') {
        def[t] = true;
        delete def.delay;
      }
      def.capitalized = s;
      def.name = name;
      if (!def.fn) {
        def.fn = 'do' + s;
      }
      if (!def.flag) {
        def.flag = 'is' + s + 'Pending';
      }
    }
  }, _canceller:function() {
    var timer = this, id = timer.id;
    if (id) {
      if (timer.delay) {
        Ext.undefer(id);
      } else {
        if (timer.asap) {
          Ext.unasap(id);
        } else {
          if (timer.idle) {
            Ext.un('idle', id, null, Bufferable.SINGLE);
          } else {
            if (timer.raf) {
              Ext.unraf(id);
            }
          }
        }
      }
      timer.id = null;
    }
    timer.args = null;
    timer.target[timer.flag] = false;
  }, _invoker:function() {
    var timer = this, args = timer.args || Ext.emptyArray, target = timer.target;
    ++timer.invokes;
    timer.cancel();
    target[timer.fn].apply(target, args);
  }, delayCall:function(target, def, args) {
    var bufferables = target.bufferables || target.initBufferables(), name = def.name, timer = bufferables[name] || (bufferables[name] = Ext.apply({calls:0, invokes:0, args:null, cancel:Bufferable._canceller, id:null, target:target, invoke:Bufferable._invoker}, def)), delay = def.delay, exec = function() {
      if (timer.id) {
        timer.id = null;
        timer.invoke();
      }
    };
    if (timer.id) {
      timer.cancel();
    }
    timer.args = args;
    ++timer.calls;
    target[timer.flag] = true;
    if (delay) {
      timer.id = Ext.defer(exec, delay);
    } else {
      if (def.asap) {
        timer.id = Ext.asap(exec);
      } else {
        if (def.idle) {
          timer.id = exec;
          Ext.on('idle', exec, null, Bufferable.SINGLE);
        } else {
          if (def.raf) {
            timer.id = Ext.raf(exec);
          } else {
            timer.invoke();
          }
        }
      }
    }
  }, processClass:function(cls, bufferableMethods) {
    var proto = cls.prototype, inherited = proto.bufferableMethods, def, name;
    if (bufferableMethods) {
      Bufferable._canonicalize(bufferableMethods);
      if (inherited) {
        inherited = Ext.merge(Ext.clone(inherited), bufferableMethods);
      }
      proto.bufferableMethods = inherited || bufferableMethods;
    } else {
      bufferableMethods = inherited;
      Bufferable._canonicalize(bufferableMethods);
      proto.bufferables = null;
    }
    if (bufferableMethods) {
      for (name in bufferableMethods) {
        if (!proto[name]) {
          def = bufferableMethods[name];
          Bufferable.processMethod(proto, def, Array.prototype.slice);
        }
      }
    }
  }, processMethod:function(proto, def, slice) {
    var name = def.name, cap = def.capitalized;
    proto[name] = function() {
      return Bufferable.delayCall(this, def, slice.call(arguments));
    };
    proto['cancel' + cap] = function() {
      return this.cancelBufferedCall(name);
    };
    proto['flush' + cap] = function() {
      return this.flushBufferedCall(name);
    };
  }}}};
});
Ext.define('Ext.ComponentManager', {alternateClassName:'Ext.ComponentMgr', singleton:true, mixins:[Ext.mixin.Bufferable], count:0, referencesDirty:true, referenceRepairs:0, typeName:'xtype', bufferableMethods:{handleDocumentMouseDown:'asap'}, constructor:function(config) {
  var me = this;
  Ext.apply(me, config);
  me.all = {};
  me.byInstanceId = {};
  me.holders = {};
  me.names = {};
  me.references = {};
  me.onAvailableCallbacks = {};
}, create:function(config, defaultType) {
  if (typeof config === 'string') {
    return Ext.widget(config);
  }
  if (config.isComponent) {
    return config;
  }
  if ('xclass' in config) {
    return Ext.create(config.xclass, config);
  }
  return Ext.widget(config.xtype || defaultType, config);
}, get:function(id) {
  return this.all[id];
}, register:function(component) {
  var me = this, id = component.getId(), onAvailableCallbacks = me.onAvailableCallbacks;
  if (id === undefined) {
    Ext.raise('Component id is undefined. Please ensure the component has an id.');
  }
  if (id in me.all) {
    Ext.raise('Duplicate component id "' + id + '"');
  }
  if (component.$iid in me.byInstanceId) {
    Ext.raise('Duplicate component instance id "' + component.$iid + '"');
  }
  me.all[id] = component;
  me.byInstanceId[component.$iid] = component;
  if (component.reference) {
    me.references[id] = component;
  }
  if (component.name && component.nameable) {
    me.names[id] = component;
  }
  if (component.nameHolder || component.referenceHolder) {
    me.holders[id] = component;
  }
  ++me.count;
  if (!me.hasFocusListener) {
    me.installFocusListener();
  }
  onAvailableCallbacks = onAvailableCallbacks && onAvailableCallbacks[id];
  if (onAvailableCallbacks && onAvailableCallbacks.length) {
    me.notifyAvailable(component);
  }
}, unregister:function(component) {
  var me = this, all = me.all, byInstanceId = me.byInstanceId, holders = me.holders, references = me.references, names = me.names, id = component.getId();
  if (id in holders) {
    holders[id] = null;
    delete holders[id];
  }
  if (id in names) {
    names[id] = null;
    delete names[id];
  }
  if (id in references) {
    references[id] = null;
    delete references[id];
  }
  all[id] = null;
  delete all[id];
  id = component.$iid;
  byInstanceId[id] = null;
  delete byInstanceId[id];
  --me.count;
}, markReferencesDirty:function() {
  var me = this, holders = me.holders, key;
  if (!me.referencesDirty) {
    for (key in holders) {
      holders[key].refs = holders[key].nameRefs = null;
    }
    me.referencesDirty = true;
  }
}, fixReferences:function() {
  var me = this, references = me.references, names = me.names, key;
  if (me.referencesDirty) {
    ++me.referenceRepairs;
    for (key in references) {
      references[key]._fixReference();
    }
    for (key in names) {
      names[key]._fixName();
    }
    me.referencesDirty = false;
  }
}, onAvailable:function(id, fn, scope) {
  var me = this, callbacks = me.onAvailableCallbacks, all = me.all, item;
  if (id in all) {
    item = all[id];
    fn.call(scope || item, item);
  } else {
    if (id) {
      if (!Ext.isArray(callbacks[id])) {
        callbacks[id] = [];
      }
      callbacks[id].push(function(item) {
        fn.call(scope || item, item);
      });
    }
  }
}, notifyAvailable:function(item) {
  var callbacks = this.onAvailableCallbacks[item && item.getId()] || [];
  while (callbacks.length) {
    callbacks.shift()(item);
  }
}, each:function(fn, scope) {
  Ext.Object.each(this.all, fn, scope);
}, getCount:function() {
  return this.count;
}, getAll:function() {
  return Ext.Object.getValues(this.all);
}, getActiveComponent:function() {
  return Ext.Component.from(Ext.dom.Element.getActiveElement());
}, onGlobalFocus:function(e) {
  var me = this, event = e.event, toComponent = event.toComponent = e.toComponent = Ext.Component.from(e.toElement), fromComponent = event.fromComponent = e.fromComponent = Ext.Component.from(e.fromElement), commonAncestor = me.getCommonAncestor(fromComponent, toComponent), targetComponent;
  if (toComponent !== fromComponent) {
    if (fromComponent && !fromComponent.destroyed && !fromComponent.isDestructing()) {
      if (fromComponent.handleBlurEvent) {
        fromComponent.handleBlurEvent(e);
      }
      for (targetComponent = fromComponent; targetComponent && targetComponent !== commonAncestor; targetComponent = targetComponent.getRefOwner()) {
        if (!(targetComponent.destroyed || targetComponent.destroying)) {
          e.type = 'focusleave';
          targetComponent.onFocusLeave(event);
        }
      }
    }
    if (toComponent && !toComponent.destroyed && !toComponent.isDestructing()) {
      if (toComponent.handleFocusEvent) {
        toComponent.handleFocusEvent(e);
      }
      for (targetComponent = toComponent; targetComponent && targetComponent !== commonAncestor; targetComponent = targetComponent.getRefOwner()) {
        e.type = 'focusenter';
        targetComponent.onFocusEnter(event);
      }
    }
  }
  for (targetComponent = commonAncestor; targetComponent; targetComponent = targetComponent.getRefOwner()) {
    if (!(targetComponent.destroying || targetComponent.destroyed)) {
      targetComponent.onFocusMove(e);
    }
  }
}, getCommonAncestor:function(compA, compB) {
  if (compA === compB) {
    return compA;
  }
  while (compA && !(compA.isAncestor(compB) || compA === compB)) {
    compA = compA.getRefOwner();
  }
  return compA;
}, privates:{doHandleDocumentMouseDown:function(e) {
  var floatedSelector = Ext.Widget.prototype.floatedSelector, targetFloated;
  if (floatedSelector) {
    targetFloated = Ext.Component.from(e.getTarget(floatedSelector, Ext.getBody()));
    if (targetFloated) {
      targetFloated.toFront(true);
    }
  }
}, installFocusListener:function() {
  var me = this;
  Ext.on('focus', me.onGlobalFocus, me);
  me.hasFocusListener = true;
}, clearAll:function() {
  this.all = {};
  this.names = {};
  this.references = {};
  this.onAvailableCallbacks = {};
}, from:function(el, limit, selector) {
  if (el && el.isEvent) {
    el = el.target;
  }
  var target = Ext.getDom(el), cache = this.all, depth = 0, topmost, cmpId, cmp;
  if (typeof limit !== 'number') {
    topmost = Ext.getDom(limit);
    limit = Number.MAX_VALUE;
  }
  while (target && target.nodeType === 1 && depth < limit && target !== topmost) {
    cmpId = target.getAttribute('data-componentid') || target.id;
    if (cmpId) {
      cmp = cache[cmpId];
      if (cmp && (!selector || Ext.ComponentQuery.is(cmp, selector))) {
        return cmp;
      }
      depth++;
    }
    target = target.parentNode;
  }
  return null;
}}}, function() {
  var ComponentManager = Ext.ComponentManager;
  ComponentManager.fromElement = ComponentManager.from;
  Ext.getCmp = function(id) {
    return ComponentManager.get(id);
  };
  Ext.iidToCmp = function(iid) {
    return ComponentManager.byInstanceId[iid] || null;
  };
  Ext.doEv = function(node, e) {
    var cmp, method, event;
    cmp = Ext.Component.from(e.target);
    if (cmp && !cmp.destroying && !cmp.destroyed && cmp.getEventHandlers) {
      method = cmp.getEventHandlers()[e.type];
      if (method && cmp[method]) {
        event = new Ext.event.Event(e);
        return cmp[method](event);
      }
    }
    return true;
  };
});
Ext.ns('Ext.util').Operators = {'\x3d':function(a, v) {
  return a == v;
}, '!\x3d':function(a, v) {
  return a != v;
}, '^\x3d':function(a, v) {
  return a && a.substr(0, v.length) == v;
}, '$\x3d':function(a, v) {
  return a && a.substr(a.length - v.length) == v;
}, '*\x3d':function(a, v) {
  return a && a.indexOf(v) !== -1;
}, '%\x3d':function(a, v) {
  return a % v === 0;
}, '|\x3d':function(a, v) {
  return a && (a == v || a.substr(0, v.length + 1) == v + '-');
}, '~\x3d':function(a, v) {
  return a && (' ' + a + ' ').indexOf(' ' + v + ' ') != -1;
}};
Ext.define('Ext.util.LruCache', {extend:Ext.util.HashMap, config:{maxSize:null}, add:function(key, newValue) {
  var me = this, entry, last;
  me.removeAtKey(key);
  last = me.last;
  entry = {prev:last, next:null, key:key, value:newValue};
  if (last) {
    last.next = entry;
  } else {
    me.first = entry;
  }
  me.last = entry;
  me.callParent([key, entry]);
  me.prune();
  return newValue;
}, insertBefore:function(key, newValue, sibling) {
  var me = this, existingKey, entry;
  if (sibling = this.map[this.findKey(sibling)]) {
    existingKey = me.findKey(newValue);
    if (existingKey) {
      me.unlinkEntry(entry = me.map[existingKey]);
    } else {
      entry = {prev:sibling.prev, next:sibling, key:key, value:newValue};
    }
    if (sibling.prev) {
      entry.prev.next = entry;
    } else {
      me.first = entry;
    }
    entry.next = sibling;
    sibling.prev = entry;
    me.prune();
    return newValue;
  } else {
    return me.add(key, newValue);
  }
}, get:function(key) {
  var entry = this.map[key];
  if (entry) {
    if (entry.next) {
      this.moveToEnd(entry);
    }
    return entry.value;
  }
}, removeAtKey:function(key) {
  this.unlinkEntry(this.map[key]);
  return this.callParent(arguments);
}, clear:function(initial) {
  this.first = this.last = null;
  return this.callParent([initial]);
}, unlinkEntry:function(entry) {
  if (entry) {
    if (entry.next) {
      entry.next.prev = entry.prev;
    } else {
      this.last = entry.prev;
    }
    if (entry.prev) {
      entry.prev.next = entry.next;
    } else {
      this.first = entry.next;
    }
    entry.prev = entry.next = null;
  }
}, moveToEnd:function(entry) {
  this.unlinkEntry(entry);
  if (entry.prev = this.last) {
    this.last.next = entry;
  } else {
    this.first = entry;
  }
  this.last = entry;
}, getArray:function(isKey) {
  var arr = [], entry = this.first;
  while (entry) {
    arr.push(isKey ? entry.key : entry.value);
    entry = entry.next;
  }
  return arr;
}, each:function(fn, scope, reverse) {
  var me = this, entry = reverse ? me.last : me.first, length = me.length;
  scope = scope || me;
  while (entry) {
    if (fn.call(scope, entry.key, entry.value, length) === false) {
      break;
    }
    entry = reverse ? entry.prev : entry.next;
  }
  return me;
}, findKey:function(value) {
  var key, map = this.map;
  for (key in map) {
    if (map.hasOwnProperty(key) && map[key].value === value) {
      return key;
    }
  }
  return undefined;
}, clone:function() {
  var newCache = new this.self(this.initialConfig), map = this.map, key;
  newCache.suspendEvents();
  for (key in map) {
    if (map.hasOwnProperty(key)) {
      newCache.add(key, map[key].value);
    }
  }
  newCache.resumeEvents();
  return newCache;
}, prune:function() {
  var me = this, max = me.getMaxSize(), purgeCount = max ? me.length - max : 0;
  if (purgeCount > 0) {
    for (; me.first && purgeCount; purgeCount--) {
      me.removeAtKey(me.first.key);
    }
  }
}});
Ext.define('Ext.ComponentQuery', {singleton:true}, function() {
  var cq = this, queryOperators = Ext.util.Operators, nthRe = /(\d*)n\+?(\d*)/, nthRe2 = /\D/, stripLeadingSpaceRe = /^(\s)+/, unescapeRe = /\\(.)/g, regexCache = new Ext.util.LruCache({maxSize:100}), filterFnPattern = ['var r \x3d [],', 'i \x3d 0,', 'it \x3d items,', 'l \x3d it.length,', 'c;', 'for (; i \x3c l; i++) {', 'c \x3d it[i];', 'if (c.{0}) {', 'r.push(c);', '}', '}', 'return r;'].join(''), filterItems = function(items, operation) {
    return operation.method.apply(this, [items].concat(operation.args));
  }, getItems = function(items, mode) {
    var result = [], i = 0, length = items.length, candidate, deep = mode !== '\x3e';
    for (; i < length; i++) {
      candidate = items[i];
      if (candidate.getRefItems) {
        result = result.concat(candidate.getRefItems(deep));
      }
    }
    return result;
  }, getAncestors = function(items) {
    var result = [], i = 0, length = items.length, candidate;
    for (; i < length; i++) {
      candidate = items[i];
      while (!!(candidate = candidate.getRefOwner())) {
        result.push(candidate);
      }
    }
    return result;
  }, filterByXType = function(items, xtype, shallow) {
    if (xtype === '*') {
      return items.slice();
    } else {
      var result = [], i = 0, length = items.length, candidate;
      for (; i < length; i++) {
        candidate = items[i];
        if (!candidate.destroyed && candidate.isXType(xtype, shallow)) {
          result.push(candidate);
        }
      }
      return result;
    }
  }, filterByAttribute = function(items, property, operator, compareTo) {
    var result = [], i = 0, length = items.length, mustBeOwnProperty, presenceOnly, candidate, propValue, j, propLen, config;
    if (property.charAt(0) === '@') {
      mustBeOwnProperty = true;
      property = property.substr(1);
    }
    if (property.charAt(0) === '?') {
      mustBeOwnProperty = true;
      presenceOnly = true;
      property = property.substr(1);
    }
    for (; i < length; i++) {
      candidate = items[i];
      config = candidate.self && candidate.self.getConfigurator && candidate.self.$config.configs[property];
      if (config) {
        propValue = candidate[config.names.get]();
      } else {
        if (mustBeOwnProperty && !candidate.hasOwnProperty(property)) {
          continue;
        } else {
          propValue = candidate[property];
        }
      }
      if (presenceOnly) {
        result.push(candidate);
      } else {
        if (operator === '~\x3d') {
          if (propValue) {
            if (!Ext.isArray(propValue)) {
              propValue = propValue.split(' ');
            }
            for (j = 0, propLen = propValue.length; j < propLen; j++) {
              if (queryOperators[operator](Ext.coerce(propValue[j], compareTo), compareTo)) {
                result.push(candidate);
                break;
              }
            }
          }
        } else {
          if (operator === '/\x3d') {
            if (propValue != null && compareTo.test(propValue)) {
              result.push(candidate);
            }
          } else {
            if (!compareTo ? !!propValue : queryOperators[operator](Ext.coerce(propValue, compareTo), compareTo)) {
              result.push(candidate);
            }
          }
        }
      }
    }
    return result;
  }, filterById = function(items, id, idOnly) {
    var result = [], i = 0, length = items.length, candidate, check;
    for (; i < length; i++) {
      candidate = items[i];
      check = idOnly ? candidate.id : candidate.getItemId();
      if (check === id) {
        result.push(candidate);
      }
    }
    return result;
  }, filterByPseudo = function(items, name, value) {
    return cq.pseudos[name](items, value);
  }, modeRe = /^(\s?([>\^])\s?|\s|$)/, tokenRe = /^(#)?((?:\\\.|[\w\-])+|\*)(?:\((true|false)\))?/, matchers = [{re:/^\.((?:\\\.|[\w\-])+)(?:\((true|false)\))?/, method:filterByXType, argTransform:function(args) {
    var selector = args[0];
    Ext.log.warn('"' + selector + '" ComponentQuery selector style is deprecated,' + ' use "' + selector.replace(/^\./, '') + '" without the leading dot instead');
    if (args[1] !== undefined) {
      args[1] = args[1].replace(unescapeRe, '$1');
    }
    return args.slice(1);
  }}, {re:/^(?:\[((?:[@?$])?[\w\-]*)\s*(?:([\^$*~%!\/]?=)\s*(['"])?((?:\\\]|.)*?)\3)?(?!\\)\])/, method:filterByAttribute, argTransform:function(args) {
    var selector = args[0], property = args[1], operator = args[2], compareTo = args[4], compareRe;
    if (compareTo !== undefined) {
      compareTo = compareTo.replace(unescapeRe, '$1');
      var format = Ext.String.format, msg = "ComponentQuery selector '{0}' has an unescaped ({1}) character at the {2} " + 'of the attribute value pattern. Usually that indicates an error ' + 'where the opening quote is not followed by the closing quote. ' + 'If you need to match a ({1}) character at the {2} of the attribute ' + 'value, escape the quote character in your pattern: (\\{1})', match;
      if (match = /^(['"]).*?[^'"]$/.exec(compareTo)) {
        Ext.log.warn(format(msg, selector, match[1], 'beginning'));
      } else {
        if (match = /^[^'"].*?(['"])$/.exec(compareTo)) {
          Ext.log.warn(format(msg, selector, match[1], 'end'));
        }
      }
    }
    if (operator === '/\x3d') {
      compareRe = regexCache.get(compareTo);
      if (compareRe) {
        compareTo = compareRe;
      } else {
        compareTo = regexCache.add(compareTo, new RegExp(compareTo));
      }
    }
    return [property, operator, compareTo];
  }}, {re:/^#((?:\\\.|[\w\-])+)/, method:filterById}, {re:/^:([\w\-]+)(?:\(((?:\{[^\}]+\})|(?:(?!\{)[^\s>\/]*?(?!\})))\))?/, method:filterByPseudo, argTransform:function(args) {
    if (args[2] !== undefined) {
      args[2] = args[2].replace(unescapeRe, '$1');
    }
    return args.slice(1);
  }}, {re:/^(?:\{([^\}]+)\})/, method:filterFnPattern}];
  cq.Query = Ext.extend(Object, {constructor:function(cfg) {
    cfg = cfg || {};
    Ext.apply(this, cfg);
  }, execute:function(root) {
    var operations = this.operations, result = [], op, i, len;
    for (i = 0, len = operations.length; i < len; i++) {
      op = operations[i];
      result = result.concat(this._execute(root, op));
    }
    return result;
  }, _execute:function(root, operations) {
    var i = 0, length = operations.length, operation, workingItems;
    if (!root) {
      workingItems = Ext.ComponentManager.getAll();
    } else {
      if (Ext.isIterable(root)) {
        workingItems = root;
      } else {
        if (root.isMixedCollection) {
          workingItems = root.items;
        }
      }
    }
    for (; i < length; i++) {
      operation = operations[i];
      if (operation.mode === '^') {
        workingItems = getAncestors(workingItems || [root]);
      } else {
        if (operation.mode) {
          workingItems = getItems(workingItems || [root], operation.mode);
        } else {
          workingItems = filterItems(workingItems || getItems([root]), operation);
        }
      }
      if (i === length - 1) {
        return workingItems;
      }
    }
    return [];
  }, is:function(component, root) {
    var operations = this.operations, result = false, len = operations.length, op, i;
    if (len === 0) {
      return true;
    }
    for (i = 0; i < len; i++) {
      op = operations[i];
      result = this._is(component, root, op);
      if (result) {
        return result;
      }
    }
    return false;
  }, _is:function(component, root, operations) {
    var len = operations.length, active = [component], operation, i, j, mode, items, item;
    for (i = len - 1; i >= 0; --i) {
      operation = operations[i];
      mode = operation.mode;
      if (mode) {
        if (mode === '^') {
          active = getItems(active, ' ');
        } else {
          if (mode === '\x3e') {
            items = [];
            for (j = 0, len = active.length; j < len; ++j) {
              item = active[j].getRefOwner();
              if (item) {
                items.push(item);
              }
            }
            active = items;
          } else {
            active = getAncestors(active);
          }
        }
      } else {
        active = filterItems(active, operation);
      }
      if (active.length === 0) {
        return false;
      }
    }
    if (root) {
      if (!mode) {
        active = getAncestors(active);
      }
      if (active.length > 0) {
        active = filterItems(active, {method:filterById, args:[root.id, true]});
      }
      if (active.length === 0) {
        return false;
      }
    }
    return true;
  }, getMatches:function(components, operations) {
    var len = operations.length, i;
    for (i = 0; i < len; ++i) {
      components = filterItems(components, operations[i]);
      if (components.length === 0) {
        break;
      }
    }
    return components;
  }, isMultiMatch:function() {
    return this.operations.length > 1;
  }});
  Ext.apply(cq, {cache:new Ext.util.LruCache({maxSize:100}), pseudos:{not:function(components, selector) {
    var i = 0, length = components.length, results = [], index = -1, component;
    for (; i < length; ++i) {
      component = components[i];
      if (!cq.is(component, selector)) {
        results[++index] = component;
      }
    }
    return results;
  }, first:function(components) {
    var ret = [];
    if (components.length > 0) {
      ret.push(components[0]);
    }
    return ret;
  }, last:function(components) {
    var len = components.length, ret = [];
    if (len > 0) {
      ret.push(components[len - 1]);
    }
    return ret;
  }, focusable:function(cmps) {
    var len = cmps.length, results = [], i = 0, c;
    for (; i < len; i++) {
      c = cmps[i];
      if (c.isFocusable && c.isFocusable()) {
        results.push(c);
      }
    }
    return results;
  }, canfocus:function(cmps, value) {
    var len = cmps.length, results = [], i = 0, c;
    for (; i < len; i++) {
      c = cmps[i];
      if (c.canFocus && c.canFocus(false, value)) {
        results.push(c);
      }
    }
    return results;
  }, 'nth-child':function(c, a) {
    var result = [], m = nthRe.exec(a === 'even' && '2n' || a === 'odd' && '2n+1' || !nthRe2.test(a) && 'n+' + a || a), f = (m[1] || 1) - 0, len = m[2] - 0, i, n, nodeIndex;
    for (i = 0; n = c[i]; i++) {
      nodeIndex = i + 1;
      if (f === 1) {
        if (len === 0 || nodeIndex === len) {
          result.push(n);
        }
      } else {
        if ((nodeIndex + len) % f === 0) {
          result.push(n);
        }
      }
    }
    return result;
  }, scrollable:function(cmps) {
    var len = cmps.length, results = [], i = 0, c;
    for (; i < len; i++) {
      c = cmps[i];
      if (c.scrollable || c._scrollable) {
        results.push(c);
      }
    }
    return results;
  }, visible:function(cmps, deep) {
    deep = deep === 'true';
    var len = cmps.length, results = [], i = 0, c;
    for (; i < len; i++) {
      c = cmps[i];
      if (c.isVisible(deep)) {
        results.push(c);
      }
    }
    return results;
  }}, query:function(selector, root) {
    if (!selector) {
      return Ext.ComponentManager.getAll();
    }
    var results = [], noDupResults = [], dupMatcher = {}, query = cq.cache.get(selector), resultsLn, cmp, i;
    if (!query) {
      query = cq.cache.add(selector, cq.parse(selector));
    }
    results = query.execute(root);
    if (query.isMultiMatch()) {
      resultsLn = results.length;
      for (i = 0; i < resultsLn; i++) {
        cmp = results[i];
        if (!dupMatcher[cmp.id]) {
          noDupResults.push(cmp);
          dupMatcher[cmp.id] = true;
        }
      }
      results = noDupResults;
    }
    return results;
  }, visitPreOrder:function(selector, root, fn, scope, extraArgs) {
    cq._visit(true, selector, root, fn, scope, extraArgs);
  }, visitPostOrder:function(selector, root, fn, scope, extraArgs) {
    cq._visit(false, selector, root, fn, scope, extraArgs);
  }, _visit:function(preOrder, selector, root, fn, scope, extraArgs) {
    var query = cq.cache.get(selector), callArgs = [root], children, len = 0, i, rootMatch;
    if (!query) {
      query = cq.cache.add(selector, cq.parse(selector));
    }
    rootMatch = query.is(root);
    if (root.getRefItems) {
      children = root.getRefItems();
      len = children.length;
    }
    if (extraArgs) {
      Ext.Array.push(callArgs, extraArgs);
    }
    if (preOrder) {
      if (rootMatch) {
        if (fn.apply(scope || root, callArgs) === false) {
          return false;
        }
      }
    }
    for (i = 0; i < len; i++) {
      if (cq._visit.call(cq, preOrder, selector, children[i], fn, scope, extraArgs) === false) {
        return false;
      }
    }
    if (!preOrder) {
      if (rootMatch) {
        if (fn.apply(scope || root, callArgs) === false) {
          return false;
        }
      }
    }
  }, is:function(component, selector, root) {
    if (!selector) {
      return true;
    }
    if (typeof selector === 'function') {
      return selector(component);
    } else {
      var query = cq.cache.get(selector);
      if (!query) {
        query = cq.cache.add(selector, cq.parse(selector));
      }
      return query.is(component, root);
    }
  }, parse:function(selector) {
    var operations = [], selectors, sel, i, len;
    selectors = Ext.splitAndUnescape(selector, ',');
    for (i = 0, len = selectors.length; i < len; i++) {
      sel = Ext.String.trim(selectors[i]);
      if (sel === '') {
        Ext.raise('Invalid ComponentQuery selector: ""');
      }
      operations.push(cq._parse(sel));
    }
    return new cq.Query({operations:operations});
  }, _parse:function(selector) {
    var operations = [], trim = Ext.String.trim, length = matchers.length, lastSelector, tokenMatch, token, matchedChar, modeMatch, selectorMatch, transform, i, matcher, method, args;
    while (selector && lastSelector !== selector) {
      lastSelector = selector;
      tokenMatch = selector.match(tokenRe);
      if (tokenMatch) {
        matchedChar = tokenMatch[1];
        token = trim(tokenMatch[2]).replace(unescapeRe, '$1');
        if (matchedChar === '#') {
          operations.push({method:filterById, args:[token]});
        } else {
          operations.push({method:filterByXType, args:[token, Boolean(tokenMatch[3])]});
        }
        selector = selector.replace(tokenMatch[0], '').replace(stripLeadingSpaceRe, '$1');
      }
      while (!(modeMatch = selector.match(modeRe))) {
        for (i = 0; selector && i < length; i++) {
          matcher = matchers[i];
          selectorMatch = selector.match(matcher.re);
          method = matcher.method;
          transform = matcher.argTransform;
          if (selectorMatch) {
            if (transform) {
              args = transform(selectorMatch);
            } else {
              args = selectorMatch.slice(1);
            }
            operations.push({method:Ext.isString(matcher.method) ? Ext.functionFactory('items', Ext.String.format.apply(Ext.String, [method].concat(selectorMatch.slice(1)))) : matcher.method, args:args});
            selector = selector.replace(selectorMatch[0], '').replace(stripLeadingSpaceRe, '$1');
            break;
          }
          if (i === length - 1) {
            Ext.raise('Invalid ComponentQuery selector: "' + arguments[0] + '"');
          }
        }
      }
      if (modeMatch[1]) {
        operations.push({mode:modeMatch[2] || modeMatch[1]});
        selector = selector.replace(modeMatch[0], '').replace(stripLeadingSpaceRe, '');
      }
    }
    return operations;
  }});
  Ext.all = function() {
    return cq.query.apply(cq, arguments);
  };
  Ext.first = function() {
    var matches = cq.query.apply(cq, arguments);
    return matches && matches[0] || null;
  };
});
Ext.define('Ext.Evented', {alternateClassName:'Ext.EventedBase', mixins:[Ext.mixin.Observable], initialized:false, constructor:function(config) {
  this.callParent();
  this.mixins.observable.constructor.call(this, config);
  this.initialized = true;
}, onClassExtended:function(cls, data) {
  if (!data.hasOwnProperty('eventedConfig')) {
    return;
  }
  var config = data.config, eventedConfig = data.eventedConfig, name, cfg;
  if (config) {
    Ext.applyIf(config, eventedConfig);
  } else {
    cls.addConfig(eventedConfig);
  }
  for (name in eventedConfig) {
    if (eventedConfig.hasOwnProperty(name)) {
      cfg = Ext.Config.get(name);
      data[cfg.names.set] = cfg.eventedSetter || cfg.getEventedSetter();
    }
  }
}});
Ext.define('Ext.util.Positionable', {mixinId:'positionable', _positionTopLeft:['position', 'top', 'left'], clippedCls:Ext.baseCSSPrefix + 'clipped', afterSetPosition:Ext.emptyFn, getAnchorToXY:function() {
  Ext.raise('getAnchorToXY is not implemented in ' + this.$className);
}, getBorderPadding:function() {
  Ext.raise('getBorderPadding is not implemented in ' + this.$className);
}, getLocalX:function() {
  Ext.raise('getLocalX is not implemented in ' + this.$className);
}, getLocalXY:function() {
  Ext.raise('getLocalXY is not implemented in ' + this.$className);
}, getLocalY:function() {
  Ext.raise('getLocalY is not implemented in ' + this.$className);
}, getX:function() {
  Ext.raise('getX is not implemented in ' + this.$className);
}, getXY:function() {
  Ext.raise('getXY is not implemented in ' + this.$className);
}, getY:function() {
  Ext.raise('getY is not implemented in ' + this.$className);
}, setLocalX:function() {
  Ext.raise('setLocalX is not implemented in ' + this.$className);
}, setLocalXY:function() {
  Ext.raise('setLocalXY is not implemented in ' + this.$className);
}, setLocalY:function() {
  Ext.raise('setLocalY is not implemented in ' + this.$className);
}, setX:function() {
  Ext.raise('setX is not implemented in ' + this.$className);
}, setXY:function() {
  Ext.raise('setXY is not implemented in ' + this.$className);
}, setY:function() {
  Ext.raise('setY is not implemented in ' + this.$className);
}, adjustForConstraints:function(xy, parent) {
  var vector = this.getConstrainVector(parent, xy);
  if (vector) {
    xy[0] += vector[0];
    xy[1] += vector[1];
  }
  return xy;
}, alignTo:function(element, position, offsets, animate) {
  var me = this, el = me.el;
  return me.setXY(me.getAlignToXY(element, position, offsets), el.anim && !!animate ? el.anim(animate) : false);
}, calculateAnchorXY:function(anchor, extraX, extraY, size) {
  var region = this.getRegion();
  region.setPosition(0, 0);
  region.translateBy(extraX || 0, extraY || 0);
  if (size) {
    region.setWidth(size.width);
    region.setHeight(size.height);
  }
  return region.getAnchorPoint(anchor);
}, convertPositionSpec:function(posSpec) {
  return Ext.util.Region.getAlignInfo(posSpec);
}, getAlignToXY:function(alignToEl, position, offsets) {
  var newRegion = this.getAlignToRegion(alignToEl, position, offsets);
  return [newRegion.x, newRegion.y];
}, getAlignToRegion:function(alignToEl, posSpec, offset, minHeight) {
  var me = this, inside, newRegion, bodyScroll;
  alignToEl = Ext.fly(alignToEl.el || alignToEl);
  if (!alignToEl || !alignToEl.dom) {
    Ext.raise({sourceClass:'Ext.util.Positionable', sourceMethod:'getAlignToXY', msg:"Attempted to align an element that doesn't exist"});
  }
  posSpec = me.convertPositionSpec(posSpec);
  if (posSpec.constrain) {
    if (posSpec.constrain === '!') {
      inside = alignToEl;
    } else {
      inside = me.constrainTo || me.container || me.el.parent();
    }
    inside = Ext.fly(inside.el || inside).getConstrainRegion();
  }
  if (alignToEl === Ext.getBody()) {
    bodyScroll = alignToEl.getScroll();
    offset = [bodyScroll.left, bodyScroll.top];
  }
  newRegion = me.getRegion().alignTo({target:alignToEl.getRegion(), inside:inside, minHeight:minHeight, offset:offset, align:posSpec, axisLock:true});
  return newRegion;
}, getAnchorXY:function(anchor, local, size) {
  var me = this, region = me.getRegion(), el = me.el, isViewport = el.dom.nodeName === 'BODY' || el.dom.nodeType === 9, scroll = el.getScroll();
  if (local) {
    region.setPosition(0, 0);
  } else {
    if (isViewport) {
      region.setPosition(scroll.left, scroll.top);
    }
  }
  if (size) {
    region.setWidth(size.width);
    region.setHeight(size.height);
  }
  return region.getAnchorPoint(anchor);
}, getBox:function(contentBox, local) {
  var me = this, xy = local ? me.getLocalXY() : me.getXY(), x = xy[0], y = xy[1], w, h, borderPadding, beforeX, beforeY;
  if (me.el.dom.nodeName === 'BODY' || me.el.dom.nodeType === 9) {
    w = Ext.Element.getViewportWidth();
    h = Ext.Element.getViewportHeight();
  } else {
    w = me.getWidth();
    h = me.getHeight();
  }
  if (contentBox) {
    borderPadding = me.getBorderPadding();
    beforeX = borderPadding.beforeX;
    beforeY = borderPadding.beforeY;
    x += beforeX;
    y += beforeY;
    w -= beforeX + borderPadding.afterX;
    h -= beforeY + borderPadding.afterY;
  }
  return {x:x, left:x, 0:x, y:y, top:y, 1:y, width:w, height:h, right:x + w, bottom:y + h};
}, calculateConstrainedPosition:function(constrainTo, proposedPosition, local, proposedSize) {
  var me = this, vector, fp = me.floatParent, parentNode = fp ? fp.getTargetEl() : null, parentOffset, borderPadding, proposedConstrainPosition, xy = false;
  if (local && fp) {
    parentOffset = parentNode.getXY();
    borderPadding = parentNode.getBorderPadding();
    parentOffset[0] += borderPadding.beforeX;
    parentOffset[1] += borderPadding.beforeY;
    if (proposedPosition) {
      proposedConstrainPosition = [proposedPosition[0] + parentOffset[0], proposedPosition[1] + parentOffset[1]];
    }
  } else {
    proposedConstrainPosition = proposedPosition;
  }
  constrainTo = constrainTo || me.constrainTo || parentNode || me.container || me.el.parent();
  if (local && proposedConstrainPosition) {
    proposedConstrainPosition = me.reverseTranslateXY(proposedConstrainPosition);
  }
  vector = (me.constrainHeader && me.header.rendered ? me.header : me).getConstrainVector(constrainTo, proposedConstrainPosition, proposedSize);
  if (vector) {
    xy = proposedPosition || me.getPosition(local);
    xy[0] += vector[0];
    xy[1] += vector[1];
  }
  return xy;
}, getConstrainRegion:function() {
  var me = this, el = me.el, isBody = el.dom.nodeName === 'BODY', dom = el.dom, borders = el.getBorders(), pos = el.getXY(), left = pos[0] + borders.beforeX, top = pos[1] + borders.beforeY, scroll, width, height;
  if (isBody) {
    scroll = el.getScroll();
    left = scroll.left;
    top = scroll.top;
    width = Ext.Element.getViewportWidth();
    height = Ext.Element.getViewportHeight();
  } else {
    width = dom.clientWidth;
    height = dom.clientHeight;
  }
  return new Ext.util.Region(top, left + width, top + height, left);
}, getConstrainVector:function(constrainTo, proposedPosition, proposedSize) {
  var me = this, thisRegion = me.getRegion(), vector = [0, 0], shadowSize = me.shadow && me.constrainShadow && !me.shadowDisabled ? me.el.shadow.getShadowSize() : undefined, overflowed = false, constraintInsets = me.constraintInsets;
  if (!(constrainTo instanceof Ext.util.Region)) {
    constrainTo = Ext.get(constrainTo.el || constrainTo);
    constrainTo = constrainTo.getConstrainRegion();
  }
  if (constraintInsets) {
    constraintInsets = Ext.isObject(constraintInsets) ? constraintInsets : Ext.Element.parseBox(constraintInsets);
    constrainTo.adjust(constraintInsets.top, constraintInsets.right, constraintInsets.bottom, constraintInsets.left);
  }
  if (proposedPosition) {
    thisRegion.translateBy(proposedPosition[0] - thisRegion.x, proposedPosition[1] - thisRegion.y);
  }
  if (proposedSize) {
    thisRegion.right = thisRegion.left + proposedSize[0];
    thisRegion.bottom = thisRegion.top + proposedSize[1];
  }
  if (shadowSize) {
    constrainTo.adjust(shadowSize[0], -shadowSize[1], -shadowSize[2], shadowSize[3]);
  }
  if (thisRegion.right > constrainTo.right) {
    overflowed = true;
    vector[0] = constrainTo.right - thisRegion.right;
  }
  if (thisRegion.left + vector[0] < constrainTo.left) {
    overflowed = true;
    vector[0] = constrainTo.left - thisRegion.left;
  }
  if (thisRegion.bottom > constrainTo.bottom) {
    overflowed = true;
    vector[1] = constrainTo.bottom - thisRegion.bottom;
  }
  if (thisRegion.top + vector[1] < constrainTo.top) {
    overflowed = true;
    vector[1] = constrainTo.top - thisRegion.top;
  }
  return overflowed ? vector : false;
}, getOffsetsTo:function(offsetsTo) {
  var o = this.getXY(), e = offsetsTo.isRegion ? [offsetsTo.x, offsetsTo.y] : Ext.fly(offsetsTo.el || offsetsTo).getXY();
  return [o[0] - e[0], o[1] - e[1]];
}, getRegion:function(contentBox, local) {
  var box = this.getBox(contentBox, local);
  return new Ext.util.Region(box.top, box.right, box.bottom, box.left);
}, getClientRegion:function() {
  var me = this, el = me.el, dom = el.dom, viewContentBox = me.getBox(true), scrollbarHeight = dom.offsetHeight > dom.clientHeight, scrollbarWidth = dom.offsetWidth > dom.clientWidth, padding, scrollSize, isRTL;
  if (scrollbarHeight || scrollbarWidth) {
    scrollSize = Ext.getScrollbarSize();
    if (scrollbarWidth) {
      scrollbarWidth = scrollSize.width;
      isRTL = el.getStyle('direction') === 'rtl' && !Ext.supports.rtlVertScrollbarOnRight;
      if (isRTL) {
        padding = el.getPadding('l');
        viewContentBox.left -= padding + Math.max(padding, scrollbarWidth);
      } else {
        padding = el.getPadding('r');
        viewContentBox.right += padding - Math.max(padding, scrollbarWidth);
      }
    }
    if (scrollbarHeight) {
      scrollbarHeight = scrollSize.height;
      padding = el.getPadding('b');
      viewContentBox.bottom += padding - Math.max(padding, scrollbarHeight);
    }
  }
  return new Ext.util.Region(viewContentBox.top, viewContentBox.right, viewContentBox.bottom, viewContentBox.left);
}, getViewRegion:function() {
  var me = this, el = me.el, isBody = el.dom.nodeName === 'BODY', borderPadding, scroll, pos, top, left, width, height;
  if (isBody) {
    scroll = el.getScroll();
    left = scroll.left;
    top = scroll.top;
    width = Ext.Element.getViewportWidth();
    height = Ext.Element.getViewportHeight();
  } else {
    borderPadding = me.getBorderPadding();
    pos = me.getXY();
    left = pos[0] + borderPadding.beforeX;
    top = pos[1] + borderPadding.beforeY;
    width = me.getWidth(true);
    height = me.getHeight(true);
  }
  return new Ext.util.Region(top, left + width, top + height, left);
}, move:function(direction, distance, animate) {
  var me = this, xy = me.getXY(), x = xy[0], y = xy[1], left = [x - distance, y], right = [x + distance, y], top = [x, y - distance], bottom = [x, y + distance], hash = {l:left, left:left, r:right, right:right, t:top, top:top, up:top, b:bottom, bottom:bottom, down:bottom};
  direction = direction.toLowerCase();
  me.setXY([hash[direction][0], hash[direction][1]], animate);
}, setBox:function(box) {
  var me = this, x, y;
  if (box.isRegion) {
    box = {x:box.left, y:box.top, width:box.right - box.left, height:box.bottom - box.top};
  }
  me.constrainBox(box);
  x = box.x;
  y = box.y;
  me.setXY([x, y]);
  me.setSize(box.width, box.height);
  me.afterSetPosition(x, y);
  return me;
}, constrainBox:function(box) {
  var me = this, constrainedPos, x, y;
  if (me.constrain || me.constrainHeader) {
    x = 'x' in box ? box.x : box.left;
    y = 'y' in box ? box.y : box.top;
    constrainedPos = me.calculateConstrainedPosition(null, [x, y], false, [box.width, box.height]);
    if (constrainedPos) {
      box.x = constrainedPos[0];
      box.y = constrainedPos[1];
    }
  }
}, translatePoints:function(x, y) {
  var pos = this.translateXY(x, y);
  return {left:pos.x, top:pos.y};
}, translateXY:function(x, y) {
  var me = this, el = me.el, styles = el.getStyle(me._positionTopLeft), relative = styles.position === 'relative', left = parseFloat(styles.left), top = parseFloat(styles.top), xy = me.getXY();
  if (Ext.isArray(x)) {
    y = x[1];
    x = x[0];
  }
  if (isNaN(left)) {
    left = relative ? 0 : el.dom.offsetLeft;
  }
  if (isNaN(top)) {
    top = relative ? 0 : el.dom.offsetTop;
  }
  left = typeof x === 'number' ? x - xy[0] + left : undefined;
  top = typeof y === 'number' ? y - xy[1] + top : undefined;
  return {x:left, y:top};
}, reverseTranslateXY:function(xy) {
  var coords = xy, el = this.el, dom = el.dom, offsetParent = dom.offsetParent, relative, offsetParentXY, x, y;
  if (offsetParent) {
    relative = el.isStyle('position', 'relative'), offsetParentXY = Ext.fly(offsetParent).getXY(), x = xy[0] + offsetParentXY[0] + offsetParent.clientLeft;
    y = xy[1] + offsetParentXY[1] + offsetParent.clientTop;
    if (relative) {
      x += el.getPadding('l');
      y += el.getPadding('t');
    }
    coords = [x, y];
  }
  return coords;
}, privates:{clipTo:function(clippingEl, sides) {
  var clippingRegion, el = this.el, floaterRegion = el.getRegion(), overflow, i, clipValues = [], clippedCls = this.clippedCls, clipStyle, clipped, shadow;
  if (clippingEl.isRegion) {
    clippingRegion = clippingEl;
  } else {
    clippingRegion = (clippingEl.isComponent ? clippingEl.el : Ext.fly(clippingEl)).getConstrainRegion();
  }
  if (!sides) {
    sides = 15;
  }
  if (sides & 1 && (overflow = clippingRegion.top - floaterRegion.top) > 0) {
    clipValues[0] = overflow;
    clipped = true;
  } else {
    clipValues[0] = -10000;
  }
  if (sides & 2 && (overflow = floaterRegion.right - clippingRegion.right) > 0) {
    clipValues[1] = Math.max(0, el.getWidth() - overflow);
    clipped = true;
  } else {
    clipValues[1] = 10000;
  }
  if (sides & 4 && (overflow = floaterRegion.bottom - clippingRegion.bottom) > 0) {
    clipValues[2] = Math.max(0, el.getHeight() - overflow);
    clipped = true;
  } else {
    clipValues[2] = 10000;
  }
  if (sides & 8 && (overflow = clippingRegion.left - floaterRegion.left) > 0) {
    clipValues[3] = overflow;
    clipped = true;
  } else {
    clipValues[3] = -10000;
  }
  clipStyle = 'rect(';
  for (i = 0; i < 4; ++i) {
    clipStyle += Ext.Element.addUnits(clipValues[i], 'px');
    clipStyle += i === 3 ? ')' : ',';
  }
  el.dom.style.clip = clipStyle;
  el.addCls(clippedCls);
  if ((shadow = el.shadow) && (el = shadow.el) && el.dom) {
    clipValues[2] -= shadow.offsets.y;
    clipValues[3] -= shadow.offsets.x;
    clipStyle = 'rect(';
    for (i = 0; i < 4; ++i) {
      clipStyle += Ext.Element.addUnits(clipValues[i], 'px');
      clipStyle += i === 3 ? ')' : ',';
    }
    el.dom.style.clip = clipStyle;
    if (clipped && !Ext.supports.CSS3BoxShadow) {
      el.dom.style.display = 'none';
    } else {
      el.dom.style.display = '';
      el.addCls(clippedCls);
    }
  }
}, clearClip:function() {
  var el = this.el, clippedCls = this.clippedCls;
  el.dom.style.clip = Ext.isIE8 ? 'auto' : '';
  el.removeCls(clippedCls);
  if (el.shadow && el.shadow.el && el.shadow.el.dom) {
    el.shadow.el.dom.style.clip = Ext.isIE8 ? 'auto' : '';
    if (!Ext.supports.CSS3BoxShadow) {
      el.dom.style.display = '';
      el.removeCls(clippedCls);
    }
  }
}}});
Ext.define('Ext.dom.UnderlayPool', {constructor:function(elementConfig) {
  this.elementConfig = elementConfig;
  this.cache = [];
}, checkOut:function() {
  var el = this.cache.shift();
  if (!el) {
    el = Ext.Element.create(this.elementConfig);
    el.setVisibilityMode(2);
    el.dom.setAttribute('data-sticky', true);
  }
  return el;
}, checkIn:function(el) {
  this.cache.push(el);
  Ext.getDetachedBody().dom.appendChild(el.dom);
}, reset:function() {
  var cache = this.cache, i = cache.length;
  while (i--) {
    cache[i].destroy();
  }
  this.cache = [];
}});
Ext.define('Ext.dom.Underlay', {constructor:function(config) {
  Ext.apply(this, config);
}, beforeShow:Ext.emptyFn, getInsertionTarget:function() {
  return this.target;
}, getPool:function() {
  return this.pool || (this.self.prototype.pool = new Ext.dom.UnderlayPool(this.elementConfig));
}, hide:function() {
  var me = this, el = me.el;
  if (el) {
    if (el.dom) {
      el.hide();
      me.getPool().checkIn(el);
    }
    me.el = null;
  }
  me.hidden = true;
}, realign:function(x, y, width, height) {
  var me = this, el = me.el, target = me.target, offsets = me.offsets, max = Math.max;
  if (el) {
    if (x == null) {
      x = target.getX();
    }
    if (y == null) {
      y = target.getY();
    }
    if (width == null) {
      width = target.getWidth();
    }
    if (height == null) {
      height = target.getHeight();
    }
    if (offsets) {
      x = x + offsets.x;
      y = y + offsets.y;
      width = max(width + offsets.w, 0);
      height = max(height + offsets.h, 0);
    }
    el.setXY([x, y]);
    el.setSize(width, height);
  }
}, setZIndex:function(zIndex) {
  this.zIndex = zIndex;
  if (this.el) {
    this.el.setStyle('z-index', zIndex);
  }
}, show:function() {
  var me = this, target = me.target, zIndex = me.zIndex, el = me.el, insertionTarget = me.getInsertionTarget().dom, dom;
  if (!el) {
    el = me.el = me.getPool().checkOut();
  }
  me.beforeShow();
  if (zIndex == null) {
    zIndex = parseInt(target.getStyle('z-index'), 10);
  }
  if (zIndex) {
    el.setStyle('z-index', zIndex);
  }
  el.setStyle('position', me.fixed ? 'fixed' : '');
  dom = el.dom;
  if (dom.nextSibling !== insertionTarget) {
    target.dom.parentNode.insertBefore(dom, insertionTarget);
  }
  el.show();
  me.realign();
  me.hidden = false;
}});
Ext.define('Ext.dom.Shadow', {extend:Ext.dom.Underlay, alternateClassName:'Ext.Shadow', mode:'drop', offset:4, cls:Ext.baseCSSPrefix + (!Ext.supports.CSS3BoxShadow ? 'ie' : 'css') + '-shadow', constructor:function(config) {
  var me = this, outerOffsets, offsets, offset, rad;
  me.callParent([config]);
  me.elementConfig = {cls:me.cls, role:'presentation'};
  offset = me.offset;
  rad = Math.floor(offset / 2);
  me.opacity = 50;
  switch(me.mode.toLowerCase()) {
    case 'drop':
      outerOffsets = {x:0, y:0, w:offset, h:offset};
      if (Ext.supports.CSS3BoxShadow) {
        offsets = {x:offset, y:offset, h:-offset, w:-offset};
      } else {
        offsets = {x:-rad, y:-rad, h:-rad, w:-rad};
      }
      break;
    case 'sides':
      outerOffsets = {x:-offset, y:0, w:offset * 2, h:offset};
      if (Ext.supports.CSS3BoxShadow) {
        offsets = {x:0, y:offset, h:-offset, w:0};
      } else {
        offsets = {x:1 + rad - 2 * offset, y:-(1 + rad), h:-1, w:rad - 1};
      }
      break;
    case 'frame':
      outerOffsets = {x:-offset, y:-offset, w:offset * 2, h:offset * 2};
      if (Ext.supports.CSS3BoxShadow) {
        offsets = {x:0, y:0, h:0, w:0};
      } else {
        offsets = {x:1 + rad - 2 * offset, y:1 + rad - 2 * offset, h:offset - rad - 1, w:offset - rad - 1};
      }
      break;
    case 'bottom':
      outerOffsets = {x:-offset, y:0, w:offset * 2, h:offset};
      if (Ext.supports.CSS3BoxShadow) {
        offsets = {x:0, y:offset, h:-offset, w:0};
      } else {
        offsets = {x:0, y:offset, h:0, w:0};
      }
      break;
  }
  me.offsets = offsets;
  me.outerOffsets = outerOffsets;
}, getShadowSize:function() {
  var me = this, offset = me.el ? me.offset : 0, result = [offset, offset, offset, offset], mode = me.mode.toLowerCase();
  if (me.el && mode !== 'frame') {
    result[0] = 0;
    if (mode == 'drop') {
      result[3] = 0;
    }
  }
  return result;
}, boxShadowProperty:function() {
  var property = 'boxShadow', style = document.documentElement.style;
  if (!('boxShadow' in style)) {
    if ('WebkitBoxShadow' in style) {
      property = 'WebkitBoxShadow';
    } else {
      if ('MozBoxShadow' in style) {
        property = 'MozBoxShadow';
      }
    }
  }
  return property;
}(), beforeShow:function() {
  var me = this, style = me.el.dom.style, shim = me.shim;
  if (Ext.supports.CSS3BoxShadow) {
    style[me.boxShadowProperty] = '0 0 ' + (me.offset + 2) + 'px #888';
  } else {
    style.filter = 'progid:DXImageTransform.Microsoft.alpha(opacity\x3d' + me.opacity + ') progid:DXImageTransform.Microsoft.Blur(pixelradius\x3d' + me.offset + ')';
  }
  if (shim) {
    shim.realign();
  }
}, setOpacity:function(opacity) {
  var el = this.el;
  if (el) {
    if (Ext.isIE && !Ext.supports.CSS3BoxShadow) {
      opacity = Math.floor(opacity * 100 / 2) / 100;
    }
    this.opacity = opacity;
    el.setOpacity(opacity);
  }
}});
Ext.define('Ext.dom.Shim', {extend:Ext.dom.Underlay, cls:Ext.baseCSSPrefix + 'shim', constructor:function(config) {
  this.callParent([config]);
  this.elementConfig = {tag:'iframe', cls:this.cls, role:'presentation', frameBorder:'0', src:Ext.SSL_SECURE_URL, tabindex:'-1'};
}, getInsertionTarget:function() {
  var shadow = this.shadow;
  return shadow && shadow.el || this.target;
}});
Ext.define('Ext.dom.ElementEvent', {extend:Ext.util.Event, addListener:function(fn, scope, options, caller, manager) {
  var me = this, added = false, name = me.name, isDirectEvent = Ext.event.publisher.Dom.instance.directEvents[name], captures, directs, directCaptures;
  options = options || {};
  if (options.delegated === false || isDirectEvent) {
    if (isDirectEvent && options.delegate) {
      options.capture = true;
    }
    if (options.capture) {
      directCaptures = me.directCaptures || (me.directCaptures = new Ext.util.Event(me.observable, name));
      added = directCaptures.addListener(fn, scope, options, caller, manager);
    } else {
      directs = me.directs || (me.directs = new Ext.util.Event(me.observable, name));
      added = directs.addListener(fn, scope, options, caller, manager);
    }
  } else {
    if (options.capture) {
      captures = me.captures || (me.captures = new Ext.util.Event(me.observable, name));
      added = captures.addListener(fn, scope, options, caller, manager);
    } else {
      added = me.callParent([fn, scope, options, caller, manager]);
    }
  }
  return added;
}, removeListener:function(fn, scope) {
  var me = this, captures = me.captures, directs = me.directs, directCaptures = me.directCaptures, removed = false, index = me.findListener(fn, scope);
  if (index !== -1) {
    removed = me.callParent([fn, scope, index]);
  } else {
    if (directs) {
      index = directs.findListener(fn, scope);
    }
    if (index !== -1) {
      removed = directs.removeListener(fn, scope, index);
    } else {
      if (captures) {
        index = captures.findListener(fn, scope);
      }
      if (index !== -1) {
        removed = captures.removeListener(fn, scope, index);
      } else {
        if (directCaptures) {
          index = directCaptures.findListener(fn, scope);
          if (index !== -1) {
            removed = directCaptures.removeListener(fn, scope, index);
          }
        }
      }
    }
  }
  return removed;
}, clearListeners:function() {
  var me = this, directCaptures = me.directCaptures, directs = me.directs, captures = me.captures;
  if (directCaptures) {
    directCaptures.clearListeners();
  }
  if (directs) {
    directs.clearListeners();
  }
  if (captures) {
    captures.clearListeners();
  }
  me.callParent();
}, suspend:function() {
  var me = this, directCaptures = me.directCaptures, directs = me.directs, captures = me.captures;
  if (directCaptures) {
    directCaptures.suspend();
  }
  if (directs) {
    directs.suspend();
  }
  if (captures) {
    captures.suspend();
  }
  me.callParent();
}, resume:function() {
  var me = this, directCaptures = me.directCaptures, directs = me.directs, captures = me.captures;
  if (directCaptures) {
    directCaptures.resume();
  }
  if (directs) {
    directs.resume();
  }
  if (captures) {
    captures.resume();
  }
  me.callParent();
}});
Ext.define('Ext.event.publisher.Publisher', {isEventPublisher:true, $vetoClearingPrototypeOnDestroy:true, handledEvents:[], statics:{publishers:{}, publishersByEvent:{}}, constructor:function() {
  var me = this, type = me.type;
  me.handles = {};
  if (!type) {
    Ext.raise("Event publisher '" + me.$className + "' defined without a 'type' property.");
  }
  if (me.self.instance) {
    Ext.raise("Cannot create multiple instances of '" + me.$className + "'. " + "Use '" + me.$className + ".instance' to retrieve the singleton instance.");
  }
  me.registerEvents();
  Ext.event.publisher.Publisher.publishers[type] = me;
}, registerEvents:function(events) {
  var me = this, publishersByEvent = Ext.event.publisher.Publisher.publishersByEvent, handledEvents = events || me.handledEvents, ln = handledEvents.length, eventName, i;
  for (i = 0; i < ln; i++) {
    eventName = handledEvents[i];
    me.handles[eventName] = 1;
    publishersByEvent[eventName] = me;
  }
}, subscribe:function() {
  Ext.raise("Ext.event.publisher.Publisher subclass '" + this.$className + '" has no subscribe method.');
}, unsubscribe:function() {
  Ext.raise("Ext.event.publisher.Publisher subclass '" + this.$className + '" has no unsubscribe method.');
}, fire:function(element, eventName, args) {
  var event;
  if (element.hasListeners[eventName]) {
    event = element.events[eventName];
    if (event) {
      event.fire.apply(event, args);
    }
  }
}});
Ext.define('Ext.util.Offset', {statics:{fromObject:function(obj) {
  if (obj instanceof this) {
    return obj;
  }
  if (typeof obj === 'number') {
    return new this(obj, obj);
  }
  if (obj.length) {
    return new this(obj[0], obj[1]);
  }
  return new this(obj.x, obj.y);
}}, constructor:function(x, y) {
  this.x = x != null && !isNaN(x) ? x : 0;
  this.y = y != null && !isNaN(y) ? y : 0;
  return this;
}, copy:function() {
  return new Ext.util.Offset(this.x, this.y);
}, copyFrom:function(p) {
  this.x = p.x;
  this.y = p.y;
}, toString:function() {
  return 'Offset[' + this.x + ',' + this.y + ']';
}, equals:function(offset) {
  if (!(offset instanceof this.statics())) {
    Ext.raise('Offset must be an instance of Ext.util.Offset');
  }
  return this.x === offset.x && this.y === offset.y;
}, add:function(offset) {
  if (!(offset instanceof this.statics())) {
    Ext.raise('Offset must be an instance of Ext.util.Offset');
  }
  this.x += offset.x;
  this.y += offset.y;
}, round:function(to) {
  if (!isNaN(to)) {
    var factor = Math.pow(10, to);
    this.x = Math.round(this.x * factor) / factor;
    this.y = Math.round(this.y * factor) / factor;
  } else {
    this.x = Math.round(this.x);
    this.y = Math.round(this.y);
  }
}, isZero:function() {
  return this.x === 0 && this.y === 0;
}});
Ext.define('Ext.util.Region', function() {
  var ExtUtil = Ext.util, constrainRe = /([^\?!]*)(!|\?)?$/, alignRe = /^(?:(?:([trbl])(\d+))|(tl|t|tc|tr|l|c|r|bl|b|bc|br))(?:-(?:(?:([trbl])(\d+))|(tl|t|tc|tr|l|c|r|bl|b|bc|br)))?$/i, LTROffsetFactors = {l:0, r:100, t:0, b:100, c:50}, RTLOffsetFactors = {l:100, r:0, t:0, b:100, c:50}, relativePositions = {b:0, l:1, t:2, r:3}, alignMap = {'tl-tr':'l0-r0', 'tl-r':'l0-r50', 'bl-r':'l100-r50', 'bl-br':'l100-r100', 'tr-tl':'r0-l0', 'tr-l':'r0-l50', 'br-l':'r100-l50', 'br-bl':'r100-l100'}, rtlAlignMap = 
  {'tl-tr':'r0-l0', 'tl-r':'r0-l50', 'bl-r':'r100-l50', 'bl-br':'r100-l100', 'tr-tl':'l0-r0', 'tr-l':'l0-r50', 'br-l':'l100-r50', 'br-bl':'l100-r100'}, adjustParams = [], zeroOffset = new ExtUtil.Offset(0, 0), parseRegion = function(box) {
    var Region = ExtUtil.Region, type = typeof box, top, right, bottom, left;
    if (box == null) {
      return Region.EMPTY;
    }
    if (box.isRegion) {
      return box;
    }
    if (box.isElement || box.nodeType === 1) {
      return this.getRegion(box);
    }
    if (type === 'string') {
      box = box.split(' ');
      switch(box.length) {
        case 1:
          box[1] = box[2] = box[3] = box[0];
          break;
        case 2:
          box[2] = box[0];
          box[3] = box[1];
          break;
        case 3:
          box[3] = box[1];
      }
      top = parseInt(box[0], 10) || 0;
      right = parseInt(box[1], 10) || 0;
      bottom = parseInt(box[2], 10) || 0;
      left = parseInt(box[3], 10) || 0;
    } else {
      if (type === 'number') {
        top = right = bottom = left = box;
      } else {
        if (typeof box.x === 'number') {
          top = box.y;
          left = box.x;
          if (typeof box.right === 'number') {
            right = box.right;
            bottom = box.bottom;
          } else {
            right = left + box.width;
            bottom = top + box.height;
          }
        } else {
          Ext.raise('Not convertible to a Region: ' + box);
        }
      }
    }
    return new Region(top, right, bottom, left);
  }, magnitude = [-1, 1, 1, -1], addAnchorOffset = function(target, anchorSize, relativePosition) {
    if (relativePosition != null && anchorSize) {
      adjustParams[0] = adjustParams[1] = adjustParams[2] = adjustParams[3] = 0;
      adjustParams[relativePosition] = anchorSize.y * magnitude[relativePosition];
      target = ExtUtil.Region.from(target);
      target.adjust.apply(target, adjustParams);
    }
    return target;
  }, calculateAnchorPosition = function(target, result, relativePosition, anchorSize, inside) {
    var anchorWidth = Math.ceil(anchorSize.x), minOverlap = Math.ceil(anchorWidth / 2) + 3, min, max, anchorPos, isBefore, overlapLine, x, y;
    if (inside && !inside.intersect(target)) {
      return;
    }
    if (relativePosition != null) {
      if (relativePosition & 1) {
        if (result.getHeight() < anchorWidth + 4) {
          return;
        }
        min = target.top + minOverlap - result.height;
        max = target.bottom - minOverlap - 1;
        result.setPosition(result.x, Math.min(Math.max(result.y, min), max));
        min = result.top + 2;
        max = result.bottom - (anchorWidth + 2);
        isBefore = relativePosition === 3;
        x = isBefore ? result.right : result.left;
        overlapLine = new ExtUtil.Region(Math.max(result.top, target.top), x, Math.min(result.bottom, target.bottom), x);
        anchorPos = (new ExtUtil.Region(0, 0, 0, 0)).setWidth(anchorSize.y).setHeight(anchorWidth).alignTo({target:overlapLine, align:isBefore ? 'l-r' : 'r-l', overlap:true});
        anchorPos.setPosition(anchorPos.x, Math.min(Math.max(anchorPos.y, min), max));
        anchorPos.position = isBefore ? 'right' : 'left';
      } else {
        if (result.getWidth() < anchorWidth + 4) {
          return;
        }
        min = target.left + minOverlap - result.width;
        max = target.right - minOverlap - 1;
        result.setPosition(Math.min(Math.max(result.x, min), max), result.y);
        min = result.left + 2;
        max = result.right - (anchorWidth + 2);
        isBefore = relativePosition === 0;
        y = isBefore ? result.bottom : result.top;
        overlapLine = new ExtUtil.Region(y, Math.min(result.right, target.right), y, Math.max(result.left, target.left));
        anchorPos = (new ExtUtil.Region(0, 0, 0, 0)).setWidth(anchorWidth).setHeight(anchorSize.y).alignTo({target:overlapLine, align:isBefore ? 't-b' : 'b-t', overlap:true});
        anchorPos.setPosition(Math.min(Math.max(anchorPos.x, min), max), anchorPos.y);
        anchorPos.position = isBefore ? 'bottom' : 'top';
      }
      if (inside && !inside.contains(anchorPos)) {
        return;
      }
      result.anchor = anchorPos;
      result.anchor.align = relativePosition;
    }
  }, checkMinHeight = function(minHeight, result, target, inside) {
    var newHeight;
    if (minHeight && inside) {
      if (result.top >= target.bottom && result.bottom > inside.bottom) {
        result.setHeight(Math.max(result.getHeight() + inside.bottom - result.bottom, minHeight));
        result.constrainHeight = true;
      } else {
        if (result.bottom <= target.top && result.top < inside.top) {
          newHeight = Math.max(result.getHeight() + result.top - inside.top, minHeight);
          result.adjust(result.getHeight() - newHeight);
          result.constrainHeight = true;
        } else {
          if (result.getHeight() > inside.getHeight()) {
            result.setHeight(Math.max(minHeight, inside.getHeight()));
            result.setPosition(result.x, 0);
            result.constrainHeight = true;
          }
        }
      }
    }
  }, checkMinWidth = function(minWidth, result, target, inside) {
    var newWidth;
    if (minWidth && inside) {
      if (result.left >= target.right && result.right > inside.right) {
        result.setWidth(Math.max(result.getWidth() + inside.right - result.right, minWidth));
        result.constrainWidth = true;
      } else {
        if (result.right <= target.left && result.left < inside.left) {
          newWidth = Math.max(result.getWidth() + result.left - inside.left, minWidth);
          result.adjust(0, 0, 0, result.getWidth() - newWidth);
          result.constrainWidth = true;
        } else {
          if (result.getWidth() > inside.getWidth()) {
            result.setWidth(Math.max(minWidth, inside.getWidth()));
            result.setPosition(0, result.y);
            result.constrainWidth = true;
          }
        }
      }
    }
  };
  return {isRegion:true, statics:{getRegion:function(el) {
    return Ext.fly(el).getRegion();
  }, from:function(o) {
    return new this(o.top, o.right, o.bottom, o.left);
  }, getAlignInfo:function(align, rtl) {
    if (typeof align === 'object') {
      return align;
    }
    align = align ? align.indexOf('-') < 0 ? 'tl-' + align : align : 'tl-bl';
    constrain = constrainRe.exec(align);
    align = constrain[1];
    align = (rtl ? rtlAlignMap : alignMap)[align] || align;
    var offsetFactors = rtl ? RTLOffsetFactors : LTROffsetFactors, constrain, parts = alignRe.exec(align), result;
    if (!parts) {
      Ext.raise({sourceClass:'Ext.util.Region', sourceMethod:'getAlignInfo', position:align, msg:'Attempted to align an element with an invalid position: "' + align + '"'});
    }
    result = {myEdge:parts[1], myOffset:parts[2], otherEdge:parts[4], otherOffset:parts[5], constrain:constrain[2]};
    if (parts[3]) {
      result.myEdge = parts[3][0];
      result.myOffset = offsetFactors[parts[3][1]];
      if (result.myOffset == null) {
        result.myOffset = 50;
      }
    }
    if (parts[6]) {
      result.otherEdge = parts[6][0];
      result.otherOffset = offsetFactors[parts[6][1]];
      if (result.otherOffset == null) {
        result.otherOffset = 50;
      }
    }
    result.position = relativePositions[result.myEdge];
    return result;
  }}, constructor:function(top, right, bottom, left) {
    var me = this;
    me.y = me.top = me[1] = top;
    me.right = right;
    me.bottom = bottom;
    me.x = me.left = me[0] = left;
    me.height = me.bottom - me.top;
    me.width = me.right - me.left;
  }, setPosition:function(x, y) {
    if (arguments.length === 1) {
      y = x[1];
      x = x[0];
    }
    return this.translateBy(x - this.x, y - this.y);
  }, contains:function(region) {
    var me = this;
    return region.x >= me.x && (region.right || region.x) <= me.right && region.y >= me.y && (region.bottom || region.y) <= me.bottom;
  }, intersect:function(region) {
    var me = this, t = Math.max(me.y, region.y), r = Math.min(me.right, region.right), b = Math.min(me.bottom, region.bottom), l = Math.max(me.x, region.x);
    if (b > t && r > l) {
      return new this.self(t, r, b, l);
    } else {
      return false;
    }
  }, union:function(region) {
    var me = this, t = Math.min(me.y, region.y), r = Math.max(me.right, region.right), b = Math.max(me.bottom, region.bottom), l = Math.min(me.x, region.x);
    return new this.self(t, r, b, l);
  }, constrainTo:function(targetRegion) {
    var me = this, constrain = Ext.Number.constrain;
    me.top = me.y = constrain(me.top, targetRegion.y, targetRegion.bottom);
    me.bottom = constrain(me.bottom, targetRegion.y, targetRegion.bottom);
    me.left = me.x = constrain(me.left, targetRegion.x, targetRegion.right);
    me.right = constrain(me.right, targetRegion.x, targetRegion.right);
    me.height = me.bottom - me.top;
    me.width = me.right - me.left;
    return me;
  }, adjust:function(top, right, bottom, left) {
    var me = this;
    me.top = me.y += top || 0;
    me.left = me.x += left || 0;
    me.right += right || 0;
    me.bottom += bottom || 0;
    me.height = me.bottom - me.top;
    me.width = me.right - me.left;
    return me;
  }, getOutOfBoundOffset:function(axis, p) {
    if (!Ext.isObject(axis)) {
      if (axis === 'x') {
        return this.getOutOfBoundOffsetX(p);
      } else {
        return this.getOutOfBoundOffsetY(p);
      }
    } else {
      p = axis;
      var d = new ExtUtil.Offset;
      d.x = this.getOutOfBoundOffsetX(p.x);
      d.y = this.getOutOfBoundOffsetY(p.y);
      return d;
    }
  }, getOutOfBoundOffsetX:function(p) {
    if (p <= this.x) {
      return this.x - p;
    } else {
      if (p >= this.right) {
        return this.right - p;
      }
    }
    return 0;
  }, getOutOfBoundOffsetY:function(p) {
    if (p <= this.y) {
      return this.y - p;
    } else {
      if (p >= this.bottom) {
        return this.bottom - p;
      }
    }
    return 0;
  }, isOutOfBound:function(axis, p) {
    if (!Ext.isObject(axis)) {
      if (axis === 'x') {
        return this.isOutOfBoundX(p);
      } else {
        return this.isOutOfBoundY(p);
      }
    } else {
      p = axis;
      return this.isOutOfBoundX(p.x) || this.isOutOfBoundY(p.y);
    }
  }, isOutOfBoundX:function(p) {
    return p < this.x || p > this.right;
  }, isOutOfBoundY:function(p) {
    return p < this.y || p > this.bottom;
  }, restrict:function(axis, p, factor) {
    if (Ext.isObject(axis)) {
      var newP;
      factor = p;
      p = axis;
      if (p.copy) {
        newP = p.copy();
      } else {
        newP = {x:p.x, y:p.y};
      }
      newP.x = this.restrictX(p.x, factor);
      newP.y = this.restrictY(p.y, factor);
      return newP;
    } else {
      if (axis === 'x') {
        return this.restrictX(p, factor);
      } else {
        return this.restrictY(p, factor);
      }
    }
  }, restrictX:function(p, factor) {
    if (!factor) {
      factor = 1;
    }
    if (p <= this.x) {
      p -= (p - this.x) * factor;
    } else {
      if (p >= this.right) {
        p -= (p - this.right) * factor;
      }
    }
    return p;
  }, restrictY:function(p, factor) {
    if (!factor) {
      factor = 1;
    }
    if (p <= this.y) {
      p -= (p - this.y) * factor;
    } else {
      if (p >= this.bottom) {
        p -= (p - this.bottom) * factor;
      }
    }
    return p;
  }, alignTo:function(options) {
    var me = this, Region = me.self, Offset = ExtUtil.Offset, Element = Ext.Element, target = parseRegion(options.target), targetPlusAnchorOffset, rtl = options.rtl, overlap = options.overlap, align = options.align, anchorSize = options.anchorSize, offset = options.offset, inside = options.inside, position = options.position, allowXTranslate = options.allowXTranslate, allowYTranslate = options.allowYTranslate, wasConstrained, result, initialPosition, constrainedPosition;
    if (offset) {
      offset = Offset.fromObject(offset);
      if (!(offset instanceof Offset)) {
        Ext.raise('offset option must be an Ext.util.Offset');
      }
    }
    if (anchorSize) {
      anchorSize = Offset.fromObject(anchorSize);
      if (!(anchorSize instanceof Offset)) {
        Ext.raise('anchorSize option must be an Ext.util.Offset');
      }
    }
    if (inside && !inside.isRegion) {
      if (Ext.getDom(inside) === document.body) {
        inside = new Region(0, Element.getDocumentWidth(), Element.getDocumentHeight(), 0);
      } else {
        inside = Ext.fly(inside).getRegion();
      }
    }
    if (position) {
      if (position.length === 2) {
        position = new ExtUtil.Point(position[0], position[1]);
      }
      result = (new Region).copyFrom(me).setPosition(position.x, position.y);
    } else {
      align = me.getAlignInfo(align, rtl);
      if (inside) {
        if (target.x >= inside.right) {
          target.setPosition(inside.right - 1, target.y);
          if (align.position !== 3) {
            align = me.getAlignInfo('r-l', rtl);
          }
        } else {
          if (target.right < inside.x) {
            target.setPosition(inside.x - target.getWidth() + 1, target.y);
            if (align.position !== 1) {
              align = me.getAlignInfo('l-r', rtl);
            }
          }
        }
        if (target.y >= inside.bottom) {
          target.setPosition(target.x, inside.bottom - 1);
          if (align.position !== 0) {
            align = me.getAlignInfo('b-t', rtl);
          }
        } else {
          if (target.bottom < inside.y) {
            target.setPosition(target.x, inside.y - target.getHeight() + 1);
            if (align.position !== 2) {
              align = me.getAlignInfo('t-b', rtl);
            }
          }
        }
      }
      targetPlusAnchorOffset = anchorSize ? addAnchorOffset(target, anchorSize, align.position) : target;
      result = Region.from(me).translateBy(me.getAlignToVector(targetPlusAnchorOffset, align));
      overlap = !!result.intersect(targetPlusAnchorOffset);
      if (offset && (overlap || !anchorSize)) {
        result.translateBy(offset);
      }
      if (anchorSize) {
        calculateAnchorPosition(target, result, align.position, anchorSize, inside);
      }
    }
    if (inside) {
      initialPosition = result.copy();
      if (result.left < inside.left) {
        result.translateBy(inside.left - result.left, 0);
        wasConstrained = true;
      }
      if (result.right > inside.right && result.left > inside.left) {
        result.translateBy(inside.right - result.right, 0);
        wasConstrained = true;
      }
      if (result.top < inside.top) {
        result.translateBy(0, inside.top - result.top);
        wasConstrained = true;
      }
      if (result.bottom > inside.bottom && result.top > inside.top) {
        result.translateBy(0, inside.bottom - result.bottom);
        wasConstrained = true;
      }
      if (wasConstrained && !overlap) {
        result.anchor = null;
        if (options.axisLock) {
          if (align.position & 1) {
            allowYTranslate = false;
          } else {
            allowXTranslate = false;
          }
        }
        if (position) {
          if (result.contains(position)) {
            position.exclude(result, {inside:inside, centerOnSideChange:false});
          }
        } else {
          constrainedPosition = result.copy();
          if (result.intersect(targetPlusAnchorOffset)) {
            align.position = target.exclude(result, {initialPosition:initialPosition, defaultPosition:align.position, inside:inside, minHeight:options.minHeight, minWidth:options.minWidth, allowX:allowXTranslate, allowY:allowYTranslate, offset:offset, anchorHeight:anchorSize ? anchorSize.y : 0, centerOnSideChange:!!anchorSize});
          } else {
            if (options.minWidth && result.getWidth() > inside.getWidth()) {
              result.setPosition(0, result.y);
              result.setWidth(Math.max(inside.getWidth(), options.minWidth));
              result.constrainWidth = true;
            } else {
              if (options.minHeight && result.getHeight() > inside.getHeight()) {
                result.setPosition(result.x, 0);
                result.setHeight(Math.max(inside.getHeight(), options.minHeight));
                result.constrainHeight = true;
              }
            }
          }
          result.align = align;
          if (inside.contains(result)) {
            if (anchorSize) {
              calculateAnchorPosition(target, result, align.position, anchorSize, inside);
            }
          } else {
            result = constrainedPosition;
          }
        }
      }
    }
    return result;
  }, exclude:function(other, options) {
    options = options || {};
    var me = this, initialPosition = options.initialPosition || other, inside = options.inside, defaultPosition = options.defaultPosition, centerOnSideChange = options.centerOnSideChange, minHeight = options.minHeight, minWidth = options.minWidth, allowX = options.allowX !== false, allowY = options.allowY !== false, anchorHeight = options.anchorHeight, offset = options.offset, translations = [], testRegion, t, i, sizeConstrainedSolution, leastBadSolution, intersection, result;
    if (!offset) {
      offset = zeroOffset;
    }
    if (allowY) {
      translations.push([0, me.top - other.bottom - anchorHeight + offset.y, 'b-t', 0, Math.abs(me.top - initialPosition.bottom - anchorHeight + offset.y)]);
      translations.push([0, me.bottom - other.top + anchorHeight + offset.y, 't-b', 2, Math.abs(me.bottom - initialPosition.top + anchorHeight + offset.y)]);
    } else {
      centerOnSideChange = false;
    }
    if (allowX) {
      translations.push([me.left - other.right - anchorHeight + offset.x, 0, 'r-l', 3, Math.abs(me.left - initialPosition.right - anchorHeight + offset.x)]);
      translations.push([me.right - other.left + anchorHeight + offset.x, 0, 'l-r', 1, Math.abs(me.right - initialPosition.left + anchorHeight + offset.x)]);
    } else {
      centerOnSideChange = false;
    }
    Ext.Array.sort(translations, function(l, r) {
      var result = l[4] - r[4];
      if (!result) {
        if (l[3] === defaultPosition) {
          return -1;
        }
        if (r[3] === defaultPosition) {
          return 1;
        }
      }
      return result;
    });
    if (inside) {
      for (i = 0; i < translations.length; i++) {
        t = translations[i];
        testRegion = ExtUtil.Region.from(other);
        testRegion.translateBy.apply(testRegion, t);
        if (inside.contains(testRegion)) {
          other.copyFrom(testRegion);
          result = {align:t[2], position:t[3], distance:t[4]};
          break;
        }
        if (minHeight) {
          checkMinHeight(minHeight, testRegion, me, inside);
          if (inside.contains(testRegion)) {
            if (!sizeConstrainedSolution || testRegion.getArea() > sizeConstrainedSolution.region.getArea()) {
              sizeConstrainedSolution = {region:testRegion, align:t[2], position:t[3], distance:t[4]};
            }
          }
        }
        if (minWidth) {
          checkMinWidth(minWidth, testRegion, me, inside);
          if (inside.contains(testRegion)) {
            if (!sizeConstrainedSolution || testRegion.getArea() > sizeConstrainedSolution.region.getArea()) {
              sizeConstrainedSolution = {region:testRegion, align:t[2], position:t[3], distance:t[4]};
            }
          }
        }
        intersection = inside.intersect(testRegion);
        if (intersection) {
          intersection = intersection.getArea();
          if (!leastBadSolution || intersection && leastBadSolution.area < intersection) {
            leastBadSolution = {region:testRegion, align:t[2], position:t[3], distance:t[4], area:intersection};
          }
        }
      }
      if (!result) {
        if (sizeConstrainedSolution) {
          other.copyFrom(sizeConstrainedSolution.region);
          result = sizeConstrainedSolution;
          other.constrainWidth = sizeConstrainedSolution.region.constrainWidth;
          other.constrainHeight = sizeConstrainedSolution.region.constrainHeight;
        } else {
          if (leastBadSolution) {
            other.copyFrom(leastBadSolution.region);
            result = leastBadSolution;
          }
        }
      }
      if (result) {
        if ((result.position & 1) !== (defaultPosition & 1)) {
          if (result.distance && centerOnSideChange) {
            t = other.alignTo({align:result.align, target:me, anchorSize:anchorHeight, offset:offset, axisLock:true, inside:inside, minHeight:options.minHeight, minWidth:options.minWidth});
            if (inside.contains(t)) {
              other.setPosition(t.x, t.y);
            }
          }
        }
        return result.position;
      }
    } else {
      other.translateBy.apply(other, translations[0]);
      return translations[0][3];
    }
    return defaultPosition;
  }, getAlignToXY:function(target, align, rtl) {
    var alignVector = this.getAlignToVector(target, align, rtl);
    return [this.x + alignVector[0], this.y + alignVector[1]];
  }, getAnchorPoint:function(align, rtl) {
    align = typeof align === 'string' ? this.getAlignInfo(align + '-tl', rtl) : align;
    return this['getAnchorPoint_' + align.myEdge](align.myOffset);
  }, getAlignToVector:function(target, align, rtl) {
    align = typeof align === 'string' ? this.getAlignInfo(align, rtl) : align;
    var myAnchorPoint = this['getAnchorPoint_' + align.myEdge](align.myOffset), targetAnchorPoint = target['getAnchorPoint_' + align.otherEdge](align.otherOffset);
    return [targetAnchorPoint[0] - myAnchorPoint[0], targetAnchorPoint[1] - myAnchorPoint[1]];
  }, getAnchorPoint_t:function(offset) {
    return [this.x + Math.round(this.getWidth() * (offset / 100)), this.y];
  }, getAnchorPoint_b:function(offset) {
    return [this.x + Math.round(this.getWidth() * (offset / 100)), this.bottom];
  }, getAnchorPoint_l:function(offset) {
    return [this.x, this.y + Math.round(this.getHeight() * (offset / 100))];
  }, getAnchorPoint_r:function(offset) {
    return [this.right, this.y + Math.round(this.getHeight() * (offset / 100))];
  }, getAnchorPoint_c:function() {
    return [this.x + Math.round(this.getWidth() / 2), this.y + Math.round(this.getHeight() / 2)];
  }, getCenter:function() {
    return [this.x + this.width / 2, this.y + this.height / 2];
  }, getHeight:function() {
    return this.bottom - this.y;
  }, getWidth:function() {
    return this.right - this.x;
  }, getArea:function() {
    return this.getHeight() * this.getWidth();
  }, setHeight:function(h) {
    this.height = h;
    this.bottom = this.top + h;
    return this;
  }, setWidth:function(w) {
    this.width = w;
    this.right = this.left + w;
    return this;
  }, getSize:function() {
    return {width:this.right - this.x, height:this.bottom - this.y};
  }, setSize:function(w, h) {
    if (h === undefined) {
      h = w;
    }
    this.setWidth(w);
    return this.setHeight(h);
  }, copy:function() {
    return new this.self(this.y, this.right, this.bottom, this.x);
  }, copyFrom:function(p) {
    var me = this;
    me.top = me.y = me[1] = p.y;
    me.right = p.right;
    me.bottom = p.bottom;
    me.left = me.x = me[0] = p.x;
    return me;
  }, toString:function() {
    return 'Region[' + this.top + ',' + this.right + ',' + this.bottom + ',' + this.left + ']';
  }, translateBy:function(x, y) {
    if (x.length) {
      y = x[1];
      x = x[0];
    } else {
      if (arguments.length === 1) {
        y = x.y;
        x = x.x;
      }
    }
    var me = this;
    me.top = me.y += y;
    me.right += x;
    me.bottom += y;
    me.left = me.x += x;
    return me;
  }, round:function() {
    var me = this;
    me.top = me.y = Math.round(me.y);
    me.right = Math.round(me.right);
    me.bottom = Math.round(me.bottom);
    me.left = me.x = Math.round(me.x);
    return me;
  }, equals:function(region) {
    return this.top === region.top && this.right === region.right && this.bottom === region.bottom && this.left === region.left;
  }, getOffsetsTo:function(offsetsTo) {
    return {x:this.x - offsetsTo.x, y:this.y - offsetsTo.y};
  }, highlight:function() {
    var highlightEl = Ext.getBody().createChild({style:'background-color:#52a0db;opacity:0.4;position:absolute;z-index:9999999'});
    highlightEl.setBox(this);
    Ext.defer(function() {
      highlightEl.destroy();
    }, 5000);
    return highlightEl;
  }};
}, function(Region) {
  Region.prototype.getAlignInfo = Region.getAlignInfo;
  Region.EMPTY = new Region(0, 0, 0, 0);
  if (Object.freeze) {
    Object.freeze(Region.EMPTY);
  }
});
Ext.define('Ext.util.Point', {extend:Ext.util.Region, isPoint:true, radianToDegreeConstant:180 / Math.PI, origin:{x:0, y:0}, statics:{fromEvent:function(e) {
  var changedTouches = e.changedTouches, touch = changedTouches && changedTouches.length > 0 ? changedTouches[0] : e;
  return this.fromTouch(touch);
}, fromTouch:function(touch) {
  return new this(touch.pageX, touch.pageY);
}, from:function(object) {
  if (!object) {
    return new this(0, 0);
  }
  if (!(object instanceof this)) {
    return new this(object.x, object.y);
  }
  return object;
}}, constructor:function(x, y) {
  if (x == null) {
    x = 0;
  }
  if (y == null) {
    y = 0;
  }
  this.callParent([y, x, y, x]);
}, clone:function() {
  return new this.self(this.x, this.y);
}, copy:function() {
  return this.clone.apply(this, arguments);
}, copyFrom:function(point) {
  this.x = point.x;
  this.y = point.y;
  return this;
}, toString:function() {
  return 'Point[' + this.x + ',' + this.y + ']';
}, equals:function(point) {
  return this.x === point.x && this.y === point.y;
}, isCloseTo:function(point, threshold) {
  if (typeof threshold == 'number') {
    return this.getDistanceTo(point) <= threshold;
  }
  var x = point.x, y = point.y, thresholdX = threshold.x, thresholdY = threshold.y;
  return this.x <= x + thresholdX && this.x >= x - thresholdX && this.y <= y + thresholdY && this.y >= y - thresholdY;
}, isWithin:function() {
  return this.isCloseTo.apply(this, arguments);
}, isContainedBy:function(region) {
  if (!(region instanceof Ext.util.Region)) {
    region = Ext.get(region.el || region).getRegion();
  }
  return region.contains(this);
}, roundedEquals:function(point) {
  if (!point || typeof point !== 'object') {
    point = this.origin;
  }
  return Math.round(this.x) === Math.round(point.x) && Math.round(this.y) === Math.round(point.y);
}, getDistanceTo:function(point) {
  if (!point || typeof point !== 'object') {
    point = this.origin;
  }
  var deltaX = this.x - point.x, deltaY = this.y - point.y;
  return Math.sqrt(deltaX * deltaX + deltaY * deltaY);
}, getAngleTo:function(point) {
  if (!point || typeof point !== 'object') {
    point = this.origin;
  }
  var deltaX = this.x - point.x, deltaY = this.y - point.y;
  return Math.atan2(deltaY, deltaX) * this.radianToDegreeConstant;
}}, function() {
  this.prototype.translate = this.prototype.translateBy;
});
Ext.define('Ext.event.Event', {alternateClassName:'Ext.EventObjectImpl', stopped:false, claimed:false, defaultPrevented:false, isEvent:true, geckoRelatedTargetEvents:{blur:1, dragenter:1, dragleave:1, focus:1}, statics:{resolveTextNode:function(node) {
  return node && node.nodeType === 3 ? node.parentNode : node;
}, gestureEvents:{}, pointerEvents:{pointerdown:1, pointermove:1, pointerup:1, pointercancel:1, pointerover:1, pointerout:1, pointerenter:1, pointerleave:1, MSPointerDown:1, MSPointerMove:1, MSPointerUp:1, MSPointerOver:1, MSPointerOut:1, MSPointerCancel:1, MSPointerEnter:1, MSPointerLeave:1}, mouseEvents:{mousedown:1, mousemove:1, mouseup:1, mouseover:1, mouseout:1, mouseenter:1, mouseleave:1}, clickEvents:{click:1, dblclick:1}, touchEvents:{touchstart:1, touchmove:1, touchend:1, touchcancel:1}, 
focusEvents:{focus:1, focusin:1, focusenter:1}, blurEvents:{blur:1, focusout:1, focusleave:1}, pointerTypeMap:{2:'touch', 3:'pen', 4:'mouse', touch:'touch', pen:'pen', mouse:'mouse'}, keyEventRe:/^key/, keyFlags:{CTRL:'ctrlKey', CONTROL:'ctrlKey', ALT:'altKey', SHIFT:'shiftKey', CMD:'metaKey', COMMAND:'metaKey', CMDORCTRL:Ext.isMac ? 'metaKey' : 'ctrlKey', COMMANDORCONTROL:Ext.isMac ? 'metaKey' : 'ctrlKey', META:'metaKey'}, modifierGlyphs:{ctrlKey:'', altKey:'', metaKey:Ext.isMac ? '' : '', shiftKey:''}, 
specialKeyGlyphs:{BACKSPACE:'', TAB:'', ENTER:'', RETURN:'', SPACE:'', PAGE_UP:'', PAGE_DOWN:'', END:'', HOME:'', LEFT:'', UP:'', RIGHT:'', DOWN:'', PRINT_SCREEN:'', INSERT:'', DELETE:'', CONTEXT_MENU:''}, _hyphenRe:/^[a-z]+\-/i, getKeyId:function(keyName) {
  if (typeof keyName === 'number') {
    keyName = this.keyCodes[keyName];
  } else {
    keyName = keyName.toUpperCase();
  }
  var me = this, delim = me._hyphenRe.test(keyName) ? '-' : '+', parts = keyName === delim ? [delim] : keyName.split(delim), numModifiers = parts.length - 1, rawKey = parts[numModifiers], result = [], eventFlag, i;
  if (!Ext.event.Event[rawKey]) {
    Ext.raise('Invalid key name: "' + rawKey + '"');
  }
  for (i = 0; i < numModifiers; i++) {
    eventFlag = me.keyFlags[parts[i]];
    if (!eventFlag) {
      Ext.raise('Invalid key modifier: "' + parts[i] + '"');
    }
    result[eventFlag] = true;
  }
  if (result.ctrlKey) {
    result.push(me.modifierGlyphs.ctrlKey);
  }
  if (result.altKey) {
    result.push(me.modifierGlyphs.altKey);
  }
  if (result.shiftKey) {
    result.push(me.modifierGlyphs.shiftKey);
  }
  if (result.metaKey) {
    result.push(me.modifierGlyphs.metaKey);
  }
  result.push(this.specialKeyGlyphs[rawKey] || rawKey);
  return result.join('');
}, globalTabKeyDown:function(e) {
  if (e.keyCode === 9) {
    Ext.event.Event.forwardTab = !e.shiftKey;
  }
}, globalTabKeyUp:function(e) {
  if (e.keyCode === 9) {
    delete Ext.event.Event.forwardTab;
  }
}}, constructor:function(event) {
  var me = this, self = me.self, resolveTextNode = me.self.resolveTextNode, changedTouches = event.changedTouches, coordinateOwner = changedTouches ? changedTouches[0] : event, type = event.type, pointerType, relatedTarget;
  me.timeStamp = me.time = Ext.now();
  me.pageX = coordinateOwner.pageX;
  me.pageY = coordinateOwner.pageY;
  me.clientX = coordinateOwner.clientX;
  me.clientY = coordinateOwner.clientY;
  me.target = me.delegatedTarget = resolveTextNode(event.target);
  me.currentTarget = resolveTextNode(event.currentTarget);
  relatedTarget = event.relatedTarget;
  if (relatedTarget) {
    if (Ext.isGecko && me.geckoRelatedTargetEvents[type]) {
      try {
        me.relatedTarget = resolveTextNode(relatedTarget);
      } catch (e$18) {
        me.relatedTarget = null;
      }
    } else {
      me.relatedTarget = resolveTextNode(relatedTarget);
    }
  }
  me.browserEvent = me.event = event;
  me.type = type;
  me.button = event.button || 0;
  me.shiftKey = event.shiftKey;
  me.ctrlKey = event.ctrlKey || event.metaKey || false;
  me.altKey = event.altKey;
  me.charCode = event.charCode;
  me.keyCode = event.keyCode;
  me.buttons = event.buttons;
  if (me.button === 0 && me.buttons === 0) {
    me.buttons = 1;
  }
  if (self.focusEvents[type] || self.blurEvents[type]) {
    if (self.forwardTab !== undefined) {
      me.forwardTab = self.forwardTab;
    }
    if (self.focusEvents[type]) {
      me.fromElement = event.relatedTarget;
      me.toElement = event.target;
    } else {
      me.fromElement = event.target;
      me.toElement = event.relatedTarget;
    }
  } else {
    if (type !== 'keydown') {
      delete self.forwardTab;
    }
  }
  if (self.mouseEvents[type]) {
    pointerType = 'mouse';
  } else {
    if (self.clickEvents[type]) {
      pointerType = self.pointerTypeMap[event.pointerType] || (Ext.now() - Ext.event.publisher.Dom.lastTouchEndTime < 1000 ? 'touch' : 'mouse');
    } else {
      if (self.pointerEvents[type]) {
        pointerType = self.pointerTypeMap[event.pointerType] || 'mouse';
      } else {
        if (self.touchEvents[type]) {
          pointerType = 'touch';
        }
      }
    }
  }
  if (pointerType) {
    me.pointerType = pointerType;
  }
  me.isMultitouch = event.isPrimary === false || event.touches && event.touches.length > 1;
}, chain:function(props) {
  var e = Ext.Object.chain(this);
  e.parentEvent = this;
  return Ext.apply(e, props);
}, correctWheelDelta:function(delta) {
  var scale = this.WHEEL_SCALE, ret = Math.round(delta / scale);
  if (!ret && delta) {
    ret = delta < 0 ? -1 : 1;
  }
  return ret;
}, getChar:function() {
  var r = this.which();
  return String.fromCharCode(r);
}, getCharCode:function() {
  return this.charCode || this.keyCode;
}, getKey:function() {
  return this.keyCode || this.charCode;
}, getKeyName:function() {
  return this.type === 'keypress' ? String.fromCharCode(this.getCharCode()) : this.keyCodes[this.keyCode];
}, key:function() {
  return this.browserEvent.key;
}, which:function() {
  var me = this, e = me.browserEvent, r = e.which;
  if (r == null) {
    if (me.self.keyEventRe.test(e.type)) {
      r = e.charCode || e.keyCode;
    } else {
      if ((r = e.button) !== undefined) {
        r = r & 1 ? 1 : r & 4 ? 2 : r & 2 ? 3 : 0;
      }
    }
  }
  return r;
}, getClipboardData:function(type) {
  var clipboardData = this.browserEvent.clipboardData, clipIE = Ext.global.clipboardData, result = null, typeIE;
  type = type || 'text/plain';
  if (clipboardData && clipboardData.getData) {
    result = clipboardData.getData(type);
  } else {
    if (clipIE && clipIE.getData) {
      typeIE = this.ieMimeType[type];
      if (typeIE) {
        result = clipIE.getData(typeIE);
      }
    }
  }
  return result;
}, getPoint:function() {
  var me = this, point = me.point, xy;
  if (!point) {
    xy = me.getXY();
    point = me.point = new Ext.util.Point(xy[0], xy[1]);
  }
  return point;
}, getRelatedTarget:function(selector, maxDepth, returnEl) {
  var relatedTarget = this.relatedTarget, target = null;
  if (relatedTarget && relatedTarget.nodeType) {
    if (selector) {
      target = Ext.fly(relatedTarget).findParent(selector, maxDepth, returnEl);
    } else {
      target = returnEl ? Ext.get(relatedTarget) : relatedTarget;
    }
  }
  return target;
}, getTarget:function(selector, maxDepth, returnEl) {
  return selector ? Ext.fly(this.target).findParent(selector, maxDepth, returnEl) : returnEl ? Ext.get(this.target) : this.target;
}, getTime:function() {
  return this.time;
}, getWheelDelta:function() {
  var deltas = this.getWheelDeltas();
  return deltas.y;
}, getWheelDeltas:function() {
  var me = this, event = me.browserEvent, dx = 0, dy = 0;
  if (Ext.isDefined(event.wheelDeltaX)) {
    dx = event.wheelDeltaX;
    dy = event.wheelDeltaY;
  } else {
    if (event.wheelDelta) {
      dy = event.wheelDelta;
    } else {
      if ('deltaX' in event) {
        dx = event.deltaX;
        dy = -event.deltaY;
      } else {
        if (event.detail) {
          dy = -event.detail;
          if (dy > 100) {
            dy = 3;
          } else {
            if (dy < -100) {
              dy = -3;
            }
          }
          if (Ext.isDefined(event.axis) && event.axis === event.HORIZONTAL_AXIS) {
            dx = dy;
            dy = 0;
          }
        }
      }
    }
  }
  return {x:me.correctWheelDelta(dx), y:me.correctWheelDelta(dy)};
}, getX:function() {
  return this.getXY()[0];
}, getXY:function() {
  var me = this, xy = me.xy;
  if (!xy) {
    xy = me.xy = [me.pageX, me.pageY];
    var x = xy[0], browserEvent, doc, docEl, body;
    if (!x && x !== 0) {
      browserEvent = me.browserEvent;
      doc = document;
      docEl = doc.documentElement;
      body = doc.body;
      xy[0] = browserEvent.clientX + (docEl && docEl.scrollLeft || body && body.scrollLeft || 0) - (docEl && docEl.clientLeft || body && body.clientLeft || 0);
      xy[1] = browserEvent.clientY + (docEl && docEl.scrollTop || body && body.scrollTop || 0) - (docEl && docEl.clientTop || body && body.clientTop || 0);
    }
  }
  return xy;
}, getY:function() {
  return this.getXY()[1];
}, hasModifier:function() {
  var me = this;
  return !!(me.ctrlKey || me.altKey || me.shiftKey || me.metaKey);
}, isNavKeyPress:function(scrollableOnly) {
  var me = this, k = me.keyCode, isKeyPress = me.type === 'keypress';
  return (!isKeyPress || Ext.isGecko) && k >= 33 && k <= 40 || !scrollableOnly && (k === me.RETURN || k === me.TAB || k === me.ESC);
}, isSpecialKey:function() {
  var me = this, k = me.keyCode, isGecko = Ext.isGecko, isKeyPress = me.type === 'keypress';
  return isGecko && isKeyPress && me.charCode === 0 || this.isNavKeyPress() || k === me.BACKSPACE || k === me.ENTER || k >= 16 && k <= 20 || (!isKeyPress || isGecko) && k >= 44 && k <= 46;
}, makeUnpreventable:function() {
  this.browserEvent.preventDefault = Ext.emptyFn;
}, preventDefault:function() {
  var me = this, parentEvent = me.parentEvent;
  me.defaultPrevented = true;
  if (parentEvent) {
    parentEvent.defaultPrevented = true;
  }
  me.browserEvent.preventDefault();
  return me;
}, setCurrentTarget:function(target) {
  this.currentTarget = this.delegatedTarget = target;
}, stopEvent:function() {
  return this.preventDefault().stopPropagation();
}, mousedownEvents:{mousedown:1, pointerdown:1, touchstart:1}, mouseupEvents:{mouseup:1, pointerup:1, touchend:1}, stopPropagation:function() {
  var me = this, browserEvent = me.browserEvent, parentEvent = me.parentEvent;
  if (me.mousedownEvents[me.type]) {
    Ext.GlobalEvents.fireMouseDown(me);
  }
  if (me.mouseupEvents[me.type]) {
    Ext.GlobalEvents.fireMouseUp(me);
  }
  me.stopped = true;
  if (parentEvent && !me.isGesture) {
    parentEvent.stopped = true;
  }
  if (!browserEvent.stopPropagation) {
    browserEvent.cancelBubble = true;
    return me;
  }
  browserEvent.stopPropagation();
  return me;
}, claimGesture:function() {
  var me = this, parentEvent = me.parentEvent;
  me.claimed = true;
  if (parentEvent && !me.isGesture) {
    parentEvent.claimGesture();
  } else {
    me.preventDefault();
  }
  return me;
}, within:function(el, related, allowEl) {
  var t;
  if (el) {
    t = related ? this.getRelatedTarget() : this.getTarget();
  }
  if (!t || allowEl === false && t === Ext.getDom(el)) {
    return false;
  }
  return Ext.fly(el).contains(t);
}, privates:{ieMimeType:{'text/plain':'Text'}}, deprecated:{'4.0':{methods:{getPageX:'getX', getPageY:'getY'}}}}, function(Event) {
  var constants = {BACKSPACE:8, TAB:9, NUM_CENTER:12, ENTER:13, RETURN:13, SHIFT:16, CTRL:17, ALT:18, PAUSE:19, CAPS_LOCK:20, ESC:27, SPACE:32, PAGE_UP:33, PAGE_DOWN:34, END:35, HOME:36, LEFT:37, UP:38, RIGHT:39, DOWN:40, PRINT_SCREEN:44, INSERT:45, DELETE:46, ZERO:48, ONE:49, TWO:50, THREE:51, FOUR:52, FIVE:53, SIX:54, SEVEN:55, EIGHT:56, NINE:57, A:65, B:66, C:67, D:68, E:69, F:70, G:71, H:72, I:73, J:74, K:75, L:76, M:77, N:78, O:79, P:80, Q:81, R:82, S:83, T:84, U:85, V:86, W:87, X:88, Y:89, 
  Z:90, META:91, CONTEXT_MENU:93, NUM_ZERO:96, NUM_ONE:97, NUM_TWO:98, NUM_THREE:99, NUM_FOUR:100, NUM_FIVE:101, NUM_SIX:102, NUM_SEVEN:103, NUM_EIGHT:104, NUM_NINE:105, NUM_MULTIPLY:106, NUM_PLUS:107, NUM_MINUS:109, NUM_PERIOD:110, NUM_DIVISION:111, F1:112, F2:113, F3:114, F4:115, F5:116, F6:117, F7:118, F8:119, F9:120, F10:121, F11:122, F12:123, WHEEL_SCALE:120}, keyCodes = {}, gestureEvents = Event.gestureEvents, prototype = Event.prototype, i, keyName, keyCode, keys, s, scale;
  if (Ext.isGecko) {
    constants.WHEEL_SCALE = 3;
  } else {
    if (Ext.isMac) {
      if (Ext.isSafari && Ext.webKitVersion >= 532) {
        scale = 120;
      } else {
        scale = 12;
      }
      constants.WHEEL_SCALE = 3 * scale;
    }
  }
  Ext.apply(gestureEvents, Event.mouseEvents);
  Ext.apply(gestureEvents, Event.pointerEvents);
  Ext.apply(gestureEvents, Event.touchEvents);
  Ext.apply(Event, constants);
  Ext.apply(prototype, constants);
  delete constants.WHEEL_SCALE;
  delete constants.RETURN;
  for (keyName in constants) {
    keyCode = constants[keyName];
    keyCodes[keyCode] = keyName;
  }
  Event.keyCodes = prototype.keyCodes = keyCodes;
  if (!Ext.isIE9m) {
    document.addEventListener('keydown', Event.globalTabKeyDown, true);
    document.addEventListener('keyup', Event.globalTabKeyUp, true);
  }
  prototype.getTrueXY = prototype.getXY;
  if (typeof KeyboardEvent !== 'undefined' && !('key' in KeyboardEvent.prototype)) {
    prototype._keys = keys = {3:'Cancel', 6:'Help', 8:'Backspace', 9:'Tab', 12:'Clear', 13:'Enter', 16:'Shift', 17:'Control', 18:'Alt', 19:'Pause', 20:'CapsLock', 27:'Escape', 28:'Convert', 29:'NonConvert', 30:'Accept', 31:'ModeChange', 32:' ', 33:'PageUp', 34:'PageDown', 35:'End', 36:'Home', 37:'ArrowLeft', 38:'ArrowUp', 39:'ArrowRight', 40:'ArrowDown', 41:'Select', 42:'Print', 43:'Execute', 44:'PrintScreen', 45:'Insert', 46:'Delete', 48:['0', ')'], 49:['1', '!'], 50:['2', '@'], 51:['3', '#'], 52:['4', 
    '$'], 53:['5', '%'], 54:['6', '^'], 55:['7', '\x26'], 56:['8', '*'], 57:['9', '('], 91:'OS', 93:'ContextMenu', 144:'NumLock', 145:'ScrollLock', 181:'VolumeMute', 182:'VolumeDown', 183:'VolumeUp', 186:[';', ':'], 187:['\x3d', '+'], 188:[',', '\x3c'], 189:['-', '_'], 190:['.', '\x3e'], 191:['/', '?'], 192:['`', '~'], 219:['[', '{'], 220:['\\', '|'], 221:[']', '}'], 222:["'", '"'], 224:'Meta', 225:'AltGraph', 246:'Attn', 247:'CrSel', 248:'ExSel', 249:'EraseEof', 250:'Play', 251:'ZoomOut'};
    for (i = 1; i < 25; ++i) {
      keys[i + 111] = 'F' + i;
    }
    for (i = 0; i < 26; ++i) {
      keys[i] = [String.fromCharCode(i + 97), String.fromCharCode(i + 65)];
    }
    prototype.key = function() {
      var k = keys[this.browserEvent.which || this.keyCode];
      if (k && typeof k !== 'string') {
        k = k[+this.shiftKey];
      }
      return k;
    };
  }
});
Ext.define('Ext.event.publisher.Dom', {extend:Ext.event.publisher.Publisher, type:'dom', handledDomEvents:[], reEnterCount:0, captureEvents:{animationstart:1, animationend:1, resize:1, focus:1, blur:1}, directEvents:{mouseenter:1, mouseleave:1, pointerenter:1, pointerleave:1, MSPointerEnter:1, MSPointerLeave:1, load:1, unload:1, beforeunload:1, error:1, DOMContentLoaded:1, DOMFrameContentLoaded:1, hashchange:1, scroll:1, online:1, offline:1}, blockedPointerEvents:{pointerover:1, pointerout:1, pointerenter:1, 
pointerleave:1, MSPointerOver:1, MSPointerOut:1, MSPointerEnter:1, MSPointerLeave:1}, blockedCompatibilityMouseEvents:{mouseenter:1, mouseleave:1}, constructor:function() {
  var me = this, supportsPassive = Ext.supports.PassiveEventListener;
  me.listenerOptions = supportsPassive ? {passive:false} : false;
  me.captureOptions = supportsPassive ? {passive:false, capture:true} : true;
  me.bubbleSubscribers = {};
  me.captureSubscribers = {};
  me.directSubscribers = {};
  me.directCaptureSubscribers = {};
  me.delegatedListeners = {};
  me.initHandlers();
  Ext.onInternalReady(me.onReady, me);
  me.callParent();
  me.registerDomEvents();
}, registerDomEvents:function() {
  var me = this, publishersByEvent = Ext.event.publisher.Publisher.publishersByEvent, domEvents = me.handledDomEvents, ln = domEvents.length, i, eventName;
  for (i = 0; i < ln; i++) {
    eventName = domEvents[i];
    me.handles[eventName] = 1;
    publishersByEvent[eventName] = me;
  }
}, onReady:function() {
  var me = this, domEvents = me.handledDomEvents, ln, i;
  if (domEvents) {
    for (i = 0, ln = domEvents.length; i < ln; i++) {
      me.addDelegatedListener(domEvents[i]);
    }
  }
  Ext.getWin().on('unload', me.destroy, me, {priority:-10000});
}, initHandlers:function() {
  var me = this;
  me.onDelegatedEvent = Ext.bind(me.onDelegatedEvent, me);
  me.onDirectEvent = Ext.bind(me.onDirectEvent, me);
  me.onDirectCaptureEvent = Ext.bind(me.onDirectCaptureEvent, me);
}, addDelegatedListener:function(eventName) {
  var me = this;
  me.delegatedListeners[eventName] = 1;
  me.target.addEventListener(eventName, me.onDelegatedEvent, me.captureEvents[eventName] ? me.captureOptions : me.listenerOptions);
}, removeDelegatedListener:function(eventName) {
  var me = this;
  delete me.delegatedListeners[eventName];
  me.target.removeEventListener(eventName, me.onDelegatedEvent, me.captureEvents[eventName] ? me.captureOptions : me.listenerOptions);
}, addDirectListener:function(eventName, element, capture) {
  var me = this;
  element.dom.addEventListener(eventName, capture ? me.onDirectCaptureEvent : me.onDirectEvent, capture ? me.captureOptions : me.listenerOptions);
}, removeDirectListener:function(eventName, element, capture) {
  var me = this;
  element.dom.removeEventListener(eventName, capture ? me.onDirectCaptureEvent : me.onDirectEvent, capture ? me.captureOptions : me.listenerOptions);
}, subscribe:function(element, eventName, delegated, capture) {
  var me = this, subscribers, id;
  if (delegated && !me.directEvents[eventName]) {
    subscribers = capture ? me.captureSubscribers : me.bubbleSubscribers;
    if (!me.handles[eventName] && !me.delegatedListeners[eventName]) {
      me.addDelegatedListener(eventName);
    }
    if (subscribers[eventName]) {
      ++subscribers[eventName];
    } else {
      subscribers[eventName] = 1;
    }
  } else {
    subscribers = capture ? me.directCaptureSubscribers : me.directSubscribers;
    id = element.id;
    subscribers = subscribers[eventName] || (subscribers[eventName] = {});
    if (subscribers[id]) {
      ++subscribers[id];
    } else {
      subscribers[id] = 1;
      me.addDirectListener(eventName, element, capture);
    }
  }
}, unsubscribe:function(element, eventName, delegated, capture) {
  var me = this, captureSubscribers, bubbleSubscribers, subscribers, id;
  if (delegated && !me.directEvents[eventName]) {
    captureSubscribers = me.captureSubscribers;
    bubbleSubscribers = me.bubbleSubscribers;
    subscribers = capture ? captureSubscribers : bubbleSubscribers;
    if (subscribers[eventName]) {
      --subscribers[eventName];
    }
    if (!me.handles[eventName] && !bubbleSubscribers[eventName] && !captureSubscribers[eventName]) {
      this.removeDelegatedListener(eventName);
    }
  } else {
    subscribers = capture ? me.directCaptureSubscribers : me.directSubscribers;
    id = element.id;
    subscribers = subscribers[eventName];
    if (subscribers[id]) {
      --subscribers[id];
    }
    if (!subscribers[id]) {
      delete subscribers[id];
      me.removeDirectListener(eventName, element, capture);
    }
  }
}, getPropagatingTargets:function(target) {
  var currentNode = target, targets = [], parentNode;
  while (currentNode) {
    targets.push(currentNode);
    parentNode = currentNode.parentNode;
    if (!parentNode) {
      parentNode = currentNode.defaultView;
    }
    currentNode = parentNode;
  }
  return targets;
}, publish:function(e, targets, claimed) {
  var me = this, hasCaptureSubscribers = false, hasBubbleSubscribers = false, events, type, target, el, i, ln, j, eLn;
  claimed = claimed || false;
  if (!targets) {
    if (e instanceof Array) {
      Ext.raise('Propagation targets must be supplied when publishing an array of events.');
    }
    target = e.target;
    if (me.captureEvents[e.type]) {
      el = Ext.cache[target.id];
      targets = el ? [el] : [];
    } else {
      targets = me.getPropagatingTargets(target);
    }
  }
  events = Ext.Array.from(e);
  ln = targets.length;
  eLn = events.length;
  for (i = 0; i < eLn; i++) {
    type = events[i].type;
    if (!hasCaptureSubscribers && me.captureSubscribers[type]) {
      hasCaptureSubscribers = true;
    }
    if (!hasBubbleSubscribers && me.bubbleSubscribers[type]) {
      hasBubbleSubscribers = true;
    }
  }
  if (hasCaptureSubscribers) {
    for (i = ln; i--;) {
      el = Ext.cache[targets[i].id];
      if (el) {
        for (j = 0; j < eLn; j++) {
          e = events[j];
          me.fire(el, e.type, e, false, true);
          if (!claimed && e.claimed) {
            claimed = true;
            j = me.filterClaimed(events, e);
            eLn = events.length;
          }
          if (e.stopped) {
            events.splice(j, 1);
            j--;
            eLn--;
          }
        }
      }
    }
  }
  if (hasBubbleSubscribers && !e.stopped) {
    for (i = 0; i < ln; i++) {
      el = Ext.cache[targets[i].id];
      if (el) {
        for (j = 0; j < eLn; j++) {
          e = events[j];
          me.fire(el, e.type, e, false, false);
          if (!claimed && e.claimed && me.filterClaimed) {
            claimed = true;
            j = me.filterClaimed(events, e);
            eLn = events.length;
          }
          if (e.stopped) {
            events.splice(j, 1);
            j--;
            eLn--;
          }
        }
      }
    }
  }
}, publishDelegatedDomEvent:function(e) {
  this.publish(e);
}, fire:function(element, eventName, e, direct, capture) {
  var event;
  if (element.hasListeners[eventName]) {
    event = element.events[eventName];
    if (event) {
      if (capture && direct) {
        event = event.directCaptures;
      } else {
        if (capture) {
          event = event.captures;
        } else {
          if (direct) {
            event = event.directs;
          }
        }
      }
      if (event) {
        e.setCurrentTarget(element.dom);
        event.fire(e, e.target);
      }
    }
  }
}, onDelegatedEvent:function(e) {
  if (Ext.elevateFunction) {
    Ext.elevateFunction(this.doDelegatedEvent, this, [e]);
  } else {
    this.doDelegatedEvent(e);
  }
}, doDelegatedEvent:function(e) {
  var me = this, timeStamp;
  e = new Ext.event.Event(e);
  timeStamp = e.time;
  if (!me.isEventBlocked(e)) {
    me.beforeEvent(e);
    Ext.frameStartTime = timeStamp;
    me.reEnterCountAdjusted = false;
    me.reEnterCount++;
    me.publishDelegatedDomEvent(e);
    if (!me.reEnterCountAdjusted) {
      me.reEnterCount--;
    }
    me.afterEvent(e);
  }
}, onDirectEvent:function(e) {
  if (Ext.elevateFunction) {
    Ext.elevateFunction(this.doDirectEvent, this, [e, false]);
  } else {
    this.doDirectEvent(e, false);
  }
}, onDirectCaptureEvent:function(e) {
  if (Ext.elevateFunction) {
    Ext.elevateFunction(this.doDirectEvent, this, [e, true]);
  } else {
    this.doDirectEvent(e, true);
  }
}, doDirectEvent:function(e, capture) {
  var me = this, currentTarget = e.currentTarget, timeStamp, el;
  e = new Ext.event.Event(e);
  timeStamp = e.time;
  if (me.isEventBlocked(e)) {
    return;
  }
  me.beforeEvent(e);
  Ext.frameStartTime = timeStamp;
  el = Ext.cache[currentTarget.id];
  if (el) {
    me.reEnterCountAdjusted = false;
    me.reEnterCount++;
    me.fire(el, e.type, e, true, capture);
    if (!me.reEnterCountAdjusted) {
      me.reEnterCount--;
    }
  }
  me.afterEvent(e);
}, beforeEvent:function(e) {
  var browserEvent = e.browserEvent, self = Ext.event.publisher.Dom, touches, touch;
  if (browserEvent.type === 'touchstart') {
    touches = browserEvent.touches;
    if (touches.length === 1) {
      touch = touches[0];
      self.lastTouchStartX = touch.pageX;
      self.lastTouchStartY = touch.pageY;
    }
  }
}, afterEvent:function(e) {
  var browserEvent = e.browserEvent, type = browserEvent.type, self = Ext.event.publisher.Dom, GlobalEvents = Ext.GlobalEvents;
  if (e.self.pointerEvents[type] && e.pointerType !== 'mouse') {
    self.lastScreenPointerEventTime = Ext.now();
  }
  if (type === 'touchend') {
    self.lastTouchEndTime = Ext.now();
  }
  if (!this.reEnterCount && !GlobalEvents.idleEventMask[type]) {
    Ext.fireIdle();
  }
}, isEventBlocked:function(e) {
  var me = this, type = e.type, self = Ext.event.publisher.Dom, now = Ext.now();
  if (Ext.isGecko && e.type === 'click' && e.button === 2) {
    return true;
  }
  return me.blockedPointerEvents[type] && e.pointerType !== 'mouse' || me.blockedCompatibilityMouseEvents[type] && now - self.lastScreenPointerEventTime < 1000 || Ext.supports.TouchEvents && e.self.mouseEvents[e.type] && Math.abs(e.pageX - self.lastTouchStartX) < 15 && Math.abs(e.pageY - self.lastTouchStartY) < 15 && Ext.now() - self.lastTouchEndTime < 1000;
}, destroy:function() {
  var GC = Ext.dom['GarbageCollector'], eventName;
  for (eventName in this.delegatedListeners) {
    this.removeDelegatedListener(eventName);
  }
  Ext.Reaper.flush();
  if (GC) {
    GC.collect();
  }
  this.callParent();
}, reset:function() {
  var self = Ext.event.publisher.Dom;
  this.reEnterCount = 0;
  self.lastScreenPointerEventTime = self.lastTouchEndTime = self.lastTouchStartX = self.lastTouchStartY = undefined;
}}, function(Dom) {
  var doc = document, defaultView = doc.defaultView, prototype = Dom.prototype;
  if (Ext.os.is.iOS && Ext.os.version.getMajor() < 5 || Ext.browser.is.AndroidStock || !(defaultView && defaultView.addEventListener)) {
    prototype.target = doc;
  } else {
    prototype.target = defaultView;
  }
  Dom.instance = new Dom;
});
Ext.define('Ext.event.publisher.Gesture', {extend:Ext.event.publisher.Dom, type:'gesture', isCancelEvent:{touchcancel:1, pointercancel:1, MSPointerCancel:1}, isEndEvent:{mouseup:1, touchend:1, pointerup:1, MSPointerUp:1}, handledEvents:[], handledDomEvents:[], constructor:function(config) {
  var me = this, handledDomEvents = me.handledDomEvents, supports = Ext.supports, supportsTouchEvents = supports.TouchEvents, onTouchStart = me.onTouchStart, onTouchMove = me.onTouchMove, onTouchEnd = me.onTouchEnd;
  me.handlers = {touchstart:onTouchStart, touchmove:onTouchMove, touchend:onTouchEnd, touchcancel:onTouchEnd, pointerdown:onTouchStart, pointermove:onTouchMove, pointerup:onTouchEnd, pointercancel:onTouchEnd, MSPointerDown:onTouchStart, MSPointerMove:onTouchMove, MSPointerUp:onTouchEnd, MSPointerCancel:onTouchEnd, mousedown:onTouchStart, mousemove:onTouchMove, mouseup:onTouchEnd};
  me.activeTouchesMap = {};
  me.activeTouches = [];
  me.changedTouches = [];
  me.recognizers = [];
  me.eventToRecognizer = {};
  me.cancelEvents = [];
  if (supportsTouchEvents) {
    me.onTargetTouchMove = me.onTargetTouchMove.bind(me);
    me.onTargetTouchEnd = me.onTargetTouchEnd.bind(me);
  }
  if (supports.PointerEvents) {
    handledDomEvents.push('pointerdown', 'pointermove', 'pointerup', 'pointercancel');
    me.mousePointerType = 'mouse';
  } else {
    if (supports.MSPointerEvents) {
      handledDomEvents.push('MSPointerDown', 'MSPointerMove', 'MSPointerUp', 'MSPointerCancel');
      me.mousePointerType = 4;
    } else {
      if (supportsTouchEvents) {
        handledDomEvents.push('touchstart', 'touchmove', 'touchend', 'touchcancel');
      }
    }
  }
  if (!handledDomEvents.length || supportsTouchEvents && Ext.os.is.Desktop) {
    handledDomEvents.push('mousedown', 'mousemove', 'mouseup');
  }
  me.initConfig(config);
  return me.callParent();
}, onReady:function() {
  this.callParent();
  Ext.Array.sort(this.recognizers, function(recognizerA, recognizerB) {
    var a = recognizerA.priority, b = recognizerB.priority;
    return a > b ? 1 : a < b ? -1 : 0;
  });
}, registerRecognizer:function(recognizer) {
  var me = this, handledEvents = recognizer.handledEvents, ln = handledEvents.length, eventName, i;
  recognizer.setOnRecognized(me.onRecognized);
  recognizer.setCallbackScope(me);
  for (i = 0; i < ln; i++) {
    eventName = handledEvents[i];
    me.handledEvents.push(eventName);
    me.eventToRecognizer[eventName] = recognizer;
  }
  me.registerEvents(handledEvents);
  me.recognizers.push(recognizer);
}, onRecognized:function(recognizer, eventName, e, info, isCancel) {
  var me = this, touches = e.touches, changedTouches = e.changedTouches, ln = changedTouches.length, events = me.events, queueWasEmpty = !events.length, cancelEvents = me.cancelEvents, targetGroups, targets, i, touch;
  info = info || {};
  info.type = eventName;
  info.target = changedTouches[0].target;
  info.stopped = false;
  info.claimed = false;
  info.isGesture = true;
  e = e.chain(info);
  if (!me.gestureTargets) {
    if (ln > 1) {
      targetGroups = [];
      for (i = 0; i < ln; i++) {
        touch = changedTouches[i];
        targetGroups.push(touch.targets);
      }
      targets = me.getCommonTargets(targetGroups);
    } else {
      targets = changedTouches[0].targets;
    }
    me.gestureTargets = targets;
  }
  if (isCancel && recognizer.isSingleTouch && touches.length > 1) {
    e.target = touches[0].target;
    cancelEvents.push(e);
  } else {
    events.push(e);
  }
  if (queueWasEmpty) {
    me.publishGestures();
  }
}, getCommonTargets:function(targetGroups) {
  var firstTargetGroup = targetGroups[0], ln = targetGroups.length;
  if (ln === 1) {
    return firstTargetGroup;
  }
  var commonTargets = [], i = 1, target, targets, j;
  while (true) {
    target = firstTargetGroup[firstTargetGroup.length - i];
    if (!target) {
      return commonTargets;
    }
    for (j = 1; j < ln; j++) {
      targets = targetGroups[j];
      if (targets[targets.length - i] !== target) {
        return commonTargets;
      }
    }
    commonTargets.unshift(target);
    i++;
  }
  return commonTargets;
}, invokeRecognizers:function(methodName, e) {
  var recognizers = this.recognizers, ln = recognizers.length, i, recognizer;
  if (methodName === 'onStart') {
    for (i = 0; i < ln; i++) {
      recognizers[i].isActive = true;
    }
  }
  for (i = 0; i < ln; i++) {
    recognizer = recognizers[i];
    if (recognizer.isActive && recognizer[methodName].call(recognizer, e) === false) {
      recognizer.isActive = false;
    }
  }
}, filterClaimed:function(events, claimedEvent) {
  var me = this, eventToRecognizer = me.eventToRecognizer, claimedEventType = claimedEvent.type, claimedRecognizer = eventToRecognizer[claimedEventType], claimedEventIndex, recognizer, type, i;
  for (i = events.length; i--;) {
    type = events[i].type;
    if (type === claimedEventType) {
      claimedEventIndex = i;
    } else {
      recognizer = eventToRecognizer[type];
      if (!claimedRecognizer || recognizer && recognizer !== claimedRecognizer) {
        events.splice(i, 1);
        if (claimedEventIndex) {
          claimedEventIndex--;
        }
      }
    }
  }
  me.claimRecognizer(claimedRecognizer, events[0]);
  return claimedEventIndex;
}, claimRecognizer:function(claimedRecognizer, e) {
  var me = this, recognizers = me.recognizers, i, ln, recognizer;
  for (i = 0, ln = recognizers.length; i < ln; i++) {
    recognizer = recognizers[i];
    if (recognizer !== claimedRecognizer) {
      recognizer.isActive = false;
      recognizer.cancel(e);
    }
  }
  if (me.events.length) {
    me.publishGestures(true);
  }
}, publishGestures:function(claimed) {
  var me = this, cancelEvents = me.cancelEvents, events = me.events, gestureTargets = me.gestureTargets;
  if (cancelEvents.length) {
    me.cancelEvents = [];
    me.publish(cancelEvents, me.getPropagatingTargets(cancelEvents[0].target), true);
  }
  if (events.length) {
    me.events = [];
    me.gestureTargets = null;
    me.publish(events, gestureTargets || me.getPropagatingTargets(events[0].target), claimed);
  }
}, updateTouches:function(e) {
  var me = this, browserEvent = e.browserEvent, type = e.type, touchSources = browserEvent.changedTouches || [browserEvent], activeTouches = me.activeTouches, activeTouchesMap = me.activeTouchesMap, changedTouches = [], touchSource, identifier, touch, target, i, ln, x, y;
  for (i = 0, ln = touchSources.length; i < ln; i++) {
    touchSource = touchSources[i];
    if ('identifier' in touchSource) {
      identifier = touchSource.identifier;
    } else {
      if ('pointerId' in touchSource) {
        identifier = touchSource.pointerId;
      } else {
        identifier = 1;
      }
    }
    touch = activeTouchesMap[identifier];
    if (!touch) {
      target = Ext.event.Event.resolveTextNode(touchSource.target);
      touch = activeTouchesMap[identifier] = {identifier:identifier, target:target, targets:me.getPropagatingTargets(target)};
      activeTouches.push(touch);
    }
    if (me.isEndEvent[type] || me.isCancelEvent[type]) {
      delete activeTouchesMap[identifier];
      Ext.Array.remove(activeTouches, touch);
    }
    x = touchSource.pageX;
    y = touchSource.pageY;
    touch.pageX = x;
    touch.pageY = y;
    touch.point = new Ext.util.Point(x, y);
    changedTouches.push(touch);
  }
  e.touches = Ext.Array.clone(activeTouches);
  e.changedTouches = changedTouches;
}, publishDelegatedDomEvent:function(e) {
  var me = this;
  if (!e.button || e.button < 1) {
    me.events = [e];
    e.browserEvent.$extHandled = true;
    me.handlers[e.type].call(me, e);
  } else {
    me.callParent([e]);
  }
}, onTouchStart:function(e) {
  var me = this, target = e.target, touches = e.browserEvent.touches;
  if (e.browserEvent.type === 'touchstart') {
    target.addEventListener('touchmove', me.onTargetTouchMove);
    target.addEventListener('touchend', me.onTargetTouchEnd);
    target.addEventListener('touchcancel', me.onTargetTouchEnd);
  }
  if (touches && touches.length <= me.activeTouches.length) {
    me.removeGhostTouches(touches);
  }
  me.updateTouches(e);
  if (!me.isStarted) {
    if (Ext.enableGarbageCollector) {
      Ext.dom.GarbageCollector.pause();
    }
    me.isStarted = true;
    me.invokeRecognizers('onStart', e);
  }
  me.invokeRecognizers('onTouchStart', e);
  me.publishGestures();
}, onTouchMove:function(e) {
  var me = this, mousePointerType = me.mousePointerType, isStarted = me.isStarted;
  if (isStarted || e.pointerType !== 'mouse') {
    me.updateTouches(e);
  }
  if (isStarted) {
    if (mousePointerType && e.browserEvent.pointerType === mousePointerType && e.buttons === 0) {
      e.type = Ext.dom.Element.prototype.eventMap.touchend;
      e.button = 0;
      me.onTouchEnd(e);
      return;
    }
    if (e.changedTouches.length > 0) {
      me.invokeRecognizers('onTouchMove', e);
    }
  }
  me.publishGestures();
}, onTouchEnd:function(e) {
  var me = this, isStarted = me.isStarted, touchCount;
  if (isStarted || e.pointerType !== 'mouse') {
    me.updateTouches(e);
  }
  if (!isStarted) {
    me.publishGestures();
    return;
  }
  touchCount = me.activeTouches.length;
  try {
    me.invokeRecognizers(me.isCancelEvent[e.type] ? 'onTouchCancel' : 'onTouchEnd', e);
  } finally {
    try {
      if (!touchCount) {
        me.isStarted = false;
        me.invokeRecognizers('onEnd', e);
      }
    } finally {
      try {
        me.publishGestures();
      } finally {
        if (!touchCount) {
          if (Ext.enableGarbageCollector) {
            Ext.dom.GarbageCollector.resume();
          }
        }
        me.reEnterCountAdjusted = true;
        me.reEnterCount--;
      }
    }
  }
}, onTargetTouchMove:function(e) {
  if (Ext.elevateFunction) {
    Ext.elevateFunction(this.doTargetTouchMove, this, [e]);
  } else {
    this.doTargetTouchMove(e);
  }
}, doTargetTouchMove:function(e) {
  var me = this;
  if (!Ext.getBody().contains(e.target)) {
    me.reEnterCountAdjusted = false;
    me.reEnterCount++;
    this.onTouchMove(new Ext.event.Event(e));
    if (!me.reEnterCountAdjusted) {
      me.reEnterCount--;
    }
  }
}, onTargetTouchEnd:function(e) {
  if (Ext.elevateFunction) {
    Ext.elevateFunction(this.doTargetTouchEnd, this, [e]);
  } else {
    this.doTargetTouchEnd(e);
  }
}, doTargetTouchEnd:function(e) {
  var me = this, target = e.target;
  target.removeEventListener('touchmove', me.onTargetTouchMove);
  target.removeEventListener('touchend', me.onTargetTouchEnd);
  target.removeEventListener('touchcancel', me.onTargetTouchEnd);
  if (!Ext.getBody().contains(target)) {
    me.reEnterCountAdjusted = false;
    me.reEnterCount++;
    me.onTouchEnd(new Ext.event.Event(e));
    if (!me.reEnterCountAdjusted) {
      me.reEnterCount--;
    }
  }
}, reset:function() {
  var me = this, recognizers = me.recognizers, ln = recognizers.length, i, recognizer;
  me.activeTouchesMap = {};
  me.activeTouches = [];
  me.changedTouches = [];
  me.isStarted = false;
  me.gestureTargets = null;
  me.events = [];
  me.cancelEvents = [];
  for (i = 0; i < ln; i++) {
    recognizer = recognizers[i];
    recognizer.reset();
    recognizer.isActive = false;
  }
  this.callParent();
}, privates:{removeGhostTouches:function(touches) {
  var ids = {}, len = touches.length, activeTouches = this.activeTouches, map = this.activeTouchesMap, i, id, touch;
  for (i = 0; i < len; ++i) {
    ids[touches[i].identifier] = true;
  }
  i = activeTouches.length;
  while (i--) {
    touch = activeTouches[i];
    id = touch.identifier;
    if (!touches[id]) {
      Ext.Array.remove(activeTouches, touch);
      delete map[id];
    }
  }
}}}, function(Gesture) {
  var EventProto = Event.prototype, stopPropagation = EventProto.stopPropagation;
  if (stopPropagation) {
    EventProto.stopPropagation = function() {
      var me = this, publisher = Gesture.instance, type = me.type, e;
      if (!me.$extHandled && publisher.handles[type]) {
        e = new Ext.event.Event(me);
        publisher.updateTouches(e);
        publisher.invokeRecognizers('onTouchCancel', e);
        publisher.reset();
        publisher.reEnterCountAdjusted = true;
      }
      stopPropagation.apply(me, arguments);
    };
  }
  Gesture.instance = Ext.$gesturePublisher = new Gesture;
});
Ext.define('Ext.mixin.Templatable', {extend:Ext.Mixin, mixinConfig:{id:'templatable'}, referenceAttributeName:'reference', referenceSelector:'[reference]', getElementConfig:function() {
  return {reference:'element'};
}, getElementTemplate:function() {
  var elementTemplate = document.createDocumentFragment();
  elementTemplate.appendChild(Ext.Element.create(this.getElementConfig(), true));
  return elementTemplate;
}, initElement:function() {
  var prototype = this.self.prototype;
  prototype.elementTemplate = this.getElementTemplate();
  prototype.initElement = prototype.doInitElement;
  this.initElement.apply(this, arguments);
}, linkElement:function(reference, node) {
  this.link(reference, node);
}, doInitElement:function() {
  var referenceAttributeName = this.referenceAttributeName, renderElement, referenceNodes, i, ln, referenceNode, reference;
  renderElement = this.elementTemplate.cloneNode(true);
  referenceNodes = renderElement.querySelectorAll(this.referenceSelector);
  for (i = 0, ln = referenceNodes.length; i < ln; i++) {
    referenceNode = referenceNodes[i];
    reference = referenceNode.getAttribute(referenceAttributeName);
    referenceNode.removeAttribute(referenceAttributeName);
    this.linkElement(reference, referenceNode);
  }
}});
Ext.define('Ext.TaskQueue', {singleton:true, pending:false, mode:true, protectedReadQueue:[], protectedWriteQueue:[], readQueue:[], writeQueue:[], readRequestId:0, writeRequestId:0, timer:null, constructor:function() {
  var me = this;
  me.run = me.run.bind(me);
  me.runProtected = Ext.Function.bind(me.run, me, [me.protectedReadQueue, me.protectedWriteQueue, 'runProtected']);
  me.runProtected.$skipTimerCheck = true;
  if (Ext.os.is.iOS) {
    me.watch.$skipTimerCheck = true;
    me.watchdogTimer = Ext.interval(this.watch, 500, this);
  }
}, requestRead:function(fn, scope, args) {
  var request = {id:++this.readRequestId, fn:fn, scope:scope, args:args};
  if (arguments[3] === true) {
    this.protectedReadQueue.push(request);
    this.request(true, 'runProtected');
  } else {
    this.readQueue.push(request);
    this.request(true);
  }
  return request.id;
}, cancelRead:function(id) {
  this.cancelRequest(this.readQueue, id, true);
}, requestWrite:function(fn, scope, args) {
  var me = this, request = {id:++me.writeRequestId, fn:fn, scope:scope, args:args};
  if (arguments[3] === true) {
    me.protectedWriteQueue.push(request);
    me.request(false, 'runProtected');
  } else {
    me.writeQueue.push(request);
    me.request(false);
  }
  return request.id;
}, cancelWrite:function(id) {
  this.cancelRequest(this.writeQueue, id, false);
}, request:function(mode, method) {
  var me = this;
  var oldMode = me.mode;
  if (!me.pending) {
    me.pendingTime = Date.now();
    me.pending = true;
    me.mode = mode;
    if (mode) {
      me.timer = Ext.defer(me[method] || me.run, 1);
    } else {
      me.timer = Ext.raf(me[method] || me.run);
    }
  }
  if (me.mode === mode && me.timer) {
    if (oldMode) {
      Ext.undefer(me.timer);
    } else {
      Ext.unraf(me.timer);
    }
    if (mode) {
      me.timer = Ext.defer(me[method] || me.run, 1);
    } else {
      me.timer = Ext.raf(me[method] || me.run);
    }
  }
}, cancelRequest:function(queue, id, mode) {
  for (var i = 0; i < queue.length; i++) {
    if (queue[i].id === id) {
      queue.splice(i, 1);
      break;
    }
  }
  if (!queue.length && this.mode === mode && this.timer) {
    Ext.undefer(this.timer);
  }
}, watch:function() {
  if (this.pending && Date.now() - this.pendingTime >= 500) {
    this.run();
  }
}, run:function(readQueue, writeQueue, method) {
  var me = this, mode = null, queue, tasks, task, fn, scope, args, i, len;
  readQueue = readQueue || me.readQueue;
  writeQueue = writeQueue || me.writeQueue;
  me.pending = false;
  me.pending = me.timer = false;
  if (me.mode) {
    queue = readQueue;
    if (writeQueue.length > 0) {
      mode = false;
    }
  } else {
    queue = writeQueue;
    if (readQueue.length > 0) {
      mode = true;
    }
  }
  tasks = queue.slice();
  queue.length = 0;
  for (i = 0, len = tasks.length; i < len; i++) {
    task = tasks[i];
    fn = task.fn;
    scope = task.scope;
    args = task.args;
    if (scope && (scope.destroying || scope.destroyed)) {
      continue;
    }
    if (typeof fn === 'string') {
      fn = scope[fn];
    }
    if (args) {
      fn.apply(scope, args);
    } else {
      fn.call(scope);
    }
  }
  tasks.length = 0;
  if (mode !== null) {
    me.request(mode, method);
  }
}, clear:function() {
  var me = this, timer = me.timer;
  if (timer) {
    if (me.mode) {
      Ext.undefer(timer);
    } else {
      Ext.unraf(timer);
    }
  }
  me.readQueue.length = me.writeQueue.length = 0;
  me.pending = me.timer = false;
  me.mode = true;
}, privates:{flush:function() {
  var me = this, mode = me.mode;
  while (me.readQueue.length || me.writeQueue.length) {
    if (mode) {
      Ext.undefer(me.timer);
    } else {
      Ext.unraf(me.timer);
    }
    me.run();
  }
  me.mode = true;
}}});
Ext.define('Ext.util.sizemonitor.Abstract', {mixins:[Ext.mixin.Templatable], config:{element:null, callback:Ext.emptyFn, scope:null, args:[]}, width:null, height:null, contentWidth:null, contentHeight:null, constructor:function(config) {
  var me = this;
  me.refresh = me.refresh.bind(me);
  me.info = {width:0, height:0, contentWidth:0, contentHeight:0, flag:0};
  me.initElement();
  me.initConfig(config);
  me.bindListeners(true);
}, bindListeners:Ext.emptyFn, applyElement:function(element) {
  if (element) {
    return Ext.get(element);
  }
}, updateElement:function(element) {
  element.append(this.detectorsContainer, true);
  element.addCls(Ext.baseCSSPrefix + 'size-monitored');
}, applyArgs:function(args) {
  return args.concat([this.info]);
}, refreshMonitors:Ext.emptyFn, forceRefresh:function() {
  Ext.TaskQueue.requestRead('refresh', this);
}, getContentBounds:function() {
  return this.detectorsContainer.getBoundingClientRect();
}, getContentWidth:function() {
  return this.detectorsContainer.clientWidth;
}, getContentHeight:function() {
  return this.detectorsContainer.clientHeight;
}, refreshSize:function() {
  var element = this.getElement();
  if (!element || element.destroyed) {
    return false;
  }
  var me = this, size = element.measure(), width = size.width, height = size.height, contentWidth = me.getContentWidth(), contentHeight = me.getContentHeight(), currentContentWidth = me.contentWidth, currentContentHeight = me.contentHeight, info = me.info, resized = false, flag;
  me.width = width;
  me.height = height;
  me.contentWidth = contentWidth;
  me.contentHeight = contentHeight;
  flag = (currentContentWidth !== contentWidth ? 1 : 0) + (currentContentHeight !== contentHeight ? 2 : 0);
  if (flag > 0) {
    info.width = width;
    info.height = height;
    info.contentWidth = contentWidth;
    info.contentHeight = contentHeight;
    info.flag = flag;
    resized = true;
    me.getCallback().apply(me.getScope(), me.getArgs());
  }
  return resized;
}, refresh:function() {
  if (this.destroying || this.destroyed) {
    return;
  }
  this.refreshSize();
  Ext.TaskQueue.requestWrite('refreshMonitors', this);
}, destroy:function() {
  var me = this, element = me.getElement();
  me.bindListeners(false);
  if (element && !element.destroyed) {
    element.removeCls(Ext.baseCSSPrefix + 'size-monitored');
  }
  delete me._element;
  me.refresh = null;
  me.callParent();
}});
Ext.define('Ext.util.sizemonitor.Scroll', {extend:Ext.util.sizemonitor.Abstract, getElementConfig:function() {
  return {reference:'detectorsContainer', classList:[Ext.baseCSSPrefix + 'size-monitors', 'scroll'], children:[{reference:'expandMonitor', className:'expand'}, {reference:'shrinkMonitor', className:'shrink'}]};
}, constructor:function(config) {
  this.onScroll = this.onScroll.bind(this);
  this.callParent(arguments);
}, bindListeners:function(bind) {
  var method = bind ? 'addEventListener' : 'removeEventListener';
  this.expandMonitor[method]('scroll', this.onScroll, true);
  this.shrinkMonitor[method]('scroll', this.onScroll, true);
}, onScroll:function() {
  if (!this.destroyed) {
    Ext.TaskQueue.requestRead('refresh', this);
  }
}, refreshMonitors:function() {
  var expandMonitor = this.expandMonitor, shrinkMonitor = this.shrinkMonitor, end = 1000000;
  if (expandMonitor && !expandMonitor.destroyed) {
    expandMonitor.scrollLeft = end;
    expandMonitor.scrollTop = end;
  }
  if (shrinkMonitor && !shrinkMonitor.destroyed) {
    shrinkMonitor.scrollLeft = end;
    shrinkMonitor.scrollTop = end;
  }
}, destroy:function() {
  this.onScroll = null;
  this.callParent();
}});
Ext.define('Ext.util.SizeMonitor', {constructor:function(config) {
  return new Ext.util.sizemonitor.Scroll(config);
}});
Ext.define('Ext.event.publisher.ElementSize', {extend:Ext.event.publisher.Publisher, type:'size', handledEvents:['resize'], constructor:function() {
  this.monitors = {};
  this.subscribers = {};
  this.callParent(arguments);
}, subscribe:function(element) {
  var id = element.id, subscribers = this.subscribers, monitors = this.monitors;
  if (subscribers[id]) {
    ++subscribers[id];
  } else {
    subscribers[id] = 1;
    monitors[id] = new Ext.util.SizeMonitor({element:element, callback:this.onElementResize, scope:this, args:[element]});
  }
  element.on('painted', 'forceRefresh', monitors[id]);
  return true;
}, unsubscribe:function(element) {
  var id = element.id, subscribers = this.subscribers, monitors = this.monitors, sizeMonitor;
  if (subscribers[id] && !--subscribers[id]) {
    delete subscribers[id];
    sizeMonitor = monitors[id];
    element.un('painted', 'forceRefresh', sizeMonitor);
    sizeMonitor.destroy();
    delete monitors[id];
  }
  if (element.activeRead) {
    Ext.TaskQueue.cancelRead(element.activeRead);
  }
}, fireElementResize:function(element, info) {
  delete element.activeRead;
  this.fire(element, 'resize', [element, info]);
}, onElementResize:function(element, info) {
  if (!element.activeRead) {
    element.activeRead = Ext.TaskQueue.requestRead('fireElementResize', this, [element, info], !!element.$skipResourceCheck);
  }
}, privates:{syncRefresh:function(elements) {
  elements = Ext.Array.from(elements);
  var len = elements.length, i = 0, el, monitor;
  for (i = 0; i < len; ++i) {
    el = elements[i];
    if (typeof el !== 'string') {
      el = el.id;
    }
    monitor = this.monitors[el];
    if (monitor) {
      monitor.forceRefresh();
    }
  }
  Ext.TaskQueue.flush();
  Ext.Function.fireElevatedHandlers();
}}}, function(ElementSize) {
  ElementSize.instance = new ElementSize;
});
Ext.define('Ext.util.paintmonitor.Abstract', {config:{element:null, callback:Ext.emptyFn, scope:null, args:[]}, eventName:'', monitorClass:'', constructor:function(config) {
  this.onElementPainted = this.onElementPainted.bind(this);
  this.initConfig(config);
}, bindListeners:function(bind) {
  this.monitorElement[bind ? 'addEventListener' : 'removeEventListener'](this.eventName, this.onElementPainted, true);
}, applyElement:function(element) {
  if (element) {
    return Ext.get(element);
  }
}, updateElement:function(element) {
  this.monitorElement = Ext.Element.create({classList:[Ext.baseCSSPrefix + 'paint-monitor', this.monitorClass]}, true);
  element.appendChild(this.monitorElement, true);
  element.addCls(Ext.baseCSSPrefix + 'paint-monitored');
  this.bindListeners(true);
}, onElementPainted:function() {
}, destroy:function() {
  var me = this, monitorElement = me.monitorElement, parentNode = monitorElement.parentNode, element = me.getElement();
  me.bindListeners(false);
  delete me.monitorElement;
  if (element && !element.destroyed) {
    element.removeCls(Ext.baseCSSPrefix + 'paint-monitored');
    delete me._element;
  }
  if (parentNode) {
    parentNode.removeChild(monitorElement);
  }
  me.callParent();
}});
Ext.define('Ext.util.paintmonitor.CssAnimation', {extend:Ext.util.paintmonitor.Abstract, eventName:Ext.browser.is.WebKit ? 'webkitAnimationEnd' : 'animationend', monitorClass:'cssanimation', onElementPainted:function(e) {
  if (e.animationName === Ext.baseCSSPrefix + 'paint-monitor-helper') {
    this.getCallback().apply(this.getScope(), this.getArgs());
  }
}});
Ext.define('Ext.util.PaintMonitor', {constructor:function(config) {
  return new Ext.util.paintmonitor.CssAnimation(config);
}});
Ext.define('Ext.event.publisher.ElementPaint', {extend:Ext.event.publisher.Publisher, type:'paint', handledEvents:['painted'], constructor:function() {
  this.monitors = {};
  this.subscribers = {};
  this.callParent(arguments);
}, subscribe:function(element) {
  var me = this, id = element.id, subscribers = me.subscribers;
  if (subscribers[id]) {
    ++subscribers[id];
  } else {
    subscribers[id] = 1;
    me.monitors[id] = new Ext.util.PaintMonitor({element:element, callback:me.onElementPainted, scope:me, args:[element]});
  }
}, unsubscribe:function(element) {
  var id = element.id, subscribers = this.subscribers, monitors = this.monitors;
  if (subscribers[id] && !--subscribers[id]) {
    delete subscribers[id];
    monitors[id].destroy();
    delete monitors[id];
  }
  if (element.activeRead) {
    Ext.TaskQueue.cancelRead(element.activeRead);
  }
}, fireElementPainted:function(element) {
  delete element.activeRead;
  this.fire(element, 'painted', [element]);
}, onElementPainted:function(element) {
  if (!element.activeRead) {
    element.activeRead = Ext.TaskQueue.requestRead('fireElementPainted', this, [element], !!element.$skipResourceCheck);
  }
}}, function(ElementPaint) {
  ElementPaint.instance = new ElementPaint;
});
Ext.define('Ext.dom.Element', function(Element) {
  var WIN = window, DOC = document, docEl = DOC.documentElement, WIN_TOP = WIN.top, EMPTY = [], elementIdCounter, windowId, documentId, WIDTH = 'width', HEIGHT = 'height', MIN_WIDTH = 'min-width', MIN_HEIGHT = 'min-height', MAX_WIDTH = 'max-width', MAX_HEIGHT = 'max-height', TOP = 'top', RIGHT = 'right', BOTTOM = 'bottom', LEFT = 'left', VISIBILITY = 'visibility', HIDDEN = 'hidden', DISPLAY = 'display', NONE = 'none', ZINDEX = 'z-index', POSITION = 'position', RELATIVE = 'relative', STATIC = 'static', 
  wordsRe = /\w/g, spacesRe = /\s+/, classNameSplitRegex = /[\s]+/, transparentRe = /^(?:transparent|(?:rgba[(](?:\s*\d+\s*[,]){3}\s*0\s*[)]))$/i, endsQuestionRe = /\?$/, topRe = /top/i, empty = {}, borders = {t:'border-top-width', r:'border-right-width', b:'border-bottom-width', l:'border-left-width'}, paddings = {t:'padding-top', r:'padding-right', b:'padding-bottom', l:'padding-left'}, margins = {t:'margin-top', r:'margin-right', b:'margin-bottom', l:'margin-left'}, selectDir = {b:'backward', 
  back:'backward', f:'forward'}, paddingsTLRB = [paddings.l, paddings.r, paddings.t, paddings.b], bordersTLRB = [borders.l, borders.r, borders.t, borders.b], numberRe = /\d+$/, unitRe = /\d+(px|r?em|%|vh|vw|vmin|vmax|en|ch|ex|pt|in|cm|mm|pc)$/i, defaultUnit = 'px', msRe = /^-ms-/, camelRe = /(-[a-z])/gi, cssRe = /([a-z0-9\-]+)\s*:\s*([^;\s]+(?:\s*[^;\s]+)*);?/gi, pxRe = /^\d+(?:\.\d*)?px$/i, relativeUnitRe = /(%|r?em|auto|vh|vw|vmin|vmax|ch|ex)$/i, propertyCache = {}, ORIGINALDISPLAY = 'originalDisplay', 
  camelReplaceFn = function(m, a) {
    return a.charAt(1).toUpperCase();
  }, clearData = function(node, deep) {
    var childNodes, i, len;
    if (node.nodeType === 1) {
      node._extData = null;
      if (deep) {
        childNodes = node.childNodes;
        for (i = 0, len = childNodes.length; i < len; ++i) {
          clearData(childNodes[i], deep);
        }
      }
    }
  }, toFloat = function(v) {
    return parseFloat(v) || 0;
  }, opacityCls = Ext.baseCSSPrefix + 'hidden-opacity', visibilityCls = Ext.baseCSSPrefix + 'hidden-visibility', displayCls = Ext.baseCSSPrefix + 'hidden-display', offsetsCls = Ext.baseCSSPrefix + 'hidden-offsets', clipCls = Ext.baseCSSPrefix + 'hidden-clip', lastFocusChange = 0, lastKeyboardClose = 0, editableHasFocus = false, isVirtualKeyboardOpen = false, inputTypeSelectionSupported = /text|password|search|tel|url/i, visFly, scrollFly, caFly, wrapFly, grannyFly, activeElFly;
  try {
    elementIdCounter = WIN_TOP.__elementIdCounter__;
    WIN_TOP.__elementIdCounter__ = elementIdCounter;
  } catch (e$19) {
    WIN_TOP = WIN;
  }
  WIN_TOP.__elementIdCounter__ = elementIdCounter = (WIN_TOP.__elementIdCounter__ || 0) + 1;
  windowId = 'ext-window-' + elementIdCounter;
  documentId = 'ext-document-' + elementIdCounter;
  if (Object.freeze) {
    Object.freeze(EMPTY);
  }
  return {alternateClassName:['Ext.Element'], mixins:[Ext.util.Positionable, Ext.mixin.Observable], observableType:'element', isElement:true, skipGarbageCollection:true, $applyConfigs:true, identifiablePrefix:'ext-element-', _selectDir:selectDir, styleHooks:{transform:{set:function(dom, value, el) {
    var prop, result = '';
    if (typeof value !== 'string') {
      for (prop in value) {
        if (result) {
          result += ' ';
        }
        if (prop.indexOf('translate') === 0) {
          result += prop + '(' + Element.addUnits(value[prop], 'px') + ')';
        } else {
          result += prop + '(' + value[prop] + ')';
        }
      }
      value = result;
    }
    dom.style.transform = value;
  }}}, validIdRe:Ext.validIdRe, blockedEvents:Ext.supports.EmulatedMouseOver ? {mouseover:1} : {}, longpressEvents:{longpress:1, taphold:1}, constructor:function(dom) {
    var me = this, id;
    if (typeof dom === 'string') {
      dom = DOC.getElementById(dom);
    }
    if (!dom) {
      Ext.raise('Invalid domNode reference or an id of an existing domNode: ' + dom);
      return null;
    }
    if (Ext.cache[dom.id]) {
      Ext.raise("Element cache already contains an entry for id '" + dom.id + "'.  Use Ext.get() to create or retrieve Element instances.");
    }
    me.dom = dom;
    id = dom.id;
    if (id) {
      me.id = id;
    } else {
      id = dom.id = me.getUniqueId();
    }
    if (!me.validIdRe.test(me.id)) {
      Ext.raise('Invalid Element "id": "' + me.id + '"');
    }
    me.el = me;
    Ext.cache[id] = me;
    me.longpressListenerCount = 0;
    me.mixins.observable.constructor.call(me);
  }, inheritableStatics:{cache:Ext.cache = {}, editableSelector:'input,textarea,[contenteditable\x3d"true"]', VISIBILITY:1, DISPLAY:2, OFFSETS:3, CLIP:4, OPACITY:5, minKeyboardHeight:100, unitRe:unitRe, useDelegatedEvents:true, validNodeTypes:{1:1, 9:1}, namespaceURIs:{html:'http://www.w3.org/1999/xhtml', svg:'http://www.w3.org/2000/svg'}, selectableCls:Ext.baseCSSPrefix + 'selectable', unselectableCls:Ext.baseCSSPrefix + 'unselectable', maxRippleDiameter:75, addUnits:function(size, units) {
    if (typeof size === 'number') {
      return size + (units || defaultUnit);
    }
    if (size === '' || size === 'auto' || size == null) {
      return size || '';
    }
    if (numberRe.test(size)) {
      return size + (units || defaultUnit);
    }
    if (!unitRe.test(size)) {
      if (!(Ext.isString(size) && size.indexOf('calc') === 0)) {
        Ext.Logger.warn('Warning, size detected (' + size + ') not a valid property value on Element.addUnits.');
      }
      return size || '';
    }
    return size;
  }, create:function(attributes, domNode) {
    var me = this, classes, element, elementStyle, tag, value, name, i, ln, tmp, ns;
    attributes = attributes || {};
    if (attributes.isElement) {
      return domNode ? attributes.dom : attributes;
    } else {
      if ('nodeType' in attributes) {
        return domNode ? attributes : Ext.get(attributes);
      }
    }
    if (typeof attributes === 'string') {
      return DOC.createTextNode(attributes);
    }
    tag = attributes.tag;
    if (!tag) {
      tag = 'div';
    }
    ns = attributes.namespace;
    if (ns) {
      element = DOC.createElementNS(me.namespaceURIs[ns] || ns, tag);
    } else {
      element = DOC.createElement(tag);
    }
    elementStyle = element.style;
    for (name in attributes) {
      if (name !== 'tag') {
        value = attributes[name];
        switch(name) {
          case 'style':
            if (typeof value === 'string') {
              element.setAttribute(name, value);
            } else {
              for (i in value) {
                elementStyle[i] = value[i];
              }
            }
            break;
          case 'className':
          case 'cls':
            tmp = value.split(spacesRe);
            classes = classes ? classes.concat(tmp) : tmp;
            break;
          case 'classList':
            classes = classes ? classes.concat(value) : value;
            break;
          case 'text':
            element.textContent = value;
            break;
          case 'html':
            element.innerHTML = value;
            break;
          case 'hidden':
            if (classes) {
              classes.push(displayCls);
            } else {
              classes = [displayCls];
            }
            break;
          case 'children':
            if (value != null) {
              for (i = 0, ln = value.length; i < ln; i++) {
                element.appendChild(me.create(value[i], true));
              }
            }
            break;
          default:
            if (value != null) {
              element.setAttribute(name, value);
            }
        }
      }
    }
    if (classes) {
      element.className = classes.join(' ');
    }
    if (domNode) {
      return element;
    } else {
      return me.get(element);
    }
  }, fly:function(dom, named) {
    return Ext.fly(dom, named);
  }, fromPoint:function() {
    var elementFromPointBug;
    if (Ext.isIE || Ext.isEdge) {
      try {
        elementFromPointBug = window.self !== window.top;
      } catch (e$20) {
        elementFromPointBug = true;
      }
    }
    return function(x, y, asDom) {
      var el = null;
      el = DOC.elementFromPoint(x, y);
      if (!el && elementFromPointBug) {
        el = DOC.elementFromPoint(x, y);
      }
      return asDom ? el : Ext.get(el);
    };
  }(), fromPagePoint:function(x, y, asDom) {
    var scroll = Ext.getDoc().getScroll();
    return Element.fromPoint(x - scroll.left, y - scroll.top, asDom);
  }, get:function(el) {
    var me = this, cache = Ext.cache, nodeType, dom, id, entry, isDoc, isWin, isValidNodeType;
    if (!el) {
      return null;
    }
    function warnDuplicate(id) {
      Ext.raise('DOM element with id ' + id + ' in Element cache is not the same as element in the DOM. ' + 'Make sure to clean up Element instances using destroy()');
    }
    if (el.isFly) {
      el = el.dom;
    }
    if (typeof el === 'string') {
      id = el;
      if (cache.hasOwnProperty(id)) {
        entry = cache[id];
        if (entry.skipGarbageCollection || !Ext.isGarbage(entry.dom)) {
          dom = Ext.getElementById ? Ext.getElementById(id) : DOC.getElementById(id);
          if (dom && dom !== entry.dom) {
            warnDuplicate(id);
          }
          return entry;
        } else {
          entry.destroy();
        }
      }
      if (id === windowId) {
        return Element.get(WIN);
      } else {
        if (id === documentId) {
          return Element.get(DOC);
        }
      }
      dom = Ext.getElementById ? Ext.getElementById(id) : DOC.getElementById(id);
      if (dom) {
        return new Element(dom);
      }
    }
    nodeType = el.nodeType;
    if (nodeType) {
      isDoc = nodeType === 9;
      isValidNodeType = me.validNodeTypes[nodeType];
    } else {
      isWin = el.window == el;
    }
    if (isValidNodeType || isWin) {
      id = el.id;
      if (cache.hasOwnProperty(id)) {
        entry = cache[id];
        if (entry.skipGarbageCollection || el === entry.dom || !Ext.isGarbage(entry.dom)) {
          if (el !== entry.dom) {
            warnDuplicate(id);
          }
          return entry;
        } else {
          entry.destroy();
        }
      }
      if (el === DOC) {
        el.id = documentId;
      }
      if (el == WIN) {
        el.id = windowId;
      }
      el = new Element(el);
      if (isWin || isDoc) {
        el.skipGarbageCollection = true;
      }
      return el;
    }
    if (el.isElement) {
      return el;
    }
    if (el.isComposite) {
      return el;
    }
    if (Ext.isIterable(el)) {
      return me.select(el);
    }
    return null;
  }, getActiveElement:function(asElement) {
    var active = DOC.activeElement;
    if (!active || !active.focus) {
      active = DOC.body;
    }
    return asElement ? Ext.get(active) : active;
  }, getDocumentHeight:function() {
    return Math.max(!Ext.isStrict ? DOC.body.scrollHeight : docEl.scrollHeight, this.getViewportHeight());
  }, getDocumentWidth:function() {
    return Math.max(!Ext.isStrict ? DOC.body.scrollWidth : docEl.scrollWidth, this.getViewportWidth());
  }, getOrientation:function() {
    if (Ext.supports.OrientationChange) {
      return WIN.orientation == 0 ? 'portrait' : 'landscape';
    }
    return WIN.innerHeight > WIN.innerWidth ? 'portrait' : 'landscape';
  }, getViewportHeight:function() {
    var viewportHeight = Element._viewportHeight;
    if (Ext.isIE9m) {
      return DOC.documentElement.clientHeight;
    }
    return viewportHeight != null ? viewportHeight : docEl.clientHeight;
  }, getViewportWidth:function() {
    var viewportWidth = Element._viewportWidth;
    if (Ext.isIE9m) {
      return DOC.documentElement.clientWidth;
    }
    return viewportWidth != null ? viewportWidth : docEl.clientWidth;
  }, getViewportScale:function() {
    var top = WIN_TOP;
    return (Ext.isiOS || Ext.isAndroid ? 1 : top.devicePixelRatio || top.screen.deviceXDPI / top.screen.logicalXDPI) * this.getViewportTouchScale();
  }, getViewportTouchScale:function(forceRead) {
    var scale = 1, top = WIN_TOP, cachedScale;
    if (!forceRead) {
      cachedScale = this._viewportTouchScale;
      if (cachedScale) {
        return cachedScale;
      }
    }
    if (Ext.isIE10p || Ext.isEdge || Ext.isiOS) {
      scale = docEl.offsetWidth / WIN.innerWidth;
    } else {
      if (Ext.isChromeMobile) {
        scale = top.outerWidth / top.innerWidth;
      }
    }
    return scale;
  }, getViewSize:function() {
    return {width:Element.getViewportWidth(), height:Element.getViewportHeight()};
  }, hasUnit:function(size) {
    return !!(size && unitRe.test(size));
  }, isRelativeUnit:function(size) {
    return !size || relativeUnitRe.test(size);
  }, maskIframes:function() {
    var iframes = document.getElementsByTagName('iframe'), fly = new Ext.dom.Fly;
    Ext.each(iframes, function(iframe) {
      var myMask;
      myMask = fly.attach(iframe.parentNode).mask();
      myMask.setStyle('background-color', 'transparent');
    });
  }, normalize:function(prop) {
    return propertyCache[prop] || (propertyCache[prop] = prop.replace(msRe, 'ms-').replace(camelRe, camelReplaceFn));
  }, _onWindowFocusChange:function(e) {
    if (Ext.fly(e.target).is(Element.editableSelector)) {
      lastFocusChange = new Date;
      editableHasFocus = e.type === 'focusin' || e.type === 'pointerup';
    }
  }, _onWindowResize:function() {
    var documentWidth = docEl.clientWidth, documentHeight = docEl.clientHeight, now = new Date, threshold = 1000, deltaX, deltaY;
    deltaX = documentWidth - Element._documentWidth;
    deltaY = documentHeight - Element._documentHeight;
    Element._documentWidth = documentWidth;
    Element._documentHeight = documentHeight;
    if (now - lastFocusChange < threshold || now - lastKeyboardClose < threshold) {
      if (deltaX === 0 && (editableHasFocus && deltaY <= -Element.minKeyboardHeight)) {
        isVirtualKeyboardOpen = true;
        return;
      }
    }
    if (isVirtualKeyboardOpen && deltaX === 0 && deltaY >= Element.minKeyboardHeight) {
      isVirtualKeyboardOpen = false;
      lastKeyboardClose = new Date;
    }
    if (isVirtualKeyboardOpen) {
      return;
    }
    Element._viewportWidth = documentWidth;
    Element._viewportHeight = documentHeight;
  }, parseBox:function(box) {
    box = box || 0;
    var type = typeof box, parts, ln;
    if (type === 'number') {
      return {top:box, right:box, bottom:box, left:box};
    } else {
      if (type !== 'string') {
        return box;
      }
    }
    parts = box.split(' ');
    ln = parts.length;
    if (ln === 1) {
      parts[1] = parts[2] = parts[3] = parts[0];
    } else {
      if (ln === 2) {
        parts[2] = parts[0];
        parts[3] = parts[1];
      } else {
        if (ln === 3) {
          parts[3] = parts[1];
        }
      }
    }
    return {top:parseFloat(parts[0]) || 0, right:parseFloat(parts[1]) || 0, bottom:parseFloat(parts[2]) || 0, left:parseFloat(parts[3]) || 0};
  }, parseStyles:function(styles) {
    var out = {}, matches;
    if (styles) {
      cssRe.lastIndex = 0;
      while (matches = cssRe.exec(styles)) {
        out[matches[1]] = matches[2] || '';
      }
    }
    return out;
  }, select:function(selector, composite, root) {
    return Ext.fly(root || DOC).select(selector, composite);
  }, query:function(selector, asDom, root) {
    return Ext.fly(root || DOC).query(selector, asDom);
  }, unitizeBox:function(box, units) {
    var me = this;
    box = me.parseBox(box);
    return me.addUnits(box.top, units) + ' ' + me.addUnits(box.right, units) + ' ' + me.addUnits(box.bottom, units) + ' ' + me.addUnits(box.left, units);
  }, unmaskIframes:function() {
    var iframes = document.getElementsByTagName('iframe'), fly = new Ext.dom.Fly;
    Ext.each(iframes, function(iframe) {
      fly.attach(iframe.parentNode).unmask();
    });
  }, serializeForm:function(form) {
    var fElements = form.elements || (DOC.forms[form] || Ext.getDom(form)).elements, hasSubmit = false, encoder = encodeURIComponent, data = '', eLen = fElements.length, element, name, type, options, hasValue, e, o, oLen, opt;
    for (e = 0; e < eLen; e++) {
      element = fElements[e];
      name = element.name;
      type = element.type;
      options = element.options;
      if (!element.disabled && name) {
        if (/select-(one|multiple)/i.test(type)) {
          oLen = options.length;
          for (o = 0; o < oLen; o++) {
            opt = options[o];
            if (opt.selected) {
              hasValue = opt.hasAttribute('value');
              data += Ext.String.format('{0}\x3d{1}\x26', encoder(name), encoder(hasValue ? opt.value : opt.text));
            }
          }
        } else {
          if (!/file|undefined|reset|button/i.test(type)) {
            if (!(/radio|checkbox/i.test(type) && !element.checked) && !(type == 'submit' && hasSubmit)) {
              data += encoder(name) + '\x3d' + encoder(element.value) + '\x26';
              hasSubmit = /submit/i.test(type);
            }
          }
        }
      }
    }
    return data.substr(0, data.length - 1);
  }, getCommonAncestor:function(nodeA, nodeB, returnDom) {
    caFly = caFly || new Ext.dom.Fly;
    caFly.attach(Ext.getDom(nodeA));
    while (!caFly.isAncestor(nodeB)) {
      if (caFly.dom.parentNode) {
        caFly.attach(caFly.dom.parentNode);
      } else {
        caFly.attach(DOC.body);
        break;
      }
    }
    return returnDom ? caFly.dom : Ext.get(caFly);
  }}, selectable:function() {
    var me = this;
    me.dom.unselectable = '';
    me.removeCls(Element.unselectableCls);
    me.addCls(Element.selectableCls);
    return me;
  }, unselectable:function() {
    var me = this;
    if (Ext.isOpera) {
      me.dom.unselectable = 'on';
    }
    me.removeCls(Element.selectableCls);
    me.addCls(Element.unselectableCls);
    return me;
  }, statics:{tabbableSelector:Ext.supports.CSS3NegationSelector ? 'a[href],button,iframe,input,select,textarea,[tabindex]:not([tabindex\x3d"-1"]),[contenteditable\x3d"true"]' : 'a[href],button,iframe,input,select,textarea,[tabindex],[contenteditable\x3d"true"]', naturallyFocusableTags:{BUTTON:true, IFRAME:true, EMBED:true, INPUT:true, OBJECT:true, SELECT:true, TEXTAREA:true, HTML:Ext.isIE ? true : false, BODY:Ext.isIE ? false : true}, naturallyTabbableTags:{BUTTON:true, IFRAME:true, INPUT:true, 
  SELECT:true, TEXTAREA:true, OBJECT:Ext.isIE8m ? true : false}, inputTags:{INPUT:true, TEXTAREA:true}, tabbableSavedCounterAttribute:'data-tabindex-counter', tabbableSavedValueAttribute:'data-tabindex-value', splitCls:function(cls) {
    if (typeof cls === 'string') {
      cls = cls.split(spacesRe);
    }
    return cls;
  }}, _init:function(E) {
    E.tabbableSelector += ',[' + E.tabbableSavedCounterAttribute + ']';
  }, addCls:function(names, prefix, suffix) {
    return this.replaceCls(null, names, prefix, suffix);
  }, addClsOnClick:function(className, testFn, scope) {
    var me = this, hasTest = Ext.isFunction(testFn);
    me.on('mousedown', function() {
      if (hasTest && testFn.call(scope || me, me) === false) {
        return false;
      }
      me.addCls(className);
      Ext.getDoc().on({mouseup:function() {
        if (me.dom) {
          me.removeCls(className);
        }
      }, single:true});
    });
    return me;
  }, addClsOnFocus:function(className, testFn, scope) {
    var me = this, hasTest = Ext.isFunction(testFn);
    me.on('focus', function() {
      if (hasTest && testFn.call(scope || me, me) === false) {
        return false;
      }
      me.addCls(className);
    });
    me.on('blur', function() {
      if (me.dom) {
        me.removeCls(className);
      }
    });
    return me;
  }, addClsOnOver:function(className, testFn, scope) {
    var me = this, hasTest = Ext.isFunction(testFn);
    me.hover(function() {
      if (hasTest && testFn.call(scope || me, me) === false) {
        return;
      }
      me.addCls(className);
    }, function() {
      me.removeCls(className);
    });
    return me;
  }, addStyles:function(sides, styles) {
    var totalSize = 0, sidesArr = (sides || '').match(wordsRe), i, len = sidesArr.length, side, styleSides = [];
    if (len === 1) {
      totalSize = parseFloat(this.getStyle(styles[sidesArr[0]])) || 0;
    } else {
      if (len) {
        for (i = 0; i < len; i++) {
          side = sidesArr[i];
          styleSides.push(styles[side]);
        }
        styleSides = this.getStyle(styleSides);
        for (i = 0; i < len; i++) {
          side = sidesArr[i];
          totalSize += parseFloat(styleSides[styles[side]]) || 0;
        }
      }
    }
    return totalSize;
  }, addUnits:function(size, units) {
    return Element.addUnits(size, units);
  }, animate:function(animation) {
    animation = new Ext.fx.Animation(animation);
    animation.setElement(this);
    this._activeAnimation = animation;
    animation.on({animationend:this._onAnimationEnd, scope:this});
    Ext.Animator.run(animation);
    return animation;
  }, _onAnimationEnd:function() {
    this._activeAnimation = null;
  }, getActiveAnimation:function() {
    return this._activeAnimation;
  }, append:function() {
    return this.appendChild.apply(this, arguments);
  }, appendChild:function(el, returnDom) {
    var me = this, insertEl, eLen, e;
    if (el.nodeType || el.dom || typeof el === 'string') {
      el = Ext.getDom(el);
      me.dom.appendChild(el);
      return !returnDom ? Ext.get(el) : el;
    } else {
      if (el.length) {
        insertEl = Ext.fly(DOC.createDocumentFragment());
        eLen = el.length;
        for (e = 0; e < eLen; e++) {
          insertEl.appendChild(el[e], returnDom);
        }
        el = Ext.Array.toArray(insertEl.dom.childNodes);
        me.dom.appendChild(insertEl.dom);
        return returnDom ? el : new Ext.dom.CompositeElementLite(el);
      } else {
        return me.createChild(el, null, returnDom);
      }
    }
  }, appendTo:function(el) {
    Ext.getDom(el).appendChild(this.dom);
    return this;
  }, applyStyles:function(styles) {
    if (styles) {
      if (typeof styles === 'function') {
        styles = styles.call();
      }
      if (typeof styles === 'string') {
        styles = Element.parseStyles(styles);
      }
      if (typeof styles === 'object') {
        this.setStyle(styles);
      }
    }
    return this;
  }, blur:function() {
    var me = this, dom = me.dom;
    if (dom !== DOC.body) {
      try {
        dom.blur();
      } catch (e$21) {
      }
      return me;
    } else {
      return me.focus(undefined, dom);
    }
  }, cacheScrollValues:function() {
    var me = this, scrollValues = [], scrolledDescendants = [], descendants, descendant, i, len;
    scrollFly = scrollFly || new Ext.dom.Fly;
    descendants = me.query('*');
    for (i = 0, len = descendants.length; i < len; i++) {
      descendant = descendants[i];
      if (descendant.scrollTop > 0 || descendant.scrollLeft !== 0) {
        scrolledDescendants.push(descendant);
        scrollValues.push(scrollFly.attach(descendant).getScroll());
      }
    }
    return function() {
      var scroll, i, len;
      for (i = 0, len = scrolledDescendants.length; i < len; i++) {
        scroll = scrollValues[i];
        scrollFly.attach(scrolledDescendants[i]);
        scrollFly.setScrollLeft(scroll.left);
        scrollFly.setScrollTop(scroll.top);
      }
    };
  }, center:function(centerIn) {
    return this.alignTo(centerIn || DOC, 'c-c');
  }, child:function(selector, returnDom) {
    var me = this, id;
    if (Ext.supports.Selectors2) {
      return me.selectNode(':scope\x3e' + selector, !!returnDom);
    } else {
      id = me.id != null ? me.id : Ext.get(me).id;
      return me.selectNode(Ext.makeIdSelector(id) + ' \x3e ' + selector, !!returnDom);
    }
  }, clone:function(deep, returnDom) {
    var clone = this.dom.cloneNode(deep);
    if (Ext.supports.CloneNodeCopiesExpando) {
      clearData(clone, deep);
    }
    return returnDom ? clone : Ext.get(clone);
  }, constrainScrollLeft:function(left) {
    var dom = this.dom;
    return Math.max(Math.min(left, dom.scrollWidth - dom.clientWidth), 0);
  }, constrainScrollTop:function(top) {
    var dom = this.dom;
    return Math.max(Math.min(top, dom.scrollHeight - dom.clientHeight), 0);
  }, createChild:function(config, insertBefore, returnDom) {
    config = config || {tag:'div'};
    if (insertBefore) {
      return Ext.DomHelper.insertBefore(insertBefore, config, returnDom !== true);
    } else {
      return Ext.DomHelper.append(this.dom, config, returnDom !== true);
    }
  }, contains:function(element) {
    if (!element) {
      return false;
    }
    var me = this, dom = Ext.getDom(element);
    return dom === me.dom || me.isAncestor(dom);
  }, destroy:function() {
    var me = this, dom = me.dom;
    if (me.destroyed) {
      Ext.Logger.warn('Cannot destroy Element "' + me.id + '". Already destroyed.');
      return;
    }
    if (me.resumeFocusEventsTimer) {
      Ext.unasap(me.resumeFocusEventsTimer);
      me.resumeFocusEventsTimer = null;
    }
    if (me.repaintTimer) {
      me.repaintTimer = Ext.undefer(me.repaintTimer);
    }
    if (me.deferFocusTimer) {
      me.deferFocusTimer = Ext.undefer(me.deferFocusTimer);
    }
    if (dom) {
      if (dom === DOC.body) {
        Ext.raise('Cannot destroy body element.');
      } else {
        if (dom === DOC) {
          Ext.raise('Cannot destroy document object.');
        } else {
          if (dom === WIN) {
            Ext.raise('Cannot destroy window object');
          }
        }
      }
    }
    if (dom && dom.parentNode) {
      dom.parentNode.removeChild(dom);
    }
    if (me.$ripples) {
      me.destroyAllRipples();
    }
    me.collect();
  }, detach:function() {
    var dom = this.dom, component = this.component;
    if (dom && dom.parentNode && dom.tagName !== 'BODY') {
      if (component) {
        component.revertFocus();
      }
      dom.parentNode.removeChild(dom);
    }
    return this;
  }, disableShadow:function() {
    var shadow = this.shadow;
    if (shadow) {
      shadow.hide();
      shadow.disabled = true;
    }
  }, disableShim:function() {
    var shim = this.shim;
    if (shim) {
      shim.hide();
      shim.disabled = true;
    }
  }, doReplaceWith:function(element) {
    var dom = this.dom;
    dom.parentNode.replaceChild(Ext.getDom(element), dom);
  }, doScrollIntoView:function(container, hscroll, animate, highlight, getScrollX, scrollTo) {
    scrollFly = scrollFly || new Ext.dom.Fly;
    var me = this, dom = me.dom, scrollX = scrollFly.attach(container)[getScrollX](), scrollY = container.scrollTop, position = me.getScrollIntoViewXY(container, scrollX, scrollY), newScrollX = position.x, newScrollY = position.y;
    if (highlight) {
      if (animate) {
        animate = Ext.apply({listeners:{afteranimate:function() {
          scrollFly.attach(dom).highlight();
        }}}, animate);
      } else {
        scrollFly.attach(dom).highlight();
      }
    }
    if (newScrollY !== scrollY) {
      scrollFly.attach(container).scrollTo('top', newScrollY, animate);
    }
    if (hscroll !== false && newScrollX !== scrollX) {
      scrollFly.attach(container)[scrollTo]('left', newScrollX, animate);
    }
    return me;
  }, down:function(selector, returnDom) {
    return this.selectNode(selector, !!returnDom);
  }, enableShadow:function(options, isVisible) {
    var me = this, shadow = me.shadow || (me.shadow = new Ext.dom.Shadow(Ext.apply({target:me}, options))), shim = me.shim;
    if (shim) {
      shim.offsets = shadow.outerOffsets;
      shim.shadow = shadow;
      shadow.shim = shim;
    }
    if (isVisible === true || isVisible !== false && me.isVisible()) {
      shadow.show();
    } else {
      shadow.hide();
    }
    shadow.disabled = false;
  }, enableShim:function(options, isVisible) {
    var me = this, shim = me.shim || (me.shim = new Ext.dom.Shim(Ext.apply({target:me}, options))), shadow = me.shadow;
    if (shadow) {
      shim.offsets = shadow.outerOffsets;
      shim.shadow = shadow;
      shadow.shim = shim;
    }
    if (isVisible === true || isVisible !== false && me.isVisible()) {
      shim.show();
    } else {
      shim.hide();
    }
    shim.disabled = false;
    return shim;
  }, findParent:function(simpleSelector, limit, returnEl) {
    var me = this, target = me.dom, topmost = docEl, depth = 0;
    if (limit || limit === 0) {
      if (typeof limit !== 'number') {
        topmost = Ext.getDom(limit);
        limit = Number.MAX_VALUE;
      }
    } else {
      limit = 50;
    }
    while (target && target.nodeType === 1 && depth < limit && target !== topmost) {
      if (Ext.fly(target).is(simpleSelector)) {
        return returnEl ? Ext.get(target) : target;
      }
      depth++;
      target = target.parentNode;
    }
    return null;
  }, findParentNode:function(simpleSelector, limit, returnEl) {
    var p = Ext.fly(this.dom.parentNode);
    return p ? p.findParent(simpleSelector, limit, returnEl) : null;
  }, first:function(selector, returnDom) {
    return this.matchNode('nextSibling', 'firstChild', selector, returnDom);
  }, focus:function(defer, dom) {
    var me = this;
    dom = dom || me.dom;
    if (Number(defer)) {
      Ext.defer(me.focus, defer, me, [null, dom]);
    } else {
      Ext.GlobalEvents.fireEvent('beforefocus', dom);
      dom.focus();
    }
    return me;
  }, collect:function() {
    var me = this, dom = me.dom, shadow = me.shadow, shim = me.shim;
    if (!me.isFly) {
      me.mixins.observable.destroy.call(me);
      delete Ext.cache[me.id];
      me.el = null;
    }
    if (dom) {
      dom._extData = me.dom = null;
    }
    if (shadow) {
      shadow.hide();
      me.shadow = null;
    }
    if (shim) {
      shim.hide();
      me.shim = null;
    }
  }, getAnchorToXY:function(el, anchor, local, mySize) {
    return el.getAnchorXY(anchor, local, mySize);
  }, getAttribute:function(name, namespace) {
    var dom = this.dom;
    return namespace ? dom.getAttributeNS(namespace, name) || dom.getAttribute(namespace + ':' + name) : dom.getAttribute(name) || dom[name] || null;
  }, getAttributes:function() {
    var attributes = this.dom.attributes, result = {}, attr, i, len;
    for (i = 0, len = attributes.length; i < len; i++) {
      attr = attributes[i];
      result[attr.name] = attr.value;
    }
    return result;
  }, getBottom:function(local) {
    return (local ? this.getLocalY() : this.getY()) + this.getHeight();
  }, getById:function(id, asDom) {
    var dom = DOC.getElementById(id) || this.dom.querySelector(Ext.makeIdSelector(id));
    return asDom ? dom : dom ? Ext.get(dom) : null;
  }, getBorderPadding:function() {
    var paddingWidth = this.getStyle(paddingsTLRB), bordersWidth = this.getStyle(bordersTLRB);
    return {beforeX:(parseFloat(bordersWidth[borders.l]) || 0) + (parseFloat(paddingWidth[paddings.l]) || 0), afterX:(parseFloat(bordersWidth[borders.r]) || 0) + (parseFloat(paddingWidth[paddings.r]) || 0), beforeY:(parseFloat(bordersWidth[borders.t]) || 0) + (parseFloat(paddingWidth[paddings.t]) || 0), afterY:(parseFloat(bordersWidth[borders.b]) || 0) + (parseFloat(paddingWidth[paddings.b]) || 0)};
  }, getBorders:function() {
    var bordersWidth = this.getStyle(bordersTLRB);
    return {beforeX:parseFloat(bordersWidth[borders.l]) || 0, afterX:parseFloat(bordersWidth[borders.r]) || 0, beforeY:parseFloat(bordersWidth[borders.t]) || 0, afterY:parseFloat(bordersWidth[borders.b]) || 0};
  }, getBorderWidth:function(side) {
    return this.addStyles(side, borders);
  }, getClassMap:function(clone) {
    var data = this.getData();
    if (data) {
      data = data.classMap;
      if (clone !== false) {
        data = Ext.apply({}, data);
      }
    }
    return data;
  }, getData:function(sync) {
    var dom = this.dom, data;
    if (dom) {
      data = dom._extData || (dom._extData = {});
      if (sync !== false && !data.isSynchronized) {
        this.synchronize();
      }
    }
    return data || null;
  }, getFirstChild:function() {
    return Ext.get(this.dom.firstElementChild);
  }, getLastChild:function() {
    return Ext.get(this.dom.lastElementChild);
  }, getHeight:function(contentHeight, preciseHeight) {
    var me = this, dom = me.dom, hidden = me.isStyle('display', 'none'), height, floating;
    if (hidden) {
      return 0;
    }
    if (dom.nodeName === 'BODY') {
      height = Element.getViewportHeight();
    } else {
      if (preciseHeight) {
        height = dom.getBoundingClientRect().height;
      } else {
        height = dom.offsetHeight;
        if (height == null) {
          height = dom.getBoundingClientRect().height;
        }
      }
    }
    if (Ext.supports.Direct2DBug) {
      floating = me.adjustDirect2DDimension(HEIGHT);
      if (preciseHeight) {
        height += floating;
      } else {
        if (floating > 0 && floating < 0.5) {
          height++;
        }
      }
    }
    if (contentHeight) {
      height -= me.getBorderWidth('tb') + me.getPadding('tb');
    }
    return height < 0 ? 0 : height;
  }, getHtml:function() {
    return this.dom ? this.dom.innerHTML : '';
  }, getLeft:function(local) {
    return local ? this.getLocalX() : this.getX();
  }, getLocalX:function() {
    var me = this, offsetParent, x = me.getStyle('left');
    if (!x || x === 'auto') {
      x = 0;
    } else {
      if (pxRe.test(x)) {
        x = parseFloat(x);
      } else {
        x = me.getX();
        offsetParent = me.dom.offsetParent;
        if (offsetParent) {
          x -= Ext.fly(offsetParent).getX();
        }
      }
    }
    return x;
  }, getLocalXY:function() {
    var me = this, offsetParent, style = me.getStyle(['left', 'top']), x = style.left, y = style.top;
    if (!x || x === 'auto') {
      x = 0;
    } else {
      if (pxRe.test(x)) {
        x = parseFloat(x);
      } else {
        x = me.getX();
        offsetParent = me.dom.offsetParent;
        if (offsetParent) {
          x -= Ext.fly(offsetParent).getX();
        }
      }
    }
    if (!y || y === 'auto') {
      y = 0;
    } else {
      if (pxRe.test(y)) {
        y = parseFloat(y);
      } else {
        y = me.getY();
        offsetParent = me.dom.offsetParent;
        if (offsetParent) {
          y -= Ext.fly(offsetParent).getY();
        }
      }
    }
    return [x, y];
  }, getLocalY:function() {
    var me = this, offsetParent, y = me.getStyle('top');
    if (!y || y === 'auto') {
      y = 0;
    } else {
      if (pxRe.test(y)) {
        y = parseFloat(y);
      } else {
        y = me.getY();
        offsetParent = me.dom.offsetParent;
        if (offsetParent) {
          y -= Ext.fly(offsetParent).getY();
        }
      }
    }
    return y;
  }, getMargin:function() {
    var hash = {t:'top', l:'left', r:'right', b:'bottom'}, allMargins = ['margin-top', 'margin-left', 'margin-right', 'margin-bottom'];
    return function(side) {
      var me = this, style, key, o;
      if (!side) {
        style = me.getStyle(allMargins);
        o = {};
        if (style && typeof style === 'object') {
          o = {};
          for (key in margins) {
            o[key] = o[hash[key]] = parseFloat(style[margins[key]]) || 0;
          }
        }
      } else {
        o = me.addStyles(side, margins);
      }
      return o;
    };
  }(), getPadding:function(side) {
    return this.addStyles(side, paddings);
  }, getParent:function() {
    return Ext.get(this.dom.parentNode);
  }, getRight:function(local) {
    return (local ? this.getLocalX() : this.getX()) + this.getWidth();
  }, getScroll:function() {
    var me = this, dom = me.dom, docElement = docEl, left, top, body = DOC.body;
    if (dom === DOC || dom === body) {
      left = docElement.scrollLeft || (body ? body.scrollLeft : 0);
      top = docElement.scrollTop || (body ? body.scrollTop : 0);
    } else {
      left = dom.scrollLeft;
      top = dom.scrollTop;
    }
    return {left:left, top:top};
  }, getScrollIntoViewXY:function(container, scrollX, scrollY, align) {
    align = align || empty;
    var me = this, dom = me.dom, offsets, clientWidth, clientHeight;
    if (container.isRegion) {
      clientHeight = container.height;
      clientWidth = container.width;
    } else {
      container = Ext.getDom(container);
      clientHeight = container.clientHeight;
      clientWidth = container.clientWidth;
    }
    offsets = me.getOffsetsTo(container);
    return {y:me.calcScrollPos(offsets[1] + scrollY, dom.offsetHeight, scrollY, clientHeight, align.y), x:me.calcScrollPos(offsets[0] + scrollX, dom.offsetWidth, scrollX, clientWidth, align.x)};
  }, calcScrollPos:function(start, size, viewStart, viewSize, align) {
    var end = start + size, viewEnd = viewStart + viewSize, force = align && !endsQuestionRe.test(align), ret = viewStart;
    if (!force) {
      if (align) {
        align = align.slice(0, -1);
      }
      if (size > viewSize || start < viewStart) {
        align = align || 'start';
        force = true;
      } else {
        if (end > viewEnd) {
          align = align || 'end';
          force = true;
        }
      }
    }
    if (force) {
      if (align === 'start') {
        ret = start;
      } else {
        if (align === 'center') {
          ret = Math.max(0, start - Math.floor(viewSize / 2));
        } else {
          if (align === 'end') {
            ret = Math.max(0, end - viewSize);
          }
        }
      }
    }
    return ret;
  }, getScrollLeft:function() {
    var dom = this.dom;
    if (dom === DOC || dom === DOC.body) {
      return this.getScroll().left;
    } else {
      return dom.scrollLeft;
    }
  }, getScrollTop:function() {
    var dom = this.dom;
    if (dom === DOC || dom === DOC.body) {
      return this.getScroll().top;
    } else {
      return dom.scrollTop;
    }
  }, getSize:function(contentSize) {
    return {width:this.getWidth(contentSize), height:this.getHeight(contentSize)};
  }, getStyle:function(property, inline) {
    var me = this, dom = me.dom, multiple = typeof property !== 'string', hooks = me.styleHooks, prop = property, props = prop, len = 1, domStyle, camel, values, hook, out, style, i;
    if (multiple) {
      values = {};
      prop = props[0];
      i = 0;
      if (!(len = props.length)) {
        return values;
      }
    }
    if (!dom || dom.documentElement) {
      return values || '';
    }
    domStyle = dom.style;
    if (inline) {
      style = domStyle;
    } else {
      style = dom.ownerDocument.defaultView.getComputedStyle(dom, null);
      if (!style) {
        inline = true;
        style = domStyle;
      }
    }
    do {
      hook = hooks[prop];
      if (!hook) {
        hooks[prop] = hook = {name:Element.normalize(prop)};
      }
      if (hook.get) {
        out = hook.get(dom, me, inline, style);
      } else {
        camel = hook.name;
        out = style[camel];
      }
      if (!multiple) {
        return out;
      }
      values[prop] = out;
      prop = props[++i];
    } while (i < len);
    return values;
  }, getStyleValue:function(name) {
    return this.dom.style.getPropertyValue(name);
  }, getCaretPos:function() {
    var dom = this.dom, pos, selection;
    if (inputTypeSelectionSupported.test(dom.type)) {
      pos = dom.selectionStart;
      selection = typeof pos !== 'number' && this.getTextSelection();
      if (selection) {
        pos = selection[0];
      }
    } else {
      Ext.raise('Input type of "' + dom.type + '" does not support selectionStart');
    }
    return pos;
  }, setCaretPos:function(pos) {
    this.selectText(pos, pos);
  }, getTextSelection:function() {
    var dom = this.dom;
    if (inputTypeSelectionSupported.test(dom.type)) {
      return [dom.selectionStart, dom.selectionEnd, dom.selectionDirection];
    } else {
      Ext.raise('Input type of "' + this.dom.type + '" does not support selectionStart, selectionEnd and selectionDirection');
      return [];
    }
  }, selectText:function(start, end, direction) {
    var me = this, range, dom = me.dom, len;
    if (dom && inputTypeSelectionSupported.test(dom.type)) {
      start = start || 0;
      len = dom.value.length;
      if (end === undefined) {
        end = len;
      }
      direction = selectDir[direction] || direction || 'forward';
      if (dom.setSelectionRange) {
        dom.setSelectionRange(start, end, direction);
      } else {
        if (dom.createTextRange) {
          if (start > end) {
            start = end;
          }
          range = dom.createTextRange();
          range.moveStart('character', start);
          range.moveEnd('character', -(len - end));
          range.select();
        }
      }
    } else {
      if (!inputTypeSelectionSupported.test(dom.type)) {
        Ext.raise('Input type of "' + dom.type + '" does not support setSelectionRange');
      }
    }
    return me;
  }, getTop:function(local) {
    return local ? this.getLocalY() : this.getY();
  }, getTouchAction:function() {
    return Ext.dom.TouchAction.get(this.dom);
  }, getValue:function(asNumber) {
    var value = this.dom.value;
    return asNumber ? parseInt(value, 10) : value;
  }, getViewSize:function() {
    var dom = this.dom;
    if (dom === DOC || dom === DOC.body) {
      return {width:Element.getViewportWidth(), height:Element.getViewportHeight()};
    } else {
      return {width:dom.clientWidth, height:dom.clientHeight};
    }
  }, getVisibilityMode:function() {
    var me = this, data = me.getData(), mode = data.visibilityMode;
    if (mode === undefined) {
      data.visibilityMode = mode = Element.DISPLAY;
    }
    return mode;
  }, getWidth:function(contentWidth, preciseWidth) {
    var me = this, dom = me.dom, hidden = me.isStyle('display', 'none'), rect, width, floating;
    if (hidden) {
      return 0;
    }
    if (Ext.supports.BoundingClientRect) {
      rect = dom.getBoundingClientRect();
      width = me.vertical && !Ext.supports.RotatedBoundingClientRect ? rect.bottom - rect.top : rect.right - rect.left;
      width = preciseWidth ? width : Math.ceil(width);
    } else {
      width = dom.offsetWidth;
    }
    if (Ext.supports.Direct2DBug && !me.vertical) {
      floating = me.adjustDirect2DDimension(WIDTH);
      if (preciseWidth) {
        width += floating;
      } else {
        if (floating > 0 && floating < 0.5) {
          width++;
        }
      }
    }
    if (contentWidth) {
      width -= me.getBorderWidth('lr') + me.getPadding('lr');
    }
    return width < 0 ? 0 : width;
  }, getX:function() {
    return this.getXY()[0];
  }, getXY:function() {
    var round = Math.round, dom = this.dom, body = DOC.body, x = 0, y = 0, bodyRect, rect;
    if (dom !== DOC && dom !== body) {
      try {
        bodyRect = body.getBoundingClientRect();
        rect = dom.getBoundingClientRect();
        x = rect.left - bodyRect.left;
        y = rect.top - bodyRect.top;
      } catch (ex) {
      }
    }
    return [round(x), round(y)];
  }, getY:function() {
    return this.getXY()[1];
  }, getZIndex:function() {
    return parseInt(this.getStyle('z-index'), 10);
  }, hasCls:function(name) {
    var classMap = this.getClassMap();
    return classMap.hasOwnProperty(name);
  }, hide:function() {
    return this.setVisible(false);
  }, hover:function(overFn, outFn, scope, options) {
    var me = this;
    me.on('mouseenter', overFn, scope || me.dom, options);
    me.on('mouseleave', outFn, scope || me.dom, options);
    return me;
  }, indexOf:function(childEl) {
    var children = this.dom, c = childEl && Ext.getDom(childEl);
    children = children && children.childNodes;
    return c && children ? Array.prototype.indexOf.call(children, c) : -1;
  }, insertAfter:function(el) {
    el = Ext.getDom(el);
    el.parentNode.insertBefore(this.dom, el.nextSibling);
    return this;
  }, insertBefore:function(el) {
    el = Ext.getDom(el);
    el.parentNode.insertBefore(this.dom, el);
    return this;
  }, insertFirst:function(el, returnDom) {
    el = el || {};
    if (el.nodeType || el.dom || typeof el === 'string') {
      el = Ext.getDom(el);
      this.dom.insertBefore(el, this.dom.firstChild);
      return !returnDom ? Ext.get(el) : el;
    } else {
      return this.createChild(el, this.dom.firstChild, returnDom);
    }
  }, insertHtml:function(where, html, returnEl) {
    var el = Ext.DomHelper.insertHtml(where, this.dom, html);
    return returnEl ? Ext.get(el) : el;
  }, insertSibling:function(el, where, returnDom) {
    var me = this, DomHelper = Ext.DomHelper, isAfter = (where || 'before').toLowerCase() === 'after', rt, insertEl, eLen, e;
    if (Ext.isIterable(el)) {
      eLen = el.length;
      insertEl = Ext.fly(DOC.createDocumentFragment());
      if (Ext.isArray(el)) {
        for (e = 0; e < eLen; e++) {
          rt = insertEl.appendChild(el[e], returnDom);
        }
      } else {
        for (e = 0; e < eLen; e++) {
          insertEl.dom.appendChild(rt = el[0]);
        }
        if (returnDom === false) {
          rt = Ext.get(rt);
        }
      }
      me.dom.parentNode.insertBefore(insertEl.dom, isAfter ? me.dom.nextSibling : me.dom);
      return rt;
    }
    el = el || {};
    if (el.nodeType || el.dom) {
      rt = me.dom.parentNode.insertBefore(Ext.getDom(el), isAfter ? me.dom.nextSibling : me.dom);
      if (!returnDom) {
        rt = Ext.get(rt);
      }
    } else {
      if (isAfter && !me.dom.nextSibling) {
        rt = DomHelper.append(me.dom.parentNode, el, !returnDom);
      } else {
        rt = DomHelper[isAfter ? 'insertAfter' : 'insertBefore'](me.dom, el, !returnDom);
      }
    }
    return rt;
  }, is:function(selector) {
    var dom = this.dom, is;
    if (!selector) {
      is = true;
    } else {
      if (!dom.tagName) {
        is = false;
      } else {
        if (Ext.isFunction(selector)) {
          is = selector(dom);
        } else {
          is = dom[Ext.supports.matchesSelector](selector);
        }
      }
    }
    return is;
  }, isAncestor:function(el) {
    var ret = false, dom = this.dom, child = Ext.getDom(el);
    if (dom && child) {
      if (!child.nodeType) {
        return false;
      }
      if (dom.contains) {
        return dom.contains(child);
      } else {
        if (dom.compareDocumentPosition) {
          return !!(dom.compareDocumentPosition(child) & 16);
        } else {
          while (child = child.parentNode) {
            ret = child === dom || ret;
          }
        }
      }
    }
    return ret;
  }, isPainted:function() {
    return !Ext.browser.is.IE ? function() {
      var dom = this.dom;
      return Boolean(dom && dom.offsetParent);
    } : function() {
      var dom = this.dom;
      return Boolean(dom && (dom.offsetHeight !== 0 || dom.offsetWidth !== 0));
    };
  }(), isScrollable:function() {
    var dom = this.dom;
    return dom.scrollHeight > dom.clientHeight || dom.scrollWidth > dom.clientWidth;
  }, isStyle:function(style, val) {
    return this.getStyle(style) === val;
  }, isVisible:function(deep, mode) {
    var dom = this.dom, visible = true, end;
    if (!dom) {
      return false;
    }
    mode = mode || 3;
    if (!visFly) {
      visFly = new Ext.dom.Fly;
    }
    for (end = dom.ownerDocument.documentElement; dom !== end; dom = dom.parentNode) {
      if (!dom || dom.nodeType === 11) {
        visible = false;
      }
      if (visible) {
        visFly.attach(dom);
        if (mode & 1) {
          visible = !visFly.isStyle(DISPLAY, NONE);
        }
        if (visible && mode & 2) {
          visible = !visFly.isStyle(VISIBILITY, HIDDEN);
        }
      }
      if (!visible || !deep) {
        break;
      }
    }
    return visible;
  }, last:function(selector, returnDom) {
    return this.matchNode('previousSibling', 'lastChild', selector, returnDom);
  }, matchNode:function(dir, start, selector, returnDom) {
    var dom = this.dom, n;
    if (!dom) {
      return null;
    }
    n = dom[start];
    while (n) {
      if (n.nodeType === 1 && (!selector || Ext.fly(n, '_matchNode').is(selector))) {
        return !returnDom ? Ext.get(n) : n;
      }
      n = n[dir];
    }
    return null;
  }, measure:function(dimension) {
    var me = this, dom = me.dom, includeWidth = dimension !== 'h', includeHeight = dimension !== 'w', width = 0, height = 0, addPadding = !Ext.supports.ComputedSizeIncludesPadding, style, rect, offsetParent;
    if (dom.nodeName === 'BODY') {
      height = includeHeight && Element.getViewportHeight();
      width = includeWidth && Element.getViewportWidth();
    } else {
      offsetParent = dom.offsetParent;
      style = dom.ownerDocument.defaultView.getComputedStyle(dom, null);
      addPadding |= style.boxSizing === 'content-box';
      if (offsetParent !== null || style.position === 'fixed') {
        if (includeHeight) {
          height = toFloat(style.height);
          if (addPadding) {
            height += toFloat(style.paddingTop) + toFloat(style.paddingBottom) + toFloat(style.borderTopWidth) + toFloat(style.borderBottomWidth);
          }
        }
        if (includeWidth) {
          width = toFloat(style.width);
          if (addPadding) {
            width += toFloat(style.paddingLeft) + toFloat(style.paddingRight) + toFloat(style.borderLeftWidth) + toFloat(style.borderRightWidth);
          }
        }
      }
    }
    rect = dimension ? null : {width:width, height:height};
    return dimension ? includeWidth ? width : height : rect;
  }, measureContent:function(dimension) {
    var me = this, includeWidth = dimension !== 'h', size = me.measure(dimension), h = dimension ? size : size.height, w = dimension ? size : size.width;
    if (dimension !== 'w') {
      h -= me.getBorderWidth('tb') + me.getPadding('tb');
    }
    if (includeWidth) {
      w -= me.getBorderWidth('lr') + me.getPadding('lr');
    }
    return dimension ? includeWidth ? w : h : {width:w, height:h};
  }, monitorMouseLeave:function(delay, handler, scope) {
    var me = this, timer, listeners = {mouseleave:function(e) {
      if (Ext.isIE9m) {
        e.enableIEAsync();
      }
      timer = Ext.defer(handler, delay, scope || me, [e]);
    }, mouseenter:function() {
      Ext.undefer(timer);
    }, destroy:function() {
      Ext.undefer(timer);
      if (!me.destroyed) {
        me.un(listeners);
      }
    }};
    me.on(listeners);
    return listeners;
  }, next:function(selector, returnDom) {
    return this.matchNode('nextSibling', 'nextSibling', selector, returnDom);
  }, parent:function(selector, returnDom) {
    return this.matchNode('parentNode', 'parentNode', selector, returnDom);
  }, peekData:function() {
    var dom = this.dom;
    return dom && dom._extData || null;
  }, position:function(pos, zIndex, x, y) {
    var me = this;
    if (me.dom.tagName !== 'BODY') {
      if (!pos && me.isStyle(POSITION, STATIC)) {
        me.setStyle(POSITION, RELATIVE);
      } else {
        if (pos) {
          me.setStyle(POSITION, pos);
        }
      }
      if (zIndex) {
        me.setStyle(ZINDEX, zIndex);
      }
      if (x || y) {
        me.setXY([x || false, y || false]);
      }
    }
  }, prev:function(selector, returnDom) {
    return this.matchNode('previousSibling', 'previousSibling', selector, returnDom);
  }, query:function(selector, asDom, single) {
    var dom = this.dom, results, len, nlen, node, nodes, i, j;
    if (!dom) {
      return null;
    }
    asDom = asDom !== false;
    selector = selector.split(',');
    if (!single) {
      results = [];
    }
    for (i = 0, len = selector.length; i < len; i++) {
      if (typeof selector[i] === 'string') {
        if (single) {
          node = dom.querySelector(selector[i]);
          return asDom ? node : Ext.get(node);
        }
        nodes = dom.querySelectorAll(selector[i]);
        for (j = 0, nlen = nodes.length; j < nlen; j++) {
          results.push(asDom ? nodes[j] : Ext.get(nodes[j]));
        }
      }
    }
    return results;
  }, radioCls:function(className) {
    var cn = this.dom.parentNode.childNodes, v;
    className = Ext.isArray(className) ? className : [className];
    for (var i = 0, len = cn.length; i < len; i++) {
      v = cn[i];
      if (v && v.nodeType === 1) {
        Ext.fly(v).removeCls(className);
      }
    }
    return this.addCls(className);
  }, redraw:function() {
    var dom = this.dom, domStyle = dom.style;
    domStyle.display = 'none';
    dom.offsetHeight;
    domStyle.display = '';
  }, remove:function() {
    this.destroy();
  }, removeChild:function(element) {
    this.dom.removeChild(Ext.getDom(element));
    return this;
  }, removeCls:function(names, prefix, suffix) {
    return this.replaceCls(names, null, prefix, suffix);
  }, repaint:function() {
    var me = this;
    me.addCls(Ext.baseCSSPrefix + 'repaint');
    if (!me.repaintTimer) {
      me.repaintTimer = Ext.defer(function() {
        me.repaintTimer = null;
        if (me.dom) {
          me.removeCls(Ext.baseCSSPrefix + 'repaint');
        }
      }, 1);
    }
    return me;
  }, replace:function(el, destroy) {
    el = Ext.getDom(el);
    var parentNode = el.parentNode, id = el.id, dom = this.dom;
    if (!parentNode) {
      Ext.raise('Cannot replace element "' + id + '". It is not attached to a parent node.');
    }
    if (destroy !== false && id && Ext.cache[id]) {
      parentNode.insertBefore(dom, el);
      Ext.get(el).destroy();
    } else {
      parentNode.replaceChild(dom, el);
    }
    return this;
  }, replaceCls:function(remove, add, prefix, suffix) {
    var me = this, added = 0, removed = 0, rem = remove, data = (add || remove) && me.getData(), list, map, i, n, name;
    if (data) {
      list = data.classList;
      map = data.classMap;
      add = add ? typeof add === 'string' ? add.split(spacesRe) : add : EMPTY;
      rem = rem ? typeof rem === 'string' ? rem.split(spacesRe) : rem : EMPTY;
      prefix = prefix || '';
      if (prefix && prefix[prefix.length - 1] !== '-') {
        prefix += '-';
      }
      suffix = suffix || '';
      if (suffix && suffix[0] !== '-') {
        suffix = '-' + suffix;
      }
      for (i = 0, n = rem.length; i < n; i++) {
        if (!(name = rem[i])) {
          continue;
        }
        name = prefix + name + suffix;
        if (spacesRe.test(name)) {
          Ext.raise('Class names in arrays must not contain spaces');
        }
        if (map[name]) {
          delete map[name];
          ++removed;
        }
      }
      for (i = 0, n = add.length; i < n; i++) {
        if (!(name = add[i])) {
          continue;
        }
        name = prefix + name + suffix;
        if (spacesRe.test(name)) {
          Ext.raise('Class names in arrays must not contain spaces');
        }
        if (!map[name]) {
          map[name] = true;
          if (!removed) {
            list.push(name);
            ++added;
          }
        }
      }
      if (removed) {
        me.setClassMap(map, true);
      } else {
        if (added) {
          me.dom.className = list.join(' ');
        }
      }
    }
    return me;
  }, replaceWith:function(el) {
    var me = this, dom = me.dom, parent = dom.parentNode, cache = Ext.cache, newDom;
    me.clearListeners();
    if (el.nodeType || el.dom || typeof el === 'string') {
      el = Ext.get(el);
      newDom = parent.insertBefore(el.dom, dom);
    } else {
      newDom = Ext.DomHelper.insertBefore(dom, el);
    }
    parent.removeChild(dom);
    me.dom = newDom;
    if (!me.isFly) {
      delete cache[me.id];
      cache[me.id = Ext.id(newDom)] = me;
    }
    return me;
  }, resolveListenerScope:function(defaultScope) {
    var component = this.component;
    return component ? component.resolveListenerScope(defaultScope) : this;
  }, scroll:function(direction, distance, animate) {
    if (!this.isScrollable()) {
      return false;
    }
    direction = direction.charAt(0);
    var me = this, dom = me.dom, side = direction === 'r' || direction === 'l' ? 'left' : 'top', scrolled = false, currentScroll, constrainedScroll;
    if (direction === 'l' || direction === 't' || direction === 'u') {
      distance = -distance;
    }
    if (side === 'left') {
      currentScroll = dom.scrollLeft;
      constrainedScroll = me.constrainScrollLeft(currentScroll + distance);
    } else {
      currentScroll = dom.scrollTop;
      constrainedScroll = me.constrainScrollTop(currentScroll + distance);
    }
    if (constrainedScroll !== currentScroll) {
      this.scrollTo(side, constrainedScroll, animate);
      scrolled = true;
    }
    return scrolled;
  }, scrollBy:function(deltaX, deltaY, animate) {
    var me = this, dom = me.dom;
    if (deltaX.length) {
      animate = deltaY;
      deltaY = deltaX[1];
      deltaX = deltaX[0];
    } else {
      if (typeof deltaX != 'number') {
        animate = deltaY;
        deltaY = deltaX.y;
        deltaX = deltaX.x;
      }
    }
    if (deltaX) {
      me.scrollTo('left', me.constrainScrollLeft(dom.scrollLeft + deltaX), animate);
    }
    if (deltaY) {
      me.scrollTo('top', me.constrainScrollTop(dom.scrollTop + deltaY), animate);
    }
    return me;
  }, scrollChildIntoView:function(child, hscroll) {
    Ext.fly(child).scrollIntoView(this, hscroll);
  }, scrollIntoView:function(container, hscroll, animate, highlight) {
    container = Ext.getDom(container) || Ext.getBody().dom;
    return this.doScrollIntoView(container, hscroll, animate, highlight, 'getScrollLeft', 'scrollTo');
  }, scrollTo:function(side, value, animate) {
    var top = topRe.test(side), me = this, prop = top ? 'scrollTop' : 'scrollLeft', dom = me.dom, animCfg;
    if (!animate || !me.anim) {
      dom[prop] = value;
      dom[prop] = value;
    } else {
      animCfg = {to:{}};
      animCfg.to[prop] = value;
      if (Ext.isObject(animate)) {
        Ext.applyIf(animCfg, animate);
      }
      me.animate(animCfg);
    }
    return me;
  }, select:function(selector, composite) {
    var isElementArray, elements;
    if (typeof selector === 'string') {
      elements = this.query(selector, !composite);
    } else {
      if (selector.length === undefined) {
        Ext.raise('Invalid selector specified: ' + selector);
      } else {
        elements = selector;
        isElementArray = true;
      }
    }
    return composite ? new Ext.CompositeElement(elements, !isElementArray) : new Ext.CompositeElementLite(elements, true);
  }, selectNode:function(selector, asDom) {
    return this.query(selector, asDom, true);
  }, set:function(attributes, useSet) {
    var me = this, dom = me.dom, attribute, value;
    for (attribute in attributes) {
      if (attributes.hasOwnProperty(attribute)) {
        value = attributes[attribute];
        if (attribute === 'style') {
          me.applyStyles(value);
        } else {
          if (attribute === 'cls') {
            dom.className = value;
          } else {
            if (useSet !== false) {
              if (value === undefined) {
                dom.removeAttribute(attribute);
              } else {
                dom.setAttribute(attribute, value);
              }
            } else {
              dom[attribute] = value;
            }
          }
        }
      }
    }
    return me;
  }, setBottom:function(bottom) {
    this.dom.style[BOTTOM] = Element.addUnits(bottom);
    return this;
  }, setClassMap:function(classMap, keep) {
    var data = this.getData(false), classList;
    if (data) {
      classMap = keep && classMap || Ext.apply({}, classMap);
      data.classMap = classMap;
      data.classList = classList = Ext.Object.getKeys(classMap);
      data.isSynchronized = true;
      this.dom.className = classList.join(' ');
    }
  }, setCls:function(className) {
    var me = this, elementData = me.getData(false), i, ln, map, classList;
    if (typeof className === 'string') {
      className = className.split(spacesRe);
    }
    elementData.classList = classList = className.slice();
    elementData.classMap = map = {};
    for (i = 0, ln = classList.length; i < ln; i++) {
      map[classList[i]] = true;
    }
    me.dom.className = classList.join(' ');
  }, setDisplayed:function(value) {
    var me = this;
    if (typeof value === 'boolean') {
      value = value ? me._getDisplay() : NONE;
    }
    me.setStyle(DISPLAY, value);
    if (me.shadow || me.shim) {
      me.setUnderlaysVisible(value !== NONE);
    }
    return me;
  }, setHeight:function(height) {
    var me = this;
    me.dom.style[HEIGHT] = Element.addUnits(height);
    if (me.shadow || me.shim) {
      me.syncUnderlays();
    }
    return me;
  }, setHtml:function(html) {
    if (this.dom) {
      this.dom.innerHTML = html;
    }
    return this;
  }, setId:function(id) {
    var me = this, currentId = me.id, cache = Ext.cache;
    if (currentId) {
      delete cache[currentId];
    }
    me.dom.id = id;
    me.id = id;
    cache[id] = me;
    return me;
  }, setLeft:function(left) {
    var me = this;
    me.dom.style[LEFT] = Element.addUnits(left);
    if (me.shadow || me.shim) {
      me.syncUnderlays();
    }
    return me;
  }, setLocalX:function(x) {
    var me = this, style = me.dom.style;
    style.right = '';
    style.left = x === null ? 'auto' : x + 'px';
    if (me.shadow || me.shim) {
      me.syncUnderlays();
    }
    return me;
  }, setLocalXY:function(x, y) {
    var me = this, style = me.dom.style;
    style.right = '';
    if (x && x.length) {
      y = x[1];
      x = x[0];
    }
    if (x === null) {
      style.left = 'auto';
    } else {
      if (x !== undefined) {
        style.left = x + 'px';
      }
    }
    if (y === null) {
      style.top = 'auto';
    } else {
      if (y !== undefined) {
        style.top = y + 'px';
      }
    }
    if (me.shadow || me.shim) {
      me.syncUnderlays();
    }
    return me;
  }, setLocalY:function(y) {
    var me = this;
    me.dom.style.top = y === null ? 'auto' : y + 'px';
    if (me.shadow || me.shim) {
      me.syncUnderlays();
    }
    return me;
  }, setMargin:function(margin) {
    var me = this, domStyle = me.dom.style;
    if (margin || margin === 0) {
      margin = me.self.unitizeBox(margin === true ? 5 : margin);
      domStyle.setProperty('margin', margin, 'important');
    } else {
      domStyle.removeProperty('margin-top');
      domStyle.removeProperty('margin-right');
      domStyle.removeProperty('margin-bottom');
      domStyle.removeProperty('margin-left');
    }
  }, setMaxHeight:function(height) {
    this.dom.style[MAX_HEIGHT] = Element.addUnits(height);
    return this;
  }, setMaxWidth:function(width) {
    this.dom.style[MAX_WIDTH] = Element.addUnits(width);
    return this;
  }, setMinHeight:function(height) {
    this.dom.style[MIN_HEIGHT] = Element.addUnits(height);
    return this;
  }, setMinWidth:function(width) {
    this.dom.style[MIN_WIDTH] = Element.addUnits(width);
    return this;
  }, setOpacity:function(opacity) {
    var me = this;
    if (me.dom) {
      me.setStyle('opacity', opacity);
    }
    return me;
  }, setPadding:function(padding) {
    var me = this, domStyle = me.dom.style;
    if (padding || padding === 0) {
      padding = me.self.unitizeBox(padding === true ? 5 : padding);
      domStyle.setProperty('padding', padding, 'important');
    } else {
      domStyle.removeProperty('padding-top');
      domStyle.removeProperty('padding-right');
      domStyle.removeProperty('padding-bottom');
      domStyle.removeProperty('padding-left');
    }
  }, setRight:function(right) {
    this.dom.style[RIGHT] = Element.addUnits(right);
    return this;
  }, setScrollLeft:function(left) {
    this.dom.scrollLeft = left;
    return this;
  }, setScrollTop:function(top) {
    this.dom.scrollTop = top;
    return this;
  }, setSize:function(width, height) {
    var me = this, style = me.dom.style;
    if (Ext.isObject(width)) {
      height = width.height;
      width = width.width;
    }
    if (width !== undefined) {
      style.width = Element.addUnits(width);
    }
    if (height !== undefined) {
      style.height = Element.addUnits(height);
    }
    if (me.shadow || me.shim) {
      me.syncUnderlays();
    }
    return me;
  }, setStyle:function(prop, value) {
    var me = this, dom = me.dom, hooks = me.styleHooks, style = dom.style, name = prop, hook;
    if (typeof name === 'string') {
      hook = hooks[name];
      if (!hook) {
        hooks[name] = hook = {name:Element.normalize(name)};
      }
      value = value == null ? '' : value;
      if (hook.set) {
        hook.set(dom, value, me);
      } else {
        style[hook.name] = value;
      }
      if (hook.afterSet) {
        hook.afterSet(dom, value, me);
      }
    } else {
      for (name in prop) {
        hook = hooks[name];
        if (!hook) {
          hooks[name] = hook = {name:Element.normalize(name)};
        }
        value = prop[name];
        value = value == null ? '' : value;
        if (hook.set) {
          hook.set(dom, value, me);
        } else {
          style[hook.name] = value;
        }
        if (hook.afterSet) {
          hook.afterSet(dom, value, me);
        }
      }
    }
    return me;
  }, setText:function(text) {
    this.dom.textContent = text;
  }, setTop:function(top) {
    var me = this;
    me.dom.style[TOP] = Element.addUnits(top);
    if (me.shadow || me.shim) {
      me.syncUnderlays();
    }
    return me;
  }, setTouchAction:function(touchAction) {
    Ext.dom.TouchAction.set(this.dom, touchAction);
  }, setUnderlaysVisible:function(visible) {
    var shadow = this.shadow, shim = this.shim;
    if (shadow && !shadow.disabled) {
      if (visible) {
        shadow.show();
      } else {
        shadow.hide();
      }
    }
    if (shim && !shim.disabled) {
      if (visible) {
        shim.show();
      } else {
        shim.hide();
      }
    }
  }, setVisibility:function(isVisible) {
    var domStyle = this.dom.style;
    if (isVisible) {
      domStyle.removeProperty('visibility');
    } else {
      domStyle.setProperty('visibility', 'hidden', 'important');
    }
  }, setVisibilityMode:function(mode) {
    if (mode !== 1 && mode !== 2 && mode !== 3 && mode !== 4 && mode !== 5) {
      Ext.raise('visibilityMode must be one of the following: ' + 'Ext.Element.DISPLAY, Ext.Element.VISIBILITY, Ext.Element.OFFSETS, ' + 'Ext.Element.CLIP, or Element.OPACITY');
    }
    this.getData().visibilityMode = mode;
    return this;
  }, setVisible:function(visible) {
    var me = this, mode = me.getVisibilityMode(), addOrRemove = visible ? 'removeCls' : 'addCls';
    switch(mode) {
      case Element.DISPLAY:
        me.removeCls([visibilityCls, offsetsCls, clipCls, opacityCls]);
        me[addOrRemove](displayCls);
        break;
      case Element.VISIBILITY:
        me.removeCls([displayCls, offsetsCls, clipCls, opacityCls]);
        me[addOrRemove](visibilityCls);
        break;
      case Element.OFFSETS:
        me.removeCls([visibilityCls, displayCls, clipCls, opacityCls]);
        me[addOrRemove](offsetsCls);
        break;
      case Element.CLIP:
        me.removeCls([visibilityCls, displayCls, offsetsCls, opacityCls]);
        me[addOrRemove](clipCls);
        break;
      case Element.OPACITY:
        me.removeCls([visibilityCls, displayCls, offsetsCls, clipCls]);
        me[addOrRemove](opacityCls);
        break;
    }
    if (me.shadow || me.shim) {
      me.setUnderlaysVisible(visible);
    }
    if (!visible && me.$ripples) {
      me.destroyAllRipples();
    }
    return me;
  }, setWidth:function(width) {
    var me = this;
    me.dom.style[WIDTH] = Element.addUnits(width);
    if (me.shadow || me.shim) {
      me.syncUnderlays();
    }
    return me;
  }, setX:function(x) {
    return this.setXY([x, false]);
  }, setXY:function(xy) {
    var me = this, pts = me.translatePoints(xy), style = me.dom.style, pos;
    me.position();
    style.right = '';
    for (pos in pts) {
      if (!isNaN(pts[pos])) {
        style[pos] = pts[pos] + 'px';
      }
    }
    if (me.shadow || me.shim) {
      me.syncUnderlays();
    }
    return me;
  }, setY:function(y) {
    return this.setXY([false, y]);
  }, setZIndex:function(zindex) {
    var me = this;
    if (me.shadow) {
      me.shadow.setZIndex(zindex);
    }
    if (me.shim) {
      me.shim.setZIndex(zindex);
    }
    return me.setStyle('z-index', zindex);
  }, show:function() {
    return this.setVisible(true);
  }, swallowEvent:function(eventName, preventDefault) {
    var me = this, e, eLen, listeners = {destroyable:true}, fn = function(e) {
      e.stopPropagation();
      if (preventDefault) {
        e.preventDefault();
      }
    };
    if (Ext.isArray(eventName)) {
      eLen = eventName.length;
      for (e = 0; e < eLen; e++) {
        listeners[eventName[e]] = fn;
      }
    } else {
      listeners[eventName] = fn;
    }
    return me.on(listeners);
  }, swapCls:function(firstClass, secondClass, flag, prefix) {
    if (flag === undefined) {
      flag = true;
    }
    var me = this, addedClass = flag ? firstClass : secondClass, removedClass = flag ? secondClass : firstClass;
    if (removedClass) {
      me.removeCls(prefix ? prefix + '-' + removedClass : removedClass);
    }
    if (addedClass) {
      me.addCls(prefix ? prefix + '-' + addedClass : addedClass);
    }
    return me;
  }, synchronize:function() {
    var me = this, dom = me.dom, hasClassMap = {}, className = dom.className, classList, i, ln, name, elementData = me.getData(false);
    if (className && className.length > 0) {
      classList = dom.className.split(classNameSplitRegex);
      for (i = 0, ln = classList.length; i < ln; i++) {
        name = classList[i];
        hasClassMap[name] = true;
      }
    } else {
      classList = [];
    }
    elementData.classList = classList;
    elementData.classMap = hasClassMap;
    elementData.isSynchronized = true;
    return me;
  }, syncUnderlays:function() {
    var me = this, shadow = me.shadow, shim = me.shim, dom = me.dom, xy, x, y, w, h;
    if (me.isVisible()) {
      xy = me.getXY();
      x = xy[0];
      y = xy[1];
      w = dom.offsetWidth;
      h = dom.offsetHeight;
      if (shadow && !shadow.hidden) {
        shadow.realign(x, y, w, h);
      }
      if (shim && !shim.hidden) {
        shim.realign(x, y, w, h);
      }
    }
  }, toggleCls:function(className, state) {
    if (state == null) {
      state = !this.hasCls(className);
    }
    return state ? this.addCls(className) : this.removeCls(className);
  }, toggle:function() {
    this.setVisible(!this.isVisible());
    return this;
  }, translate:function() {
    var transformStyleName = 'webkitTransform' in DOC.createElement('div').style ? 'webkitTransform' : 'transform';
    return function(x, y, z) {
      x = Math.round(x);
      y = Math.round(y);
      z = Math.round(z);
      this.dom.style[transformStyleName] = 'translate3d(' + (x || 0) + 'px, ' + (y || 0) + 'px, ' + (z || 0) + 'px)';
    };
  }(), unwrap:function() {
    var dom = this.dom, parentNode = dom.parentNode, activeElement = (activeElFly || (activeElFly = new Ext.dom.Fly)).attach(Ext.Element.getActiveElement()), grandparentNode, cached, resumeFocus, tabIndex;
    grannyFly = grannyFly || new Ext.dom.Fly;
    cached = Ext.cache[activeElement.dom.id];
    if (cached) {
      activeElement = cached;
    }
    if (this.contains(activeElement)) {
      if (cached) {
        cached.suspendFocusEvents();
      }
      resumeFocus = true;
    }
    if (parentNode) {
      grandparentNode = parentNode.parentNode;
      if (resumeFocus) {
        tabIndex = grandparentNode.getAttribute('tabIndex');
        grannyFly.attach(grandparentNode);
        grannyFly.set({tabIndex:-1});
        grannyFly.suspendFocusEvents();
        grannyFly.focus();
      }
      grandparentNode.insertBefore(dom, parentNode);
      grandparentNode.removeChild(parentNode);
    } else {
      grandparentNode = DOC.createDocumentFragment();
      grandparentNode.appendChild(dom);
    }
    if (resumeFocus) {
      if (cached) {
        cached.focus();
        cached.resumeFocusEvents();
      } else {
        activeElement.focus();
      }
      if (grannyFly) {
        grannyFly.resumeFocusEvents();
        grannyFly.set({tabIndex:tabIndex});
      }
    }
    return this;
  }, up:function(simpleSelector, limit, returnDom) {
    return this.findParentNode(simpleSelector, limit, !returnDom);
  }, update:function(html) {
    return this.setHtml(html);
  }, wrap:function(config, returnDom, selector) {
    var me = this, dom = me.dom, result = Ext.DomHelper.insertBefore(dom, config || {tag:'div'}, !returnDom), newEl = (wrapFly || (wrapFly = new Ext.dom.Fly)).attach(Ext.getDom(result)), target = newEl, activeElement = (activeElFly || (activeElFly = new Ext.dom.Fly)).attach(Ext.Element.getActiveElement()), cached, resumeFocus, tabIndex;
    cached = Ext.cache[activeElement.dom.id];
    if (cached) {
      activeElement = cached;
    }
    if (selector) {
      target = newEl.selectNode(selector, returnDom);
    }
    if (me.contains(activeElement)) {
      if (cached) {
        cached.suspendFocusEvents();
      }
      tabIndex = Ext.getDom(newEl).getAttribute('tabIndex');
      newEl.set({tabIndex:-1});
      newEl.suspendFocusEvents();
      newEl.focus();
      resumeFocus = true;
    }
    (target.dom || target).appendChild(dom);
    if (resumeFocus) {
      if (cached) {
        cached.focus();
        cached.resumeFocusEvents();
      } else {
        activeElement.focus();
      }
      newEl.resumeFocusEvents();
      newEl.set({tabIndex:tabIndex});
    }
    return result;
  }, isFocusable:function(skipVisibility) {
    var dom = this.dom, focusable = false, nodeName;
    if (dom && !dom.disabled) {
      nodeName = dom.nodeName;
      focusable = !!Ext.Element.naturallyFocusableTags[nodeName] || (nodeName === 'A' || nodeName === 'LINK') && !!dom.href || dom.getAttribute('tabIndex') != null || dom.contentEditable === 'true';
      if (Ext.isIE8 && nodeName === 'INPUT' && dom.type === 'hidden') {
        focusable = false;
      }
      focusable = focusable && (skipVisibility || this.isVisible(true));
    }
    return focusable;
  }, isInputField:function() {
    var dom = this.dom, contentEditable = dom.contentEditable;
    if (Ext.Element.inputTags[dom.tagName] && dom.type !== 'button' || (contentEditable === '' || contentEditable === 'true')) {
      return true;
    }
    return false;
  }, isTabbable:function(includeHidden) {
    var dom = this.dom, tabbable = false, nodeName, hasIndex, tabIndex;
    if (dom && !dom.disabled) {
      nodeName = dom.nodeName;
      tabIndex = dom.getAttribute('tabIndex');
      hasIndex = tabIndex != null;
      tabIndex -= 0;
      if (nodeName === 'A' || nodeName === 'LINK') {
        if (dom.href) {
          tabbable = hasIndex && tabIndex < 0 ? false : true;
        } else {
          if (dom.contentEditable === 'true') {
            tabbable = !hasIndex || hasIndex && tabIndex >= 0 ? true : false;
          } else {
            tabbable = hasIndex && tabIndex >= 0 ? true : false;
          }
        }
      } else {
        if (dom.contentEditable === 'true' || Ext.Element.naturallyTabbableTags[nodeName]) {
          tabbable = hasIndex && tabIndex < 0 ? false : true;
        } else {
          if (hasIndex && tabIndex >= 0) {
            tabbable = true;
          }
        }
      }
      if (Ext.isIE8 && nodeName === 'INPUT' && dom.type === 'hidden') {
        tabbable = false;
      }
      tabbable = tabbable && (includeHidden || (!this.component || this.component.isVisible(true)) && this.isVisible(true));
    }
    return tabbable;
  }, ripplingCls:Ext.baseCSSPrefix + 'rippling', ripplingTransitionCls:Ext.baseCSSPrefix + 'ripple-transition', ripplingUnboundCls:Ext.baseCSSPrefix + 'rippling-unbound', rippleBubbleCls:Ext.baseCSSPrefix + 'ripple-bubble', rippleContainerCls:Ext.baseCSSPrefix + 'ripple-container', rippleWrapperCls:Ext.baseCSSPrefix + 'ripple-wrapper', noRippleDisplayMap:{table:1, 'table-row':1, 'table-row-group':1}, noRippleTagMap:{TABLE:1, TR:1, TBODY:1}, ripple:function(event, options) {
    if (options === true || !options) {
      options = {};
    } else {
      if (Ext.isString(options)) {
        options = {color:options};
      }
    }
    var me = this, rippleParent = Ext.isString(options.delegate) ? me.down(options.delegate) : me, rippleMeasureEl = Ext.isString(options.measureSelector) ? me.down(options.measureSelector) : null, color = window.getComputedStyle(rippleParent.dom).color, unbound = options.bound === false, position = options.position, ripplingCls = me.ripplingCls, ripplingTransitionCls = me.ripplingTransitionCls, ripplingUnboundCls = me.ripplingUnboundCls, rippleBubbleCls = me.rippleBubbleCls, rippleContainerCls = 
    me.rippleContainerCls, rippleWrapperCls = me.rippleWrapperCls, offset, width, height, rippleDiameter, center, measureElWidth, measureElHeight, rippleSize, pos, posX, posY, rippleWrapper, rippleContainer, rippleBubble, rippleDestructor, rippleClearFn, rippleDestructionTimer, rippleBox, unboundEl, unboundElData, timeout;
    if (rippleParent) {
      offset = rippleParent.getXY();
      width = rippleParent.getWidth();
      height = rippleParent.getHeight();
      timeout = rippleParent.$rippleClearTimeout;
      if (timeout) {
        rippleParent.$rippleClearTimeout = Ext.undefer(timeout);
      }
      if (rippleMeasureEl) {
        measureElWidth = rippleMeasureEl.getWidth();
        measureElHeight = rippleMeasureEl.getHeight();
        rippleDiameter = Math.max(measureElWidth, measureElHeight);
      } else {
        rippleDiameter = width > height ? width : height;
      }
      if (options.diameterLimit === undefined || options.diameterLimit === true) {
        rippleDiameter = Math.min(rippleDiameter, Element.maxRippleDiameter);
      } else {
        if (options.diameterLimit && options.diameterLimit !== false && options.diameterLimit !== 0) {
          rippleDiameter = Math.min(rippleDiameter, options.diameterLimit);
        }
      }
      center = [offset[0] + width / 2, offset[1] + height / 2];
      if (unbound) {
        if (options.fit !== false) {
          rippleSize = rippleDiameter * 2.15;
          rippleBox = rippleParent.getRegion();
          rippleBox.setPosition(rippleBox.getCenter()).setSize(rippleSize).translateBy(-rippleSize / 2, -rippleSize / 2);
          unboundEl = me.up(function(candidate) {
            var fly = Ext.fly(candidate, 'ripple');
            return !(candidate.tagName in me.noRippleTagMap) && !(fly.getStyle('display') in me.noRippleDisplayMap) && fly.getRegion().contains(rippleBox);
          }) || Ext.getBody();
        } else {
          unboundEl = rippleParent;
        }
      }
      if (Ext.isString(event)) {
        options.color = event;
        event = null;
      } else {
        if (event && !event.isEvent) {
          event = new Ext.event.Event(event);
        }
      }
      if (event && event.isEvent) {
        if (event.browserEvent.$preventRipple) {
          return;
        }
        position = event.getXY();
        event.browserEvent.$preventRipple = true;
      }
      pos = !unbound && !options.centered && position || center;
      posX = pos[0] - offset[0] - rippleDiameter / 2;
      posY = pos[1] - offset[1] - rippleDiameter / 2;
      rippleParent.addCls(ripplingTransitionCls);
      if (!unbound) {
        rippleParent.addCls(ripplingCls);
        rippleContainer = rippleParent.child('.' + rippleContainerCls);
      } else {
        unboundElData = unboundEl.getData();
        rippleWrapper = unboundElData.rippleWrapper;
        if (!rippleWrapper) {
          unboundElData.rippleWrapper = rippleWrapper = unboundEl.insertFirst({style:'position: absolute; top: 0; left: 0', cls:rippleWrapperCls + ' ' + ripplingCls + ' ' + ripplingUnboundCls});
        }
      }
      if (!rippleContainer) {
        if (unbound) {
          rippleContainer = rippleWrapper.append({cls:rippleContainerCls});
          rippleContainer.setXY(offset);
        } else {
          rippleContainer = rippleParent.append({cls:rippleContainerCls});
        }
      }
      rippleBubble = rippleContainer.append({cls:rippleBubbleCls});
      if (options.color !== 'default') {
        rippleBubble.setStyle('backgroundColor', options.color || color);
      }
      rippleBubble.setWidth(rippleDiameter);
      rippleBubble.setHeight(rippleDiameter);
      rippleBubble.setTop(posY);
      rippleBubble.setLeft(posX);
      rippleClearFn = function() {
        if (!rippleParent.destroyed) {
          rippleParent.$rippleClearTimeout = Ext.defer(function() {
            rippleParent.removeCls([ripplingCls, ripplingTransitionCls]);
            rippleParent.$rippleClearTimeout = null;
          }, 50);
        }
      };
      rippleDestructor = function() {
        var ripple, timeout;
        rippleBubble.destroy();
        if (me.$ripples) {
          delete me.$ripples[rippleBubble.id];
        }
        timeout = rippleParent.$rippleClearTimeout;
        if (timeout) {
          rippleParent.$rippleClearTimeout = Ext.undefer(timeout);
        }
        if (unbound) {
          rippleContainer.destroy();
          ripple = rippleWrapper.child('.' + rippleContainerCls);
          if (!ripple) {
            unboundElData.rippleWrapper = null;
            rippleWrapper.destroy();
            rippleClearFn();
          }
        } else {
          ripple = rippleContainer.child('.' + rippleBubbleCls);
          if (!ripple) {
            rippleContainer.destroy();
            rippleClearFn();
          }
        }
      };
      rippleDestructionTimer = Ext.defer(rippleDestructor, options.destroyTime || 1000, me);
      if (!me.$ripples) {
        me.$ripples = {};
      }
      me.$ripples[rippleBubble.id] = {timerId:rippleDestructionTimer, destructor:rippleDestructor};
      rippleBubble.addCls(Ext.baseCSSPrefix + 'ripple');
    }
  }, destroyAllRipples:function() {
    var me = this, rippleEl, ripple;
    for (rippleEl in me.$ripples) {
      ripple = me.$ripples[rippleEl];
      Ext.undefer(ripple.timerId);
      if (ripple.destructor) {
        ripple.destructor();
      }
    }
    me.$ripples = null;
  }, privates:{findTabbableElements:function(options) {
    var skipSelf, skipChildren, excludeRoot, includeSaved, includeHidden, dom = this.dom, cAttr = Ext.Element.tabbableSavedCounterAttribute, selection = [], idx = 0, nodes, node, fly, i, len, tabIndex;
    if (!dom) {
      return selection;
    }
    if (options) {
      skipSelf = options.skipSelf;
      skipChildren = options.skipChildren;
      excludeRoot = options.excludeRoot;
      includeSaved = options.includeSaved;
      includeHidden = options.includeHidden;
    }
    excludeRoot = excludeRoot && Ext.getDom(excludeRoot);
    if (excludeRoot && excludeRoot.contains(dom)) {
      return selection;
    }
    if (!skipSelf && (includeSaved && dom.hasAttribute(cAttr) || this.isTabbable(includeHidden))) {
      selection[idx++] = dom;
    }
    if (skipChildren) {
      return selection;
    }
    nodes = dom.querySelectorAll(Ext.Element.tabbableSelector);
    len = nodes.length;
    if (!len) {
      return selection;
    }
    fly = new Ext.dom.Fly;
    for (i = 0; i < len; i++) {
      node = nodes[i];
      tabIndex = +node.getAttribute('tabIndex');
      if ((includeSaved && node.hasAttribute(cAttr) || !(tabIndex < 0) && fly.attach(node).isTabbable(includeHidden)) && !(excludeRoot && (excludeRoot === node || excludeRoot.contains(node)))) {
        selection[idx++] = node;
      }
    }
    return selection;
  }, saveTabbableState:function(options) {
    var counterAttr = Ext.Element.tabbableSavedCounterAttribute, savedAttr = Ext.Element.tabbableSavedValueAttribute, counter, nodes, node, i, len;
    if (!options || options.includeSaved == null) {
      options = Ext.Object.chain(options || null);
      options.includeSaved = true;
    }
    nodes = this.findTabbableElements(options);
    for (i = 0, len = nodes.length; i < len; i++) {
      node = nodes[i];
      counter = +node.getAttribute(counterAttr);
      if (counter > 0) {
        node.setAttribute(counterAttr, ++counter);
      } else {
        if (node.hasAttribute('tabIndex')) {
          node.setAttribute(savedAttr, node.getAttribute('tabIndex'));
        } else {
          node.setAttribute(savedAttr, 'none');
        }
        node.setAttribute('tabIndex', '-1');
        node.setAttribute(counterAttr, '1');
      }
    }
    return nodes;
  }, restoreTabbableState:function(options) {
    var dom = this.dom, counterAttr = Ext.Element.tabbableSavedCounterAttribute, savedAttr = Ext.Element.tabbableSavedValueAttribute, nodes = [], skipSelf = options && options.skipSelf, skipChildren = options && options.skipChildren, reset = options && options.reset, idx, counter, node, i, len;
    if (!dom) {
      return this;
    }
    if (!skipChildren) {
      nodes = Ext.Array.from(dom.querySelectorAll('[' + counterAttr + ']'));
    }
    if (!skipSelf) {
      nodes.unshift(dom);
    }
    for (i = 0, len = nodes.length; i < len; i++) {
      node = nodes[i];
      if (!node.hasAttribute(counterAttr) || !node.hasAttribute(savedAttr)) {
        continue;
      }
      counter = +node.getAttribute(counterAttr);
      if (!reset && counter > 1) {
        node.setAttribute(counterAttr, --counter);
        continue;
      }
      idx = node.getAttribute(savedAttr);
      if (idx === 'none') {
        node.removeAttribute('tabIndex');
      } else {
        node.setAttribute('tabIndex', idx);
      }
      node.removeAttribute(savedAttr);
      node.removeAttribute(counterAttr);
    }
    return nodes;
  }, setTabIndex:function(tabIndex) {
    var dom = this.dom, savedAttr = Ext.Element.tabbableSavedValueAttribute;
    if (dom.hasAttribute(savedAttr)) {
      if (tabIndex == null) {
        dom.setAttribute(savedAttr, 'none');
        dom.removeAttribute('tabIndex');
      } else {
        dom.setAttribute(savedAttr, tabIndex);
      }
    } else {
      if (tabIndex == null) {
        dom.removeAttribute('tabIndex');
      } else {
        dom.setAttribute('tabIndex', tabIndex);
      }
    }
  }, doAddListener:function(eventName, fn, scope, options, order, caller, manager) {
    var me = this, originalName = eventName, observableDoAddListener, additiveEventName, translatedEventName;
    eventName = Ext.canonicalEventName(eventName);
    if (!me.blockedEvents[eventName]) {
      observableDoAddListener = me.mixins.observable.doAddListener;
      options = options || {};
      if (Element.useDelegatedEvents === false) {
        options.delegated = options.delegated || false;
      }
      if (options.translate !== false) {
        additiveEventName = me.additiveEvents[eventName];
        if (additiveEventName) {
          options.type = eventName;
          eventName = additiveEventName;
          observableDoAddListener.call(me, eventName, fn, scope, options, order, caller, manager);
        }
        translatedEventName = me.eventMap[eventName];
        if (translatedEventName) {
          options.type = options.type || eventName;
          if (manager) {
            options.managedName = originalName;
          }
          eventName = translatedEventName;
        }
      }
      if (observableDoAddListener.call(me, eventName, fn, scope, options, order, caller, manager)) {
        if (me.longpressEvents[eventName] && ++me.longpressListenerCount === 1) {
          me.on('MSHoldVisual', 'preventMsHoldVisual', me);
        }
      }
      if (manager && translatedEventName) {
        delete options.managedName;
      }
      delete options.type;
    }
  }, doRemoveListener:function(eventName, fn, scope) {
    var me = this, observableDoRemoveListener, translatedEventName, additiveEventName, removed;
    eventName = Ext.canonicalEventName(eventName);
    if (!me.blockedEvents[eventName]) {
      observableDoRemoveListener = me.mixins.observable.doRemoveListener;
      additiveEventName = me.additiveEvents[eventName];
      if (additiveEventName) {
        eventName = additiveEventName;
        observableDoRemoveListener.call(me, eventName, fn, scope);
      }
      translatedEventName = me.eventMap[eventName];
      if (translatedEventName) {
        removed = observableDoRemoveListener.call(me, translatedEventName, fn, scope);
      }
      removed = observableDoRemoveListener.call(me, eventName, fn, scope) || removed;
      if (removed) {
        if (me.longpressEvents[eventName] && !--me.longpressListenerCount) {
          me.un('MSHoldVisual', 'preventMsHoldVisual', me);
        }
      }
    }
  }, _initEvent:function(eventName) {
    return this.events[eventName] = new Ext.dom.ElementEvent(this, eventName);
  }, _getDisplay:function() {
    var data = this.getData(), display = data[ORIGINALDISPLAY];
    if (display === undefined) {
      data[ORIGINALDISPLAY] = display = '';
    }
    return display;
  }, _getPublisher:function(eventName, noTranslate) {
    var Publisher = Ext.event.publisher.Publisher, publisher = Publisher.publishersByEvent[eventName], isNative = noTranslate && !Ext.event.Event.gestureEvents[eventName];
    if (isNative || !publisher || this.dom === window && eventName === 'resize') {
      publisher = Publisher.publishers.dom;
    }
    return publisher;
  }, isFocusSuspended:function() {
    var data = this.peekData();
    return data && data.suspendFocusEvents;
  }, preventMsHoldVisual:function(e) {
    e.preventDefault();
  }, suspendFocusEvents:function() {
    if (!this.isFly) {
      this.suspendEvent('focus', 'blur');
    }
    this.getData().suspendFocusEvents = true;
  }, resumeFocusEvents:function() {
    function resumeFn() {
      var data;
      if (!this.destroyed) {
        data = this.getData();
        if (data) {
          data.suspendFocusEvents = false;
        }
        if (!this.isFly) {
          this.resumeEvent('focus', 'blur');
        }
      }
    }
    if (!this.destroyed && this.getData().suspendFocusEvents) {
      if (Ext.isIE && !this.isFly) {
        this.resumeFocusEventsTimer = Ext.asap(resumeFn, this);
      } else {
        resumeFn.call(this);
      }
    }
  }}, deprecated:{'5.0':{methods:{getHTML:'getHtml', getPageBox:function(getRegion) {
    var me = this, dom = me.dom, isDoc = dom.nodeName === 'BODY', w = isDoc ? Element.getViewportWidth() : dom.offsetWidth, h = isDoc ? Element.getViewportHeight() : dom.offsetHeight, xy = me.getXY(), t = xy[1], r = xy[0] + w, b = xy[1] + h, l = xy[0];
    if (getRegion) {
      return new Ext.util.Region(t, r, b, l);
    } else {
      return {left:l, top:t, width:w, height:h, right:r, bottom:b};
    }
  }, isTransparent:function(prop) {
    var value = this.getStyle(prop);
    return value ? transparentRe.test(value) : false;
  }, purgeAllListeners:'clearListeners', removeAllListeners:'clearListeners', setHTML:'setHtml'}}}};
}, function(Element) {
  var DOC = document, docEl = DOC.documentElement, prototype = Element.prototype, supports = Ext.supports, pointerdown = 'pointerdown', pointermove = 'pointermove', pointerup = 'pointerup', pointercancel = 'pointercancel', MSPointerDown = 'MSPointerDown', MSPointerMove = 'MSPointerMove', MSPointerUp = 'MSPointerUp', MSPointerCancel = 'MSPointerCancel', mousedown = 'mousedown', mousemove = 'mousemove', mouseup = 'mouseup', mouseover = 'mouseover', mouseout = 'mouseout', mouseenter = 'mouseenter', 
  mouseleave = 'mouseleave', touchstart = 'touchstart', touchmove = 'touchmove', touchend = 'touchend', touchcancel = 'touchcancel', click = 'click', dblclick = 'dblclick', tap = 'tap', doubletap = 'doubletap', eventMap = prototype.eventMap = {}, additiveEvents = prototype.additiveEvents = {}, oldId = Ext.id, eventOptions;
  prototype._init(Element);
  delete prototype._init;
  Ext.id = function(obj, prefix) {
    var el = obj && Ext.getDom(obj, true), sandboxPrefix, id;
    if (!el) {
      id = oldId(obj, prefix);
    } else {
      if (!(id = el.id)) {
        id = oldId(null, prefix || Element.prototype.identifiablePrefix);
        if (Ext.isSandboxed) {
          sandboxPrefix = Ext.sandboxPrefix || (Ext.sandboxPrefix = Ext.sandboxName.toLowerCase() + '-');
          id = sandboxPrefix + id;
        }
        el.id = id;
      }
    }
    return id;
  };
  if (supports.PointerEvents) {
    eventMap[mousedown] = pointerdown;
    eventMap[mousemove] = pointermove;
    eventMap[mouseup] = pointerup;
    eventMap[touchstart] = pointerdown;
    eventMap[touchmove] = pointermove;
    eventMap[touchend] = pointerup;
    eventMap[touchcancel] = pointercancel;
    eventMap[mouseover] = 'pointerover';
    eventMap[mouseout] = 'pointerout';
    eventMap[mouseenter] = 'pointerenter';
    if (!Ext.isIE11) {
      eventMap[mouseleave] = 'pointerleave';
    }
  } else {
    if (supports.MSPointerEvents) {
      eventMap[pointerdown] = MSPointerDown;
      eventMap[pointermove] = MSPointerMove;
      eventMap[pointerup] = MSPointerUp;
      eventMap[pointercancel] = MSPointerCancel;
      eventMap[mousedown] = MSPointerDown;
      eventMap[mousemove] = MSPointerMove;
      eventMap[mouseup] = MSPointerUp;
      eventMap[touchstart] = MSPointerDown;
      eventMap[touchmove] = MSPointerMove;
      eventMap[touchend] = MSPointerUp;
      eventMap[touchcancel] = MSPointerCancel;
      eventMap[mouseover] = 'MSPointerOver';
      eventMap[mouseout] = 'MSPointerOut';
    } else {
      if (supports.TouchEvents) {
        eventMap[pointerdown] = touchstart;
        eventMap[pointermove] = touchmove;
        eventMap[pointerup] = touchend;
        eventMap[pointercancel] = touchcancel;
        eventMap[mousedown] = touchstart;
        eventMap[mousemove] = touchmove;
        eventMap[mouseup] = touchend;
        eventMap[click] = tap;
        eventMap[dblclick] = doubletap;
        if (Ext.os.is.Desktop) {
          eventMap[touchstart] = mousedown;
          eventMap[touchmove] = mousemove;
          eventMap[touchend] = mouseup;
          eventMap[touchcancel] = mouseup;
          additiveEvents[mousedown] = mousedown;
          additiveEvents[mousemove] = mousemove;
          additiveEvents[mouseup] = mouseup;
          additiveEvents[touchstart] = touchstart;
          additiveEvents[touchmove] = touchmove;
          additiveEvents[touchend] = touchend;
          additiveEvents[touchcancel] = touchcancel;
          additiveEvents[pointerdown] = mousedown;
          additiveEvents[pointermove] = mousemove;
          additiveEvents[pointerup] = mouseup;
          additiveEvents[pointercancel] = mouseup;
        }
      } else {
        eventMap[pointerdown] = mousedown;
        eventMap[pointermove] = mousemove;
        eventMap[pointerup] = mouseup;
        eventMap[pointercancel] = mouseup;
        eventMap[touchstart] = mousedown;
        eventMap[touchmove] = mousemove;
        eventMap[touchend] = mouseup;
        eventMap[touchcancel] = mouseup;
      }
    }
  }
  if (Ext.isWebKit) {
    eventMap.transitionend = Ext.browser.getVendorProperyName('transitionEnd');
    eventMap.animationstart = Ext.browser.getVendorProperyName('animationStart');
    eventMap.animationend = Ext.browser.getVendorProperyName('animationEnd');
  }
  if (!Ext.supports.MouseWheel && !Ext.isOpera) {
    eventMap.mousewheel = 'DOMMouseScroll';
  }
  eventOptions = prototype.$eventOptions = Ext.Object.chain(prototype.$eventOptions);
  eventOptions.translate = eventOptions.capture = eventOptions.delegate = eventOptions.delegated = eventOptions.stopEvent = eventOptions.preventDefault = eventOptions.stopPropagation = eventOptions.element = 1;
  prototype.styleHooks.opacity = {name:'opacity', afterSet:function(dom, value, el) {
    var shadow = el.shadow;
    if (shadow) {
      shadow.setOpacity(value);
    }
  }};
  prototype.getTrueXY = prototype.getXY;
  Ext.getViewportHeight = Element.getViewportHeight;
  Ext.getViewportWidth = Element.getViewportWidth;
  Ext.select = Element.select;
  Ext.query = Element.query;
  Ext.apply(Ext, {get:function(element) {
    return Element.get(element);
  }, getDom:function(el) {
    if (!el || !DOC) {
      return null;
    }
    return typeof el === 'string' ? Ext.getElementById(el) : 'dom' in el ? el.dom : el;
  }, getBody:function() {
    if (!Ext._bodyEl) {
      if (!DOC.body) {
        throw new Error('[Ext.getBody] document.body does not yet exist');
      }
      Ext._bodyEl = Ext.get(DOC.body);
      Ext._bodyEl.skipGarbageCollection = true;
    }
    return Ext._bodyEl;
  }, getHead:function() {
    if (!Ext._headEl) {
      Ext._headEl = Ext.get(DOC.head || DOC.getElementsByTagName('head')[0]);
      Ext._headEl.skipGarbageCollection = true;
    }
    return Ext._headEl;
  }, getDoc:function() {
    if (!Ext._docEl) {
      Ext._docEl = Ext.get(DOC);
      Ext._docEl.skipGarbageCollection = true;
    }
    return Ext._docEl;
  }, getWin:function() {
    if (!Ext._winEl) {
      Ext._winEl = Ext.get(window);
      Ext._winEl.skipGarbageCollection = true;
    }
    return Ext._winEl;
  }, removeNode:function(node) {
    node = node.dom || node;
    var id = node && node.id, el = Ext.cache[id], parent;
    if (el) {
      el.destroy();
    } else {
      if (node && (node.nodeType === 3 || node.tagName.toUpperCase() !== 'BODY')) {
        parent = node.parentNode;
        if (parent) {
          parent.removeChild(node);
        }
      }
    }
  }});
  Ext.isGarbage = function(dom) {
    return dom && dom.nodeType === 1 && dom.tagName !== 'BODY' && dom.tagName !== 'HTML' && (!dom.parentNode || dom.offsetParent === null && (Ext.isIE8 ? DOC.all[dom.id] : DOC.getElementById(dom.id)) !== dom && !(Ext.detachedBodyEl && Ext.detachedBodyEl.isAncestor(dom)));
  };
  Ext.onInternalReady(function() {
    var bodyCls = [], theme;
    Ext.getDoc().on('selectstart', function(ev, dom) {
      var selectableCls = Element.selectableCls, unselectableCls = Element.unselectableCls, tagName = dom && dom.tagName, el = new Ext.dom.Fly;
      tagName = tagName && tagName.toLowerCase();
      if (tagName === 'input' || tagName === 'textarea') {
        return;
      }
      while (dom && dom.nodeType === 1 && dom !== DOC.documentElement) {
        el.attach(dom);
        if (el.hasCls(selectableCls)) {
          return;
        }
        if (el.hasCls(unselectableCls)) {
          ev.stopEvent();
          return;
        }
        dom = dom.parentNode;
      }
    });
    if (Ext.os.is.Android || Ext.os.is.Windows && Ext.supports.Touch) {
      var win = Ext.getWin();
      Element._documentWidth = Element._viewportWidth = docEl.clientWidth;
      Element._documentHeight = Element._viewportHeight = docEl.clientHeight;
      win.on({focusin:'_onWindowFocusChange', focusout:'_onWindowFocusChange', pointerup:'_onWindowFocusChange', capture:true, delegated:false, delay:1, scope:Element});
      win.on({resize:'_onWindowResize', priority:2000, scope:Element});
    }
    if (supports.Touch) {
      bodyCls.push(Ext.baseCSSPrefix + 'touch');
    }
    if (Ext.isIE && Ext.isIE9m) {
      bodyCls.push(Ext.baseCSSPrefix + 'ie', Ext.baseCSSPrefix + 'ie9m');
      bodyCls.push(Ext.baseCSSPrefix + 'ie8p');
      if (Ext.isIE8) {
        bodyCls.push(Ext.baseCSSPrefix + 'ie8');
      } else {
        bodyCls.push(Ext.baseCSSPrefix + 'ie9', Ext.baseCSSPrefix + 'ie9p');
      }
      if (Ext.isIE8m) {
        bodyCls.push(Ext.baseCSSPrefix + 'ie8m');
      }
    }
    if (Ext.isIE10) {
      bodyCls.push(Ext.baseCSSPrefix + 'ie10');
    }
    if (Ext.isIE10p) {
      bodyCls.push(Ext.baseCSSPrefix + 'ie10p');
    }
    if (Ext.isIE11) {
      bodyCls.push(Ext.baseCSSPrefix + 'ie11');
    }
    if (Ext.isEdge) {
      bodyCls.push(Ext.baseCSSPrefix + 'edge');
    }
    if (Ext.isGecko) {
      bodyCls.push(Ext.baseCSSPrefix + 'gecko');
    }
    if (Ext.isOpera) {
      bodyCls.push(Ext.baseCSSPrefix + 'opera');
    }
    if (Ext.isOpera12m) {
      bodyCls.push(Ext.baseCSSPrefix + 'opera12m');
    }
    if (Ext.isWebKit) {
      bodyCls.push(Ext.baseCSSPrefix + 'webkit');
    }
    if (Ext.isSafari) {
      bodyCls.push(Ext.baseCSSPrefix + 'safari');
    }
    if (Ext.isSafari9) {
      bodyCls.push(Ext.baseCSSPrefix + 'safari9');
    }
    if (Ext.isSafari10) {
      bodyCls.push(Ext.baseCSSPrefix + 'safari10');
    }
    if (Ext.isSafari11) {
      bodyCls.push(Ext.baseCSSPrefix + 'safari11');
    }
    if (Ext.isSafari && Ext.browser.version.isLessThan(9)) {
      bodyCls.push(Ext.baseCSSPrefix + 'safari8m');
    }
    if (Ext.isChrome) {
      bodyCls.push(Ext.baseCSSPrefix + 'chrome');
    }
    if (Ext.isMac) {
      bodyCls.push(Ext.baseCSSPrefix + 'mac');
    }
    if (Ext.isWindows) {
      bodyCls.push(Ext.baseCSSPrefix + 'windows');
    }
    if (Ext.isLinux) {
      bodyCls.push(Ext.baseCSSPrefix + 'linux');
    }
    if (!supports.CSS3BorderRadius) {
      bodyCls.push(Ext.baseCSSPrefix + 'nbr');
    }
    if (!supports.CSS3LinearGradient) {
      bodyCls.push(Ext.baseCSSPrefix + 'nlg');
    }
    if (supports.Touch) {
      bodyCls.push(Ext.baseCSSPrefix + 'touch');
    }
    if (Ext.os.deviceType) {
      bodyCls.push(Ext.baseCSSPrefix + Ext.os.deviceType.toLowerCase());
    }
    if (Ext.os.is.BlackBerry) {
      bodyCls.push(Ext.baseCSSPrefix + 'bb');
      if (Ext.browser.userAgent.match(/Kbd/gi)) {
        bodyCls.push(Ext.baseCSSPrefix + 'bb-keyboard');
      }
    }
    if (Ext.os.is.iOS && Ext.isSafari) {
      bodyCls.push(Ext.baseCSSPrefix + 'mobile-safari');
    }
    if (Ext.os.is.iOS && Ext.browser.is.WebView && !Ext.browser.is.Standalone) {
      bodyCls.push(Ext.baseCSSPrefix + 'ios-native');
    }
    if (Ext.supports.FlexBoxBasisBug) {
      bodyCls.push(Ext.baseCSSPrefix + 'has-flexbasis-bug');
    }
    Ext.getBody().addCls(bodyCls);
    theme = Ext.theme;
    if (theme && theme.getDocCls) {
      Ext.fly(document.documentElement).addCls(theme.getDocCls());
    }
  }, null, {priority:1500});
});
Ext.define('Ext.overrides.dom.Element', {override:'Ext.dom.Element', _positionTopLeft:['position', 'top', 'left'], setX:function(x, animate) {
  return this.setXY([x, this.getY()], animate);
}, setXY:function(xy, animate) {
  var me = this;
  if (!animate) {
    me.callParent([xy]);
  } else {
    if (!Ext.isObject(animate)) {
      animate = {};
    }
    me.animate(Ext.applyIf({to:{x:xy[0], y:xy[1]}}, animate));
  }
  return this;
}, setY:function(y, animate) {
  return this.setXY([this.getX(), y], animate);
}, translateXY:function(x, y) {
  var me = this, el = me.el, styles = el.getStyle(me._positionTopLeft), relative = styles.position === 'relative', left = parseFloat(styles.left), top = parseFloat(styles.top), xy = me.getXY();
  if (Ext.isArray(x)) {
    y = x[1];
    x = x[0];
  }
  if (isNaN(left)) {
    left = relative ? 0 : el.dom.offsetLeft;
  }
  if (isNaN(top)) {
    top = relative ? 0 : el.dom.offsetTop;
  }
  left = typeof x === 'number' ? x - xy[0] + left : undefined;
  top = typeof y === 'number' ? y - xy[1] + top : undefined;
  return {x:left, y:top};
}, visit:function(options) {
  var me = this, dom = me.dom, skipSelf = options.skipSelf, excludeRoot = options.excludeRoot, callback = options.callback || options.fn, scope = options.scope || this, reverse = options.reverse, selector = options.selector, whatToShow = options.include || NodeFilter.SHOW_ELEMENT, treeWalker = document.createTreeWalker(dom, whatToShow, null, false), result = null, node = dom;
  if (reverse) {
    for (node = dom.lastElementChild; node.lastElementChild; node = node.lastElementChild) {
    }
    treeWalker.currentNode = node;
  }
  for (; result !== false && node; node = reverse ? treeWalker.previousNode() : treeWalker.nextNode()) {
    if (!(excludeRoot && excludeRoot.contains(node))) {
      if (!(node === dom && skipSelf)) {
        if (!(selector && !node[Ext.supports.matchesSelector](selector))) {
          result = Ext.callback(callback, scope, [node]);
        }
      }
    }
  }
  return result;
}});
Ext.define('Ext.overrides.dom.Element', {override:'Ext.dom.Element', rippleShowTimeout:300});
Ext.define('Ext.GlobalEvents', {extend:Ext.mixin.Observable, alternateClassName:'Ext.globalEvents', observableType:'global', singleton:true, resizeBuffer:100, idleEventMask:{mousemove:1, touchmove:1, pointermove:1, MSPointerMove:1, unload:1}, windowListeners:{resize:{fn:'fireResize'}}, constructor:function() {
  var me = this;
  me.callParent();
  Ext.onInternalReady(function() {
    me.attachListeners();
  });
}, setPressedComponent:function(component, e) {
  var me = this, pressedComponent = me.pressedComponent;
  if (pressedComponent && pressedComponent.onRelease) {
    pressedComponent.onRelease(e);
  }
  me.pressedComponent = component;
  if (component) {
    me.pressedScrollStart = Ext.on({scrollstart:function() {
      me.setPressedComponent(null, e);
    }, destroyable:true});
  } else {
    me.pressedScrollStart = Ext.destroy(me.pressedScrollStart);
  }
}, attachListeners:function() {
  var me = this, win = Ext.getWin(), winListeners = me.windowListeners;
  me.onlineState = Ext.isOnline();
  me.curHeight = Ext.Element.getViewportHeight();
  me.curWidth = Ext.Element.getViewportWidth();
  win.on({scope:me, online:'handleOnlineChange', offline:'handleOnlineChange'});
  me.fireResize.$skipTimerCheck = true;
  if (winListeners) {
    winListeners.scope = me;
    if (Ext.isModern) {
      winListeners.resize.onFrame = true;
    } else {
      winListeners.resize.buffer = me.resizeBuffer;
    }
    win.on(winListeners);
  }
  Ext.getDoc().on({touchstart:'fireMouseDown', mousedown:'fireMouseDown', mouseup:'fireMouseUp', touchend:'fireMouseUp', drop:'fireMouseUp', dragend:'fireMouseUp', scope:me});
}, fireMouseDown:function(e) {
  this.fireEvent('mousedown', e);
  Ext.ComponentManager.handleDocumentMouseDown(e);
}, fireMouseUp:function(e) {
  this.fireEvent('mouseup', e);
  this.setPressedComponent(null, e);
}, fireResize:function() {
  var me = this, Element = Ext.Element, w = Element.getViewportWidth(), h = Element.getViewportHeight();
  if (me.curHeight !== h || me.curWidth !== w) {
    me.curHeight = h;
    me.curWidth = w;
    if (me.hasListeners.resize) {
      me.fireEvent('resize', w, h);
    }
  }
}, handleOnlineChange:function() {
  var online = Ext.isOnline();
  if (online !== this.onlineState) {
    this.onlineState = online;
    this.fireEvent('onlinechange', online);
  }
}}, function(GlobalEvents) {
  Ext.on = function() {
    return GlobalEvents.addListener.apply(GlobalEvents, arguments);
  };
  Ext.un = function() {
    return GlobalEvents.removeListener.apply(GlobalEvents, arguments);
  };
  Ext.fireEvent = function() {
    return GlobalEvents.fireEvent.apply(GlobalEvents, arguments);
  };
  Ext.fireIdle = function() {
    if (GlobalEvents.hasListeners.idle && !Ext._suppressIdle) {
      GlobalEvents.fireEventArgs('idle');
    }
    Ext._suppressIdle = false;
  };
  Ext._suppressIdle = false;
});
Ext.USE_NATIVE_JSON = true;
Ext.JSON = new function() {
  var me = this, hasNative = window.JSON && JSON.toString() === '[object JSON]', useHasOwn = !!{}.hasOwnProperty, pad = function(n) {
    return n < 10 ? '0' + n : n;
  }, doDecode = function(json) {
    return eval('(' + json + ')');
  }, doEncode = function(o, newline) {
    if (o === null || o === undefined) {
      return 'null';
    } else {
      if (Ext.isDate(o)) {
        return me.encodeDate(o);
      } else {
        if (Ext.isString(o)) {
          if (Ext.isMSDate(o)) {
            return me.encodeMSDate(o);
          } else {
            return me.encodeString(o);
          }
        } else {
          if (typeof o === 'number') {
            return isFinite(o) ? String(o) : 'null';
          } else {
            if (Ext.isBoolean(o)) {
              return String(o);
            } else {
              if (typeof o.toJSON === 'function') {
                return doEncode(o.toJSON());
              } else {
                if (Ext.isArray(o)) {
                  return encodeArray(o, newline);
                } else {
                  if (Ext.isObject(o)) {
                    return encodeObject(o, newline);
                  } else {
                    if (typeof o === 'function') {
                      return 'null';
                    }
                  }
                }
              }
            }
          }
        }
      }
    }
    return 'undefined';
  }, m = {'\b':'\\b', '\t':'\\t', '\n':'\\n', '\f':'\\f', '\r':'\\r', '"':'\\"', '\\':'\\\\', '\x0B':'\\u000b'}, charToReplace = /[\\"\x00-\x1f\x7f-\uffff]/g, encodeString = function(s) {
    return '"' + s.replace(charToReplace, function(a) {
      var c = m[a];
      return typeof c === 'string' ? c : '\\u' + ('0000' + a.charCodeAt(0).toString(16)).slice(-4);
    }) + '"';
  }, encodeMSDate = function(o) {
    return '"' + o + '"';
  }, encodeArrayPretty = function(o, newline) {
    var len = o.length, cnewline = newline + '   ', sep = ',' + cnewline, a = ['[', cnewline], i;
    for (i = 0; i < len; i += 1) {
      a.push(me.encodeValue(o[i], cnewline), sep);
    }
    a[a.length - 1] = newline + ']';
    return a.join('');
  }, encodeObjectPretty = function(o, newline) {
    var cnewline = newline + '   ', sep = ',' + cnewline, a = ['{', cnewline], i, val;
    for (i in o) {
      val = o[i];
      if (!useHasOwn || o.hasOwnProperty(i)) {
        if (typeof val === 'function' || val === undefined || val.isInstance) {
          continue;
        }
        a.push(me.encodeValue(i) + ': ' + me.encodeValue(val, cnewline), sep);
      }
    }
    a[a.length - 1] = newline + '}';
    return a.join('');
  }, encodeArray = function(o, newline) {
    if (newline) {
      return encodeArrayPretty(o, newline);
    }
    var a = ['[', ''], len = o.length, i;
    for (i = 0; i < len; i += 1) {
      a.push(me.encodeValue(o[i]), ',');
    }
    a[a.length - 1] = ']';
    return a.join('');
  }, encodeObject = function(o, newline) {
    if (newline) {
      return encodeObjectPretty(o, newline);
    }
    var a = ['{', ''], i, val;
    for (i in o) {
      val = o[i];
      if (!useHasOwn || o.hasOwnProperty(i)) {
        if (typeof val === 'function' || val === undefined) {
          continue;
        }
        a.push(me.encodeValue(i), ':', me.encodeValue(val), ',');
      }
    }
    a[a.length - 1] = '}';
    return a.join('');
  };
  me.encodeString = encodeString;
  me.encodeValue = doEncode;
  me.encodeDate = function(o) {
    return '"' + o.getFullYear() + '-' + pad(o.getMonth() + 1) + '-' + pad(o.getDate()) + 'T' + pad(o.getHours()) + ':' + pad(o.getMinutes()) + ':' + pad(o.getSeconds()) + '"';
  };
  me.encode = function(o) {
    if (hasNative && Ext.USE_NATIVE_JSON) {
      return JSON.stringify(o);
    }
    return me.encodeValue(o);
  };
  me.decode = function(json, safe) {
    try {
      if (hasNative && Ext.USE_NATIVE_JSON) {
        return JSON.parse(json);
      }
      return doDecode(json);
    } catch (e$22) {
      if (safe) {
        return null;
      }
      Ext.raise({sourceClass:'Ext.JSON', sourceMethod:'decode', msg:"You're trying to decode an invalid JSON String: " + json});
    }
  };
  me.encodeMSDate = encodeMSDate;
  if (!Ext.util) {
    Ext.util = {};
  }
  Ext.util.JSON = me;
  Ext.encode = me.encode;
  Ext.decode = me.decode;
};
Ext.define('Ext.mixin.Inheritable', {extend:Ext.Mixin, mixinConfig:{id:'inheritable'}, getInherited:function(inner) {
  var me = this, inheritedState = inner && me.inheritedStateInner || me.inheritedState, ownerCt = me.getRefOwner(), isContainer = me.isContainer, parent, inheritedStateInner, getInner, ownerLayout;
  if (!inheritedState || inheritedState.invalid) {
    parent = me.getRefOwner();
    ownerLayout = me.ownerLayout;
    if (ownerCt) {
      getInner = ownerLayout ? ownerLayout === ownerCt.layout : true;
    }
    me.inheritedState = inheritedState = Ext.Object.chain(parent ? parent.getInherited(getInner) : Ext.rootInheritedState);
    if (isContainer) {
      me.inheritedStateInner = inheritedStateInner = Ext.Object.chain(inheritedState);
    }
    me.initInheritedState(inheritedState, inheritedStateInner);
    inheritedState = isContainer && inner ? me.inheritedStateInner : me.inheritedState;
  }
  return inheritedState;
}, getInheritedConfig:function(property, skipThis) {
  var state = this.inheritedState, old, ret;
  if (!state || state.invalid) {
    state = this.getInherited();
  }
  ret = state[property];
  if (skipThis && state.hasOwnProperty(property)) {
    old = ret;
    delete state[property];
    ret = state[property];
    state[property] = old;
  }
  return ret;
}, resolveListenerScope:function(defaultScope, skipThis) {
  var me = this, hasSkipThis = typeof skipThis === 'boolean', namedScope = Ext._namedScopes[defaultScope], ret;
  if (!namedScope) {
    ret = me.getInheritedConfig('defaultListenerScope', hasSkipThis ? skipThis : true) || defaultScope || me;
  } else {
    if (namedScope.isController) {
      ret = me.getInheritedConfig('controller', hasSkipThis ? skipThis : !namedScope.isSelf);
    } else {
      if (namedScope.isOwner) {
        ret = me.getRefOwner();
      } else {
        if (namedScope.isSelf) {
          ret = me.getInheritedConfig('defaultListenerScope', hasSkipThis && skipThis) || me;
        } else {
          if (namedScope.isThis) {
            ret = me;
          }
        }
      }
    }
  }
  return ret || null;
}, resolveSatelliteListenerScope:function(satellite, defaultScope) {
  var me = this, namedScope = Ext._namedScopes[defaultScope], ret;
  if (!namedScope) {
    ret = me.getInheritedConfig('defaultListenerScope') || defaultScope || me;
  } else {
    if (namedScope.isController) {
      ret = me.getInheritedConfig('controller');
    } else {
      if (namedScope.isSelf) {
        ret = me.getInheritedConfig('defaultListenerScope') || satellite;
      } else {
        if (namedScope.isThis) {
          ret = satellite;
        }
      }
    }
  }
  return ret || null;
}, lookupNameHolder:function(skipThis) {
  return this.getInheritedConfig('nameHolder', skipThis !== false) || null;
}, lookupReferenceHolder:function(skipThis) {
  return this.getInheritedConfig('referenceHolder', skipThis !== false) || null;
}, getRefOwner:function() {
  var me = this;
  return me.ownerCmp || me.ownerCt || me.parent || me.$initParent || me.floatParent;
}, bubble:function(fn, scope, args) {
  for (var target = this; target; target = target.getRefOwner()) {
    if (fn.apply(scope || target, args || [target]) === false) {
      break;
    }
  }
}, isDescendantOf:function(ancestor) {
  return ancestor ? ancestor.isAncestor(this) : false;
}, isAncestor:function(possibleDescendant) {
  while (possibleDescendant) {
    if (possibleDescendant.getRefOwner() === this) {
      return true;
    }
    possibleDescendant = possibleDescendant.getRefOwner();
  }
  return false;
}, invalidateInheritedState:function() {
  var inheritedState = this.inheritedState;
  if (inheritedState) {
    inheritedState.invalid = true;
    delete this.inheritedState;
  }
}, privates:{_fixName:function() {
  var me = this, owner;
  if (me.name) {
    owner = me.lookupNameHolder();
    if (owner && !owner.destroyed) {
      owner.attachNameRef(me);
    }
  }
}, _fixReference:function() {
  var me = this, refHolder;
  if (me.reference) {
    refHolder = me.lookupReferenceHolder();
    if (refHolder) {
      refHolder.attachReference(me);
    }
  }
}, onInheritedAdd:function(parent, instanced) {
  var me = this;
  if (me.inheritedState && instanced) {
    me.invalidateInheritedState();
  }
  if (me.name || me.reference) {
    Ext.ComponentManager.markReferencesDirty();
  }
}, onInheritedRemove:function(destroying) {
  var me = this;
  if (me.name || me.reference) {
    Ext.ComponentManager.markReferencesDirty();
  }
  if (me.inheritedState && !destroying) {
    me.invalidateInheritedState();
  }
}}}, function() {
  Ext.rootInheritedState = {};
});
Ext.define('Ext.mixin.Bindable', {mixinId:'bindable', config:{bind:{$value:null, lazy:true}, controller:null, defaultListenerScope:false, publishes:{$value:null, lazy:true, merge:function(newValue, oldValue) {
  return this.mergeSets(newValue, oldValue);
}}, session:{$value:null, lazy:true}, twoWayBindable:{$value:null, lazy:true, merge:function(newValue, oldValue) {
  return this.mergeSets(newValue, oldValue);
}}, viewModel:{$value:null, lazy:true}}, defaultBindProperty:null, nameable:false, shareableName:false, reference:null, validRefRe:/^[a-z_][a-z0-9_]*$/i, getReference:function() {
  return this.reference;
}, initInheritedState:function(inheritedState) {
  var me = this, reference = me.reference, controller = me.getController(), viewModel = me.getConfig('viewModel', true), session = me.getConfig('session', true), defaultListenerScope = me.getDefaultListenerScope();
  if (controller) {
    inheritedState.controller = controller;
  }
  if (defaultListenerScope) {
    inheritedState.defaultListenerScope = me;
  } else {
    if (controller) {
      inheritedState.defaultListenerScope = controller;
    }
  }
  if (viewModel) {
    if (!viewModel.isViewModel) {
      viewModel = me;
    }
    inheritedState.viewModel = viewModel;
  }
  if (session) {
    if (!session.isSession) {
      session = me;
    }
    inheritedState.session = session;
  }
  if (reference) {
    me.referenceKey = (inheritedState.referencePath || '') + reference;
    me.viewModelKey = (inheritedState.viewModelPath || '') + reference;
  }
}, isBound:function(name) {
  var bind = this.getBind();
  return !!(bind && bind[name || this.defaultBindProperty]);
}, lookupController:function(skipThis) {
  return this.getInheritedConfig('controller', skipThis) || null;
}, lookupSession:function(skipThis) {
  var ret = skipThis ? null : this.getSession();
  if (!ret) {
    ret = this.getInheritedConfig('session', skipThis);
    if (ret && !ret.isSession) {
      ret = ret.getInherited().session = ret.getSession();
    }
  }
  return ret || null;
}, lookupViewModel:function(skipThis) {
  var ret = skipThis ? null : this.getViewModel();
  if (!ret) {
    ret = this.getInheritedConfig('viewModel', skipThis);
    if (ret && !ret.isViewModel) {
      ret = ret.getInherited().viewModel = ret.getViewModel();
    }
  }
  return ret || null;
}, publishState:function(property, value) {
  var me = this, state = me.publishedState, binds = me.getBind(), binding = binds && property && binds[property], count = 0, name, publishes, vm, path;
  if (!(arguments.length === 0 || arguments.length === 2)) {
    Ext.raise('publishState must either be called with no args, or with both name AND value passed');
  }
  if (binding && !binding.syncing && !binding.isReadOnly()) {
    if (binding.calls || !(value == null || value === me.getInitialConfig()[property])) {
      binding.setValue(value);
    }
  }
  if (!(publishes = me.getPublishes())) {
    return;
  }
  if (!(vm = me.lookupViewModel())) {
    return;
  }
  if (!(path = me.viewModelKey)) {
    return;
  }
  state = state || (me.publishedState = {});
  if (property) {
    if (!publishes[property]) {
      return;
    }
    if (!(value && value.constructor === Object) && !(value instanceof Array)) {
      if (state[property] === value) {
        return;
      }
    }
    path += '.';
    path += property;
  } else {
    for (name in publishes) {
      ++count;
      state[name] = me.getConfig(name);
    }
    if (!count) {
      return;
    }
    value = state;
  }
  vm.set(path, value);
}, privates:{addBindableUpdater:function(property) {
  var me = this, configs = me.self.$config.configs, cfg = configs[property], updateName;
  if (cfg && !me.hasOwnProperty(updateName = cfg.names.update)) {
    me[updateName] = cfg.bindableUpdater || (cfg.root.bindableUpdater = me.makeBindableUpdater(cfg));
  }
}, applyBind:function(binds, currentBindings) {
  if (!binds) {
    return binds;
  }
  var me = this, viewModel = me.lookupViewModel(), twoWayable = me.getTwoWayBindable(), getBindTemplateScope = me._getBindTemplateScope, b, property, descriptor, destroy;
  me.$hasBinds = true;
  if (!currentBindings || typeof currentBindings === 'string') {
    currentBindings = {};
  }
  if (!viewModel) {
    Ext.raise('Cannot use bind config without a viewModel');
  }
  if (Ext.isString(binds)) {
    if (!me.defaultBindProperty) {
      Ext.raise(me.$className + ' has no defaultBindProperty - ' + 'Please specify a bind object');
    }
    b = binds;
    binds = {};
    binds[me.defaultBindProperty] = b;
  }
  for (property in binds) {
    descriptor = binds[property];
    b = currentBindings[property];
    if (b && b.isBinding) {
      b.destroy();
      b = null;
      destroy = true;
    }
    if (descriptor) {
      b = viewModel.bind(descriptor, me.onBindNotify, me);
      b._config = Ext.Config.get(property);
      b.getTemplateScope = getBindTemplateScope;
      if (!me[b._config.names.set]) {
        Ext.raise('Cannot bind ' + property + ' on ' + me.$className + ' - missing a ' + b._config.names.set + ' method.');
      }
    }
    if (destroy) {
      delete currentBindings[property];
    } else {
      currentBindings[property] = b;
    }
    if (twoWayable && twoWayable[property]) {
      if (destroy) {
        me.clearBindableUpdater(property);
      } else {
        if (!b.isReadOnly()) {
          me.addBindableUpdater(property);
        }
      }
    }
  }
  return currentBindings;
}, applyController:function(controller) {
  if (controller) {
    controller = Ext.Factory.controller(controller);
    controller.setView(this);
  }
  this.controller = controller;
  return controller;
}, updatePublishes:function(all) {
  var me = this;
  if (me.lookupViewModel()) {
    for (var property in all) {
      me.addBindableUpdater(property);
    }
  }
  return all;
}, applySession:function(session) {
  if (!session) {
    return null;
  }
  if (!session.isSession) {
    var parentSession = this.lookupSession(true), config = session === true ? {} : session;
    if (parentSession) {
      session = parentSession.spawn(config);
    } else {
      session = new Ext.data['Session'](config);
    }
  }
  return session;
}, applyViewModel:function(viewModel) {
  var me = this, config, session;
  if (!viewModel) {
    return null;
  }
  if (!viewModel.isViewModel) {
    config = {parent:me.lookupViewModel(true), view:me};
    config.session = me.getSession();
    if (!session && !config.parent) {
      config.session = me.lookupSession();
    }
    if (viewModel) {
      if (viewModel.constructor === Object) {
        Ext.apply(config, viewModel);
      } else {
        if (typeof viewModel === 'string') {
          config.type = viewModel;
        }
      }
    }
    viewModel = Ext.Factory.viewModel(config);
  }
  return viewModel;
}, _getBindTemplateScope:function() {
  return this.scope.resolveListenerScope();
}, clearBindableUpdater:function(property) {
  var me = this, configs = me.self.$config.configs, cfg = configs[property], updateName;
  if (cfg && me.hasOwnProperty(updateName = cfg.names.update)) {
    if (me[updateName].$bindableUpdater) {
      delete me[updateName];
    }
  }
}, destroyBindable:function() {
  var me = this, viewModel = me.getConfig('viewModel', true), session = me.getConfig('session', true), controller = me.getController();
  if (viewModel && viewModel.isViewModel) {
    viewModel.destroy();
    me.setViewModel(null);
  }
  if (session && session.isSession) {
    if (session.getAutoDestroy()) {
      session.destroy();
    }
    me.setSession(null);
  }
  if (controller) {
    me.setController(null);
    controller.destroy();
  }
}, initBindable:function() {
  var me = this, controller = me.controller;
  me.initBindable = Ext.emptyFn;
  me.getBind();
  me.getPublishes();
  if (!me.viewModel) {
    me.getViewModel();
  }
  if (controller) {
    controller.initBindings();
  }
  if (me.reference) {
    me.publishState();
  }
}, isSyncing:function(name) {
  var bindings = this.getBind(), ret = false, binding;
  if (bindings) {
    binding = bindings[name];
    if (binding) {
      ret = binding.syncing > 0;
    }
  }
  return ret;
}, makeBindableUpdater:function(cfg) {
  var updateName = cfg.names.update, fn = function(newValue, oldValue) {
    var me = this, updater = me.self.prototype[updateName];
    if (updater) {
      updater.call(me, newValue, oldValue);
    }
    me.publishState(cfg.name, me[cfg.getInternalName(me)]);
  };
  fn.$bindableUpdater = true;
  return fn;
}, notifyIf:function(skipThis) {
  var vm = this.lookupViewModel(skipThis);
  if (vm) {
    vm.notify();
  }
}, onBindNotify:function(value, oldValue, binding) {
  binding.syncing = binding.syncing + 1 || 1;
  this[binding._config.names.set](value);
  --binding.syncing;
}, removeBindings:function() {
  var me = this, bindings, key, binding;
  if (me.$hasBinds) {
    bindings = me.getBind();
    if (bindings && typeof bindings !== 'string') {
      for (key in bindings) {
        binding = bindings[key];
        binding.destroy();
        binding._config = binding.getTemplateScope = null;
      }
    }
  }
  me.setBind(null);
}, updateSession:function(session) {
  var state = this.getInherited();
  if (session) {
    state.session = session;
  } else {
    delete state.session;
  }
}, updateViewModel:function(viewModel, oldViewModel) {
  var me = this, state = me.getInherited(), controller = me.getController();
  if (viewModel) {
    me.hasVM = true;
    state.viewModel = viewModel;
    viewModel.setView(me);
    if (controller) {
      controller.initViewModel(viewModel);
    }
  } else {
    delete state.viewModel;
  }
  me.viewModel = viewModel;
}}});
Ext.define('Ext.mixin.ComponentDelegation', {extend:Ext.Mixin, mixinConfig:{id:'componentDelegation'}, privates:{addDelegatedListener:function(eventName, fn, scope, options, order, caller, manager) {
  var me = this, delegatedEvents, event, priority;
  eventName = Ext.canonicalEventName(eventName);
  order = order || options.order;
  if (order) {
    priority = options && options.priority;
    if (!priority) {
      options = options ? Ext.Object.chain(options) : {};
      options.priority = me.$orderToPriority[order];
    }
  }
  if (options.target) {
    Ext.raise("Cannot add '" + eventName + "' listener to component: '" + me.id + "' - 'delegate' and 'target' event options are incompatible.");
  }
  delegatedEvents = me.$delegatedEvents || (me.$delegatedEvents = {});
  event = delegatedEvents[eventName] || (delegatedEvents[eventName] = new Ext.util.Event(me, eventName));
  if (event.addListener(fn, scope, options, caller, manager)) {
    me.$hasDelegatedListeners._incr_(eventName);
  }
}, clearDelegatedListeners:function() {
  var me = this, delegatedEvents = me.$delegatedEvents, eventName, event, listenerCount;
  if (delegatedEvents) {
    for (eventName in delegatedEvents) {
      event = delegatedEvents[eventName];
      listenerCount = event.listeners.length;
      event.clearListeners();
      me.$hasDelegatedListeners._decr_(eventName, listenerCount);
      delete delegatedEvents[eventName];
    }
  }
}, doFireDelegatedEvent:function(eventName, args) {
  var me = this, ret = true, owner, delegatedEvents, event;
  if (me.$hasDelegatedListeners[eventName]) {
    owner = me.getRefOwner();
    while (owner) {
      delegatedEvents = owner.$delegatedEvents;
      if (delegatedEvents) {
        event = delegatedEvents[eventName];
        if (event) {
          ret = event.fireDelegated(me, args);
          if (ret === false) {
            break;
          }
        }
      }
      owner = owner.getRefOwner();
    }
  }
  return ret;
}, removeDelegatedListener:function(eventName, fn, scope) {
  var me = this, delegatedEvents = me.$delegatedEvents, event;
  if (delegatedEvents) {
    event = delegatedEvents[eventName];
    if (event && event.removeListener(fn, scope)) {
      me.$hasDelegatedListeners._decr_(eventName);
      if (event.listeners.length === 0) {
        delete delegatedEvents[eventName];
      }
    }
  }
}, destroyComponentDelegation:function() {
  if (this.clearPropertiesOnDestroy) {
    this.$delegatedEvents = null;
  }
}}, onClassMixedIn:function(T) {
  function HasListeners() {
  }
  T.prototype.HasListeners = T.HasListeners = HasListeners;
  HasListeners.prototype = T.hasListeners = new Ext.mixin.ComponentDelegation.HasDelegatedListeners;
}}, function(ComponentDelegation) {
  function HasDelegatedListeners() {
  }
  ComponentDelegation.HasDelegatedListeners = HasDelegatedListeners;
  HasDelegatedListeners.prototype = ComponentDelegation.prototype.$hasDelegatedListeners = new Ext.mixin.Observable.HasListeners;
});
Ext.define('Ext.plugin.Abstract', {alternateClassName:'Ext.AbstractPlugin', isPlugin:true, constructor:function(config) {
  if (config) {
    this.pluginConfig = config;
    this.initConfig(config);
  }
}, clonePlugin:function(overrideCfg) {
  return new this.self(Ext.apply({}, overrideCfg, this.pluginConfig));
}, getCmp:function() {
  return this.cmp;
}, setCmp:function(host) {
  this.cmp = host;
}, init:Ext.emptyFn, destroy:function() {
  this.cmp = this.pluginConfig = null;
  this.callParent();
}, onClassExtended:function(cls, data, hooks) {
  var alias = data.alias, prototype = cls.prototype;
  if (alias && !data.ptype) {
    if (Ext.isArray(alias)) {
      alias = alias[0];
    }
    prototype.ptype = alias.split('plugin.')[1];
  }
}, resolveListenerScope:function(defaultScope) {
  var me = this, cmp = me.getCmp(), scope;
  if (cmp) {
    scope = cmp.resolveSatelliteListenerScope(me, defaultScope);
  }
  return scope || me.mixins.observable.resolveListenerScope.call(me, defaultScope);
}, statics:{decode:function(plugins, typeProp, include) {
  if (plugins) {
    var type = Ext.typeOf(plugins), entry, key, obj, value;
    if (type === 'string') {
      obj = {};
      obj[typeProp] = plugins;
      plugins = [obj];
    } else {
      if (plugins.isInstance) {
        plugins = [plugins];
      } else {
        if (type === 'object') {
          if (plugins[typeProp]) {
            plugins = [plugins];
          } else {
            obj = include ? Ext.merge(Ext.clone(include), plugins) : plugins;
            plugins = [];
            for (key in obj) {
              if (!(value = obj[key])) {
                continue;
              }
              entry = {id:key};
              entry[typeProp] = key;
              if (key === 'responsive') {
                entry.weight = -1000;
              }
              Ext.apply(entry, value);
              plugins.push(entry);
            }
            plugins.sort(Ext.weightSortFn);
          }
        } else {
          if (type !== 'array') {
            Ext.raise('Invalid value for "plugins" config ("' + type + '"');
          } else {
            plugins = plugins.slice();
          }
        }
      }
    }
  }
  return plugins;
}}});
Ext.define('Ext.mixin.Pluggable', function(Pluggable) {
  return {config:{plugins:null}, addPlugin:function(plugin) {
    var me = this, plugins = me.getPlugins();
    if (plugins) {
      plugin = me.createPlugin(plugin);
      plugin.init(me);
      plugins.push(plugin);
    } else {
      me.setPlugins(plugin);
      plugin = me.getPlugins()[0];
    }
    return plugin;
  }, destroyPlugin:function(plugin) {
    return this.removePlugin(plugin, true);
  }, findPlugin:function(type) {
    var plugins = this.getPlugins(), n = plugins && plugins.length, i, plugin, ret;
    for (i = 0; i < n && !ret; i++) {
      plugin = plugins[i];
      if (plugin.type === type || plugin.ptype === type) {
        ret = plugin;
      }
    }
    return ret || null;
  }, getPlugin:function(id) {
    var plugins = this.getPlugins(), n = plugins && plugins.length, i, plugin, ret;
    for (i = 0; i < n && !ret; i++) {
      plugin = plugins[i];
      if (plugin.id === id || plugin.pluginId === id) {
        ret = plugin;
      }
    }
    return ret || null;
  }, removePlugin:function(plugin, destroy) {
    var plugins = this.getPlugins(), i = plugins && plugins.length || 0, p;
    while (i-- > 0) {
      p = plugins[i];
      if (p === plugin || p.id === plugin) {
        plugins.splice(i, 1);
        if (destroy) {
          if (p.destroy) {
            p.destroy();
          }
        } else {
          if (p.detachCmp) {
            p.detachCmp();
            if (p.setCmp) {
              p.setCmp(null);
            }
          }
        }
        break;
      }
      p = null;
    }
    return p;
  }, privates:{statics:{idSeed:0}, activatePlugin:function(type) {
    var me = this, config = me.initialConfig, plugins = config && config.plugins, ret = null, i, include, p;
    if (plugins) {
      include = me.config.plugins;
      include = include && typeof include === 'object' ? include : null;
      plugins = Ext.plugin.Abstract.decode(plugins, 'type', include);
      for (i = plugins.length; i-- > 0;) {
        p = plugins[i];
        if (p === type || p.type === type) {
          me.initialConfig = config = Ext.apply({}, config);
          config.plugins = plugins;
          plugins[i] = ret = me.createPlugin(p);
          break;
        }
      }
    }
    return ret;
  }, applyPlugins:function(plugins, oldPlugins) {
    var me = this, oldCount = oldPlugins && oldPlugins.length || 0, count, i, plugin;
    if (plugins) {
      plugins = Ext.plugin.Abstract.decode(plugins, 'type');
    }
    for (i = 0; i < oldCount; ++i) {
      oldPlugins[i].$dead = true;
    }
    count = plugins && plugins.length || 0;
    for (i = 0; i < count; ++i) {
      plugins[i] = me.createPlugin(plugins[i]);
    }
    for (i = 0; i < count; ++i) {
      plugin = plugins[i];
      if (plugin.$dead) {
        delete plugin.$dead;
      } else {
        plugin.init(me);
      }
    }
    for (i = 0; i < oldCount; ++i) {
      if ((plugin = oldPlugins[i]).$dead) {
        delete plugin.$dead;
        Ext.destroy(plugin);
      }
    }
    return plugins;
  }, createPlugin:function(config) {
    if (typeof config === 'string') {
      config = {type:config};
    }
    var ret = config;
    if (!config.isInstance) {
      config.cmp = this;
      ret = Ext.factory(config, null, null, 'plugin');
      delete config.cmp;
    }
    if (!ret.id) {
      ret.id = ++Pluggable.idSeed;
    }
    if (ret.setCmp) {
      ret.setCmp(this);
    }
    return ret;
  }}};
});
Ext.define('Ext.mixin.Keyboard', function(Keyboard) {
  return {extend:Ext.Mixin, mixinConfig:{id:'keyboard'}, config:{keyMap:{$value:null, cached:true, merge:function(value, baseValue, cls, mixin) {
    if (value === null) {
      return value;
    }
    var ret = baseValue && !cls.isInstance ? Ext.Object.chain(baseValue) : {}, key, ucKey, v, vs;
    for (key in value) {
      if (key !== 'scope') {
        ucKey = key.toUpperCase();
        if (!mixin || ret[ucKey] === undefined) {
          v = value[key];
          if (v) {
            if (typeof v === 'string' || typeof v === 'function') {
              v = {handler:v};
            } else {
              v = Ext.apply({handler:v.fn}, v);
            }
            vs = v.scope || value.scope || 'self';
            v.scope = vs === 'controller' ? 'self.controller' : vs;
          }
          ret[ucKey] = v;
        }
      }
    }
    return ret;
  }}, keyMapEnabled:null}, keyMapTarget:'el', applyKeyMap:function(keyMap, existingKeyMap) {
    var me = this, own = me.hasOwnProperty('config');
    if (own && existingKeyMap && existingKeyMap.$owner !== me) {
      existingKeyMap = Ext.apply({}, existingKeyMap);
    }
    keyMap = keyMap ? Keyboard.combineKeyMaps(existingKeyMap, keyMap, own && me) : null;
    if (me._keyMapReady) {
      me.setKeyMapListener(keyMap && me.getKeyMapEnabled());
    }
    return keyMap;
  }, initKeyMap:function() {
    var me = this, enabled = me.getKeyMapEnabled();
    me._keyMapReady = true;
    if (enabled === null) {
      me.setKeyMapEnabled(true);
    } else {
      me.setKeyMapListener(enabled && me.getKeyMap());
    }
  }, disableKeyMapGroup:function(group) {
    this.setKeyMapGroupEnabled(group, false);
  }, enableKeyMapGroup:function(group) {
    this.setKeyMapGroupEnabled(group, true);
  }, setKeyMapGroupEnabled:function(group, state) {
    var me = this, disabledGroups = me.disabledKeyMapGroups || (me.disabledKeyMapGroups = {});
    disabledGroups[group] = !state;
  }, updateKeyMapEnabled:function(enabled) {
    this.setKeyMapListener(enabled && this._keyMapReady && this.getKeyMap());
  }, privates:{_keyMapListenCount:0, _keyMapReady:false, comparePriorities:function(lhs, rhs) {
    return (rhs.priority || 0) - (lhs.priority || 0);
  }, findKeyMapEntries:function(e) {
    var me = this, disabledGroups = me.disabledKeyMapGroups, keyMap = me.getKeyMap(), entries = keyMap && Keyboard.getKeyName(e), entry, len, i, result = [];
    entries = entries && keyMap[entries];
    if (entries) {
      if (!entries.sorted) {
        Ext.Array.sort(entries, me.comparePriorities);
        entries.sorted = true;
      }
      len = entries.length;
      for (i = 0; i < len; i++) {
        entry = entries[i];
        if (!disabledGroups || !disabledGroups[entry.group]) {
          if (Keyboard.matchEntry(entry, e)) {
            result.push(entry);
          }
        }
      }
    }
    return result;
  }, onKeyMapEvent:function(e) {
    var me = this, entries = me.getKeyMapEnabled() ? me.findKeyMapEntries(e) : null, len = entries && entries.length, i, entry, result;
    for (i = 0; i < len && result !== false; i++) {
      entry = entries[i];
      result = Ext.callback(entry.handler, entry.scope, [e, this], 0, this);
    }
    return result;
  }, setKeyMapListener:function(enabled) {
    var me = this, listener = me._keyMapListener, eventSource;
    if (listener) {
      listener.destroy();
      listener = null;
    }
    if (enabled) {
      ++me._keyMapListenCount;
      if (enabled) {
        eventSource = me[me.keyMapTarget];
        if (typeof eventSource === 'function') {
          eventSource = eventSource.call(me);
        }
        listener = eventSource.on({destroyable:true, scope:me, keydown:'onKeyMapEvent', keypress:'onKeyMapEvent'});
      }
    }
    me._keyMapListener = listener || null;
  }, statics:{_charCodeRe:/^#([\d]+)$/, _keySpecRe:/^(?:(?:(\*)[\+\-])|(?:([a-z\+\-]*)[\+\-]))?(?:([a-z0-9_]+|[\+\-]|(?:#?\d+))(?::([a-z]+))?)$/i, _delimiterRe:/\-|\+/, _keyMapEvents:{charCode:'keypress', keyCode:'keydown'}, combineKeyMaps:function(existingKeyMap, keyMap, owner) {
    var defaultScope = keyMap.scope || 'controller', entry, key, mapping, existingMapping;
    for (key in keyMap) {
      if (key === 'scope') {
        continue;
      }
      if (!(mapping = keyMap[key])) {
        if (mapping === undefined) {
          Ext.raise('keyMap entry "' + key + '" is undefined');
        }
        if (!existingKeyMap) {
          continue;
        }
      } else {
        if (typeof mapping === 'string' || typeof mapping === 'function') {
          mapping = {handler:mapping, scope:defaultScope};
        } else {
          if (mapping) {
            mapping = Ext.apply({handler:mapping.fn, scope:defaultScope}, mapping);
          }
        }
        existingKeyMap = existingKeyMap || {};
      }
      if (Keyboard.parseEntry(key, entry = mapping || {})) {
        existingMapping = existingKeyMap[entry.name];
        if (existingMapping) {
          if (owner && existingMapping.$owner !== owner) {
            existingKeyMap[entry.name] = existingMapping = existingMapping.slice();
            existingMapping.$owner = owner;
          }
          existingMapping.push(mapping);
          existingMapping.sorted = false;
        } else {
          existingMapping = existingKeyMap[entry.name] = [mapping];
          existingMapping.$owner = owner;
          existingMapping.sorted = true;
        }
      } else {
        Ext.raise('Invalid keyMap key specification "' + key + '"');
      }
    }
    if (existingKeyMap && owner) {
      existingKeyMap.$owner = owner;
    }
    return existingKeyMap || null;
  }, getKeyName:function(event) {
    var keyCode;
    if (event.isEvent) {
      keyCode = event.keyCode || event.charCode;
      event = event.browserEvent;
      if (keyCode === 229 && 'code' in event) {
        if (Ext.String.startsWith(event.code, 'Key')) {
          return event.key.substr(3);
        }
        if (Ext.String.startsWith(event.code, 'Digit')) {
          return event.key.substr(5);
        }
      }
    } else {
      keyCode = event;
    }
    return Ext.event.Event.keyCodes[keyCode] || String.fromCharCode(keyCode);
  }, matchEntry:function(entry, e) {
    var ev = e.browserEvent, code;
    if (e.type !== entry.event) {
      return false;
    }
    if (!(code = entry.charCode)) {
      if (entry.keyCode !== e.keyCode || !entry.ignoreModifiers && !entry.shiftKey !== !ev.shiftKey) {
        return false;
      }
    } else {
      if (e.getCharCode() !== code) {
        return false;
      }
    }
    return entry.ignoreModifiers || !entry.ctrlKey === !ev.ctrlKey && !entry.altKey === !ev.altKey && !entry.metaKey === !ev.metaKey && !entry.shiftKey === !ev.shiftKey;
  }, parseEntry:function(key, entry) {
    key = key.toUpperCase();
    var me = this, Event = Ext.event.Event, keyFlags = Event.keyFlags, parts = me._keySpecRe.exec(key), type = 'keyCode', name, code, i, match, n;
    if (parts) {
      name = parts[3];
      if (parts[4]) {
        entry.group = parts[4];
      }
      if (!(entry.ignoreModifiers = !!parts[1]) && parts[2]) {
        parts = parts[2].split(me._delimiterRe);
        n = parts.length;
        for (i = 0; i < n; i++) {
          if (!keyFlags[parts[i]]) {
            return false;
          }
          entry[keyFlags[parts[i]]] = true;
        }
      }
      entry.name = name;
      if (isNaN(code = Event[name])) {
        if (!(match = me._charCodeRe.exec(name))) {
          if (name.length === 1) {
            code = name.charCodeAt(0);
          }
        } else {
          code = +match[1];
        }
        if (code) {
          type = 'charCode';
        } else {
          code = +name;
        }
        entry.name = Keyboard.getKeyName(code);
      }
      entry.event = entry.event || me._keyMapEvents[type];
      return !isNaN(code) && (entry[type] = code);
    }
  }}}};
});
Ext.define('Ext.mixin.Focusable', {mixinId:'focusable', $isFocusableEntity:true, focusable:false, hasFocus:false, containsFocus:false, focusCls:Ext.baseCSSPrefix + 'focused', focusEl:'el', getFocusEl:function() {
  var focusEl = this.focusEl;
  return focusEl && focusEl.dom ? focusEl : null;
}, getFocusClsEl:function() {
  return this.getFocusEl();
}, initFocusable:Ext.emptyFn, initFocusableEvents:function(force) {
  this.initFocusableElement(force);
}, enableFocusable:Ext.emptyFn, disableFocusable:function() {
  var me = this;
  if (me.hasFocus) {
    me.revertFocus();
  }
  me.removeFocusCls();
}, destroyFocusable:function() {
  var me = this;
  Ext.destroy(me.focusListeners);
  me.focusListeners = me.focusEnterEvent = me.focusTask = null;
  me.focusEl = me.ariaEl = null;
}, isFocusable:function(deep) {
  var me = this, focusEl;
  if (!me.focusable && (!me.isContainer || !deep)) {
    return false;
  }
  focusEl = me.getFocusEl();
  if (focusEl && me.canFocus()) {
    return focusEl && !focusEl.destroyed && focusEl.isFocusable(deep);
  }
  return false;
}, isDestructing:function() {
  for (var c = this; c; c = c.getRefOwner()) {
    if (c.destroying || c.destroyed) {
      return true;
    }
  }
  return false;
}, canFocus:function(skipVisibility, includeFocusTarget) {
  var me = this, ownerFC = me.ownerFocusableContainer, focusableIfDisabled = ownerFC && ownerFC.allowFocusingDisabledChildren, canFocus;
  canFocus = !me.destroyed && me.rendered && !me.isDestructing() && (me.isContainer || me.focusable) && (!me.isDisabled() || focusableIfDisabled) && (skipVisibility || me.isVisible(true));
  return canFocus || includeFocusTarget && !!me.findFocusTarget();
}, focus:function(selectText) {
  var me = this, focusTarget, focusElDom;
  if (!me.focusable && !me.isContainer || me.destroyed || me.destroying) {
    return false;
  }
  if (me.canFocus() && (focusTarget = me.getFocusEl())) {
    if (focusTarget.$isFocusableEntity) {
      return focusTarget.focus.apply(focusTarget, arguments);
    }
    focusElDom = focusTarget.dom;
    if (focusElDom) {
      focusTarget.focus();
      if (selectText && (me.selectText || focusElDom.select)) {
        if (me.selectText) {
          if (Ext.isArray(selectText)) {
            me.selectText.apply(me, selectText);
          } else {
            me.selectText();
          }
        } else {
          focusElDom.select();
        }
      }
    } else {
      if (focusTarget.focus) {
        focusTarget.focus();
      } else {
        return false;
      }
    }
  } else {
    focusTarget = me.findFocusTarget();
    if (focusTarget && focusTarget != me) {
      return focusTarget.focus.apply(focusTarget, arguments);
    } else {
      return false;
    }
  }
  return true;
}, onBlur:function(e) {
  var me = this, container = me.ownerFocusableContainer;
  me.hasFocus = false;
  if (me.beforeBlur && !me.beforeBlur.$emptyFn) {
    me.beforeBlur(e);
  }
  if (container) {
    container.beforeFocusableChildBlur(me, e);
  }
  me.removeFocusCls(e);
  if (me.hasListeners.blur) {
    me.fireEvent('blur', me, e);
  }
  if (me.postBlur && !me.postBlur.$emptyFn) {
    me.postBlur(e);
  }
  if (container) {
    container.afterFocusableChildBlur(me, e);
  }
}, onFocus:function(e) {
  var me = this, container = me.ownerFocusableContainer;
  if (me.canFocus()) {
    if (me.beforeFocus && !me.beforeFocus.$emptyFn) {
      me.beforeFocus(e);
    }
    if (container) {
      container.beforeFocusableChildFocus(me, e);
    }
    me.addFocusCls(e);
    if (!me.hasFocus) {
      me.hasFocus = true;
      me.fireEvent('focus', me, e);
    }
    if (me.postFocus && !me.postFocus.$emptyFn) {
      me.postFocus(e);
    }
    if (container) {
      container.afterFocusableChildFocus(me, e);
    }
  }
}, getTabIndex:function() {
  var me = this, el, index;
  if (!me.focusable) {
    return;
  }
  el = me.getFocusEl();
  if (el) {
    if (el.$isFocusableEntity) {
      index = el.getTabIndex();
    } else {
      if (el.isElement && el.dom) {
        index = el.dom.getAttribute('tabIndex');
        if (index !== null) {
          index -= 0;
        }
      } else {
        return;
      }
    }
  }
  if (typeof index !== 'number') {
    index = me.tabIndex;
  }
  return index;
}, setTabIndex:function(newTabIndex, focusEl) {
  var me = this, ownerFC = me.ownerFocusableContainer, focusableIfDisabled = ownerFC && ownerFC.allowFocusingDisabledChildren, el;
  if (!me.focusable && !me.forceTabIndex) {
    return;
  }
  me.tabIndex = newTabIndex;
  if (me.destroying || me.destroyed || me.isDisabled() && !focusableIfDisabled) {
    return;
  }
  el = focusEl || me.getFocusEl();
  if (el) {
    if (el.$isFocusableEntity) {
      el.setTabIndex(newTabIndex);
    } else {
      if (el.isElement && el.dom) {
        el.setTabIndex(newTabIndex);
      }
    }
  }
}, onFocusEnter:function(e) {
  var me = this;
  if (me.destroying || me.destroyed) {
    return;
  }
  me.focusEnterEvent = e;
  me.containsFocus = true;
  if (me.hasListeners.focusenter) {
    me.fireEvent('focusenter', me, e);
  }
}, onFocusLeave:function(e) {
  var me = this;
  if (me.destroying || me.destroyed) {
    return;
  }
  me.focusEnterEvent = null;
  me.containsFocus = false;
  if (me.hasListeners.focusleave) {
    me.fireEvent('focusleave', me, e);
  }
}, onFocusMove:Ext.emptyFn, privates:{forceTabIndex:false, revertFocus:function() {
  var me = this, focusEvent = me.focusEnterEvent, activeElement = Ext.Element.getActiveElement(), focusTarget, fromComponent, reverted;
  if (focusEvent && !me.preventRefocus && me.el.contains(activeElement)) {
    fromComponent = focusEvent.fromComponent;
    if (fromComponent && (fromComponent.destroyed || fromComponent.isDestructing())) {
      focusTarget = document.body;
    } else {
      focusTarget = focusEvent.relatedTarget;
    }
    if (focusTarget === document.body) {
      fromComponent = me.findFocusTarget();
      if (fromComponent) {
        focusTarget = fromComponent.getFocusEl();
      }
    }
    if (focusTarget && focusTarget.$isFocusableEntity) {
      if (!focusTarget.destroyed && focusTarget.isFocusable()) {
        focusTarget.focus();
      }
    } else {
      if (Ext.getDoc().contains(focusTarget) && Ext.fly(focusTarget).isFocusable()) {
        fromComponent = Ext.Component.from(focusTarget);
        if (fromComponent) {
          fromComponent.revertFocusTo(focusTarget);
        } else {
          focusTarget.focus();
        }
      } else {
        if (focusEvent.fromComponent && focusEvent.fromComponent.focus) {
          reverted = focusEvent.fromComponent.focus();
          if (!reverted) {
            activeElement.blur();
          }
        }
      }
    }
  }
}, revertFocusTo:function(target) {
  target.focus();
}, findFocusTarget:function() {
  var me = this, parentAxis, candidate, len, i, focusTargets, focusIndex;
  if (me.preventRefocus) {
    return null;
  }
  for (parentAxis = [], candidate = me.getRefOwner(); candidate; candidate = candidate.getRefOwner()) {
    if (!candidate.isDisabled()) {
      parentAxis.unshift(candidate);
    }
  }
  for (i = 0, len = parentAxis.length; i < len; i++) {
    candidate = parentAxis[i];
    if (candidate.destroying || !candidate.isVisible()) {
      parentAxis.length = i;
      break;
    }
  }
  for (i = parentAxis.length - 1; i >= 0; i--) {
    candidate = parentAxis[i];
    focusTargets = Ext.ComponentQuery.query(':canfocus()', candidate);
    if (focusTargets.length) {
      focusIndex = Ext.Array.indexOf(focusTargets, Ext.ComponentManager.getActiveComponent());
      return focusTargets[focusIndex + 1] || focusTargets[focusIndex - 1] || focusTargets[0];
    }
    if (candidate.isFocusable && candidate.isFocusable()) {
      return candidate;
    }
  }
}, initFocusableElement:function(force) {
  var me = this, tabIndex = me.getTabIndex(), focusEl = me.getFocusEl();
  if (focusEl && !focusEl.$isFocusableEntity) {
    if (tabIndex != null && (force || me.canFocus(true))) {
      me.setTabIndex(tabIndex, focusEl);
    }
    if (!focusEl.dom.hasAttribute('data-componentid')) {
      focusEl.dom.setAttribute('data-componentid', me.id);
    }
  }
}, addFocusCls:function(e) {
  var focusCls = this.focusCls, el;
  el = this.getFocusClsEl();
  if (focusCls) {
    el = this.getFocusClsEl(e);
    if (el) {
      el.addCls(focusCls);
    }
  }
}, removeFocusCls:function(e) {
  var focusCls = this.focusCls, el;
  if (focusCls) {
    el = this.getFocusClsEl(e);
    if (el) {
      el.removeCls(focusCls);
    }
  }
}, handleFocusEvent:function(e) {
  var me = this, event;
  if (!me.focusable || me.destroying || me.destroyed) {
    return;
  }
  if (me.isFocusing(e)) {
    event = new Ext.event.Event(e.event);
    event.type = 'focus';
    event.relatedTarget = e.fromElement;
    event.target = e.toElement;
    me.onFocus(event);
  }
}, handleBlurEvent:function(e) {
  var me = this, event;
  if (!me.focusable || me.destroying || me.destroyed) {
    return;
  }
  if (e.toElement === document.body || me.isBlurring(e)) {
    event = new Ext.event.Event(e.event);
    event.type = 'blur';
    event.target = e.fromElement;
    event.relatedTarget = e.toElement;
    me.onBlur(event);
  }
}, isFocusing:function(e) {
  var focusEl = this.getFocusEl();
  if (focusEl) {
    if (focusEl.isFocusing) {
      return focusEl.isFocusing(e);
    } else {
      return focusEl.dom === document.activeElement && e.toElement === focusEl.dom && e.fromElement !== e.toElement;
    }
  }
  return false;
}, isBlurring:function(e) {
  var focusEl = this.getFocusEl();
  if (focusEl) {
    if (focusEl.isFocusing) {
      return focusEl.isBlurring(e);
    } else {
      return focusEl.dom !== document.activeElement && e.fromElement === focusEl.dom && e.fromElement !== e.toElement;
    }
  }
  return false;
}, blur:function() {
  var me = this, focusEl;
  if (!me.focusable || !me.canFocus()) {
    return;
  }
  focusEl = me.getFocusEl();
  if (focusEl) {
    me.blurring = true;
    focusEl.blur();
    delete me.blurring;
  }
}, isTabbable:function() {
  var me = this, focusEl;
  if (me.focusable) {
    focusEl = me.getFocusEl();
    if (focusEl && focusEl.isTabbable()) {
      return focusEl.isTabbable();
    }
  }
  return false;
}, disableTabbing:function() {
  var me = this, el = me.el, focusEl;
  if (me.destroying || me.destroyed) {
    return;
  }
  if (el) {
    el.saveTabbableState();
  }
  focusEl = me.getFocusEl();
  if (focusEl) {
    if (focusEl.$isFocusableEntity) {
      focusEl.disableTabbing();
    } else {
      if (focusEl.isElement && el && !el.contains(focusEl)) {
        focusEl.saveTabbableState();
      }
    }
  }
}, enableTabbing:function(reset) {
  var me = this, el = me.el, focusEl;
  if (me.destroying || me.destroyed) {
    return;
  }
  focusEl = me.getFocusEl();
  if (focusEl) {
    if (focusEl.$isFocusableEntity) {
      focusEl.enableTabbing();
    } else {
      if (focusEl.isElement && el && !el.contains(focusEl)) {
        focusEl.restoreTabbableState();
      }
    }
  }
  if (el) {
    el.restoreTabbableState({reset:reset});
  }
}}}, function() {
  var keyboardModeCls = Ext.baseCSSPrefix + 'keyboard-mode', keyboardMode = false;
  Ext.enableKeyboardMode = Ext.isModern || !Ext.os.is.Desktop;
  Ext.setKeyboardMode = Ext.setKeyboardMode || function(keyboardMode) {
    Ext.keyboardMode = keyboardMode;
    Ext.getBody().toggleCls(keyboardModeCls, keyboardMode);
  };
  Ext.isTouchMode = function() {
    return Ext.now() - Ext.lastTouchTime < 500;
  };
  Ext.syncKeyboardMode = function(e) {
    if (!Ext.enableKeyboardMode) {
      return;
    }
    var type = e.type;
    if (type === 'pointermove') {
      keyboardMode = false;
    } else {
      keyboardMode = type === 'keydown';
      Ext.lastTouchTime = e.pointerType === 'touch' && Ext.now();
      Ext.setKeyboardMode(keyboardMode);
    }
  };
  function keyboardModeFocusHandler() {
    if (keyboardMode !== Ext.getBody().hasCls(keyboardModeCls)) {
      Ext.setKeyboardMode(keyboardMode);
    }
  }
  Ext.getEnableKeyboardMode = function() {
    return Ext.enableKeyboardMode;
  };
  Ext.setEnableKeyboardMode = function(enable) {
    var listeners = {pointerdown:Ext.syncKeyboardMode, pointermove:Ext.syncKeyboardMode, keydown:Ext.syncKeyboardMode, capture:true, delegated:false};
    Ext.enableKeyboardMode = !!enable;
    if (Ext.enableKeyboardMode) {
      Ext.getWin().on(listeners);
      Ext.on('focus', keyboardModeFocusHandler);
    } else {
      Ext.getWin().un(listeners);
      Ext.un('focus', keyboardModeFocusHandler);
    }
  };
  Ext.onReady(function() {
    if (!Ext.enableKeyboardMode) {
      Ext.getBody().addCls(keyboardModeCls);
    }
    Ext.setEnableKeyboardMode(Ext.enableKeyboardMode);
  });
});
Ext.define('Ext.mixin.Accessible', {extend:Ext.Mixin, mixinConfig:{id:'accessible'}, config:{ariaAttributes:{$value:null, lazy:true}}, ariaEl:'el', privates:{getAriaLabelEl:function(reference) {
  var ids = [], refHolder, i, len, cmp, result;
  if (reference) {
    if (Ext.isFunction(reference)) {
      return reference.call(this);
    } else {
      if (!Ext.isArray(reference)) {
        reference = [reference];
      }
      refHolder = this.lookupReferenceHolder();
      if (refHolder) {
        for (i = 0, len = reference.length; i < len; i++) {
          cmp = refHolder.lookupReference(reference[i]);
          if (cmp) {
            ids.push(cmp.ariaEl.id);
          }
        }
      }
    }
  }
  return ids.length ? ids.join(' ') : null;
}}});
Ext.define('Ext.Widget', {extend:Ext.Evented, xtype:'widget', alternateClassName:'Ext.Gadget', mixins:[Ext.mixin.Inheritable, Ext.mixin.Bindable, Ext.mixin.ComponentDelegation, Ext.mixin.Pluggable, Ext.mixin.Keyboard, Ext.mixin.Factoryable, Ext.mixin.Focusable, Ext.mixin.Accessible], isWidget:true, factoryConfig:{creator:null, defaultProperty:'xtype', defaultType:'component', typeProperty:'xtype'}, element:{reference:'element'}, observableType:'component', cachedConfig:{cls:null, style:null, border:null, 
touchAction:null, eventHandlers:{focus:'handleFocusEvent', blur:'handleBlurEvent'}}, name:null, config:{renderTo:null, ui:null, userCls:null, ripple:null, hideMode:null, instanceCls:null}, eventedConfig:{width:null, height:null, hidden:null, disabled:null}, template:[], baseCls:null, classCls:null, classClsRoot:true, classClsList:[], clearPropertiesOnDestroy:'async', focusEl:'element', ariaEl:'element', spaceRe:/\s+/, noBorderCls:Ext.baseCSSPrefix + 'noborder-trbl', borderedCls:Ext.baseCSSPrefix + 
'bordered', disabledCls:Ext.baseCSSPrefix + 'disabled', heightedCls:Ext.baseCSSPrefix + 'heighted', widthedCls:Ext.baseCSSPrefix + 'widthed', constructor:function(config) {
  var me = this, baseCls = me.baseCls, renderTo = config && config.renderTo, controller;
  me.$iid = ++Ext.$nextIid;
  if (baseCls == null || baseCls === true) {
    me.baseCls = me.classCls || Ext.baseCSSPrefix + me.xtype;
  }
  if (config && 'baseCls' in config) {
    Ext.raise('baseCls cannot be used as an instance config. It must be specified at class definition time.');
  }
  if (config && config.controller || me.config.controller) {
    me.referenceHolder = true;
  }
  me.initId(config);
  me.initElement();
  if (renderTo) {
    config = Ext.apply({}, config);
    delete config.renderTo;
  }
  me.mixins.observable.constructor.call(me, config);
  if (me.focusable) {
    me.initFocusableEvents(true);
  }
  if (renderTo) {
    me.setRenderTo(renderTo);
  }
  me.syncUiCls();
  Ext.ComponentManager.register(me);
  controller = me.getController();
  if (controller) {
    controller.init(me);
  }
}, afterCachedConfig:function() {
  var me = this, prototype = me.self.prototype, referenceList = me.referenceList, renderElement = me.renderElement, renderTemplate, element, i, ln, reference, elements;
  prototype.renderTemplate = renderTemplate = document.createDocumentFragment();
  renderTemplate.appendChild(renderElement.clone(true, true));
  elements = renderTemplate.querySelectorAll('[id]');
  for (i = 0, ln = elements.length; i < ln; i++) {
    element = elements[i];
    element.removeAttribute('id');
  }
  for (i = 0, ln = referenceList.length; i < ln; i++) {
    reference = referenceList[i];
    me[reference].dom.removeAttribute('reference');
  }
}, applyHidden:function(hidden) {
  return !!hidden;
}, applyDisabled:function(disabled) {
  return !!disabled;
}, updateDisabled:function(disabled) {
  var me = this, container = me.ownerFocusableContainer;
  if (container) {
    if (disabled) {
      if (!container.beforeFocusableChildDisable.$nullFn) {
        container.beforeFocusableChildDisable(me);
      }
    } else {
      if (!container.beforeFocusableChildEnable.$nullFn) {
        container.beforeFocusableChildEnable(me);
      }
    }
  }
  me.element.toggleCls(me.disabledCls, disabled);
  if (me.focusable) {
    if (disabled) {
      me.disableFocusable();
    } else {
      me.enableFocusable();
    }
  }
  if (container) {
    if (disabled) {
      if (!container.onFocusableChildDisable.$nullFn) {
        container.onFocusableChildDisable(me);
      }
    } else {
      if (!container.onFocusableChildEnable.$nullFn) {
        container.onFocusableChildEnable(me);
      }
    }
  }
}, disable:function() {
  this.setDisabled(true);
}, enable:function() {
  this.setDisabled(false);
}, isDisabled:function() {
  return this.getDisabled();
}, isEnabled:function() {
  return !this.getDisabled();
}, applyTouchAction:function(touchAction, oldTouchAction) {
  if (oldTouchAction != null) {
    touchAction = Ext.merge({}, oldTouchAction, touchAction);
  }
  return touchAction;
}, applyWidth:function(width) {
  return this.filterLengthValue(width);
}, applyHeight:function(height) {
  return this.filterLengthValue(height);
}, updateBorder:function(border) {
  var me = this;
  border = border || border === null;
  me.toggleCls(me.noBorderCls, !border);
  me.toggleCls(me.borderedCls, !!border);
}, clearListeners:function() {
  var me = this;
  me.mixins.observable.clearListeners.call(me);
  me.mixins.componentDelegation.clearDelegatedListeners.call(me);
}, destroy:function() {
  var me = this;
  me.isDestroying = me.destroying = true;
  me.doDestroy();
  me.clearListeners();
  me.isDestroying = me.destroying = false;
  me.mixins.componentDelegation.destroyComponentDelegation.call(me);
  me.callParent();
}, doDestroy:function() {
  var me = this, referenceList = me.referenceList, container = me.ownerFocusableContainer, i, ln, reference;
  me.ownerCmp = null;
  if (container && !container.onFocusableChildDestroy.$nullFn) {
    container.onFocusableChildDestroy(me);
  }
  for (i = 0, ln = referenceList.length; i < ln; i++) {
    reference = referenceList[i];
    if (me.hasOwnProperty(reference)) {
      me[reference].destroy();
      me[reference] = null;
    }
  }
  me.destroyBindable();
  Ext.ComponentManager.unregister(me);
}, doFireEvent:function(eventName, args, bubbles) {
  var me = this, ret;
  ret = me.mixins.observable.doFireEvent.call(me, eventName, args, bubbles);
  if (ret !== false && !me.destroyed) {
    ret = me.mixins.componentDelegation.doFireDelegatedEvent.call(me, eventName, args);
  }
  return ret;
}, getBubbleTarget:function() {
  return this.getRefOwner();
}, getElementConfig:function() {
  var me = this, el = me.element;
  if (!('children' in el)) {
    el = Ext.apply({children:me.getTemplate()}, el);
  }
  return el;
}, getSize:function() {
  return this.el.getSize();
}, getTemplate:function() {
  return Ext.clone(this.template);
}, getClassCls:function() {
  var proto = this.self.prototype, prototype = proto, classes, classCls, i, ln;
  while (prototype) {
    classCls = prototype.hasOwnProperty('classCls') ? prototype.classCls : null;
    if (classCls) {
      if (classCls instanceof Array) {
        for (i = 0, ln = classCls.length; i < ln; i++) {
          (classes || (classes = [])).push(classCls[i]);
        }
      } else {
        (classes || (classes = [])).push(classCls);
      }
    }
    if (prototype.classClsRoot && prototype.hasOwnProperty('classClsRoot')) {
      break;
    }
    prototype = prototype.superclass;
  }
  if (classes) {
    proto.classClsList = classes;
  }
  return classes;
}, hide:function() {
  this.setHidden(true);
}, initElement:function() {
  var me = this, prototype = me.self.prototype, id = me.getId(), referenceList = me.referenceList = me.referenceList = [], isFirstInstance = !prototype.hasOwnProperty('renderTemplate'), uiReferences = prototype.hasOwnProperty('uiReferences') ? prototype.uiReferences : prototype.uiReferences = {element:''}, renderTemplate, renderElement, renderConfig, element, referenceNodes, i, ln, referenceNode, reference, classCls, uiCls, baseCls, referenceElement;
  if (isFirstInstance) {
    renderTemplate = document.createDocumentFragment();
    renderConfig = me.processElementConfig.call(prototype);
    renderElement = Ext.Element.create(renderConfig, true);
    renderTemplate.appendChild(renderElement);
    referenceNodes = renderTemplate.querySelectorAll('[uiCls]');
    for (i = 0, ln = referenceNodes.length; i < ln; i++) {
      referenceNode = referenceNodes[i];
      reference = referenceNode.getAttribute('reference');
      uiCls = referenceNode.getAttribute('uiCls');
      if (!reference) {
        Ext.raise('Cannot render element with uiCls\x3d"' + uiCls + '". uiCls is only allowed on elements that have a reference name.');
      }
      uiReferences[reference] = uiCls;
      referenceNode.removeAttribute('uiCls');
    }
  } else {
    renderTemplate = me.renderTemplate.cloneNode(true);
    renderElement = renderTemplate.firstChild;
  }
  referenceNodes = renderTemplate.querySelectorAll('[reference]');
  for (i = 0, ln = referenceNodes.length; i < ln; i++) {
    referenceNode = referenceNodes[i];
    reference = referenceNode.getAttribute('reference');
    if (!isFirstInstance) {
      referenceNode.removeAttribute('reference');
    }
    if (reference === 'element') {
      if (element) {
        Ext.raise("Duplicate 'element' reference detected in '" + me.$className + "' template.");
      }
      referenceNode.id = id;
      element = me.el = me.addElementReference(reference, referenceNode);
      element.dom.setAttribute('data-componentid', id);
      if (isFirstInstance) {
        classCls = me.getClassCls();
        if (classCls) {
          element.addCls(classCls);
        }
        baseCls = me.baseCls;
        if (baseCls && baseCls !== me.classCls) {
          element.addCls(baseCls);
        }
      }
    } else {
      uiCls = uiReferences[reference];
      if (uiCls && isFirstInstance) {
        referenceElement = me.addElementReference(reference, referenceNode);
        me.initUiReference(reference, uiCls, false);
      } else {
        me.addElementReferenceOnDemand(reference, referenceNode);
      }
    }
    if (reference === me.focusEl) {
      me.addElementReference('focusEl', referenceNode);
    }
    if (reference === me.ariaEl) {
      me.addElementReferenceOnDemand('ariaEl', referenceNode);
    }
    referenceList.push(reference);
  }
  if (!element) {
    Ext.raise("No 'element' reference found in '" + me.$className + "' template.");
  }
  if (renderElement === element.dom) {
    me.renderElement = element;
  } else {
    me.addElementReferenceOnDemand('renderElement', renderElement);
  }
  renderElement.setAttribute(me.dataXid, me.$iid);
}, dataXid:'data-' + Ext.baseCSSPrefix.substr(0, Ext.baseCSSPrefix.length - 1) + 'id', is:function(selector) {
  return Ext.ComponentQuery.is(this, selector);
}, isHidden:function(deep) {
  var hidden = !!this.getHidden(), owner;
  if (!hidden && deep) {
    owner = this.getRefOwner();
    while (owner && owner !== deep && !hidden) {
      hidden = !!owner.getHidden();
      owner = owner.getRefOwner();
    }
  }
  return hidden;
}, isVisible:function(deep) {
  return this.rendered && !this.destroyed && !this.isHidden(deep);
}, isXType:function(xtype, shallow) {
  return shallow ? Ext.Array.indexOf(this.xtypes, xtype) !== -1 : !!this.xtypesMap[xtype];
}, lookupTpl:function(name) {
  return Ext.XTemplate.getTpl(this, name);
}, owns:function(element) {
  var result = false, cmp;
  if (element.isEvent) {
    element = element.target;
  } else {
    if (element.isElement) {
      element = element.dom;
    }
  }
  cmp = Ext.Component.from(element);
  if (cmp) {
    result = cmp === this || !!cmp.up(this);
  }
  return result;
}, render:function(container, insertBeforeElement) {
  if (container && container.isWidget) {
    container = container.el;
  }
  var dom = this.renderElement.dom, containerDom = Ext.getDom(container), insertBeforeChildDom;
  if (Ext.isNumber(insertBeforeChildDom)) {
    insertBeforeElement = containerDom.childNodes[insertBeforeElement];
  }
  insertBeforeChildDom = Ext.getDom(insertBeforeElement);
  if (containerDom) {
    if (insertBeforeChildDom) {
      containerDom.insertBefore(dom, insertBeforeChildDom);
    } else {
      containerDom.appendChild(dom);
    }
    this.setRendered(Ext.getBody().contains(dom), true);
  }
}, toggleCls:function(className, state) {
  this.element.toggleCls(className, state);
  return this;
}, resolveListenerScope:function(defaultScope, skipThis) {
  return this.mixins.inheritable.resolveListenerScope.call(this, defaultScope, skipThis);
}, setSize:function(width, height) {
  if (width && typeof width === 'object') {
    return this.setSize(width.width, width.height);
  }
  if (width !== undefined) {
    this.setWidth(width);
  }
  if (height !== undefined) {
    this.setHeight(height);
  }
}, show:function() {
  this.setHidden(false);
}, addCls:function(cls, prefix, suffix) {
  if (!this.destroyed) {
    this.el.replaceCls(null, cls, prefix, suffix);
  }
}, applyCls:function(cls) {
  return cls && Ext.dom.Element.splitCls(cls);
}, applyUi:function(ui) {
  return this.parseUi(ui, true);
}, removeCls:function(cls, prefix, suffix) {
  if (!this.destroyed) {
    this.el.replaceCls(cls, null, prefix, suffix);
  }
}, replaceCls:function(oldCls, newCls, prefix, suffix) {
  if (!this.destroyed) {
    this.el.replaceCls(oldCls, newCls, prefix, suffix);
  }
}, hasCls:function(className) {
  return this.el.hasCls(className);
}, updateCls:function(newCls, oldCls) {
  this.element.replaceCls(oldCls, newCls);
}, updateHidden:function(hidden) {
  var me = this, element = me.renderElement, container = me.ownerFocusableContainer;
  if (container) {
    if (hidden) {
      if (!container.beforeFocusableChildHide.$nullFn) {
        container.beforeFocusableChildHide(me);
      }
    } else {
      if (!container.beforeFocusableChildShow.$nullFn) {
        container.beforeFocusableChildShow(me);
      }
    }
  } else {
    if (hidden) {
      me.revertFocus();
    }
  }
  if (element && !element.destroyed) {
    if (hidden) {
      element.hide();
    } else {
      element.show();
    }
  }
  if (me.focusableContainer && me.activateFocusableContainer) {
    me.activateFocusableContainer(!hidden);
  }
  if (container) {
    if (hidden) {
      if (!container.onFocusableChildHide.$nullFn) {
        container.onFocusableChildHide(me);
      }
    } else {
      if (!container.onFocusableChildShow.$nullFn) {
        container.onFocusableChildShow(me);
      }
    }
  }
}, updateRipple:function(ripple) {
  var me = this, el = me.el;
  if (el) {
    el.un('touchstart', 'onRippleStart', me);
    el.un('touchend', 'onRippleStart', me);
    el.destroyAllRipples();
    if (ripple.release) {
      el.on('touchend', 'onRippleStart', me);
    } else {
      el.on('touchstart', 'onRippleStart', me);
    }
  }
}, shouldRipple:function(e) {
  var me = this, disabled = me.getDisabled && me.getDisabled(), el = me.el, ripple = !disabled && me.getRipple(), target;
  if (ripple && e) {
    target = e.getTarget(me.noRippleSelector);
    if (target) {
      if (el.dom === target || el.contains(target)) {
        ripple = null;
      }
    }
  }
  return ripple;
}, onRippleStart:function(e) {
  var ripple = this.shouldRipple(e);
  if (e.button === 0 && ripple) {
    this.el.ripple(e, ripple);
  }
}, applyStyle:function(style, oldStyle) {
  if (oldStyle && style === oldStyle && Ext.isObject(oldStyle)) {
    style = Ext.apply({}, style);
  }
  this.element.applyStyles(style);
  return null;
}, getStyle:function() {
  Ext.Error.raise("'style' is a write-only config.  To query element styles use the Ext.dom.Element API.");
}, updateRenderTo:function(newContainer) {
  this.render(newContainer);
}, updateTouchAction:function(touchAction) {
  var name, childEl, value, hasRootActions;
  for (name in touchAction) {
    childEl = this[name];
    value = touchAction[name];
    if (childEl && childEl.isElement) {
      childEl.setTouchAction(value);
    } else {
      hasRootActions = true;
    }
  }
  if (hasRootActions) {
    this.el.setTouchAction(touchAction);
  }
}, updateUi:function() {
  if (!this.isConfiguring) {
    this.syncUiCls();
  }
}, updateWidth:function(width) {
  var el = this.el;
  el.setWidth(width);
  el.toggleCls(this.widthedCls, width != null && width !== 'auto');
}, updateHeight:function(height) {
  var el = this.el;
  el.setHeight(height);
  el.toggleCls(this.heightedCls, height != null && height !== 'auto');
}, isWidthed:function() {
  var width = this.getWidth();
  return width != null && width !== 'auto';
}, isHeighted:function() {
  var height = this.getHeight();
  return height != null && height !== 'auto';
}, up:function(selector, limit) {
  var result = this.getRefOwner(), limitSelector = typeof limit === 'string', limitCount = typeof limit === 'number', limitComponent = limit && limit.isComponent, steps = 0;
  if (selector) {
    for (; result; result = result.getRefOwner()) {
      if (result.destroyed) {
        return null;
      }
      steps++;
      if (selector.isComponent || selector.isWidget) {
        if (result === selector) {
          return result;
        }
      } else {
        if (Ext.ComponentQuery.is(result, selector)) {
          return result;
        }
      }
      if (limitSelector && result.is(limit)) {
        return;
      }
      if (limitCount && steps === limit) {
        return;
      }
      if (limitComponent && result === limit) {
        return;
      }
    }
  }
  return result;
}, updateLayout:Ext.emptyFn, updateInstanceCls:function(instanceCls, oldInstanceCls) {
  var me = this, el = me.el, classClsList = me.classClsList, Array = Ext.Array, uiReferences = me.uiReferences, referenceName, referenceElement, i, ln, cls, uiCls;
  if (oldInstanceCls) {
    el.removeCls(oldInstanceCls);
    oldInstanceCls = Array.from(oldInstanceCls);
    for (i = 0, ln = oldInstanceCls.length; i < ln; i++) {
      cls = oldInstanceCls[i];
      Array.remove(classClsList, cls);
      for (referenceName in uiReferences) {
        referenceElement = me[referenceName];
        uiCls = uiReferences[referenceName];
        referenceElement.removeCls(cls + '-' + uiCls);
      }
    }
  }
  if (instanceCls) {
    el.addCls(instanceCls);
    instanceCls = Array.from(instanceCls);
    me.classClsList = classClsList.concat(instanceCls);
    for (i = 0, ln = instanceCls.length; i < ln; i++) {
      cls = instanceCls[i];
      for (referenceName in uiReferences) {
        referenceElement = me[referenceName];
        uiCls = uiReferences[referenceName];
        referenceElement.addCls(cls + '-' + uiCls);
      }
    }
  }
  if (!me.isConfiguring) {
    me.syncUiCls();
  }
}, getBaseCls:function() {
  return this.baseCls;
}, setBaseCls:function() {
  Ext.raise('baseCls cannot be reconfigured. It must be specified at class definition time.');
}, onClassExtended:function(Class, members) {
  if (members.config && members.config.baseCls) {
    Ext.raise('baseCls must be declared directly on the class body. Please move it outside of the config block.');
  }
}, privates:{_hideModes:{clip:'CLIP', display:'DISPLAY', offsets:'OFFSETS', opacity:'OPACITY', visibility:'VISIBILITY'}, noRippleSelector:'.' + Ext.baseCSSPrefix + 'no-ripple', addElementReferenceOnDemand:function(name, domNode) {
  if (this._elementListeners[name]) {
    this.addElementReference(name, domNode);
  } else {
    Ext.Object.defineProperty(this, name, {get:function() {
      if (this.destroyed) {
        return;
      }
      delete this[name];
      return this.addElementReference(name, domNode);
    }, configurable:true});
  }
}, addElementReference:function(name, domNode) {
  var me = this, referenceEl = me[name] = Ext.get(domNode), listeners = me._elementListeners[name], eventName, listener;
  referenceEl.skipGarbageCollection = true;
  referenceEl.component = me;
  if (listeners) {
    listeners = Ext.clone(listeners);
    for (eventName in listeners) {
      listener = listeners[eventName];
      if (typeof listener === 'object') {
        listener.scope = me;
      }
    }
    listeners.scope = me;
    referenceEl.on(listeners);
  }
  return referenceEl;
}, detachFromBody:function() {
  Ext.getDetachedBody().appendChild(this.element, true);
  this.isDetached = true;
}, reattachToBody:function() {
  var detachedBody;
  if (this.isDetached) {
    detachedBody = Ext.getDetachedBody();
    if (detachedBody.contains(this.element)) {
      Ext.getBody().appendChild(this.element, true);
    }
  }
  this.isDetached = false;
}, doAddListener:function(name, fn, scope, options, order, caller, manager) {
  var me = this, elementName = options && options.element, delegate = options && options.delegate, listeners, eventOptions, option;
  if (elementName) {
    if (Ext.Array.indexOf(me.referenceList, elementName) === -1) {
      Ext.Logger.error("Adding event listener with an invalid element reference of '" + elementName + "' for this component. Available values are: '" + me.referenceList.join("', '") + "'", me);
    }
    listeners = {};
    listeners[name] = fn;
    if (scope) {
      listeners.scope = scope;
    }
    eventOptions = Ext.Element.prototype.$eventOptions;
    for (option in options) {
      if (eventOptions[option]) {
        listeners[option] = options[option];
      }
    }
    me.mon(me[elementName], listeners);
    return;
  } else {
    if (delegate) {
      me.mixins.componentDelegation.addDelegatedListener.call(me, name, fn, scope, options, order, caller, manager);
      return;
    }
  }
  me.callParent([name, fn, scope, options, order, caller, manager]);
}, doRemoveListener:function(eventName, fn, scope) {
  var me = this;
  me.mixins.observable.doRemoveListener.call(me, eventName, fn, scope);
  me.mixins.componentDelegation.removeDelegatedListener.call(me, eventName, fn, scope);
}, filterLengthValue:function(value) {
  if (!value && value !== 0) {
    return null;
  }
  return value;
}, initElementListeners:function(elementConfig) {
  var prototype = this, superPrototype = prototype.self.superclass, superElementListeners = superPrototype._elementListeners, reference = elementConfig.reference, children = elementConfig.children, elementListeners, listeners, superListeners, ln, i;
  if (prototype.hasOwnProperty('_elementListeners')) {
    elementListeners = prototype._elementListeners;
  } else {
    elementListeners = prototype._elementListeners = superElementListeners ? Ext.Object.chain(superElementListeners) : {};
  }
  if (reference) {
    listeners = elementConfig.listeners;
    if (listeners) {
      if (superElementListeners) {
        superListeners = superElementListeners[reference];
        if (superListeners) {
          listeners = Ext.Object.chain(superListeners);
          Ext.apply(listeners, elementConfig.listeners);
        }
      }
      elementListeners[reference] = listeners;
      elementConfig.listeners = null;
    }
  }
  if (children) {
    for (i = 0, ln = children.length; i < ln; i++) {
      prototype.initElementListeners(children[i]);
    }
  }
}, initId:function(config) {
  var me = this, defaultConfig = me.config, id = config && config.id || defaultConfig && defaultConfig.id;
  if (id) {
    me.setId(id);
    me.id = id;
  } else {
    me.getId();
  }
}, measure:function(dimension) {
  return this.element.measure(dimension);
}, processElementConfig:function() {
  var prototype = this, superPrototype = prototype.self.superclass, elementConfig;
  if (prototype.hasOwnProperty('_elementConfig')) {
    elementConfig = prototype._elementConfig;
  } else {
    elementConfig = prototype._elementConfig = prototype.getElementConfig();
    if (superPrototype.isWidget) {
      prototype.processElementConfig.call(superPrototype);
    }
    prototype.initElementListeners(elementConfig);
  }
  return elementConfig;
}, parseUi:function(ui, asString) {
  ui = Ext.String.splitWords(ui);
  if (asString) {
    ui = ui.join(' ');
  }
  return ui;
}, addUi:function(ui) {
  this.setUi(this.doAddUi(ui, this.getUi()));
}, doAddUi:function(ui, oldUi) {
  var me = this, newUi = null, i, u, len;
  if (ui) {
    ui = me.parseUi(ui);
    len = ui.length;
    oldUi = me.parseUi(oldUi);
    for (i = 0; i < len; i++) {
      u = ui[i];
      if (Ext.Array.indexOf(oldUi, u) === -1) {
        oldUi.push(u);
      }
    }
    newUi = oldUi.join(' ');
  }
  return newUi;
}, removeUi:function(ui) {
  this.setUi(this.doRemoveUi(ui, this.getUi()));
}, doRemoveUi:function(ui, oldUi) {
  var me = this, newUi = null, i, u, index, len;
  if (ui) {
    ui = me.parseUi(ui);
    len = ui.length;
    oldUi = me.parseUi(oldUi);
    for (i = 0; i < len; i++) {
      u = ui[i];
      index = Ext.Array.indexOf(oldUi, u);
      if (index !== -1) {
        oldUi.splice(index, 1);
      }
    }
    newUi = oldUi.join(' ');
  }
  return newUi;
}, initUiReference:function(referenceName, uiCls, isInstance) {
  var me = this, referenceElement = me[referenceName], baseCls = me.baseCls, classClsList = me.classClsList, cls = [], i, n;
  isInstance = isInstance !== false;
  if (isInstance) {
    if (!me.hasOwnProperty('uiReferences')) {
      me.uiReferences = Ext.clone(me.uiReferences);
    }
    me.uiReferences[referenceName] = uiCls;
  }
  uiCls = '-' + uiCls;
  if (baseCls && baseCls !== me.classCls) {
    cls.push(baseCls + uiCls);
  }
  if (classClsList) {
    for (i = 0, n = classClsList.length; i < n; i++) {
      cls.push(classClsList[i] + uiCls);
    }
  }
  referenceElement.addCls(cls);
  if (isInstance && !me.isConfiguring) {
    me.syncUiCls();
  }
}, syncUiCls:function(refs) {
  var me = this, ui = me.getUi(), currentUiCls = me.currentUiCls || (me.currentUiCls = {}), baseCls = me.baseCls, uiReferences = refs || me.uiReferences, classClsList = me.classClsList, classClsListLen = classClsList ? classClsList.length : 0, uiCls, uiLen, refName, refEl, cls, suffix, uiSuffix, i, j;
  if (ui) {
    ui = me.parseUi(ui);
    uiLen = ui.length;
  }
  for (refName in uiReferences) {
    refEl = me[refName];
    uiCls = [];
    if (refEl) {
      cls = currentUiCls[refName];
      if (cls) {
        refEl.removeCls(cls);
      }
      if (ui) {
        suffix = uiReferences[refName];
        suffix = suffix ? '-' + suffix : '';
        for (i = 0; i < uiLen; i++) {
          uiSuffix = '-' + ui[i] + suffix;
          if (baseCls && baseCls !== me.classCls) {
            uiCls.push(baseCls + uiSuffix);
          }
          if (classClsList) {
            for (j = 0; j < classClsListLen; j++) {
              uiCls.push(classClsList[j] + uiSuffix);
            }
          }
        }
        refEl.addCls(uiCls);
        currentUiCls[refName] = uiCls;
      }
    }
  }
}, applyHideMode:function(mode) {
  return mode || 'display';
}, updateHideMode:function(mode) {
  var me = this, el = me.el, shouldToggle = me.getHidden();
  if (!me._hideModes[mode]) {
    Ext.raise('Invalid hideMode: "' + mode + '" (must be one of: "' + Object.keys(me._hideModes).join('", "') + '")');
  }
  if (shouldToggle) {
    el.show();
  }
  me.renderElement.setVisibilityMode(Ext.Element[me._hideModes[mode]]);
  if (shouldToggle) {
    el.hide();
  }
}, updateUserCls:function(newCls, oldCls) {
  this.element.replaceCls(oldCls, newCls);
}}}, function(Widget) {
  var prototype = Widget.prototype;
  (prototype.$elementEventOptions = Ext.Object.chain(Ext.Element.prototype.$eventOptions)).element = 1;
  (prototype.$eventOptions = Ext.Object.chain(prototype.$eventOptions)).delegate = 1;
  Ext.updateWidget = Ext.Factory.widget.update;
});
Ext.define('Ext.mixin.Traversable', {extend:Ext.Mixin, mixinConfig:{id:'traversable'}, setParent:function(parent) {
  this.parent = parent;
  return this;
}, hasParent:function() {
  return Boolean(this.getParent());
}, is:function() {
  return true;
}, getParent:function() {
  return this.parent || this.$initParent;
}, getAncestors:function() {
  var ancestors = [], parent = this.getParent();
  while (parent) {
    ancestors.push(parent);
    parent = parent.getParent();
  }
  return ancestors;
}, getAncestorIds:function() {
  var ancestorIds = [], parent = this.getParent();
  while (parent) {
    ancestorIds.push(parent.getId());
    parent = parent.getParent();
  }
  return ancestorIds;
}, previousNode:function(selector, includeSelf) {
  var node = this, parent = node.getRefOwner(), result, it, i, sibling;
  if (includeSelf && node.is(selector)) {
    return node;
  }
  if (parent) {
    for (it = parent.items.items, i = Ext.Array.indexOf(it, node) - 1; i > -1; i--) {
      sibling = it[i];
      if (sibling.query) {
        result = sibling.query(selector);
        result = result[result.length - 1];
        if (result) {
          return result;
        }
      }
      if (!selector || sibling.is(selector)) {
        return sibling;
      }
    }
    return parent.previousNode(selector, true);
  }
  return null;
}, previousSibling:function(selector) {
  var parent = this.getRefOwner(), it, idx, sibling;
  if (parent) {
    it = parent.items;
    idx = it.indexOf(this);
    if (idx !== -1) {
      if (selector) {
        for (--idx; idx >= 0; idx--) {
          if ((sibling = it.getAt(idx)).is(selector)) {
            return sibling;
          }
        }
      } else {
        if (idx) {
          return it.getAt(--idx);
        }
      }
    }
  }
  return null;
}, nextNode:function(selector, includeSelf) {
  var node = this, parent = node.getRefOwner(), result, it, len, i, sibling;
  if (includeSelf && node.is(selector)) {
    return node;
  }
  if (parent) {
    for (it = parent.items.items, i = Ext.Array.indexOf(it, node) + 1, len = it.length; i < len; i++) {
      sibling = it[i];
      if (!selector || sibling.is(selector)) {
        return sibling;
      }
      if (sibling.down) {
        result = sibling.down(selector);
        if (result) {
          return result;
        }
      }
    }
    return parent.nextNode(selector);
  }
  return null;
}, nextSibling:function(selector) {
  var parent = this.getRefOwner(), it, last, idx, sibling;
  if (parent) {
    it = parent.items;
    idx = it.indexOf(this) + 1;
    if (idx) {
      if (selector) {
        for (last = it.getCount(); idx < last; idx++) {
          if ((sibling = it.getAt(idx)).is(selector)) {
            return sibling;
          }
        }
      } else {
        if (idx < it.getCount()) {
          return it.getAt(idx);
        }
      }
    }
  }
  return null;
}});
Ext.define('Ext.fx.easing.Abstract', {config:{startTime:0, startValue:0}, isEasing:true, isEnded:false, constructor:function(config) {
  this.initConfig(config);
  return this;
}, applyStartTime:function(startTime) {
  if (!startTime) {
    startTime = Ext.Date.now();
  }
  return startTime;
}, updateStartTime:function(startTime) {
  this.reset();
}, reset:function() {
  this.isEnded = false;
}, getValue:Ext.emptyFn});
Ext.define('Ext.fx.easing.Linear', {extend:Ext.fx.easing.Abstract, alias:'easing.linear', config:{duration:0, endValue:0}, updateStartValue:function(startValue) {
  this.distance = this.getEndValue() - startValue;
}, updateEndValue:function(endValue) {
  this.distance = endValue - this.getStartValue();
}, getValue:function() {
  var deltaTime = Ext.Date.now() - this.getStartTime(), duration = this.getDuration();
  if (deltaTime > duration) {
    this.isEnded = true;
    return this.getEndValue();
  } else {
    return this.getStartValue() + deltaTime / duration * this.distance;
  }
}});
Ext.define('Ext.util.translatable.Abstract', {extend:Ext.Evented, mixins:[Ext.mixin.Factoryable], factoryConfig:{type:'translatable', defaultType:'csstransform'}, config:{easing:null, easingX:{duration:300}, easingY:{duration:300}}, x:0, y:0, activeEasingX:null, activeEasingY:null, isAnimating:false, isTranslatable:true, constructor:function(config) {
  this.callParent([config]);
  this.position = {x:0, y:0};
}, factoryEasing:function(easing) {
  return Ext.factory(easing, Ext.fx.easing.Linear, null, 'easing');
}, applyEasing:function(easing) {
  if (!this.getEasingX()) {
    this.setEasingX(this.factoryEasing(easing));
  }
  if (!this.getEasingY()) {
    this.setEasingY(this.factoryEasing(easing));
  }
}, applyEasingX:function(easing) {
  return this.factoryEasing(easing);
}, applyEasingY:function(easing) {
  return this.factoryEasing(easing);
}, doTranslate:function(x, y) {
  if (this.hasListeners.translate) {
    this.fireEvent('translate', this, x, y);
  }
}, translate:function(x, y, animation) {
  if (animation) {
    return this.translateAnimated(x, y, animation);
  }
  if (this.isAnimating) {
    this.stopAnimation();
  }
  if (!isNaN(x) && typeof x === 'number') {
    this.x = x;
  }
  if (!isNaN(y) && typeof y === 'number') {
    this.y = y;
  }
  this.doTranslate(x, y);
}, translateAxis:function(axis, value, animation) {
  var x, y;
  if (axis === 'x') {
    x = value;
  } else {
    y = value;
  }
  return this.translate(x, y, animation);
}, getPosition:function() {
  var me = this, position = me.position;
  position.x = -me.x;
  position.y = -me.y;
  return position;
}, animate:function(easingX, easingY) {
  var me = this;
  me.activeEasingX = easingX;
  me.activeEasingY = easingY;
  me.isAnimating = true;
  if (me.ownerCmp) {
    me.ownerCmp.isTranslating = true;
  }
  me.lastX = null;
  me.lastY = null;
  Ext.AnimationQueue.start(me.doAnimationFrame, me);
  me.fireEvent('animationstart', me, me.x, me.y);
  return me;
}, translateAnimated:function(x, y, animation) {
  var me = this, now, easing, easingX, easingY;
  if (!Ext.isObject(animation)) {
    animation = {};
  }
  if (me.isAnimating) {
    me.stopAnimation();
  }
  me.callback = animation.callback;
  me.callbackScope = animation.scope;
  now = Ext.Date.now();
  easing = animation.easing;
  easingX = typeof x === 'number' ? animation.easingX || easing || me.getEasingX() || true : null;
  easingY = typeof y === 'number' ? animation.easingY || easing || me.getEasingY() || true : null;
  if (easingX) {
    easingX = me.factoryEasing(easingX);
    easingX.setStartTime(now);
    easingX.setStartValue(me.x);
    easingX.setEndValue(x);
    if ('duration' in animation) {
      easingX.setDuration(animation.duration);
    }
  }
  if (easingY) {
    easingY = me.factoryEasing(easingY);
    easingY.setStartTime(now);
    easingY.setStartValue(me.y);
    easingY.setEndValue(y);
    if ('duration' in animation) {
      easingY.setDuration(animation.duration);
    }
  }
  return me.animate(easingX, easingY);
}, doAnimationFrame:function() {
  var me = this, easingX = me.activeEasingX, easingY = me.activeEasingY, now = Date.now(), x, y;
  if (!me.isAnimating) {
    return;
  }
  me.lastRun = now;
  if (easingX === null && easingY === null) {
    me.stopAnimation();
    return;
  }
  if (easingX !== null) {
    me.x = x = Math.round(easingX.getValue());
    if (easingX.isEnded) {
      me.activeEasingX = null;
      me.fireEvent('axisanimationend', me, 'x', x);
    }
  } else {
    x = me.x;
  }
  if (easingY !== null) {
    me.y = y = Math.round(easingY.getValue());
    if (easingY.isEnded) {
      me.activeEasingY = null;
      me.fireEvent('axisanimationend', me, 'y', y);
    }
  } else {
    y = me.y;
  }
  if (me.lastX !== x || me.lastY !== y) {
    me.doTranslate(x, y);
    me.lastX = x;
    me.lastY = y;
  }
  me.fireEvent('animationframe', me, x, y);
}, stopAnimation:function() {
  var me = this;
  if (!me.isAnimating) {
    return;
  }
  me.activeEasingX = null;
  me.activeEasingY = null;
  me.isAnimating = false;
  if (me.ownerCmp) {
    me.ownerCmp.isTranslating = false;
  }
  Ext.AnimationQueue.stop(me.doAnimationFrame, me);
  me.fireEvent('animationend', me, me.x, me.y);
  if (me.callback) {
    me.callback.call(me.callbackScope);
    me.callback = null;
  }
}, refresh:function() {
  this.translate(this.x, this.y);
}, resolveListenerScope:function() {
  var ownerCmp = this.ownerCmp, a = arguments;
  if (ownerCmp) {
    return ownerCmp.resolveListenerScope.apply(ownerCmp, a);
  }
  return this.callParent(a);
}, destroy:function() {
  var me = this;
  me.destroying = true;
  if (me.isAnimating) {
    me.stopAnimation();
  }
  me.callParent();
  me.destroying = false;
  me.destroyed = true;
}});
Ext.define('Ext.overrides.Widget', {override:'Ext.Widget', mixins:[Ext.mixin.Traversable], statics:{floatInset:8, onModalMaskTap:function(e) {
  var top = this.topModal;
  if (top && top.onModalMaskTap && top.onModalMaskTap(e)) {
    this.topModal = null;
  }
}, range:document.createRange()}, config:{flex:{evented:true, $value:null}, itemId:undefined, floated:null, relative:null, x:null, y:null, shadow:null, shim:null, alwaysOnTop:null, toFrontOnShow:true, translatable:{lazy:true, $value:null}, constrainAlign:null, alignSelf:null}, inheritUi:false, floatedCls:Ext.baseCSSPrefix + 'floated', floatedSelector:'.' + Ext.baseCSSPrefix + 'floated', shadowCls:Ext.baseCSSPrefix + 'shadow', noShadowCls:Ext.baseCSSPrefix + 'no-shadow', floatWrapCls:Ext.baseCSSPrefix + 
'float-wrap', shimCls:Ext.baseCSSPrefix + 'shim', rootCls:Ext.baseCSSPrefix + 'root', isInner:true, clearPropertiesOnDestroy:'async', beforeHide:Ext.emptyFn, afterHide:function() {
  var me = this, parent = me.getParent();
  if (parent && parent.afterItemHide) {
    parent.afterItemHide(me);
  }
  if (me.getFloated()) {
    me.syncShim();
  }
}, beforeShow:Ext.emptyFn, afterShow:function() {
  var me = this, parent = me.getParent();
  if (parent && parent.afterItemShow) {
    parent.afterItemShow(me);
  }
}, applyItemId:function(itemId) {
  return itemId || this.getId();
}, doDestroy:function() {
  var me = this, parent = me.getParent(), fw = me.floatWrap;
  if (parent && parent.remove) {
    parent.remove(me, false);
  }
  me.setShim(false);
  Ext.destroy(me.getTranslatable());
  if (fw) {
    me.un('resize', 'syncFloatWrap', me);
    fw.destroy();
    me.floatWrap = null;
  }
  me.removeBindings();
  me.callParent();
}, isInnerItem:function() {
  return this.isInner;
}, isCentered:function() {
  return false;
}, isDocked:function() {
  return Boolean(this.getDocked());
}, isPositioned:function() {
  return false;
}, getDocked:function() {
  return this._docked;
}, isHidden:function(deep) {
  var me = this, hidden;
  if (me.isConfiguring) {
    hidden = me.getConfig('hidden', true);
    if (me.getConfig('floated', true)) {
      return hidden !== false;
    } else {
      return !!hidden;
    }
  } else {
    return this.callParent([deep]);
  }
  return me.callParent([deep]);
}, onAdded:function(parent, instanced) {
  var me = this, currentParent = me.parent;
  if (currentParent && currentParent !== parent) {
    currentParent.remove(me, false);
  }
  me.parent = parent;
  me.onInheritedAdd(parent, instanced);
  me.isDetached = false;
  if (me.getFloated()) {
    me.findFloatParent();
  }
  if (me.inheritUi) {
    me.doInheritUi();
  }
}, onRemoved:function(destroying) {
  var me = this;
  if (me.inheritUi && !destroying) {
    me.doUninheritUi();
  }
  me.onInheritedRemove(destroying);
  me.parent = null;
}, setIsInner:function(isInner) {
  var parent;
  if (isInner !== this.isInner) {
    this.isInner = isInner;
    parent = this.initialized && this.getParent();
    if (parent) {
      parent.onItemInnerStateChange(this, isInner);
    }
  }
}, refreshInnerState:function() {
  this.setIsInner(!this.getFloated() && !this.isCentered() && !this.isPositioned() && !this.isDocked());
}, toFront:function(fromMousedown) {
  if (!this.getFloated()) {
    Ext.raise('Cannot use toFront on a non-floated component');
  }
  var me = this, floatParent = me.getFloatParent();
  if (!me.hasListeners.beforetofront || me.fireEvent('beforetofront', me) !== false) {
    me.syncAlwaysOnTop(fromMousedown);
    if (floatParent && floatParent.getFloated()) {
      floatParent.toFront(fromMousedown);
    }
    if (me.hasListeners.tofront) {
      me.fireEvent('tofront', me);
    }
  }
  return me;
}, applyTranslatable:function(config, translatable) {
  return Ext.Factory.translatable.update(translatable, config, this, 'createTranslatable');
}, createTranslatable:function(config) {
  var me = this, listeners = config.listeners;
  config = Ext.apply({type:'cssposition', ownerCmp:me, element:me.renderElement}, config);
  if (listeners && listeners.scope === 'this') {
    config.listeners = listeners = Ext.apply({}, listeners);
    listeners.scope = me;
  }
  return config;
}, ensureTranslatable:function() {
  var me = this, translatable = me.getTranslatable();
  if (!translatable) {
    me.setTranslatable(true);
    translatable = me.getTranslatable();
  }
  return translatable;
}, translate:function() {
  var translatable = this.ensureTranslatable();
  translatable.translate.apply(translatable, arguments);
}, getAlignmentInfo:function(component, alignment) {
  var me = this, alignToBox = component.isRegion ? component : (component.isWidget ? component.renderElement : Ext.fly(component)).getBox(), element = me.renderElement, box = element.getBox(), stats = {alignToBox:alignToBox, alignment:alignment, top:alignToBox.top, left:alignToBox.left, alignToWidth:alignToBox.width || 0, alignToHeight:alignToBox.height || 0, width:box.width, height:box.height, anchor:!!(me.getAnchor && me.getAnchor())}, currentAlignmentInfo = me.getCurrentAlignmentInfo(), isAligned = 
  true;
  if (!Ext.isEmpty(currentAlignmentInfo)) {
    Ext.Object.each(stats, function(key, value) {
      if (!Ext.isObject(value) && currentAlignmentInfo[key] !== value) {
        isAligned = false;
        return false;
      }
      return true;
    });
  } else {
    isAligned = false;
  }
  return {isAligned:isAligned, stats:stats};
}, getCurrentAlignmentInfo:function() {
  return this.$currentAlignmentInfo;
}, setCurrentAlignmentInfo:function(alignmentInfo) {
  this.$currentAlignmentInfo = Ext.isEmpty(alignmentInfo) ? null : Ext.merge({}, alignmentInfo.stats ? alignmentInfo.stats : alignmentInfo);
}, alignTo:function(component, alignment, options) {
  var me = this, alignmentInfo = me.getAlignmentInfo(component, alignment), config = me.initialConfig, positioned = !me.getFloated(), setX = positioned ? me.setLeft : me.setX, setY = positioned ? me.setTop : me.setY, oldHeight, resultRegion;
  if (alignmentInfo.isAligned) {
    return;
  }
  if ('unconstrainedWidth' in me) {
    me.setWidth(me.unconstrainedWidth);
  }
  if ('unconstrainedHeight' in me) {
    me.setHeight(me.unconstrainedHeight);
  }
  resultRegion = me.getAlignRegion(component, alignment, options);
  setX.call(me, resultRegion.x);
  setY.call(me, resultRegion.y);
  if (resultRegion.constrainWidth) {
    me.unconstrainedWidth = config.width || me.self.prototype.width;
    oldHeight = me.el.getHeight();
    me.setWidth(alignmentInfo.stats.width = resultRegion.getWidth());
    if (resultRegion.align.position === 0) {
      setY.call(me, resultRegion.y + (oldHeight - me.el.getHeight()));
    }
  }
  if (resultRegion.constrainHeight) {
    me.unconstrainedHeight = config.height || me.self.prototype.height;
    me.setHeight(alignmentInfo.stats.height = resultRegion.getHeight());
  }
  me.alignToArgs = [component, alignment, options];
  me.setCurrentAlignmentInfo(alignmentInfo);
}, realign:function(component, alignment, options) {
  var args = this.alignToArgs;
  if (this.isVisible()) {
    this.alignTo.call(this, component || args[0], alignment || args[1], options || args[2]);
  }
}, getAlignRegion:function(component, alignment, options) {
  var me = this, alignmentInfo = me.getAlignmentInfo(component, alignment), constrainModifier, inside;
  if (alignmentInfo.isAligned) {
    return;
  }
  var alignToBox = alignmentInfo.stats.alignToBox, constrainBox = me.getConstrainAlignRegion(), height = alignmentInfo.stats.height, width = alignmentInfo.stats.width;
  if (constrainBox && (!alignment || alignment === 'auto')) {
    if (constrainBox.bottom - alignToBox.bottom < height) {
      if (alignToBox.top - constrainBox.top < height) {
        if (alignToBox.left - constrainBox.left < width) {
          alignment = 'l-r?';
        } else {
          alignment = 'r-l?';
        }
      } else {
        alignment = 'b-t?';
      }
    } else {
      alignment = 't-b?';
    }
  }
  constrainModifier = alignment[alignment.length - 1];
  if (constrainModifier === '!') {
    inside = component.isRegion ? component : (component.isWidget ? component.renderElement : Ext.fly(component)).getBox();
    alignment = alignment.substr(0, alignment.length - 1);
  } else {
    inside = constrainBox;
    if (constrainModifier === '?') {
      alignment = alignment.substr(0, alignment.length - 1);
    }
  }
  return me.el.getRegion().alignTo(Ext.apply({target:Ext.util.Region.from(alignmentInfo.stats.alignToBox), align:alignment, inside:inside, minWidth:me.getMinWidth && me.getMinWidth(), minHeight:me.getMinHeight && me.getMinHeight()}, options));
}, render:function(container, insertBeforeElement) {
  if (this.getFloated()) {
    Ext.raise('floated: true components cannot be rendered. They render themselves on first show');
    return;
  }
  this.callParent([container, insertBeforeElement]);
}, afterRender:Ext.emptyFn, onRender:Ext.emptyFn, applyFloated:function(floated) {
  return Boolean(floated);
}, updateFloated:function(floated, oldFloated) {
  var me = this, fw = me.floatWrap, modal, sibling;
  if (floated) {
    me.refreshInnerState = Ext.emptyFn;
    if (me.isPositioned()) {
      me.resetPositioned();
    }
    if (me.isDocked()) {
      me.setDocked(false);
    }
    delete me.refreshInnerState;
  } else {
    if (fw) {
      fw.dom.removeChild(me.el.dom);
      me.un('resize', 'syncFloatWrap', me);
      fw.destroy();
      me.floatWrap = null;
      me.setRendered(false);
    }
  }
  me.refreshInnerState();
  me.el.toggleCls(me.floatedCls, floated);
  if (me.hasOwnProperty('_modal')) {
    modal = me.getModal && me.getModal();
    if (modal) {
      me.setModal(false);
      if (floated) {
        Ext.destroy(modal);
        if (me.isVisible()) {
          me.showModalMask();
        }
      } else {
        sibling = me.getModalSibling();
        if (sibling) {
          sibling.showModalMask();
        } else {
          me.hideModalMask();
        }
      }
      me.setModal(true);
    }
    if (me.getHideOnMaskTap && me.getHideOnMaskTap()) {
      me.setHideOnMaskTap(false);
      me.setHideOnMaskTap(true);
    }
  }
  me.syncFloatedState(floated, oldFloated, me.rendered && oldFloated === false);
}, applyUi:function(ui) {
  var me = this, inheritedUi = me._inheritedUi;
  ui = me.callParent([ui]);
  if (inheritedUi) {
    ui = me.doAddUi(inheritedUi, ui);
  }
  return ui;
}, updateUi:function(ui, oldUi) {
  var me = this, item, refItems, i, n;
  me.callParent([ui, oldUi]);
  if (me.$inheritUiCount) {
    refItems = me.getRefItems();
    for (i = 0, n = refItems.length; i < n; i++) {
      item = refItems[i];
      if (item.inheritUi) {
        item.doUninheritUi();
        item.doInheritUi();
      }
    }
  }
}, updateHidden:function(hidden, oldHidden) {
  var globals = Ext.GlobalEvents, event = hidden ? 'hide' : 'show';
  this.callParent([hidden, oldHidden]);
  if (!this.isConfiguring && globals.hasListeners[event]) {
    globals.fireEvent(event, this);
  }
}, updateAlignSelf:function(align) {
  this.el.setStyle({'align-self':align});
}, privates:{setRendered:function(rendered, root) {
  var me = this, afterRenderQueue, item, items, ln, i;
  if (!rendered && me.rendered && me.getFloated()) {
    me.floatWrap.dom.parentNode.removeChild(me.floatWrap.dom);
  }
  me.rendered = rendered;
  if (!me.destroying && !me.destroyed) {
    if (rendered && me.onRender) {
      me.initBindable();
      me.initKeyMap();
      if (!me.onRender.$nullFn) {
        me.onRender();
      }
      me.onRender = null;
      if (!me.afterRender.$nullFn) {
        (Ext._afterRenderQueue || (Ext._afterRenderQueue = [])).push(me);
      }
    }
    items = me.getRefItems && me.getRefItems();
    ln = items && items.length;
    for (i = 0; i < ln; i++) {
      item = items[i];
      if (item.setRendered) {
        me.setChildRendered(rendered, item);
      }
    }
    if (me.focusableContainer && me.initFocusableContainer) {
      me.initFocusableContainer();
    }
    if (root) {
      afterRenderQueue = Ext._afterRenderQueue;
      if (afterRenderQueue) {
        while (afterRenderQueue.length) {
          item = afterRenderQueue.pop();
          if (!item.destroyed) {
            item.afterRender();
          }
        }
      }
    }
  }
}, setChildRendered:function(rendered, item) {
  if (!rendered || !item.getFloated()) {
    item.setRendered(rendered);
  }
}, hideFromModal:function() {
  this.hide();
}, owns:function(element) {
  var result = false, cmp;
  if (element.isEvent) {
    element = element.target;
  } else {
    if (element.isElement) {
      element = element.dom;
    }
  }
  cmp = Ext.Component.from(element);
  if (cmp) {
    result = cmp === this || !!cmp.up(this);
  }
  return result;
}, doInheritUi:function() {
  var me = this, owner, ownerUi;
  if (me.inheritUi) {
    me._ownUi = me.getUi();
    owner = me.getRefOwner();
    ownerUi = owner.getUi();
    if (ownerUi) {
      me.addUi(ownerUi);
      me._inheritedUi = ownerUi;
    }
    owner.$inheritUiCount = (owner.$inheritUiCount || 0) + 1;
  }
}, doUninheritUi:function() {
  var me = this, inheritUi = me.inheritUi, ownUi, owner;
  if (inheritUi) {
    owner = me.getRefOwner();
    ownUi = me._ownUi;
    me._ownUi = null;
    me._inheritedUi = null;
    me.setUi(ownUi || null);
    if (owner.$inheritUiCount) {
      --owner.$inheritUiCount;
    }
  }
}, getBubbleTarget:function() {
  return this.getParent();
}, getConstrainAlignRegion:function() {
  var me = this, isFloated = me.getFloated(), constrainAlign = me.getConstrainAlign(), parent, isViewport, docInsets;
  if (constrainAlign !== false) {
    if (typeof constrainAlign === 'string') {
      constrainAlign = parent = me.up(constrainAlign);
    }
    if (!constrainAlign) {
      parent = isFloated ? me.floatParentNode.getData().component : me.getParent();
    }
    if (parent) {
      if (parent.getFloated() && !parent.getRelative()) {
        constrainAlign = Ext.getBody();
        isViewport = true;
      } else {
        constrainAlign = parent.getRenderTarget ? parent.getRenderTarget() : parent.bodyElement || parent.element;
        isViewport = parent.isViewport;
      }
    } else {
      if (!constrainAlign) {
        if (isFloated) {
          isViewport = true;
          constrainAlign = Ext.getBody();
        } else {
          constrainAlign = me.element.parent();
        }
      }
    }
    if (!constrainAlign.isRegion) {
      constrainAlign = Ext.fly(constrainAlign).getConstrainRegion();
      if (isViewport) {
        docInsets = Math.round(Ext.Widget.floatInset);
        constrainAlign.adjust(docInsets, -docInsets, -docInsets, docInsets);
      }
    }
    return constrainAlign;
  }
}, getFloatParent:function() {
  var result = this.floatParentNode.getData().component;
  return result && result.getFloated() ? result : null;
}, syncFloatedState:function(floated, oldFloated, rendered) {
  var me = this, isHidden = me.isHidden();
  if (floated) {
    if (rendered) {
      if (me.isCentered()) {
        me.getWidth();
        me.getHeight();
        me.center();
      } else {
        me.syncXYPosition();
      }
      if (!isHidden) {
        me.showModalMask();
      }
    } else {
      if (!isHidden) {
        me.findFloatParent();
      } else {
        me.setHidden(true);
      }
    }
  } else {
    me.translate(0, 0, 0);
  }
}, findFloatParent:function(needsShow) {
  var me = this, parent = me.getRefOwner();
  while (parent && !parent.getFloated()) {
    parent = parent.getRefOwner();
  }
  if (!parent) {
    me.floatParentNode = Ext.getFloatRoot();
  } else {
    me.floatParentNode = parent.getFloatWrap();
  }
  me.insertFloatedDom(needsShow);
}, getFloatWrap:function() {
  var me = this, fw = me.floatWrap;
  if (!fw) {
    me.floatWrap = fw = Ext.get(Ext.DomHelper.createDom({cls:me.floatWrapCls, id:me.id + '-floatWrap', 'data-componentId':me.id}));
    me.on('resize', 'syncFloatWrap', me);
    fw.getData().component = me;
    if (me.isContainer && (!me.isWidthed() || !me.isHeighted())) {
      me.setAutoSize(true);
    }
    fw.dom.appendChild(me.element.dom);
    fw.getData().alwaysOnTop = me.element.getData().alwaysOnTop;
    me.syncFloatWrap();
  }
  return fw;
}, applyRenderTo:function(renderTo) {
  if (renderTo && this.getFloated()) {
    Ext.raise('floated: true components cannot be rendered. They render themselves on first show');
    return;
  }
  return renderTo;
}, syncFloatWrap:function() {
  var me = this, floatWrap = me.floatWrap, mySize = me.el.getSize(), mask;
  if (me.getRelative()) {
    floatWrap.setSize(mySize);
  } else {
    mask = floatWrap.getData().modalMask;
    if (mask) {
      mask.setSize(mySize);
    }
  }
}, insertFloatedDom:function(needsShow) {
  var me = this, fw = me.getFloatWrap(), floatParentNode = me.floatParentNode;
  if (fw.dom.parentNode !== floatParentNode.dom) {
    floatParentNode.dom.appendChild(me.getFloatWrap().dom);
    if (needsShow) {
      me.setVisibility(true);
      me._hidden = false;
    }
    me.setRendered(true, true);
    me.syncXYPosition();
  }
}, applyShim:function(shim) {
  if (shim && !this.getFloated()) {
    Ext.raise('Cannot use setShim on a non-floated component');
  }
  if (shim) {
    return Ext.getBody().createChild(Ext.apply({cls:this.shimCls}, shim));
  } else {
    Ext.destroy(this.shim);
    return null;
  }
}, updateShim:function(shim, oldShim) {
  var me = this;
  if (shim) {
    me.syncShim();
    if (!oldShim) {
      me.on('resize', 'syncShim', me);
    }
  } else {
    if (oldShim) {
      me.un('resize', 'syncShim', me);
    }
  }
}, hideModalMask:function() {
  var me = this, floatRoot = Ext.getFloatRoot(), floatParentNode = me.floatParentNode, data, mask;
  if (floatParentNode) {
    data = floatParentNode.getData();
    if (floatParentNode !== floatRoot && !data.component.getRelative()) {
      data = floatRoot.getData();
    }
    mask = data.modalMask;
    if (mask && mask.dom.parentNode) {
      mask = mask.dom;
      Ext.getDetachedBody().appendChild(mask);
    }
  }
}, showModalMask:function() {
  var me = this, Widget = Ext.Widget, floatRoot = Ext.getFloatRoot(), positionEl = me.getFloatWrap(), parent = me.getParent(), floatParentNode = me.floatParentNode, data = floatParentNode.getData(), mask;
  if (me.getFloated() && me.getModal && me.getModal()) {
    if (floatParentNode !== floatRoot && !data.component.getRelative()) {
      data = floatRoot.getData();
    }
    mask = data.modalMask;
    if (mask) {
      if (positionEl.dom.parentElement === floatParentNode.dom) {
        floatParentNode.dom.insertBefore(mask.dom, positionEl.dom);
      } else {
        floatParentNode.dom.appendChild(mask.dom);
      }
    } else {
      mask = data.modalMask = floatParentNode.createChild({cls:'x-mask'}, positionEl);
      mask.on({tap:Widget.onModalMaskTap, scope:Widget});
      if (Ext.isiOS && floatParentNode === floatRoot) {
        mask.on({touchmove:function(e) {
          e.preventDefault();
        }});
      }
    }
    Widget.topModal = me;
    if (parent && parent.getFloated() && !parent.getRelative()) {
      parent.syncXYPosition();
    }
  }
}, syncShim:function() {
  var me = this, shim = me.getShim();
  if (shim) {
    if (me.isVisible(true)) {
      shim.show();
      me.getFloatWrap().dom.insertBefore(shim.dom, me.el.dom);
      shim.setSize(me.getSize());
    } else {
      shim.hide();
    }
  }
}, updateAlwaysOnTop:function(alwaysOnTop) {
  var me = this;
  me.getFloatWrap().getData().alwaysOnTop = Number(alwaysOnTop);
  if (!me.floatParentNode) {
    me.findFloatParent();
  }
  if (!me.isConfiguring) {
    me.syncAlwaysOnTop();
  }
}, syncAlwaysOnTop:function(fromMousedown) {
  var me = this, positionEl = me.getFloatWrap().dom, parentEl = me.floatParentNode, nodes = parentEl.dom.childNodes, len = nodes.length, alwaysOnTop = Number(me.getAlwaysOnTop()), range = me.statics().range, maskCls = Ext.Mask.prototype.baseCls, i, startIdx, nodeEl, refNode, isTopModal, currentAlwaysOnTop;
  startIdx = parentEl === Ext.floatRoot ? 0 : 1;
  isTopModal = me.getModal() && positionEl.previousSibling && Ext.fly(positionEl.previousSibling).hasCls(maskCls);
  if (positionEl.nextSibling) {
    for (i = len - 1; i >= startIdx; i--) {
      nodeEl = Ext.fly(nodes[i]);
      if (!nodeEl.hasCls(me.shimCls) && !nodeEl.hasCls(maskCls) && nodes[i] !== positionEl) {
        if (alwaysOnTop >= (Ext.get(nodes[i]).getData().alwaysOnTop || 0)) {
          refNode = nodes[i].nextSibling;
          break;
        }
      }
    }
    if (refNode === positionEl) {
      return;
    }
    if (i < startIdx) {
      refNode = nodes[0];
    }
    if (me.containsFocus || fromMousedown) {
      range.setStartAfter(positionEl);
      range.setEndAfter(refNode || nodes[len - 1]);
      parentEl.dom.insertBefore(range.extractContents(), positionEl);
    } else {
      parentEl.dom.insertBefore(positionEl, refNode);
    }
  } else {
    if (positionEl.previousSibling) {
      for (i = len - 2; i >= startIdx; i--) {
        if (!Ext.fly(nodes[i]).is('.' + me.shimCls) && nodes[i] !== positionEl) {
          currentAlwaysOnTop = Ext.get(nodes[i]).getData().alwaysOnTop;
          if (alwaysOnTop < currentAlwaysOnTop) {
            refNode = nodes[i];
            parentEl.dom.insertBefore(refNode, null);
            if (nodes[i - 1] && Ext.fly(nodes[i - 1]).hasCls(maskCls)) {
              parentEl.dom.insertBefore(nodes[i - 1], refNode);
              i -= 1;
            }
            alwaysOnTop = currentAlwaysOnTop;
          }
        }
      }
    }
  }
  if (isTopModal) {
    me.showModalMask();
  }
  me.syncShim();
  if (refNode && !Ext.fly(refNode).hasCls(maskCls)) {
    Ext.Component.from(refNode).syncShim();
  } else {
    return true;
  }
}, updateRelative:function() {
  this.syncXYPosition();
}, updateShadow:function(shadow) {
  this.el.toggleCls(this.shadowCls, shadow);
  this.el.toggleCls(this.noShadowCls, shadow === false);
}, updateX:function() {
  if (!this.getFloated()) {
    Ext.raise('Cannot use setX on a non-floated component');
  }
  if (!this.$updatingXY) {
    this.syncXYPosition();
  }
}, updateY:function() {
  if (!this.getFloated()) {
    Ext.raise('Cannot use setY on a non-floated component');
  }
  if (!this.$updatingXY) {
    this.syncXYPosition();
  }
}, syncXYPosition:function(animation) {
  var me = this, floatWrap = me.getFloatWrap(), maskAnim = animation, mask, x = me.getX() || 0, y = me.getY() || 0;
  if (me.getRelative()) {
    floatWrap.translate(x, y, animation);
    floatWrap.setWidth(me.el.getWidth());
    floatWrap.setHeight(me.el.getHeight());
    me.translate(0, 0);
    mask = floatWrap.getData().modalMask;
    if (mask) {
      mask.translate(0, 0);
    }
  } else {
    me.translate(x, y, animation);
    mask = floatWrap.getData().modalMask;
    if (mask) {
      if (maskAnim) {
        maskAnim = Ext.apply({}, maskAnim);
        delete maskAnim.callback;
      }
      mask.translate(x, y, maskAnim);
    }
  }
  me.syncShim();
}}}, function(Widget) {
  this.borrow(Ext.util.Positionable, ['clipTo', 'clearClip']);
  Widget.createAlias({prev:'previousSibling', next:'nextSibling'});
  Ext.getFloatRoot = function() {
    var fp = Ext.floatRoot, viewport = Ext['Viewport'], prototype = Widget.prototype, range = Widget.range;
    if (fp) {
      if (fp.el.dom.nextSibling) {
        if (fp.el.contains(document.activeElement)) {
          range.setStartBefore(fp.el.dom.nextSibling);
          range.setEndAfter(fp.el.dom.parentNode.lastChild);
          fp.el.dom.parentNode.insertBefore(range.extractContents(), fp.el.dom);
        } else {
          fp.el.dom.parentNode.appendChild(fp.dom);
        }
      }
    } else {
      fp = Ext.getBody().createChild({cls:prototype.floatWrapCls + ' ' + prototype.rootCls, id:'ext-global-floatWrap', 'data-sticky':true});
      fp.$skipResourceCheck = true;
      Ext.floatRoot = fp;
    }
    return fp;
  };
});
Ext.define('Ext.util.Format', function() {
  var me;
  return {singleton:true, defaultDateFormat:'m/d/Y', thousandSeparator:',', decimalSeparator:'.', currencyPrecision:2, currencySign:'$', currencySpacer:'', percentSign:'%', currencyAtEnd:false, stripTagsRe:/<\/?[^>]+>/gi, stripScriptsRe:/(?:<script.*?>)((\n|\r|.)*?)(?:<\/script>)/ig, nl2brRe:/\r?\n/g, hashRe:/#+$/, allHashes:/^#+$/, formatPattern:/[\d,\.#]+/, formatCleanRe:/[^\d\.#]/g, I18NFormatCleanRe:null, formatFns:{}, constructor:function() {
    me = this;
  }, nbsp:function(value, strict) {
    strict = strict !== false;
    if (strict ? value === '' || value == null : !value) {
      value = '';
    }
    return value;
  }, undef:function(value) {
    return value !== undefined ? value : '';
  }, defaultValue:function(value, defaultValue) {
    return value !== undefined && value !== '' ? value : defaultValue;
  }, substr:'ab'.substr(-1) != 'b' ? function(value, start, length) {
    var str = String(value);
    return start < 0 ? str.substr(Math.max(str.length + start, 0), length) : str.substr(start, length);
  } : function(value, start, length) {
    return String(value).substr(start, length);
  }, lowercase:function(value) {
    return String(value).toLowerCase();
  }, uppercase:function(value) {
    return String(value).toUpperCase();
  }, usMoney:function(value) {
    return me.currency(value, '$', 2);
  }, currency:function(value, currencySign, decimals, end, currencySpacer) {
    var negativeSign = '', format = ',0', i = 0;
    value = value - 0;
    if (value < 0) {
      value = -value;
      negativeSign = '-';
    }
    decimals = Ext.isDefined(decimals) ? decimals : me.currencyPrecision;
    format += decimals > 0 ? '.' : '';
    for (; i < decimals; i++) {
      format += '0';
    }
    value = me.number(value, format);
    if (currencySpacer == null) {
      currencySpacer = me.currencySpacer;
    }
    if ((end || me.currencyAtEnd) === true) {
      return Ext.String.format('{0}{1}{2}{3}', negativeSign, value, currencySpacer, currencySign || me.currencySign);
    } else {
      return Ext.String.format('{0}{1}{2}{3}', negativeSign, currencySign || me.currencySign, currencySpacer, value);
    }
  }, date:function(value, format) {
    if (!value) {
      return '';
    }
    if (!Ext.isDate(value)) {
      value = new Date(Date.parse(value));
    }
    return Ext.Date.dateFormat(value, format || Ext.Date.defaultFormat);
  }, dateRenderer:function(format) {
    return function(v) {
      return me.date(v, format);
    };
  }, hex:function(value, digits) {
    var s = parseInt(value || 0, 10).toString(16);
    if (digits) {
      if (digits < 0) {
        digits = -digits;
        if (s.length > digits) {
          s = s.substring(s.length - digits);
        }
      }
      while (s.length < digits) {
        s = '0' + s;
      }
    }
    return s;
  }, or:function(value, orValue) {
    return value || orValue;
  }, pick:function(value, firstValue, secondValue) {
    if (Ext.isNumber(value)) {
      var ret = arguments[value + 1];
      if (ret) {
        return ret;
      }
    }
    return value ? secondValue : firstValue;
  }, lessThanElse:function(value, threshold, below, above, equal) {
    var v = Ext.Number.from(value, 0), t = Ext.Number.from(threshold, 0), missing = !Ext.isDefined(equal);
    return v < t ? below : v > t ? above : missing ? above : equal;
  }, sign:function(value, negative, positive, zero) {
    if (zero === undefined) {
      zero = positive;
    }
    return me.lessThanElse(value, 0, negative, positive, zero);
  }, stripTags:function(value) {
    return !value ? value : String(value).replace(me.stripTagsRe, '');
  }, stripScripts:function(value) {
    return !value ? value : String(value).replace(me.stripScriptsRe, '');
  }, fileSize:function() {
    var byteLimit = 1024, kbLimit = 1048576, mbLimit = 1073741824;
    return function(size) {
      var out;
      if (size < byteLimit) {
        if (size === 1) {
          out = '1 byte';
        } else {
          out = size + ' bytes';
        }
      } else {
        if (size < kbLimit) {
          out = Math.round(size * 10 / byteLimit) / 10 + ' KB';
        } else {
          if (size < mbLimit) {
            out = Math.round(size * 10 / kbLimit) / 10 + ' MB';
          } else {
            out = Math.round(size * 10 / mbLimit) / 10 + ' GB';
          }
        }
      }
      return out;
    };
  }(), math:function() {
    var fns = {};
    return function(v, a) {
      if (!fns[a]) {
        fns[a] = Ext.functionFactory('v', 'return v ' + a + ';');
      }
      return fns[a](v);
    };
  }(), round:function(value, precision) {
    var result = Number(value);
    if (typeof precision === 'number') {
      precision = Math.pow(10, precision);
      result = Math.round(value * precision) / precision;
    } else {
      if (precision === undefined) {
        result = Math.round(result);
      }
    }
    return result;
  }, number:function(v, formatString) {
    if (!formatString) {
      return v;
    }
    if (isNaN(v)) {
      return '';
    }
    var formatFn = me.formatFns[formatString];
    if (!formatFn) {
      var originalFormatString = formatString, comma = me.thousandSeparator, decimalSeparator = me.decimalSeparator, precision = 0, trimPart = '', hasComma, splitFormat, extraChars, trimTrailingZeroes, code, len;
      if (formatString.substr(formatString.length - 2) === '/i') {
        if (!me.I18NFormatCleanRe || me.lastDecimalSeparator !== decimalSeparator) {
          me.I18NFormatCleanRe = new RegExp('[^\\d\\' + decimalSeparator + '#]', 'g');
          me.lastDecimalSeparator = decimalSeparator;
        }
        formatString = formatString.substr(0, formatString.length - 2);
        hasComma = formatString.indexOf(comma) !== -1;
        splitFormat = formatString.replace(me.I18NFormatCleanRe, '').split(decimalSeparator);
      } else {
        hasComma = formatString.indexOf(',') !== -1;
        splitFormat = formatString.replace(me.formatCleanRe, '').split('.');
      }
      extraChars = formatString.replace(me.formatPattern, '');
      if (splitFormat.length > 2) {
        Ext.raise({sourceClass:'Ext.util.Format', sourceMethod:'number', value:v, formatString:formatString, msg:'Invalid number format, should have no more than 1 decimal'});
      } else {
        if (splitFormat.length === 2) {
          precision = splitFormat[1].length;
          trimTrailingZeroes = splitFormat[1].match(me.hashRe);
          if (trimTrailingZeroes) {
            len = trimTrailingZeroes[0].length;
            trimPart = 'trailingZeroes\x3dnew RegExp(Ext.String.escapeRegex(utilFormat.decimalSeparator) + "*0{0,' + len + '}$")';
          }
        }
      }
      code = ['var utilFormat\x3dExt.util.Format,extNumber\x3dExt.Number,neg,absVal,fnum,parts' + (hasComma ? ',thousandSeparator,thousands\x3d[],j,n,i' : '') + (extraChars ? ',formatString\x3d"' + formatString + '",formatPattern\x3d/[\\d,\\.#]+/' : '') + ',trailingZeroes;' + 'return function(v){' + 'if(typeof v!\x3d\x3d"number"\x26\x26isNaN(v\x3dextNumber.from(v,NaN)))return"";' + 'neg\x3dv\x3c0;', 'absVal\x3dMath.abs(v);', 'fnum\x3dExt.Number.toFixed(absVal, ' + precision + ');', trimPart, ';'];
      if (hasComma) {
        if (precision) {
          code[code.length] = 'parts\x3dfnum.split(".");';
          code[code.length] = 'fnum\x3dparts[0];';
        }
        code[code.length] = 'if(absVal\x3e\x3d1000) {';
        code[code.length] = 'thousandSeparator\x3dutilFormat.thousandSeparator;' + 'thousands.length\x3d0;' + 'j\x3dfnum.length;' + 'n\x3dfnum.length%3||3;' + 'for(i\x3d0;i\x3cj;i+\x3dn){' + 'if(i!\x3d\x3d0){' + 'n\x3d3;' + '}' + 'thousands[thousands.length]\x3dfnum.substr(i,n);' + '}' + 'fnum\x3dthousands.join(thousandSeparator);' + '}';
        if (precision) {
          code[code.length] = 'fnum +\x3d utilFormat.decimalSeparator+parts[1];';
        }
      } else {
        if (precision) {
          code[code.length] = 'if(utilFormat.decimalSeparator!\x3d\x3d"."){' + 'parts\x3dfnum.split(".");' + 'fnum\x3dparts[0]+utilFormat.decimalSeparator+parts[1];' + '}';
        }
      }
      code[code.length] = 'if(neg\x26\x26fnum!\x3d\x3d"' + (precision ? '0.' + Ext.String.repeat('0', precision) : '0') + '") { fnum\x3d"-"+fnum; }';
      if (trimTrailingZeroes) {
        code[code.length] = 'fnum\x3dfnum.replace(trailingZeroes,"");';
      }
      code[code.length] = 'return ';
      if (extraChars) {
        code[code.length] = 'formatString.replace(formatPattern, fnum);';
      } else {
        code[code.length] = 'fnum;';
      }
      code[code.length] = '};';
      formatFn = me.formatFns[originalFormatString] = Ext.functionFactory('Ext', code.join(''))(Ext);
    }
    return formatFn(v);
  }, numberRenderer:function(format) {
    return function(v) {
      return me.number(v, format);
    };
  }, percent:function(value, formatString) {
    return me.number(value * 100, formatString || '0') + me.percentSign;
  }, repeat:function(value, text, sep) {
    return Ext.String.repeat(text, value, sep);
  }, attributes:function(attributes) {
    if (typeof attributes === 'object') {
      var result = [], name;
      for (name in attributes) {
        if (attributes.hasOwnProperty(name)) {
          result.push(name, '\x3d"', name === 'style' ? Ext.DomHelper.generateStyles(attributes[name], null, true) : Ext.htmlEncode(attributes[name]), '" ');
        }
      }
      attributes = result.join('');
    }
    return attributes || '';
  }, plural:function(value, singular, plural) {
    return value + ' ' + (value === 1 ? singular : plural ? plural : singular + 's');
  }, nl2br:function(v) {
    return Ext.isEmpty(v) ? '' : v.replace(me.nl2brRe, '\x3cbr/\x3e');
  }, capitalize:Ext.String.capitalize, uncapitalize:Ext.String.uncapitalize, ellipsis:Ext.String.ellipsis, escape:Ext.String.escape, escapeRegex:Ext.String.escapeRegex, htmlDecode:Ext.String.htmlDecode, htmlEncode:Ext.String.htmlEncode, leftPad:Ext.String.leftPad, toggle:Ext.String.toggle, trim:Ext.String.trim, parseBox:function(box) {
    box = box || 0;
    if (typeof box === 'number') {
      return {top:box, right:box, bottom:box, left:box};
    }
    var parts = box.split(' '), ln = parts.length;
    if (ln === 1) {
      parts[1] = parts[2] = parts[3] = parts[0];
    } else {
      if (ln === 2) {
        parts[2] = parts[0];
        parts[3] = parts[1];
      } else {
        if (ln === 3) {
          parts[3] = parts[1];
        }
      }
    }
    return {top:parseInt(parts[0], 10) || 0, right:parseInt(parts[1], 10) || 0, bottom:parseInt(parts[2], 10) || 0, left:parseInt(parts[3], 10) || 0};
  }, resource:function(url, prefix) {
    prefix = prefix || '';
    return Ext.resolveResource(prefix + url);
  }, uri:function(value) {
    return encodeURI(value);
  }, uriCmp:function(value) {
    return encodeURIComponent(value);
  }, wordBreakRe:/[\W\s]+/, word:function(value, index, sep) {
    var re = sep ? typeof sep === 'string' ? new RegExp(sep) : sep : me.wordBreakRe, parts = (value || '').split(re);
    return parts[index || 0] || '';
  }};
});
Ext.define('Ext.Template', {inheritableStatics:{from:function(el, config) {
  el = Ext.getDom(el);
  return new this(el.value || el.innerHTML, config || '');
}}, useEval:Ext.isGecko, constructor:function(html) {
  var me = this, args = arguments, buffer = [], length = args.length, i, value;
  me.initialConfig = {};
  if (length === 1 && Ext.isArray(html)) {
    args = html;
    length = args.length;
  }
  if (length > 1) {
    for (i = 0; i < length; i++) {
      value = args[i];
      if (typeof value === 'object') {
        Ext.apply(me.initialConfig, value);
        Ext.apply(me, value);
      } else {
        buffer.push(value);
      }
    }
  } else {
    buffer.push(html);
  }
  me.html = buffer.join('');
}, isTemplate:true, disableFormats:false, tokenRe:/\{(?:(?:(\d+)|([a-z_$][\w\-$]*))(?::([a-z_\.]+)(?:\(([^\)]*?)?\))?)?)\}/gi, apply:function(values) {
  var me = this;
  if (me.compiled) {
    if (!me.fn) {
      me.compile();
    }
    return me.fn(values).join('');
  }
  return me.evaluate(values);
}, evaluate:function(values) {
  var me = this, useFormat = !me.disableFormats, fm = Ext.util.Format, tpl = me;
  function fn(match, index, name, formatFn, args) {
    if (name == null || name === '') {
      name = index;
    }
    if (formatFn && useFormat) {
      if (args) {
        args = [values[name]].concat(Ext.functionFactory('return [' + args + '];')());
      } else {
        args = [values[name]];
      }
      if (formatFn.substr(0, 5) === 'this.') {
        return tpl[formatFn.substr(5)].apply(tpl, args);
      } else {
        if (fm[formatFn]) {
          return fm[formatFn].apply(fm, args);
        } else {
          return match;
        }
      }
    } else {
      return values[name] !== undefined ? values[name] : '';
    }
  }
  return me.html.replace(me.tokenRe, fn);
}, applyOut:function(values, out) {
  var me = this;
  if (me.compiled) {
    if (!me.fn) {
      me.compile();
    }
    out.push.apply(out, me.fn(values));
  } else {
    out.push(me.apply(values));
  }
  return out;
}, applyTemplate:function() {
  return this.apply.apply(this, arguments);
}, set:function(html, compile) {
  var me = this;
  me.html = html;
  me.compiled = !!compile;
  me.fn = null;
  return me;
}, compileARe:/\\/g, compileBRe:/(\r\n|\n)/g, compileCRe:/'/g, compile:function() {
  var me = this, code;
  code = me.html.replace(me.compileARe, '\\\\').replace(me.compileBRe, '\\n').replace(me.compileCRe, "\\'").replace(me.tokenRe, me.regexReplaceFn.bind(me));
  code = (this.disableFormats !== true ? 'var fm\x3dExt.util.Format;' : '') + (me.useEval ? '$\x3d' : 'return') + " function(v){return ['" + code + "'];};";
  me.fn = me.useEval ? me.evalCompiled(code) : (new Function('Ext', code))(Ext);
  me.compiled = true;
  return me;
}, evalCompiled:function($) {
  eval($);
  return $;
}, regexReplaceFn:function(match, index, name, formatFn, args) {
  if (index == null || index === '') {
    index = '"' + name + '"';
  } else {
    if (this.stringFormat) {
      index = parseInt(index) + 1;
    }
  }
  if (formatFn && this.disableFormats !== true) {
    args = args ? ',' + args : '';
    if (formatFn.substr(0, 5) === 'this.') {
      formatFn = formatFn + '(';
    } else {
      if (Ext.util.Format[formatFn]) {
        formatFn = 'fm.' + formatFn + '(';
      } else {
        return match;
      }
    }
    return "'," + formatFn + 'v[' + index + ']' + args + "),'";
  } else {
    return "',v[" + index + "] \x3d\x3d undefined ? '' : v[" + index + "],'";
  }
}, insertFirst:function(el, values, returnElement) {
  return this.doInsert('afterBegin', el, values, returnElement);
}, insertBefore:function(el, values, returnElement) {
  return this.doInsert('beforeBegin', el, values, returnElement);
}, insertAfter:function(el, values, returnElement) {
  return this.doInsert('afterEnd', el, values, returnElement);
}, append:function(el, values, returnElement) {
  return this.doInsert('beforeEnd', el, values, returnElement);
}, doInsert:function(where, el, values, returnElement) {
  var newNode = Ext.DomHelper.insertHtml(where, Ext.getDom(el), this.apply(values));
  return returnElement ? Ext.get(newNode) : newNode;
}, overwrite:function(el, values, returnElement) {
  var newNode = Ext.DomHelper.overwrite(Ext.getDom(el), this.apply(values));
  return returnElement ? Ext.get(newNode) : newNode;
}}, function(Template) {
  var formatRe = /\{\d+\}/, generateFormatFn = function(format) {
    if (formatRe.test(format)) {
      format = new Template(format, formatTplConfig);
      return function() {
        return format.apply(arguments);
      };
    } else {
      return function() {
        return format;
      };
    }
  }, formatTplConfig = {useFormat:false, compiled:true, stringFormat:true}, formatFns = {};
  Ext.String.format = Ext.util.Format.format = function(format) {
    var formatFn = formatFns[format] || (formatFns[format] = generateFormatFn(format));
    return formatFn.apply(this, arguments);
  };
  Ext.String.formatEncode = function() {
    return Ext.String.htmlEncode(Ext.String.format.apply(this, arguments));
  };
});
Ext.define('Ext.util.XTemplateParser', {constructor:function(config) {
  Ext.apply(this, config);
}, doTpl:Ext.emptyFn, parse:function(str) {
  var me = this, len = str.length, aliases = {elseif:'elif'}, topRe = me.topRe, actionsRe = me.actionsRe, index, stack, s, m, t, prev, frame, subMatch, begin, end, actions, prop, expectTplNext;
  me.level = 0;
  me.stack = stack = [];
  for (index = 0; index < len; index = end) {
    topRe.lastIndex = index;
    m = topRe.exec(str);
    if (!m) {
      me.doText(str.substring(index, len));
      break;
    }
    begin = m.index;
    end = topRe.lastIndex;
    if (index < begin) {
      s = str.substring(index, begin);
      if (!(expectTplNext && Ext.String.trim(s) === '')) {
        me.doText(s);
      }
    }
    expectTplNext = false;
    if (m[1]) {
      end = str.indexOf('%}', begin + 2);
      me.doEval(str.substring(begin + 2, end));
      end += 2;
    } else {
      if (m[2]) {
        end = str.indexOf(']}', begin + 2);
        me.doExpr(str.substring(begin + 2, end));
        end += 2;
      } else {
        if (m[3]) {
          me.doTag(m[3]);
        } else {
          if (m[4]) {
            actions = null;
            while ((subMatch = actionsRe.exec(m[4])) !== null) {
              s = subMatch[2] || subMatch[3];
              if (s) {
                s = Ext.String.htmlDecode(s);
                t = subMatch[1];
                t = aliases[t] || t;
                actions = actions || {};
                prev = actions[t];
                if (typeof prev == 'string') {
                  actions[t] = [prev, s];
                } else {
                  if (prev) {
                    actions[t].push(s);
                  } else {
                    actions[t] = s;
                  }
                }
              }
            }
            if (!actions) {
              if (me.elseRe.test(m[4])) {
                me.doElse();
              } else {
                if (me.defaultRe.test(m[4])) {
                  me.doDefault();
                } else {
                  me.doTpl();
                  stack.push({type:'tpl'});
                }
              }
            } else {
              if (actions['if']) {
                me.doIf(actions['if'], actions);
                stack.push({type:'if'});
              } else {
                if (actions['switch']) {
                  me.doSwitch(actions['switch'], actions);
                  stack.push({type:'switch'});
                  expectTplNext = true;
                } else {
                  if (actions['case']) {
                    me.doCase(actions['case'], actions);
                  } else {
                    if (actions['elif']) {
                      me.doElseIf(actions['elif'], actions);
                    } else {
                      if (actions['for']) {
                        ++me.level;
                        if (prop = me.propRe.exec(m[4])) {
                          actions.propName = prop[1] || prop[2];
                        }
                        me.doFor(actions['for'], actions);
                        stack.push({type:'for', actions:actions});
                      } else {
                        if (actions['foreach']) {
                          ++me.level;
                          if (prop = me.propRe.exec(m[4])) {
                            actions.propName = prop[1] || prop[2];
                          }
                          me.doForEach(actions['foreach'], actions);
                          stack.push({type:'foreach', actions:actions});
                        } else {
                          if (actions.exec) {
                            me.doExec(actions.exec, actions);
                            stack.push({type:'exec', actions:actions});
                          }
                        }
                      }
                    }
                  }
                }
              }
            }
          } else {
            if (m[0].length === 5) {
              stack.push({type:'tpl'});
            } else {
              frame = stack.pop();
              me.doEnd(frame.type, frame.actions);
              if (frame.type == 'for' || frame.type == 'foreach') {
                --me.level;
              }
            }
          }
        }
      }
    }
  }
}, topRe:/(?:(\{%)|(\{\[)|\{([^{}]+)\})|(?:<tpl([^>]*)>)|(?:<\/tpl>)/g, actionsRe:/\s*(elif|elseif|if|for|foreach|exec|switch|case|eval|between)\s*=\s*(?:(?:"([^"]*)")|(?:'([^']*)'))\s*/g, propRe:/prop=(?:(?:"([^"]*)")|(?:'([^']*)'))/, defaultRe:/^\s*default\s*$/, elseRe:/^\s*else\s*$/});
Ext.define('Ext.util.XTemplateCompiler', {extend:Ext.util.XTemplateParser, useEval:Ext.isGecko, useIndex:Ext.isIE8m, useFormat:true, propNameRe:/^[\w\d\$]*$/, compile:function(tpl) {
  var me = this, code = me.generate(tpl);
  return me.useEval ? me.evalTpl(code) : (new Function('Ext', code))(Ext);
}, generate:function(tpl) {
  var me = this, definitions = 'var fm\x3dExt.util.Format,ts\x3dObject.prototype.toString;', code;
  me.maxLevel = 0;
  me.body = ['var c0\x3dvalues, a0\x3d' + me.createArrayTest(0) + ', p0\x3dparent, n0\x3dxcount, i0\x3dxindex, k0, v;\n'];
  if (me.definitions) {
    if (typeof me.definitions === 'string') {
      me.definitions = [me.definitions, definitions];
    } else {
      me.definitions.push(definitions);
    }
  } else {
    me.definitions = [definitions];
  }
  me.switches = [];
  me.parse(tpl);
  me.definitions.push((me.useEval ? '$\x3d' : 'return') + ' function (' + me.fnArgs + ') {', me.body.join(''), '}');
  code = me.definitions.join('\n');
  me.definitions.length = me.body.length = me.switches.length = 0;
  me.definitions = me.body = me.switches = 0;
  return code;
}, doText:function(text) {
  var me = this, out = me.body;
  text = text.replace(me.aposRe, "\\'").replace(me.newLineRe, '\\n');
  if (me.useIndex) {
    out.push("out[out.length]\x3d'", text, "'\n");
  } else {
    out.push("out.push('", text, "')\n");
  }
}, doExpr:function(expr) {
  var out = this.body;
  out.push('if ((v\x3d' + expr + ') !\x3d null) out');
  if (this.useIndex) {
    out.push('[out.length]\x3dv\n');
  } else {
    out.push('.push(v)\n');
  }
}, doTag:function(tag) {
  var expr = this.parseTag(tag);
  if (expr) {
    this.doExpr(expr);
  } else {
    this.doText('{' + tag + '}');
  }
}, doElse:function() {
  this.body.push('} else {\n');
}, doEval:function(text) {
  this.body.push(text, '\n');
}, doIf:function(action, actions) {
  var me = this;
  if (action === '.') {
    me.body.push('if (values) {\n');
  } else {
    if (me.propNameRe.test(action)) {
      me.body.push('if (', me.parseTag(action), ') {\n');
    } else {
      me.body.push('if (', me.addFn(action), me.callFn, ') {\n');
    }
  }
  if (actions.exec) {
    me.doExec(actions.exec);
  }
}, doElseIf:function(action, actions) {
  var me = this;
  if (action === '.') {
    me.body.push('else if (values) {\n');
  } else {
    if (me.propNameRe.test(action)) {
      me.body.push('} else if (', me.parseTag(action), ') {\n');
    } else {
      me.body.push('} else if (', me.addFn(action), me.callFn, ') {\n');
    }
  }
  if (actions.exec) {
    me.doExec(actions.exec);
  }
}, doSwitch:function(action) {
  var me = this, key;
  if (action === '.' || action === '#') {
    key = action === '.' ? 'values' : 'xindex';
    me.body.push('switch (', key, ') {\n');
  } else {
    if (me.propNameRe.test(action)) {
      me.body.push('switch (', me.parseTag(action), ') {\n');
    } else {
      me.body.push('switch (', me.addFn(action), me.callFn, ') {\n');
    }
  }
  me.switches.push(0);
}, doCase:function(action) {
  var me = this, cases = Ext.isArray(action) ? action : [action], n = me.switches.length - 1, match, i;
  if (me.switches[n]) {
    me.body.push('break;\n');
  } else {
    me.switches[n]++;
  }
  for (i = 0, n = cases.length; i < n; ++i) {
    match = me.intRe.exec(cases[i]);
    cases[i] = match ? match[1] : "'" + cases[i].replace(me.aposRe, "\\'") + "'";
  }
  me.body.push('case ', cases.join(': case '), ':\n');
}, doDefault:function() {
  var me = this, n = me.switches.length - 1;
  if (me.switches[n]) {
    me.body.push('break;\n');
  } else {
    me.switches[n]++;
  }
  me.body.push('default:\n');
}, doEnd:function(type, actions) {
  var me = this, L = me.level - 1;
  if (type == 'for' || type == 'foreach') {
    if (actions.exec) {
      me.doExec(actions.exec);
    }
    me.body.push('}\n');
    me.body.push('parent\x3dp', L, ';values\x3dr', L + 1, ';xcount\x3dn' + L + ';xindex\x3di', L, '+1;xkey\x3dk', L, ';\n');
  } else {
    if (type == 'if' || type == 'switch') {
      me.body.push('}\n');
    }
  }
}, doFor:function(action, actions) {
  var me = this, s, L = me.level, up = L - 1, parentAssignment;
  if (action === '.') {
    s = 'values';
  } else {
    if (me.propNameRe.test(action)) {
      s = me.parseTag(action);
    } else {
      s = me.addFn(action) + me.callFn;
    }
  }
  if (me.maxLevel < L) {
    me.maxLevel = L;
    me.body.push('var ');
  }
  if (action == '.') {
    parentAssignment = 'c' + L;
  } else {
    parentAssignment = 'a' + up + '?c' + up + '[i' + up + ']:c' + up;
  }
  me.body.push('i', L, '\x3d0,n', L, '\x3d0,c', L, '\x3d', s, ',a', L, '\x3d', me.createArrayTest(L), ',r', L, '\x3dvalues,p', L, ',k', L, ';\n', 'p', L, '\x3dparent\x3d', parentAssignment, '\n', 'if (c', L, '){if(a', L, '){n', L, '\x3dc', L, '.length;}else if (c', L, '.isMixedCollection){c', L, '\x3dc', L, '.items;n', L, '\x3dc', L, '.length;}else if(c', L, '.isStore){c', L, '\x3dc', L, '.data.items;n', L, '\x3dc', L, '.length;}else{c', L, '\x3d[c', L, '];n', L, '\x3d1;}}\n', 'for (xcount\x3dn', 
  L, ';i', L, '\x3cn' + L + ';++i', L, '){\n', 'values\x3dc', L, '[i', L, ']');
  if (actions.propName) {
    me.body.push('.', actions.propName);
  }
  me.body.push('\n', 'xindex\x3di', L, '+1\n');
  if (actions.between) {
    me.body.push('if(xindex\x3e1){ out.push("', actions.between, '"); } \n');
  }
}, doForEach:function(action, actions) {
  var me = this, s, L = me.level, up = L - 1, parentAssignment;
  if (action === '.') {
    s = 'values';
  } else {
    if (me.propNameRe.test(action)) {
      s = me.parseTag(action);
    } else {
      s = me.addFn(action) + me.callFn;
    }
  }
  if (me.maxLevel < L) {
    me.maxLevel = L;
    me.body.push('var ');
  }
  if (action == '.') {
    parentAssignment = 'c' + L;
  } else {
    parentAssignment = 'a' + up + '?c' + up + '[i' + up + ']:c' + up;
  }
  me.body.push('i', L, '\x3d-1,n', L, '\x3d0,c', L, '\x3d', s, ',a', L, '\x3d', me.createArrayTest(L), ',r', L, '\x3dvalues,p', L, ',k', L, ';\n', 'p', L, '\x3dparent\x3d', parentAssignment, '\n', 'for(k', L, ' in c', L, '){\n', 'xindex\x3d++i', L, '+1;\n', 'xkey\x3dk', L, ';\n', 'values\x3dc', L, '[k', L, '];');
  if (actions.propName) {
    me.body.push('.', actions.propName);
  }
  if (actions.between) {
    me.body.push('if(xindex\x3e1){ out.push("', actions.between, '"); } \n');
  }
}, createArrayTest:'isArray' in Array ? function(L) {
  return 'Array.isArray(c' + L + ')';
} : function(L) {
  return 'ts.call(c' + L + ')\x3d\x3d\x3d"[object Array]"';
}, doExec:function(action, actions) {
  var me = this, name = 'f' + me.definitions.length, guards = me.guards[me.strict ? 0 : 1];
  me.definitions.push('function ' + name + '(' + me.fnArgs + ') {', guards.doTry, ' var $v \x3d values; with($v) {', '  ' + action, ' }', guards.doCatch, '}');
  me.body.push(name + me.callFn + '\n');
}, guards:[{doTry:'', doCatch:''}, {doTry:'try { ', doCatch:' } catch(e) {\n' + 'Ext.log.warn("XTemplate evaluation exception: " + e.message);\n' + '}'}], addFn:function(body) {
  var me = this, name = 'f' + me.definitions.length, guards = me.guards[me.strict ? 0 : 1];
  if (body === '.') {
    me.definitions.push('function ' + name + '(' + me.fnArgs + ') {', ' return values', '}');
  } else {
    if (body === '..') {
      me.definitions.push('function ' + name + '(' + me.fnArgs + ') {', ' return parent', '}');
    } else {
      me.definitions.push('function ' + name + '(' + me.fnArgs + ') {', guards.doTry, ' var $v \x3d values; with($v) {', '  return(' + body + ')', ' }', guards.doCatch, '}');
    }
  }
  return name;
}, parseTag:function(tag) {
  var me = this, m = me.tagRe.exec(tag), name, format, args, math, v;
  if (!m) {
    return null;
  }
  name = m[1];
  format = m[2];
  args = m[3];
  math = m[4];
  if (name == '.') {
    if (!me.validTypes) {
      me.definitions.push('var validTypes\x3d{string:1,number:1,boolean:1};');
      me.validTypes = true;
    }
    v = 'validTypes[typeof values] || ts.call(values) \x3d\x3d\x3d "[object Date]" ? values : ""';
  } else {
    if (name == '#') {
      v = 'xindex';
    } else {
      if (name == '$') {
        v = 'xkey';
      } else {
        if (name.substr(0, 7) == 'parent.') {
          v = name;
        } else {
          if (isNaN(name) && name.indexOf('-') == -1 && name.indexOf('.') != -1) {
            v = 'values.' + name;
          } else {
            v = "values['" + name + "']";
          }
        }
      }
    }
  }
  if (math) {
    v = '(' + v + math + ')';
  }
  if (format && me.useFormat) {
    args = args ? ',' + args : '';
    if (format.substr(0, 5) != 'this.') {
      format = 'fm.' + format + '(';
    } else {
      format += '(';
    }
  } else {
    return v;
  }
  return format + v + args + ')';
}, evalTpl:function($) {
  eval($);
  return $;
}, newLineRe:/\r\n|\r|\n/g, aposRe:/[']/g, intRe:/^\s*(\d+)\s*$/, tagRe:/^([\w-\.#\$]+)(?::([\w\.]*)(?:\((.*?)?\))?)?(\s?[\+\-\*\/]\s?[\d\.\+\-\*\/\(\)]+)?$/}, function() {
  var proto = this.prototype;
  proto.fnArgs = 'out,values,parent,xindex,xcount,xkey';
  proto.callFn = '.call(this,' + proto.fnArgs + ')';
});
Ext.define('Ext.XTemplate', {extend:Ext.Template, isXTemplate:true, emptyObj:{}, fn:null, strict:false, apply:function(values, parent, xindex, xcount) {
  var buffer = this.applyOut(values, [], parent, xindex, xcount);
  return buffer.length === 1 ? buffer[0] : buffer.join('');
}, applyOut:function(values, out, parent, xindex, xcount) {
  var me = this, compiler;
  if (!me.fn) {
    compiler = new Ext.util.XTemplateCompiler({useFormat:me.disableFormats !== true, definitions:me.definitions, strict:me.strict});
    me.fn = compiler.compile(me.html);
  }
  xindex = xindex || 1;
  xcount = xcount || 1;
  if (me.strict) {
    me.fn(out, values, parent || me.emptyObj, xindex, xcount);
  } else {
    try {
      me.fn(out, values, parent || me.emptyObj, xindex, xcount);
    } catch (e$23) {
      Ext.log.warn('XTemplate evaluation exception: ' + e$23.message);
    }
  }
  return out;
}, compile:function() {
  return this;
}, statics:{get:function(config, source, defaultTpl) {
  var ret = config;
  if (config == null) {
    if (source && defaultTpl) {
      ret = this.getTpl(source, defaultTpl);
    }
  } else {
    if ((config || config === '') && !config.isTemplate) {
      ret = new this(config);
    }
  }
  return ret;
}, getTpl:function(instance, name) {
  var tpl = instance[name], owner;
  if (tpl) {
    if (!tpl.isTemplate) {
      tpl = Ext.XTemplate.get(tpl);
    }
    if (!tpl.owner) {
      if (instance.hasOwnProperty(name)) {
        owner = instance;
      } else {
        for (owner = instance.self.prototype; owner && !owner.hasOwnProperty(name); owner = owner.superclass) {
        }
      }
      owner[name] = tpl;
      tpl.owner = owner;
    }
  }
  return tpl || null;
}}});
Ext.define('Ext.util.translatable.Dom', {extend:Ext.util.translatable.Abstract, alias:'translatable.dom', config:{element:null}, applyElement:function(element) {
  if (!element) {
    return;
  }
  return Ext.get(element);
}, updateElement:function() {
  this.refresh();
}});
Ext.define('Ext.util.translatable.CssPosition', {extend:Ext.util.translatable.Dom, alias:'translatable.cssposition', doTranslate:function(x, y) {
  var domStyle = this.getElement().dom.style;
  if (typeof x === 'number') {
    domStyle.left = x + 'px';
  }
  if (typeof y === 'number') {
    domStyle.top = y + 'px';
  }
  this.callParent([x, y]);
}, syncPosition:function() {
  var domStyle = this.getElement().dom.style;
  return [this.x = parseFloat(domStyle.left), this.y = parseFloat(domStyle.top)];
}, destroy:function() {
  var domStyle = this.getElement().dom.style;
  domStyle.left = null;
  domStyle.top = null;
  this.callParent();
}});
Ext.define('Ext.util.translatable.CssTransform', {extend:Ext.util.translatable.Dom, alias:'translatable.csstransform', isCssTransform:true, posRegex:/(\d+)px[^\d]*(\d+)px/, doTranslate:function(x, y) {
  var me = this, element = me.getElement();
  if (!me.destroyed && !element.destroyed) {
    element.translate(x, y);
  }
  me.callParent([x, y]);
}, syncPosition:function() {
  var pos = this.posRegex.exec(this.getElement().dom.style.tranform);
  if (pos) {
    this.x = parseFloat(pos[1]);
    this.y = parseFloat(pos[2]);
  }
  return [this.x, this.y];
}, destroy:function() {
  var element = this.getElement();
  if (element && !element.destroyed) {
    element.dom.style.webkitTransform = null;
  }
  this.callParent();
}});
Ext.define('Ext.util.CSS', function() {
  var CSS, rules = null, doc = document, camelRe = /(-[a-z])/gi, camelFn = function(m, a) {
    return a.charAt(1).toUpperCase();
  };
  return {singleton:true, rules:rules, initialized:false, constructor:function() {
    CSS = this;
  }, createStyleSheet:function(cssText, id) {
    var ss, head = doc.getElementsByTagName('head')[0], styleEl = doc.createElement('style');
    styleEl.setAttribute('type', 'text/css');
    if (id) {
      styleEl.setAttribute('id', id);
    }
    ss = styleEl.styleSheet;
    if (ss) {
      head.appendChild(styleEl);
      ss.cssText = cssText;
    } else {
      styleEl.appendChild(doc.createTextNode(cssText));
      head.appendChild(styleEl);
      ss = styleEl.sheet;
    }
    CSS.cacheStyleSheet(ss);
    return ss;
  }, removeStyleSheet:function(stylesheet) {
    var styleEl = typeof stylesheet === 'string' ? doc.getElementById(stylesheet) : stylesheet.ownerNode;
    if (styleEl) {
      styleEl.parentNode.removeChild(styleEl);
    }
  }, swapStyleSheet:function(id, url) {
    var ss;
    CSS.removeStyleSheet(id);
    ss = doc.createElement('link');
    ss.setAttribute('rel', 'stylesheet');
    ss.setAttribute('type', 'text/css');
    ss.setAttribute('id', id);
    ss.setAttribute('href', url);
    doc.getElementsByTagName('head')[0].appendChild(ss);
  }, cacheStyleSheet:function(ss) {
    if (!rules) {
      rules = CSS.rules = {};
    }
    try {
      var ssRules = ss.cssRules || ss.rules, i = ssRules.length - 1, imports = ss.imports, len = imports ? imports.length : 0, rule, j;
      for (j = 0; j < len; ++j) {
        CSS.cacheStyleSheet(imports[j]);
      }
      for (; i >= 0; --i) {
        rule = ssRules[i];
        if (rule.styleSheet) {
          CSS.cacheStyleSheet(rule.styleSheet);
        }
        CSS.cacheRule(rule, ss);
      }
    } catch (e$24) {
    }
  }, cacheRule:function(cssRule, styleSheet) {
    if (cssRule.styleSheet) {
      return CSS.cacheStyleSheet(cssRule.styleSheet);
    }
    var selectorText = cssRule.selectorText, selectorCount, j;
    if (selectorText) {
      selectorText = selectorText.split(',');
      selectorCount = selectorText.length;
      for (j = 0; j < selectorCount; j++) {
        rules[Ext.String.trim(selectorText[j]).toLowerCase()] = {parentStyleSheet:styleSheet, cssRule:cssRule};
      }
    }
  }, getRules:function(refreshCache) {
    var result = {}, selector;
    if (rules === null || refreshCache) {
      CSS.refreshCache();
    }
    for (selector in rules) {
      result[selector] = rules[selector].cssRule;
    }
    return result;
  }, refreshCache:function() {
    var ds = doc.styleSheets, i = 0, len = ds.length;
    rules = CSS.rules = {};
    for (; i < len; i++) {
      try {
        if (!ds[i].disabled) {
          CSS.cacheStyleSheet(ds[i]);
        }
      } catch (e$25) {
      }
    }
  }, getRule:function(selector, refreshCache, rawCache) {
    var i, result;
    if (!rules || refreshCache) {
      CSS.refreshCache();
    }
    if (!Ext.isArray(selector)) {
      result = rules[selector.toLowerCase()];
      if (result && !rawCache) {
        result = result.cssRule;
      }
      return result || null;
    }
    for (i = 0; i < selector.length; i++) {
      if (rules[selector[i]]) {
        return rawCache ? rules[selector[i].toLowerCase()] : rules[selector[i].toLowerCase()].cssRule;
      }
    }
    return null;
  }, createRule:function(styleSheet, selector, cssText) {
    var result, ruleSet = styleSheet.cssRules || styleSheet.rules, index = ruleSet.length;
    if (styleSheet.insertRule) {
      styleSheet.insertRule(selector + ' {' + cssText + '}', index);
    } else {
      styleSheet.addRule(selector, cssText || ' ');
    }
    CSS.cacheRule(result = ruleSet[index], styleSheet);
    return result;
  }, updateRule:function(selector, property, value) {
    var rule, i, styles;
    if (!Ext.isArray(selector)) {
      rule = CSS.getRule(selector);
      if (rule) {
        if (arguments.length === 2) {
          styles = Ext.Element.parseStyles(property);
          for (property in styles) {
            rule.style[property.replace(camelRe, camelFn)] = styles[property];
          }
        } else {
          rule.style[property.replace(camelRe, camelFn)] = value;
        }
        return true;
      }
    } else {
      for (i = 0; i < selector.length; i++) {
        if (CSS.updateRule(selector[i], property, value)) {
          return true;
        }
      }
    }
    return false;
  }, deleteRule:function(selector) {
    var rule = CSS.getRule(selector, false, true), styleSheet, index;
    if (rule) {
      styleSheet = rule.parentStyleSheet;
      index = Ext.Array.indexOf(styleSheet.cssRules || styleSheet.rules, rule.cssRule);
      if (styleSheet.deleteRule) {
        styleSheet.deleteRule(index);
      } else {
        styleSheet.removeRule(index);
      }
      delete rules[selector];
    }
  }};
});
Ext.define('Ext.util.translatable.ScrollPosition', {extend:Ext.util.translatable.Dom, alias:'translatable.scrollposition', constructor:function(config) {
  if (config && config.element) {
    this.x = config.element.getScrollLeft();
    this.y = config.element.getScrollTop();
  }
  this.callParent([config]);
}, translateAnimated:function() {
  var element = this.getElement();
  this.x = element.getScrollLeft();
  this.y = element.getScrollTop();
  this.callParent(arguments);
}, doTranslate:function(x, y) {
  var element = this.getElement();
  element.setScrollLeft(Math.round(x));
  element.setScrollTop(Math.round(y));
}, getPosition:function() {
  var me = this, position = me.position, element = me.getElement();
  position.x = element.getScrollLeft();
  position.y = element.getScrollTop();
  return position;
}});
Ext.define('Ext.scroll.Scroller', {extend:Ext.Evented, alias:'scroller.scroller', mixins:[Ext.mixin.Factoryable, Ext.mixin.Bufferable], factoryConfig:{defaultType:'scroller'}, bufferableMethods:{onDomScrollEnd:100}, isScroller:true, config:{direction:undefined, element:undefined, scrollbars:null, snapSelector:null, snapOffset:null, msSnapInterval:null, x:true, y:true, scrollElement:null, size:null, spacerXY:null, touchAction:null}, snappableCls:Ext.baseCSSPrefix + 'scroller-snappable', elementCls:Ext.baseCSSPrefix + 
'scroller', spacerCls:Ext.baseCSSPrefix + 'scroller-spacer', noScrollbarsCls:Ext.baseCSSPrefix + 'no-scrollbars', statics:{create:function(config, type) {
  return Ext.Factory.scroller(config, type);
}, getScrollingElement:function() {
  var doc = document, standard = this.$standardScrollElement, el = doc.scrollingElement, iframe, frameDoc;
  if (el) {
    return el;
  }
  if (standard === undefined) {
    iframe = document.createElement('iframe');
    iframe.style.height = '1px';
    document.body.appendChild(iframe);
    frameDoc = iframe.contentWindow.document;
    frameDoc.write('\x3c!DOCTYPE html\x3e\x3cdiv style\x3d"height:9999em"\x3ex\x3c/div\x3e');
    frameDoc.close();
    standard = frameDoc.documentElement.scrollHeight > frameDoc.body.scrollHeight;
    iframe.parentNode.removeChild(iframe);
    this.$standardScrollElement = standard;
  }
  return standard ? doc.documentElement : doc.body;
}, initViewportScroller:function() {
  var scroller = Ext.getViewportScroller();
  if (!scroller.getElement()) {
    scroller.setElement(Ext.getBody());
  }
}}, constructor:function(config) {
  var me = this;
  me.position = {x:0, y:0};
  me.callParent([config]);
}, destroy:function() {
  var me = this, partners = me._partners, key;
  Ext.undefer(me.restoreTimer);
  me.setX(Ext.emptyString);
  me.setY(Ext.emptyString);
  if (me._spacer) {
    me._spacer.destroy();
  }
  if (me.scrollListener) {
    me.scrollListener.destroy();
  }
  if (partners) {
    for (key in partners) {
      me.removePartner(partners[key].scroller);
    }
  }
  me.setElement(null);
  me._partners = me.component = null;
  if (me.translatable) {
    me.translatable.destroy();
    me.translatable = null;
  }
  me.removeSnapStylesheet();
  me.callParent();
}, addPartner:function(partner, axis) {
  var me = this, partners = me._partners || (me._partners = {}), otherPartners = partner._partners || (partner._partners = {});
  axis = me.axisConfigs[axis || 'both'];
  partners[partner.getId()] = {scroller:partner, axes:axis};
  otherPartners[me.getId()] = {scroller:me, axes:axis};
}, applyElement:function(element, oldElement) {
  var me = this;
  if (oldElement && me.scrollListener) {
    me.scrollListener.destroy();
  }
  if (element) {
    if (typeof element === 'string' && !Ext.get(element)) {
      Ext.raise('Cannot create Ext.scroll.Scroller instance. ' + "Element with id '" + element + "' not found.");
    }
    element = Ext.get(element);
  }
  return element;
}, applySize:function(size, oldSize) {
  var x, y;
  if (size === null || typeof size === 'number') {
    x = y = size;
  } else {
    if (size) {
      x = size.x;
      y = size.y;
    }
  }
  if (x === null) {
    x = 0;
  } else {
    if (x === undefined) {
      x = oldSize ? oldSize.x : 0;
    }
  }
  if (y === null) {
    y = 0;
  } else {
    if (y === undefined) {
      y = oldSize ? oldSize.y : 0;
    }
  }
  if (!oldSize || x !== oldSize.x || y !== oldSize.y) {
    return {x:x, y:y};
  }
}, getClientSize:function() {
  var dom = this.getElement().dom;
  return {x:dom.clientWidth, y:dom.clientHeight};
}, getScrollbarSize:function() {
  var me = this, width = 0, height = 0, element = me.getElement(), dom, x, y, hasXScroll, hasYScroll, scrollbarSize;
  if (element && !element.destroyed) {
    x = me.getX();
    y = me.getY();
    dom = element.dom;
    if (x || y) {
      scrollbarSize = Ext.getScrollbarSize();
    }
    if (x === 'scroll') {
      hasXScroll = true;
    } else {
      if (x) {
        hasXScroll = dom.scrollWidth > dom.clientWidth;
      }
    }
    if (y === 'scroll') {
      hasYScroll = true;
    } else {
      if (y) {
        hasYScroll = dom.scrollHeight > dom.clientHeight;
      }
    }
    if (hasXScroll) {
      height = scrollbarSize.height;
    }
    if (hasYScroll) {
      width = scrollbarSize.width;
    }
  }
  return {width:width, height:height};
}, getPosition:function() {
  var me = this;
  if (me.positionDirty) {
    me.updateDomScrollPosition();
  }
  return me.position;
}, getSize:function() {
  var element = this.getElement(), size, dom;
  if (element && !element.destroyed) {
    dom = element.dom;
    size = {x:dom.scrollWidth, y:dom.scrollHeight};
  } else {
    size = {x:0, y:0};
  }
  return size;
}, getMaxPosition:function() {
  var element = this.getElement(), x = 0, y = 0, dom;
  if (element && !element.destroyed) {
    dom = element.dom;
    x = dom.scrollWidth - dom.clientWidth;
    y = dom.scrollHeight - dom.clientHeight;
  }
  return {x:x, y:y};
}, getMaxUserPosition:function() {
  var me = this, element = me.getElement(), x = 0, y = 0, dom;
  if (element && !element.destroyed) {
    dom = element.dom;
    if (me.getX()) {
      x = dom.scrollWidth - dom.clientWidth;
    }
    if (me.getY()) {
      y = dom.scrollHeight - dom.clientHeight;
    }
  }
  return {x:x, y:y};
}, refresh:function() {
  this.positionDirty = true;
  this.fireEvent('refresh', this);
  return this;
}, removePartner:function(partner) {
  var partners = this._partners, otherPartners = partner._partners;
  if (partners) {
    delete partners[partner.getId()];
  }
  if (otherPartners) {
    delete otherPartners[this.getId()];
  }
}, scrollBy:function(deltaX, deltaY, animate) {
  var position = this.getPosition();
  if (deltaX) {
    if (deltaX.length) {
      animate = deltaY;
      deltaY = deltaX[1];
      deltaX = deltaX[0];
    } else {
      if (typeof deltaX !== 'number') {
        animate = deltaY;
        deltaY = deltaX.y;
        deltaX = deltaX.x;
      }
    }
  }
  deltaX = typeof deltaX === 'number' ? deltaX + position.x : null;
  deltaY = typeof deltaY === 'number' ? deltaY + position.y : null;
  return this.doScrollTo(deltaX, deltaY, animate);
}, ensureVisible:function(el, options) {
  var me = this, position = me.getPosition(), highlight, newPosition, ret;
  if (el) {
    if (el && el.element && !el.isElement) {
      options = el;
      el = options.element;
    }
    options = options || {};
    highlight = options.highlight;
    newPosition = me.getEnsureVisibleXY(el, options);
    if (newPosition.y !== position.y || newPosition.x !== position.x) {
      if (highlight) {
        me.on({scrollend:'doHighlight', scope:me, single:true, args:[el, highlight]});
      }
      ret = me.doScrollTo(newPosition.x, newPosition.y, options.animation);
    } else {
      if (highlight) {
        me.doHighlight(el, highlight);
      }
      ret = Ext.Deferred.getCachedResolved();
    }
  } else {
    ret = Ext.Deferred.getCachedRejected();
  }
  return ret;
}, scrollIntoView:function(el, hscroll, animate, highlight) {
  return this.ensureVisible(el, {animation:animate, highlight:highlight, x:hscroll});
}, isInView:function(el) {
  return this.doIsInView(el);
}, scrollTo:function(x, y, animation) {
  var maxPosition;
  if (x) {
    if (x.length) {
      animation = y;
      y = x[1];
      x = x[0];
    } else {
      if (typeof x !== 'number') {
        animation = y;
        y = x.y;
        x = x.x;
      }
    }
  }
  if (x < 0 || y < 0) {
    maxPosition = this.getMaxPosition();
    if (x < 0) {
      x += maxPosition.x;
    }
    if (y < 0) {
      y += maxPosition.y;
    }
  }
  return this.doScrollTo(x, y, animation);
}, updateDirection:function(direction) {
  var me = this, x, y;
  if (!direction) {
    x = me.getX();
    y = me.getY();
    if (x && y) {
      direction = y === 'scroll' && x === 'scroll' ? 'both' : 'auto';
    } else {
      if (y) {
        direction = 'vertical';
      } else {
        if (x) {
          direction = 'horizontal';
        }
      }
    }
    me._direction = direction;
  } else {
    if (direction === 'auto') {
      x = true;
      y = true;
    } else {
      if (direction === 'vertical') {
        x = false;
        y = true;
      } else {
        if (direction === 'horizontal') {
          x = true;
          y = false;
        } else {
          if (direction === 'both') {
            x = 'scroll';
            y = 'scroll';
          }
        }
      }
    }
    me.setX(x);
    me.setY(y);
  }
}, updateScrollbars:function(scrollbars, oldScrollbars) {
  this.syncScrollbarCls();
}, updateSize:function(size) {
  var me = this, element = me.getElement(), x = size.x, y = size.y, spacer;
  if (element) {
    me.positionDirty = true;
    spacer = me.getSpacer();
    if (!x && !y) {
      spacer.hide();
    } else {
      if (x > 0) {
        x -= 1;
      }
      if (y > 0) {
        y -= 1;
      }
      me.setSpacerXY({x:x, y:y});
      spacer.show();
    }
  }
}, updateMsSnapInterval:function() {
  this.initMsSnapInterval();
}, updateSnapSelector:function() {
  this.initSnap();
}, updateSnapOffset:function() {
  this.initSnap();
}, updateTouchAction:function(touchAction) {
  var element = this.getElement();
  if (element) {
    element.setTouchAction(touchAction);
  }
}, updateElement:function(element, oldElement) {
  var me = this, touchAction = me.getTouchAction(), scrollListener = me.scrollListener, elementCls = me.elementCls, eventSource, scrollEl;
  if (scrollListener) {
    scrollListener.destroy();
    me.scrollListener = null;
    me.setScrollElement(null);
  }
  if (oldElement && !oldElement.destroyed) {
    oldElement.setStyle('overflow', 'hidden');
    oldElement.removeCls(elementCls);
  }
  if (element) {
    if (element.dom === document.documentElement || element.dom === document.body) {
      eventSource = Ext.getWin();
      scrollEl = Ext.scroll.Scroller.getScrollingElement();
    } else {
      scrollEl = eventSource = element;
    }
    me.setScrollElement(Ext.get(scrollEl));
    me.scrollListener = eventSource.on({scroll:me.onDomScroll, scope:me, destroyable:true});
    if (touchAction) {
      element.setTouchAction(touchAction);
    }
    me.initXStyle();
    me.initYStyle();
    element.addCls(elementCls);
    me.initSnap();
    me.initMsSnapInterval();
    me.syncScrollbarCls();
  }
}, updateX:function(x) {
  this.initXStyle();
}, updateY:function(y) {
  this.initYStyle();
}, deprecated:{5:{methods:{getScroller:function() {
  return this;
}}}, '5.1.0':{methods:{scrollToTop:function(animate) {
  return this.scrollTo(0, 0, animate);
}, scrollToEnd:function(animate) {
  return this.scrollTo(Infinity, Infinity, animate);
}}}}, privates:{axisConfigs:{x:{x:true}, y:{y:true}, both:{x:true, y:true}}, getEnsureVisibleXY:function(el, options) {
  var position = this.getPosition(), viewport = this.component ? this.component.getScrollableClientRegion() : this.getElement(), newPosition, align;
  if (el && el.element && !el.isElement) {
    options = el;
    el = options.element;
  }
  options = options || {};
  align = options.align;
  if (align) {
    if (Ext.isString(align)) {
      align = {x:options.x === false ? null : align, y:options.y === false ? null : align};
    } else {
      if (Ext.isObject(align)) {
        if (align.x && options.x === false) {
          align.x = null;
        }
        if (align.y && options.y === false) {
          align.y = null;
        }
      }
    }
  }
  newPosition = Ext.fly(el).getScrollIntoViewXY(viewport, position.x, position.y, align);
  newPosition.x = options.x === false ? position.x : newPosition.x;
  newPosition.y = options.y === false ? position.y : newPosition.y;
  return newPosition;
}, getSpacer:function() {
  var me = this, spacer = me._spacer, element;
  if (!spacer) {
    element = me.getElement();
    spacer = me._spacer = element.createChild({cls:me.spacerCls, role:'presentation'}, element.dom.firstChild);
    spacer.setVisibilityMode(2);
    spacer.hide();
    element.position();
  }
  return spacer;
}, applySpacerXY:function(pos, oldPos) {
  if (oldPos && pos.x === oldPos.x && pos.y === oldPos.y) {
    pos = undefined;
  }
  return pos;
}, updateSpacerXY:function(pos) {
  var me = this, spacer = me.getSpacer(), sStyle = spacer.dom.style, scrollHeight = pos.y, shortfall;
  sStyle.marginTop = '';
  me.translateSpacer(pos.x, me.constrainScrollRange(scrollHeight));
  sStyle.lineHeight = Number(!parseInt(sStyle.lineHeight, 10)) + 'px';
  if (scrollHeight > 1000000) {
    shortfall = scrollHeight - me.getElement().dom.scrollHeight;
    if (shortfall > 0) {
      sStyle.marginTop = Math.min(shortfall, me.maxSpacerMargin || 0) + 'px';
    }
  }
}, translateSpacer:function(x, y) {
  this.getSpacer().translate(x, y);
}, doIsInView:function(el, skipCheck) {
  var me = this, c = me.component, result = {x:false, y:false}, elRegion, myEl = me.getElement(), myElRegion;
  if (el && (skipCheck || (myEl.contains(el) || c && c.owns(el)))) {
    myElRegion = myEl.getRegion();
    elRegion = Ext.fly(el).getRegion();
    result.x = elRegion.right > myElRegion.left && elRegion.left < myElRegion.right;
    result.y = elRegion.bottom > myElRegion.top && elRegion.top < myElRegion.bottom;
  }
  return result;
}, contains:function(component) {
  var el = this.getElement(), owner = component;
  while (owner && owner !== Ext.Viewport) {
    if (el.contains(owner.el)) {
      return true;
    }
    owner = owner.getRefOwner();
  }
  return false;
}, constrainScrollRange:function(scrollRange) {
  if (scrollRange < 1000000) {
    return scrollRange;
  }
  if (!this.maxSpacerTranslate) {
    var maxScrollHeight = Math.pow(2, 32), tooHigh = maxScrollHeight, tooLow = 500, scrollTest = Ext.getBody().createChild({style:{position:'absolute', left:'-10000px', top:'0', width:'500px', height:'500px'}, cn:{cls:this.spacerCls}}, null, true), stretcher = Ext.get(scrollTest.firstChild), sStyle = stretcher.dom.style;
    stretcher.translate(0, maxScrollHeight - 1);
    sStyle.lineHeight = Number(!parseInt(sStyle.lineHeight, 10)) + 'px';
    while (tooHigh !== tooLow + 1) {
      stretcher.translate(0, maxScrollHeight = tooLow + Math.floor((tooHigh - tooLow) / 2));
      sStyle.lineHeight = Number(!parseInt(sStyle.lineHeight, 10)) + 'px';
      if (scrollTest.scrollHeight < maxScrollHeight) {
        tooHigh = maxScrollHeight;
      } else {
        tooLow = maxScrollHeight;
      }
    }
    stretcher.translate(0, Ext.scroll.Scroller.prototype.maxSpacerTranslate = tooLow);
    tooHigh = tooLow * 2;
    while (tooHigh !== tooLow + 1) {
      stretcher.dom.style.marginTop = (maxScrollHeight = tooLow + Math.floor((tooHigh - tooLow) / 2)) + 'px';
      sStyle.lineHeight = Number(!parseInt(sStyle.lineHeight, 10)) + 'px';
      if (scrollTest.scrollHeight < maxScrollHeight) {
        tooHigh = maxScrollHeight;
      } else {
        tooLow = maxScrollHeight;
      }
    }
    Ext.fly(scrollTest).destroy();
    Ext.scroll.Scroller.prototype.maxSpacerMargin = tooLow - Ext.scroll.Scroller.prototype.maxSpacerTranslate;
  }
  return Math.min(scrollRange, this.maxSpacerTranslate);
}, convertX:function(x) {
  return x;
}, doHighlight:function(el, highlight) {
  if (highlight !== true) {
    Ext.fly(el).highlight(highlight);
  } else {
    Ext.fly(el).highlight();
  }
}, doScrollTo:function(x, y, animate) {
  var me = this, element = me.getScrollElement(), maxPosition, dom, xInf, yInf, ret, translatable, deferred;
  if (element && !element.destroyed) {
    dom = element.dom;
    xInf = x === Infinity;
    yInf = y === Infinity;
    if (xInf || yInf) {
      maxPosition = me.getMaxPosition();
      if (xInf) {
        x = maxPosition.x;
      }
      if (yInf) {
        y = maxPosition.y;
      }
    }
    if (x !== null) {
      x = me.convertX(x);
    }
    if (animate) {
      translatable = me.translatable;
      if (!translatable) {
        me.translatable = translatable = new Ext.util.translatable.ScrollPosition({element:element});
      }
      deferred = new Ext.Deferred;
      translatable.on('animationend', function() {
        if (me.destroyed) {
          deferred.reject();
        } else {
          deferred.resolve();
        }
      }, Ext.global, {single:true, onFrame:true});
      translatable.translate(x, y, animate);
      ret = deferred.promise;
    } else {
      if (y != null) {
        dom.scrollTop = y;
      }
      if (x != null) {
        dom.scrollLeft = x;
      }
      ret = Ext.Deferred.getCachedResolved();
    }
    me.positionDirty = true;
  } else {
    ret = Ext.Deferred.getCachedRejected();
  }
  return ret;
}, fireScrollStart:function(x, y, xDelta, yDelta) {
  var me = this, component = me.component;
  me.invokePartners('onPartnerScrollStart', x, y, xDelta, yDelta);
  me.startX = x - xDelta;
  me.startY = y - yDelta;
  if (me.hasListeners.scrollstart) {
    me.fireEvent('scrollstart', me, x, y);
  }
  if (component && component.onScrollStart) {
    component.onScrollStart(x, y);
  }
  Ext.GlobalEvents.fireEvent('scrollstart', me, x, y);
}, fireScroll:function(x, y, xDelta, yDelta) {
  var me = this, component = me.component;
  me.invokePartners('onPartnerScroll', x, y, xDelta, yDelta);
  if (me.hasListeners.scroll) {
    me.fireEvent('scroll', me, x, y, xDelta, yDelta);
  }
  if (component && component.onScrollMove) {
    component.onScrollMove(x, y);
  }
  Ext.GlobalEvents.fireEvent('scroll', me, x, y, xDelta, yDelta);
}, fireScrollEnd:function(x, y, xDelta, yDelta) {
  var me = this, component = me.component, dx = x - me.startX, dy = y - me.startY;
  me.startX = me.startY = null;
  me.invokePartners('onPartnerScrollEnd', x, y, xDelta, yDelta);
  if (me.hasListeners.scrollend) {
    me.fireEvent('scrollend', me, x, y, dx, dy);
  }
  if (component && component.onScrollEnd) {
    component.onScrollEnd(x, y);
  }
  Ext.GlobalEvents.fireEvent('scrollend', me, x, y, dx, dy);
}, getElementScroll:function(element) {
  return element.getScroll();
}, initSnap:function() {
  var me = this, snapOffset = me.getSnapOffset(), snapSelector = me.getSnapSelector(), element = me.getElement(), offsetX, offsetY, snapCoordinate;
  if (element && snapSelector) {
    element.addCls(me.snappableCls);
    me.removeSnapStylesheet();
    if (snapOffset) {
      offsetX = snapOffset.x || 0;
      offsetY = snapOffset.y || 0;
      if (offsetX) {
        offsetX = -offsetX + 'px';
      }
      if (offsetY) {
        offsetY = -offsetY + 'px';
      }
    }
    snapCoordinate = offsetX + ' ' + offsetY + ';';
    me.snapStylesheet = Ext.util.CSS.createStyleSheet('#' + element.id + ' ' + snapSelector + '{-webkit-scroll-snap-coordinate:' + snapCoordinate + 'scroll-snap-coordinate:' + snapCoordinate + '}');
  }
}, initMsSnapInterval:function() {
  var element = this.getElement(), interval, x, y, style;
  if (element) {
    interval = this.getMsSnapInterval();
    if (interval) {
      x = interval.x;
      y = interval.y;
      style = element.dom.style;
      if (x) {
        style['-ms-scroll-snap-points-x'] = 'snapInterval(0px, ' + x + 'px)';
      }
      if (y) {
        style['-ms-scroll-snap-points-y'] = 'snapInterval(0px, ' + y + 'px)';
      }
    }
  }
}, initXStyle:function() {
  var element = this.getElement(), x = this.getX();
  if (element && element.dom) {
    if (!x) {
      x = 'hidden';
    } else {
      if (x === true) {
        x = 'auto';
      }
    }
    element.setStyle('overflow-x', x);
  }
}, initYStyle:function() {
  var element = this.getElement(), y = this.getY();
  if (element && element.dom) {
    if (!y) {
      y = 'hidden';
    } else {
      if (y === true) {
        y = 'auto';
      }
    }
    element.setStyle('overflow-y', y);
  }
}, invokePartners:function(method, x, y, xDelta, yDelta) {
  var me = this, partners = me._partners, partner, id, axes;
  if (!me.suspendSync) {
    me.invokingPartners = true;
    for (id in partners) {
      axes = partners[id].axes;
      partner = partners[id].scroller;
      if (!partner.invokingPartners && (xDelta && axes.x || yDelta && axes.y)) {
        partner[method](me, axes.x ? x : null, axes.y ? y : null, xDelta, yDelta);
      }
    }
    me.invokingPartners = false;
  }
}, suspendPartnerSync:function() {
  this.suspendSync = (this.suspendSync || 0) + 1;
}, resumePartnerSync:function(syncNow) {
  var me = this, position;
  if (me.suspendSync) {
    me.suspendSync--;
  }
  if (!me.suspendSync && syncNow) {
    position = me.getPosition();
    me.invokePartners('onPartnerScroll', position.x, position.y);
    me.invokePartners('onPartnerScrollEnd', position.x, position.y);
  }
}, readPosition:function(position) {
  var me = this, element = me.getScrollElement(), elScroll;
  position = position || {};
  if (element && !element.destroyed) {
    elScroll = me.getElementScroll(element);
    position.x = elScroll.left;
    position.y = elScroll.top;
  }
  return position;
}, updateDomScrollPosition:function(silent) {
  var me = this, position = me.position, oldX = position.x, oldY = position.y, x, y, xDelta, yDelta;
  me.readPosition(position);
  x = position.x;
  y = position.y;
  me.positionDirty = false;
  if (!silent) {
    xDelta = x - oldX;
    yDelta = y - oldY;
    if (xDelta || yDelta) {
      if (!me.isScrolling) {
        me.isScrolling = Ext.isScrolling = true;
        me.fireScrollStart(x, y, xDelta, yDelta);
      }
      me.fireScroll(x, y, xDelta, yDelta);
      me.onDomScrollEnd(x, y, xDelta, yDelta);
    }
  }
  return position;
}, syncWithPartners:function() {
  var me = this, partners = me._partners, id, partner, position;
  me.suspendPartnerSync();
  for (id in partners) {
    partner = partners[id].scroller;
    position = partner.getPosition();
    me.onPartnerScroll(partner, position.x, position.y);
  }
  me.resumePartnerSync();
}, syncScrollbarCls:function() {
  var element = this.getElement();
  if (element) {
    element.toggleCls(this.noScrollbarsCls, this.getScrollbars() === false);
  }
}, onDomScroll:function() {
  var hasTimer = !!this.restoreTimer;
  this.updateDomScrollPosition(hasTimer);
  if (hasTimer) {
    Ext.undefer(this.onDomScrollEnd.timer);
    return;
  }
}, doOnDomScrollEnd:function(x, y, xDelta, yDelta) {
  var me = this;
  if (me.destroying || me.destroyed) {
    return;
  }
  me.isScrolling = Ext.isScrolling = false;
  if (x === undefined) {
    return;
  }
  me.trackingScrollLeft = x;
  me.trackingScrollTop = y;
  me.fireScrollEnd(x, y, xDelta, yDelta);
}, onPartnerScrollStart:function(partner, x, y, xDelta, yDelta) {
  this.isScrolling = true;
  this.fireScrollStart(x, y, xDelta, yDelta);
}, onPartnerScroll:function(partner, x, y, xDelta, yDelta) {
  this.doScrollTo(x, y, false);
  this.updateDomScrollPosition(true);
  this.fireScroll(x, y, xDelta, yDelta);
}, onPartnerScrollEnd:function(partner, x, y, xDelta, yDelta) {
  this.cancelOnDomScrollEnd();
  this.doOnDomScrollEnd(x, y, xDelta, yDelta);
}, removeSnapStylesheet:function() {
  var stylesheet = this.snapStylesheet;
  if (stylesheet) {
    Ext.util.CSS.removeStyleSheet(stylesheet);
    this.snapStylesheet = null;
  }
}, restoreState:function() {
  var me = this, el = me.getScrollElement();
  if (el) {
    if (me.trackingScrollTop !== undefined) {
      if (!me.restoreTimer) {
        me.restoreTimer = Ext.defer(function() {
          me.restoreTimer = null;
        }, 50);
      }
      me.doScrollTo(me.trackingScrollLeft, me.trackingScrollTop, false);
    }
  }
}}}, function(Scroller) {
  Ext.getViewportScroller = function() {
    var scroller = Scroller.viewport;
    if (!scroller) {
      Scroller.viewport = scroller = new Scroller;
      Scroller.initViewportScroller();
    }
    return scroller;
  };
  Ext.setViewportScroller = function(scroller) {
    if (Scroller.viewport !== scroller) {
      Ext.destroy(Scroller.viewport);
      if (scroller && !scroller.isScroller) {
        scroller = new Scroller(scroller);
      }
      Scroller.viewport = scroller;
    }
  };
  Ext.onReady(function() {
    Scroller.initViewportScrollerTimer = Ext.defer(Scroller.initViewportScroller, 100);
  });
});
Ext.define('Ext.Component', {extend:Ext.Widget, alternateClassName:['Ext.lib.Component', 'Ext.Gadget'], xtype:'component', cachedConfig:{margin:null, padding:null, tabIndex:null}, eventedConfig:{left:null, top:null, right:null, bottom:null, minWidth:null, minHeight:null, maxWidth:null, maxHeight:null, scrollable:null, docked:null, centered:{lazy:true, $value:null}}, config:{displayed:null, html:null, draggable:null, zIndex:null, tpl:null, enterAnimation:null, exitAnimation:null, showAnimation:null, 
hideAnimation:null, tplWriteMode:'overwrite', data:null, contentEl:null, record:null, tooltip:null, axisLock:null, modal:{lazy:true, $value:null}, hideOnMaskTap:null, weight:null, userSelectable:null}, modelValidation:null, defaultBindProperty:'html', isComponent:true, positioned:false, rendered:false, activeAnimation:null, dockPositions:{top:true, right:true, bottom:true, left:true}, bodyElement:null, classCls:Ext.baseCSSPrefix + 'component', floatingCls:Ext.baseCSSPrefix + 'floating', hiddenCls:Ext.baseCSSPrefix + 
'hidden', _scrollableCfg:{x:{x:true, y:false}, y:{x:false, y:true}, horizontal:{x:true, y:false}, vertical:{x:false, y:true}, both:{x:true, y:true}, 'true':{x:true, y:true}, 'false':{x:false, y:false}}, statics:{from:function(el, limit, selector) {
  return Ext.ComponentManager.from(el, limit, selector);
}, fromElement:function(el, limit, selector) {
  return Ext.ComponentManager.from(el, limit, selector);
}}, initialConfig:null, $initParent:null, userSelectableClsMap:{'true':Ext.baseCSSPrefix + 'user-selectable-auto', 'false':Ext.baseCSSPrefix + 'user-selectable-none', all:Ext.baseCSSPrefix + 'user-selectable-all', auto:Ext.baseCSSPrefix + 'user-selectable-auto', text:Ext.baseCSSPrefix + 'user-selectable-text', none:Ext.baseCSSPrefix + 'user-selectable-none'}, constructor:function(config) {
  var me = this, VP = Ext['Viewport'], renderTo = config && config.renderTo, hasListeners, hasResize, el;
  me.lastSize = {};
  me.onInitializedListeners = [];
  if (config) {
    me.initialConfig = config;
    me.$initParent = config.$initParent;
    if (me.activatePlugin('responsive')) {
      config = me.initialConfig;
    }
  }
  if (renderTo) {
    config = Ext.apply({}, config);
    delete config.renderTo;
  }
  me.callParent([config]);
  el = me.el;
  if (!me.getRefOwner()) {
    el.addCls(me.rootCls);
  }
  me.refreshPositioned = me.doRefreshPositioned;
  if (me.refreshPositionedOnInitialized) {
    me.refreshPositioned();
  }
  me.initialize();
  me.triggerInitialized();
  if (me.isCentered()) {
    me.center();
  }
  hasListeners = me.hasListeners;
  hasResize = hasListeners.resize;
  if (me.hasListeners.painted) {
    el.on('painted', 'handleElementPainted', me);
  }
  if ((hasResize || me.onResize) && !me.isViewport) {
    if (!hasResize) {
      hasListeners._incr_('resize');
    }
    el.on({scope:me, resize:'handleElementResize', priority:1000});
  }
  if (me.fullscreen && VP) {
    VP.setItemFullScreen(me);
  }
  me.fireEvent('initialize', me);
  if (renderTo) {
    me.setRenderTo(renderTo);
  }
}, beforeInitConfig:function(config) {
  this.beforeInitialize.apply(this, arguments);
}, beforeInitialize:Ext.emptyFn, initialize:Ext.emptyFn, center:function() {
  var me = this, parent = me.getParent(), parentBox, translateXY, xy, size;
  if ((!parent || parent.rendered) && me.shouldRecenter()) {
    translateXY = !!parent;
    parent = parent ? parent.bodyElement : Ext.getBody();
    parentBox = parent.getConstrainRegion();
    size = me.measure();
    xy = [(parentBox.getWidth() - size.width) / 2, (parentBox.getHeight() - size.height) / 2];
    me.needsCenter = false;
    me._centering = true;
    if (me.getFloated()) {
      if (translateXY) {
        xy = parent.reverseTranslateXY(xy);
      }
      me.setXY(xy);
    } else {
      me.setLeft(xy[0]);
      me.setTop(xy[1]);
    }
    me._centering = false;
  } else {
    me.needsCenter = true;
  }
  return me;
}, shouldRecenter:function() {
  return this.rendered && !this.$isShowing && (this.el.isVisible() || this.el.getVisibilityMode() !== Ext.Element.DISPLAY);
}, getModalSibling:function() {
  var me = this, floatRoot = Ext.getFloatRoot().dom, parentWrap, parentContainer, childNodes, c, i;
  for (parentWrap = me.floatParentNode && me.floatParentNode.dom; parentWrap; parentWrap = parentWrap === floatRoot || parentContainer.getRelative() ? null : parentWrap.parentNode) {
    parentContainer = Ext.fly(parentWrap).getData().component;
    childNodes = parentWrap.childNodes;
    for (i = childNodes ? childNodes.length : 0; i-- > 0;) {
      c = Ext.fly(childNodes[i]);
      if (c.hasCls(me.floatWrapCls)) {
        c = c.getData().component;
        if (c && c !== me && c.isVisible() && c.getModal()) {
          return c;
        }
      }
    }
  }
  return null;
}, triggerInitialized:function() {
  var listeners = this.onInitializedListeners, ln = listeners.length, listener, fn, scope, args, i;
  if (!this.initialized) {
    this.initialized = true;
    if (ln > 0) {
      for (i = 0; i < ln; i++) {
        listener = listeners[i];
        fn = listener.fn;
        scope = listener.scope;
        args = listener.args;
        if (typeof fn == 'string') {
          scope[fn].apply(scope, args);
        } else {
          fn.apply(scope, args);
        }
      }
      listeners.length = 0;
    }
  }
}, onInitialized:function(fn, scope, args) {
  var listeners = this.onInitializedListeners;
  if (!scope) {
    scope = this;
  }
  if (this.initialized) {
    if (typeof fn == 'string') {
      scope[fn].apply(scope, args);
    } else {
      fn.apply(scope, args);
    }
  } else {
    listeners.push({fn:fn, scope:scope, args:args});
  }
}, initElement:function() {
  var me = this;
  me.callParent();
  if (!me.bodyElement) {
    me.bodyElement = me.element;
  }
  me.innerElement = me.innerElement || me.bodyElement;
}, initInheritedState:function(inheritedState) {
  var me = this;
  if (me.modelValidation !== null) {
    inheritedState.modelValidation = me.modelValidation;
  }
  me.callParent([inheritedState]);
}, applyScrollable:function(scrollable, oldScrollable) {
  var me = this;
  if (typeof scrollable === 'boolean' || typeof scrollable === 'string') {
    if (!me._scrollableCfg[scrollable]) {
      Ext.raise("'" + scrollable + "' is not a valid value for 'scrollable'");
    }
    scrollable = me._scrollableCfg[scrollable];
  }
  return Ext.Factory.scroller.update(oldScrollable, scrollable, this, 'createScrollable');
}, applyHidden:function(hidden) {
  if (!hidden && this.isConfiguring && this.getFloated()) {
    this.preprocessShow();
  }
  return !!hidden;
}, createScrollable:function(defaults) {
  return Ext.apply({component:this, element:this.getScrollerTarget()}, defaults);
}, getScrollerTarget:function() {
  return this.bodyElement;
}, getScrollableClientRegion:function() {
  return this.getScrollerTarget().getClientRegion();
}, updatePadding:function(padding) {
  this.bodyElement.setPadding(padding);
}, updateMargin:function(margin) {
  this.element.setMargin(margin);
}, updateWeight:function(weight, oldWeight) {
  var me = this, owner = !me.isConfiguring && me.getRefOwner();
  me.weight = weight;
  if (owner && owner.onItemWeightChange) {
    owner.onItemWeightChange(me, weight, oldWeight);
  }
}, applyContentEl:function(contentEl) {
  if (contentEl) {
    return Ext.get(contentEl);
  }
}, updateContentEl:function(newContentEl, oldContentEl) {
  if (oldContentEl) {
    oldContentEl.hide();
    Ext.getBody().append(oldContentEl);
  }
  if (newContentEl) {
    this.setHtml(newContentEl.dom);
    newContentEl.show();
  }
}, createTranslatable:function(config) {
  var me = this, ret = me.callParent([config]);
  if (config && !config.type && me.getFloated()) {
    ret.type = 'csstransform';
  }
  return ret;
}, isCentered:function() {
  return Boolean(this.getCentered());
}, isPositioned:function() {
  return this.positioned;
}, isDocked:function() {
  return Boolean(this.getDocked());
}, applyTop:function(top) {
  return this.filterLengthValue(top);
}, applyRight:function(right) {
  return this.filterLengthValue(right);
}, applyBottom:function(bottom) {
  return this.filterLengthValue(bottom);
}, applyLeft:function(left) {
  return this.filterLengthValue(left);
}, applyMinWidth:function(width) {
  return this.filterLengthValue(width);
}, applyMinHeight:function(height) {
  return this.filterLengthValue(height);
}, applyMaxWidth:function(width) {
  return this.filterLengthValue(width);
}, applyMaxHeight:function(height) {
  return this.filterLengthValue(height);
}, updateTop:function(top) {
  if (!this.$updatingXY) {
    this.element.setTop(top);
  }
  this.refreshPositioned();
}, updateRight:function(right) {
  if (!this.$updatingXY) {
    this.element.setRight(right);
  }
  this.refreshPositioned();
}, updateBottom:function(bottom) {
  if (!this.$updatingXY) {
    this.element.setBottom(bottom);
  }
  this.refreshPositioned();
}, updateLeft:function(left) {
  if (!this.$updatingXY) {
    this.element.setLeft(left);
  }
  this.refreshPositioned();
}, onResize:null, updateMinWidth:function(width) {
  this.element.setMinWidth(width);
}, updateMinHeight:function(height) {
  this.element.setMinHeight(height);
}, updateMaxWidth:function(width) {
  this.element.setMaxWidth(width);
}, updateMaxHeight:function(height) {
  this.element.setMaxHeight(height);
}, applyCentered:function(centered) {
  var me = this, doCenter = me.getLeft() === null && me.getRight() === null && me.getTop() === null && me.getBottom() === null;
  if (doCenter) {
    return !!centered;
  }
}, updateCentered:function(centered) {
  var me = this, resizeParent;
  if (me.getFloated()) {
    if (centered) {
      me.center();
      if (!me.centerResizeListener && !me.needsCenter) {
        resizeParent = me.floatParentNode;
        resizeParent = resizeParent === Ext.floatRoot ? Ext : resizeParent;
        me.centerResizeListener = resizeParent.on({resize:'center', scope:me, destroyable:true});
      }
    } else {
      me.centerResizeListener = Ext.destroy(me.centerResizeListener);
    }
  } else {
    me.el.toggleCls(me.floatingCls, centered);
    if (centered) {
      me.refreshInnerState = Ext.emptyFn;
      if (me.isContainer && (!me.isWidthed() || !me.isHeighted())) {
        me.setAutoSize(true);
      }
      if (me.isPositioned()) {
        me.resetPositioned();
      }
      if (me.isDocked()) {
        me.setDocked(false);
      }
      me.setIsInner(false);
      delete me.refreshInnerState;
    } else {
      me.refreshInnerState();
    }
  }
}, applyDocked:function(docked) {
  var me = this;
  if (!docked) {
    return null;
  }
  if (!/^(top|right|bottom|left)$/.test(docked)) {
    Ext.Logger.error("Invalid docking position of '" + docked.position + "', must be either 'top', 'right', 'bottom', " + "'left' or `null` (for no docking)", me);
    return;
  }
  me.refreshInnerState = Ext.emptyFn;
  if (me.isPositioned()) {
    me.resetPositioned();
  }
  if (me.isCentered()) {
    me.setCentered(false);
  }
  me.setIsInner(false);
  delete me.refreshInnerState;
  return docked;
}, getDisplayed:function() {
  return !this.getHidden();
}, setDisplayed:function(displayed) {
  var me = this, hidden = me.getHidden() !== false;
  if (displayed === hidden) {
    me._displayed = displayed;
    me.updateDisplayed(displayed, !displayed);
  }
  return me;
}, updateDisplayed:function(displayed) {
  this[displayed ? 'show' : 'hide']();
}, updateDocked:function(docked, oldDocked) {
  var me = this;
  if (!me.isConfiguring) {
    me.fireEvent('afterdockedchange', me, docked, oldDocked);
    if (!docked) {
      me.refreshInnerState();
    }
  }
}, updateUserSelectable:function(newSelectable, oldSelectable) {
  var me = this, map = me.userSelectableClsMap, el = me.el, name, childEl;
  if (typeof oldSelectable === 'boolean' || typeof oldSelectable === 'string') {
    el.removeCls(map[oldSelectable]);
  } else {
    for (name in oldSelectable) {
      childEl = me[name];
      if (!childEl || !childEl.isElement) {
        Ext.raise('Element not found: "' + name + '"');
      }
      childEl.removeCls(map[oldSelectable[name]]);
    }
  }
  if (typeof newSelectable === 'boolean' || typeof newSelectable === 'string') {
    el.addCls(map[newSelectable]);
  } else {
    for (name in newSelectable) {
      childEl = me[name];
      if (!childEl || !childEl.isElement) {
        Ext.raise('Element not found: "' + name + '"');
      }
      childEl.addCls(map[newSelectable[name]]);
    }
  }
}, resetPositioned:function() {
  var me = this;
  me.setTop(null);
  me.setRight(null);
  me.setBottom(null);
  me.setLeft(null);
}, refreshPositioned:function() {
  this.refreshPositionedOnInitialized = true;
}, doRefreshPositioned:function() {
  var me = this, positioned = !me.getConfig('floated', false, true) && (me.getTop() !== null || me.getBottom() !== null || me.getRight() !== null || me.getLeft() !== null);
  if (positioned !== this.positioned) {
    me.positioned = positioned;
    if (positioned) {
      me.refreshInnerState = Ext.emptyFn;
      if (me.isContainer && (!me.isWidthed() || !me.isHeighted())) {
        me.setAutoSize(true);
      }
      if (me.isCentered()) {
        me.setCentered(false);
      }
      if (me.isDocked()) {
        me.setDocked(false);
      }
      me.setIsInner(false);
      delete me.refreshInnerState;
    }
    me.element.toggleCls(me.floatingCls, positioned);
    if (me.initialized) {
      me.fireEvent('floatingchange', me, positioned);
      me.fireEvent('positionedchange', me, positioned);
    }
    if (!positioned) {
      me.refreshInnerState();
    }
  }
}, applyZIndex:function(zIndex) {
  if (!zIndex && zIndex !== 0) {
    zIndex = null;
  }
  if (zIndex !== null) {
    zIndex = Number(zIndex);
    if (isNaN(zIndex)) {
      zIndex = null;
    }
  }
  return zIndex;
}, updateZIndex:function(zIndex) {
  var element = this.element, modal = !this.getFloated() && this.getModal(), domStyle;
  if (element && !element.destroyed) {
    domStyle = element.dom.style;
    if (zIndex !== null) {
      domStyle.setProperty('z-index', zIndex, 'important');
    } else {
      domStyle.removeProperty('z-index');
    }
  }
  if (modal && !modal.destroyed) {
    modal.setZIndex(zIndex - 1);
  }
}, getInnerHtmlElement:function() {
  var me = this, innerHtmlElement = me.innerHtmlElement;
  if (!innerHtmlElement || !innerHtmlElement.dom || !innerHtmlElement.dom.parentNode) {
    me.innerHtmlElement = innerHtmlElement = Ext.Element.create({cls:Ext.baseCSSPrefix + 'innerhtml'});
    me.getRenderTarget().appendChild(innerHtmlElement);
  }
  return innerHtmlElement;
}, updateHtml:function(html) {
  if (!this.destroyed) {
    var innerHtmlElement = this.getInnerHtmlElement();
    if (Ext.isElement(html)) {
      innerHtmlElement.setHtml('');
      innerHtmlElement.append(html);
    } else {
      innerHtmlElement.setHtml(html);
    }
  }
}, updateHidden:function(hidden, oldHidden) {
  var me = this, element = me.renderElement, modal = me.getModal(), name;
  if (me.rendered) {
    if (modal && !modal.destroyed) {
      if (me.getFloated()) {
        if (hidden) {
          modal = me.getModalSibling();
          if (modal) {
            modal.showModalMask();
          } else {
            me.hideModalMask();
          }
        } else {
          me.showModalMask();
        }
      } else {
        if (modal !== true) {
          modal.setZIndex(me.getZIndex() - 1);
          if (modal.getHidden() !== hidden) {
            modal.setHidden(hidden);
          }
        }
      }
    }
    if (!me.destroying && element && !element.destroyed) {
      element.toggleCls(me.hiddenCls, hidden);
    }
    me.callParent([hidden, oldHidden]);
  } else {
    element.toggleCls(me.hiddenCls, hidden);
    me.callParent([hidden, oldHidden]);
  }
  if (!me.isConfiguring && !me.destroying) {
    name = hidden ? 'hide' : 'show';
    if (me.hasListeners[name]) {
      me.fireEvent(name, me);
    }
    me[hidden ? 'afterHide' : 'afterShow'](me);
  }
}, hide:function(animation) {
  var me = this, activeAnim = me.activeAnimation, modal;
  if (me.isVisible()) {
    if (me.hasListeners.beforehide && me.fireEvent('beforehide', me) === false) {
      return;
    }
    if (me.beforeHide() === false) {
      return;
    }
    me.viewportResizeListener = Ext.destroy(me.viewportResizeListener);
    me.setCurrentAlignmentInfo(null);
    if (activeAnim) {
      activeAnim.on({animationend:function() {
        me.hide(animation);
      }, single:true});
      return me;
    }
    if (!me.getHidden()) {
      if (animation === undefined || animation && !Ext.isObject(animation)) {
        animation = me.getHideAnimation();
      }
      if (animation) {
        me.on({beforehiddenchange:'onBeforeHiddenChange', scope:me, single:true, args:[animation]});
      }
      me.setHidden(true);
    }
    if (!me.getFloated()) {
      modal = me.getModal();
      if (modal && modal !== true && !modal.destroyed) {
        modal.setHidden(true);
      }
    }
  } else {
    me.setHidden(true);
  }
  return me;
}, preprocessShow:function(component, alignment, options) {
  var me = this, hideMode = me.getHideMode(), hidden;
  if (me.isContainer) {
    me.getItems();
  }
  me.getHtml();
  if (me.getFloated()) {
    hidden = (!hideMode || hideMode === 'display') && me.getHidden();
    if (me.rendered) {
      if (hidden) {
        me.setVisibility(true);
        me._hidden = false;
      }
    } else {
      hidden = hidden !== false;
      me.findFloatParent(hidden);
    }
    if (component) {
      me.notifyIf();
      me.alignTo(component, alignment, options);
    } else {
      if (me.isCentered()) {
        me.notifyIf();
        me.updateCentered(true);
      } else {
        me.syncXYPosition();
      }
    }
    if (me.getModal()) {
      me.showModalMask();
    }
    if (me.getToFrontOnShow()) {
      me.toFront();
    } else {
      me.syncAlwaysOnTop();
    }
    if (hidden) {
      me.setVisibility(false);
      me._hidden = true;
    }
  }
}, showBy:function(component, alignment, options) {
  var me = this, offset;
  if (Ext.isArray(options)) {
    offset = options;
    options = {offset:offset};
  }
  if (me.isVisible()) {
    me.alignTo(component, alignment, options);
  } else {
    if (!me.getFloated()) {
      if (!me.getParent()) {
        me.setFloated(true);
      } else {
        me.positioned = true;
      }
    }
    me.alignToArgs = [component, alignment, options];
    me.show({animation:true, alignment:{component:component, alignment:alignment, options:options}});
  }
}, show:function(animation, options) {
  var me = this, hidden = me.getHidden(), floated = me.getFloated(), alignment, modal;
  if (animation && typeof animation === 'object' && 'animation' in animation) {
    options = animation;
    animation = options.animation;
  } else {
    options = Ext.apply({animation:animation}, options);
  }
  if (me.hasListeners.beforeshow && me.fireEvent('beforeshow', me, options) === false) {
    return false;
  }
  if (me.beforeShow(options) === false) {
    return;
  }
  alignment = options.alignment || {};
  me.preprocessShow(alignment.component, alignment.alignment, alignment.options);
  if (me.activeAnimation) {
    if (!me.$isShowing) {
      me.activeAnimation.on({animationend:function() {
        if (!me.destroying && !me.destroyed) {
          me.show(animation, options);
        }
      }, single:true});
    }
    return me;
  }
  if (hidden || hidden === null) {
    if (animation === undefined || animation && !Ext.isObject(animation)) {
      animation = me.getShowAnimation();
    }
    if (animation && !me.isConfiguring) {
      me.on({beforehiddenchange:'onBeforeHiddenChange', scope:me, single:true, args:[animation]});
    }
    me.setHidden(false);
  }
  if (!floated) {
    modal = me.getModal();
    if (modal && modal.setHidden) {
      modal.setHidden(false);
    }
  }
  return me;
}, onAnimationStart:function(hidden, animation, data) {
  var me = this, element = me.element, fromTransform = data.from.transform, toTransform = data.to.transform;
  if (!hidden) {
    me.renderElement.show();
    element.removeCls(me.hiddenCls);
    if (me.needsCenter) {
      me.center();
    }
  }
  me.$isShowing = true;
  if (me.getFloated() && fromTransform && toTransform && !(fromTransform.translateX | toTransform.translateX | fromTransform.translateY | toTransform.translateY)) {
    fromTransform.translateX = toTransform.translateX = null;
    fromTransform.translateY = toTransform.translateY = null;
  }
}, onBeforeHiddenChange:function(animation, component, hidden, oldHidden, controller) {
  var me = this;
  if (animation && (!hidden || hidden && me.isPainted())) {
    if (!animation.isAnimation) {
      animation = hidden ? me.createHideAnimation(animation) : me.createShowAnimation(animation);
      animation = Ext.Factory.animation(animation);
    }
    me.activeAnimation = animation;
    animation.on({animationstart:'onAnimationStart', scope:me, single:true, args:[hidden]});
    if (!Ext.isEmpty(hidden)) {
      animation.setOnEnd(function() {
        me.activeAnimation = null;
        me.$isShowing = false;
        if (!me.destroyed) {
          controller.resume();
          if (me.destroying || me.destroyed) {
            return;
          }
          if (me.getFloated()) {
            me.syncXYPosition();
          }
        }
      });
      if (!hidden) {
        me._hidden = false;
      }
      controller.pause();
    }
    Ext.Animator.run(animation);
  }
}, setVisibility:function(isVisible) {
  this.renderElement.setVisible(isVisible);
}, isRendered:function() {
  return this.rendered;
}, isPainted:function() {
  return this.renderElement.isPainted();
}, applyTpl:function(tpl) {
  return Ext.XTemplate.get(tpl);
}, updateTpl:function(tpl) {
  if (!this.isConfiguring) {
    if (tpl) {
      this.doUpdateTpl();
    } else {
      this.getInnerHtmlElement().setHtml('');
    }
  }
}, applyData:function(data) {
  if (Ext.isObject(data)) {
    return Ext.apply({}, data);
  } else {
    if (!data) {
      data = {};
    }
  }
  return data;
}, updateData:function(newData) {
  var me = this;
  if (newData) {
    me.doUpdateTpl(newData);
    if (!me.isConfiguring) {
      me.fireEvent('updatedata', me, newData);
    }
  }
}, applyRecord:function(config) {
  if (config && Ext.isObject(config) && config.isModel) {
    return config;
  }
  return null;
}, updateRecord:function(newRecord, oldRecord) {
  var me = this;
  if (oldRecord) {
    oldRecord.unjoin(me);
  }
  if (!newRecord) {
    me.updateData('');
  } else {
    newRecord.join(me);
    me.doUpdateTpl(newRecord.getData(true));
  }
}, afterEdit:function() {
  this.updateRecord(this.getRecord());
}, afterErase:function() {
  this.setRecord(null);
}, getXTypes:function() {
  return this.xtypesChain.join('/');
}, applyDraggable:function(draggable, existing) {
  if (existing) {
    if (draggable) {
      existing.setConfig(draggable);
    } else {
      existing.destroy();
    }
  } else {
    if (draggable) {
      draggable = this.createDraggable(draggable);
      draggable = new Ext.drag.Source(draggable);
      if (this.initDragConstraints) {
        draggable.on('initdragconstraints', 'initDragConstraints', this);
      }
    }
  }
  return draggable;
}, createDraggable:function(draggable) {
  var me = this, listeners = draggable.listeners;
  draggable = Ext.apply({autoDestroy:false, component:me, ownerCmp:me, local:true}, draggable);
  if (listeners && listeners.scope === 'this') {
    draggable.listeners = listeners = Ext.apply({}, listeners);
    listeners.scope = me;
  }
  return draggable;
}, updateDraggable:function(dragger, existing) {
  if (existing) {
    if (dragger) {
      existing.setConfig(dragger);
    } else {
      existing.destroy();
    }
  }
}, onModalMaskTap:function(e) {
  if (this.getHideOnMaskTap()) {
    this.hide();
  }
}, translateAxis:function(axis, value, animation) {
  var x, y;
  if (axis === 'x') {
    x = value;
  } else {
    y = value;
  }
  return this.translate(x, y, animation);
}, alignTo:function(component, alignment, options) {
  var me = this;
  if (!me.viewportResizeListener) {
    me.viewportResizeListener = Ext.on({resize:'onViewportResize', scope:me, destroyable:true});
  }
  me.aligning = true;
  me.callParent([component, alignment, Ext.apply({axisLock:me.getAxisLock()}, options)]);
  me.aligning = false;
}, onViewportResize:function() {
  if (this.isVisible()) {
    this.realign();
  }
}, showAt:function(x, y) {
  var me = this;
  if (me.getFloated() || me.isPositioned()) {
    if (arguments.length === 1) {
      if (x.x) {
        y = x.y;
        x = x.x;
      } else {
        y = x[1];
        x = x[0];
      }
    }
    me.show();
    if (me.isPositioned()) {
      me.setLeft(x);
      me.setTop(y);
    } else {
      me.setX(x);
      me.setY(y);
    }
  }
  return me;
}, onAdded:function(parent, instanced) {
  var me = this, modal;
  me.callParent([parent, instanced]);
  if (!me.getFloated()) {
    modal = me.getModal();
    if (modal) {
      parent.insertBefore(modal, me);
      modal.setZIndex(me.getZIndex() - 1);
    }
  }
  me.el.removeCls(me.rootCls);
}, onRemoved:function(destroying) {
  if (!destroying) {
    this.el.addCls(this.rootCls);
  }
  this.callParent([destroying]);
}, applyTooltip:function(tooltip) {
  if (tooltip) {
    if (tooltip.isInstance) {
      tooltip.setTarget(this);
      return tooltip;
    } else {
      if (typeof tooltip === 'string') {
        tooltip = {html:tooltip};
      } else {
        tooltip = Ext.merge({}, tooltip);
      }
    }
    if (tooltip.autoCreate || tooltip.autoHide === false) {
      delete tooltip.autoCreate;
      tooltip.target = this;
      tooltip.xtype = tooltip.xtype || 'tooltip';
      tooltip = Ext.create(tooltip);
    } else {
      delete tooltip.xtype;
    }
  }
  return tooltip;
}, updateTooltip:function(tooltip, oldTooltip) {
  var el = this.el, data, manager, target, tip;
  if (oldTooltip) {
    if (oldTooltip.isInstance) {
      Ext.destroy(oldTooltip);
    } else {
      target = Ext.fly(oldTooltip.target);
      data = target && target.peekData();
      if (data) {
        delete data.qtip;
      }
    }
  }
  if (tooltip && !tooltip.isInstance) {
    el.getData().qtip = tooltip;
    manager = Ext['tip'];
    manager = manager && manager.Manager;
    manager = manager && manager.instance;
    if (manager) {
      tip = manager.tip;
      if (tip.currentTarget.dom === el.dom) {
        manager.onBeforeShow(tip);
      }
    }
  }
}, applyModal:function(modal, currentModal) {
  if (this.getFloated()) {
    return !!modal;
  }
  var isVisible = this.isVisible();
  if (modal === false) {
    modal = true;
    isVisible = false;
  }
  currentModal = Ext.factory(modal, Ext['Mask'], typeof currentModal === 'boolean' ? null : currentModal);
  if (currentModal) {
    currentModal.setVisibility(isVisible);
    currentModal.on('tap', 'onModalMaskTap', this);
  }
  return currentModal;
}, updateModal:function(modal) {
  var me = this, parent = me.getParent(), positionEl = (me.floatWrap || me.element).dom, topModal;
  if (me.getFloated()) {
    if (modal) {
      if (me.isVisible() && !positionEl.nextSibling) {
        me.showModalMask();
      }
    } else {
      topModal = me.getModalSibling();
      if (topModal) {
        topModal.showModalMask();
      } else {
        me.hideModalMask();
      }
    }
  } else {
    if (parent) {
      if (modal) {
        parent.insertBefore(modal, me);
        modal.setZIndex(me.getZIndex() - 1);
      } else {
        parent.remove(modal);
      }
    }
  }
}, applyHideAnimation:function(hideAnimation, oldHideAnimation) {
  return Ext.Factory.animation.update(oldHideAnimation, hideAnimation, this, 'createHideAnimation');
}, createHideAnimation:function(defaults) {
  return Ext.apply({type:'fadeOut', element:this.element}, defaults);
}, applyShowAnimation:function(showAnimation, oldShowAnimation) {
  return Ext.Factory.animation.update(oldShowAnimation, showAnimation, this, 'createShowAnimation');
}, createShowAnimation:function(defaults) {
  return Ext.apply({type:'fadeIn', element:this.element}, defaults);
}, doDestroy:function() {
  var me = this, sibling;
  if (me.isVisible()) {
    me.revertFocus();
    if (me.getModal() && me.getFloated()) {
      sibling = me.getModalSibling();
      if (sibling) {
        sibling.showModalMask();
      } else {
        me.hideModalMask();
      }
    }
  }
  if (me.hasListeners.destroy) {
    me.fireEvent('destroy', me);
  }
  me.destroyMembers('modal', 'innerHtmlElement', 'scrollerElement', 'scrollable', 'showAnimation', 'hideAnimation', 'centerResizeListener', 'visibleListener');
  me.setPlugins(null);
  me.setRecord(null);
  me.setTooltip(null);
  me.callParent();
}, privates:{preciseWidth:false, clearWhenVisible:function(fn) {
  var me = this, pending = me.pendingVisible;
  if (pending) {
    delete pending[fn];
    if (Ext.Object.isEmpty(pending)) {
      me.pendingVisible = null;
      me.visibleListener = Ext.destroy(me.visibleListener);
    }
  }
}, convertToLocalXY:function(xy) {
  var me = this, pageXY = me.element.getXY(), x = 0, y = 0;
  if (me.isPositioned()) {
    x = me.getLeft() || 0;
    y = me.getTop() || 0;
  } else {
    x = me.getX() || 0;
    y = me.getY() || 0;
  }
  return [xy[0] - pageXY[0] + x, xy[1] - pageXY[1] + y];
}, doAddListener:function(name, fn, scope, options, order, caller, manager) {
  var me = this, el = me.element;
  if (me.initialized) {
    if (name === 'painted') {
      if (!me.hasListeners.painted) {
        el.on('painted', 'handleElementPainted', me);
      }
    } else {
      if (name === 'resize' && !me.isViewport) {
        if (!me.hasListeners.resize) {
          el.on({scope:me, resize:'handleElementResize', priority:1000});
        }
      }
    }
  }
  return me.callParent([name, fn, scope, options, order, caller, manager]);
}, doRemoveListener:function(name, fn, scope) {
  var me = this, el = me.element, ret = me.callParent([name, fn, scope]);
  if (ret && me.initialized) {
    if (name === 'painted') {
      if (!me.hasListeners.painted) {
        el.un('painted', 'handleElementPainted', me);
      }
    } else {
      if (name === 'resize' && !me.isViewport) {
        if (!me.hasListeners.resize) {
          el.un('resize', 'handleElementResize', me);
        }
      }
    }
  }
  return ret;
}, doUpdateTpl:function(data) {
  var me = this, tpl = me.getTpl(), writeMode;
  if (tpl) {
    writeMode = me.getTplWriteMode();
    data = data || me.getData() || {};
    tpl[writeMode](me.getInnerHtmlElement(), data);
  }
}, getRenderTarget:function() {
  return this.bodyElement;
}, handleElementPainted:function(el) {
  this.fireEvent('painted', this, el);
}, handleElementResize:function(el, info) {
  var me = this, ceil = Math.ceil, lastSize = me.lastSize, oldWidth = lastSize.width || null, oldHeight = lastSize.height || null, w, h;
  if (info.flag) {
    w = info.width;
    h = info.height;
    if (!me.preciseWidth) {
      w = ceil(w);
      h = ceil(h);
    }
    lastSize.width = w;
    lastSize.height = h;
    if (me.onResize) {
      me.onResize(w, h, oldWidth, oldHeight, info);
    }
    if (me.isCentered()) {
      me.center();
    }
    me.fireEvent('resize', this, w, h, oldWidth, oldHeight, info);
  }
}, handleGlobalShow:function(c) {
  var me = this;
  if (me.isVisible(true) && (c === me || me.isDescendantOf(c))) {
    me.runWhenVisible();
  }
}, runWhenVisible:function() {
  var me = this, pending = me.pendingVisible, key;
  me.pendingVisible = null;
  me.visibleListener = Ext.destroy(me.visibleListener);
  for (key in pending) {
    me[key].apply(me, pending[key]);
  }
}, whenVisible:function(fn, args) {
  args = args || Ext.emptyArray;
  var me = this, listener = me.visibleListener, pending = me.pendingVisible, visible = me.isVisible(true);
  if (!visible && !listener) {
    me.visibleListener = Ext.on({scope:me, show:'handleGlobalShow', destroyable:true});
  }
  if (visible) {
    if (pending) {
      pending[fn] = args;
      me.runWhenVisible();
    } else {
      me[fn].apply(me, args);
    }
  } else {
    if (!pending) {
      me.pendingVisible = pending = {};
    }
    pending[fn] = args;
  }
  return visible;
}, setXY:function(x, y, animation) {
  var me = this, floated = me.getFloated();
  if (typeof x !== 'number') {
    animation = y;
    y = x[1];
    x = x[0];
  }
  me.$updatingXY = true;
  if (floated) {
    if (x != null) {
      me.setX(x);
    }
    if (y != null) {
      me.setY(y);
    }
  } else {
    if (x != null) {
      me.setLeft(x);
    }
    if (y != null) {
      me.setTop(y);
    }
  }
  me.$updatingXY = false;
  if (floated) {
    me.syncXYPosition(animation);
  } else {
    me.translate(x, y, animation);
  }
}, syncXYPosition:function(animation) {
  var me = this;
  if (!me.aligning) {
    me.viewportResizeListener = Ext.destroy(me.viewportResizeListener);
  }
  me.callParent([animation]);
}}, deprecated:{'6.2.0':{methods:{resetFloating:'resetPositioned'}}, '6.5':{configs:{styleHtmlCls:null, styleHtmlContent:null}}}}, function(Cls) {
  if (!document.querySelector('meta[name\x3dviewport]')) {
    Ext.log.warn('Ext JS requires a viewport meta tag in order to function correctly on mobile devices.  Please add the following tag to the \x3chead\x3e of your html page: \n \x3cmeta name\x3d"viewport" content\x3d"width\x3ddevice-width, initial-scale\x3d1, maximum-scale\x3d10, user-scalable\x3dyes"\x3e');
  }
});
Ext.define('Ext.theme.material.Widget', {override:'Ext.Widget', statics:{floatInset:16 / (window.devicePixelRatio || 1)}});
Ext.define('Ext.fx.State', {isAnimatable:{'background-color':true, 'background-image':true, 'background-position':true, 'border-bottom-color':true, 'border-bottom-width':true, 'border-color':true, 'border-left-color':true, 'border-left-width':true, 'border-right-color':true, 'border-right-width':true, 'border-spacing':true, 'border-top-color':true, 'border-top-width':true, 'border-width':true, 'bottom':true, 'color':true, 'crop':true, 'font-size':true, 'font-weight':true, 'height':true, 'left':true, 
'letter-spacing':true, 'line-height':true, 'margin-bottom':true, 'margin-left':true, 'margin-right':true, 'margin-top':true, 'max-height':true, 'max-width':true, 'min-height':true, 'min-width':true, 'opacity':true, 'outline-color':true, 'outline-offset':true, 'outline-width':true, 'padding-bottom':true, 'padding-left':true, 'padding-right':true, 'padding-top':true, 'right':true, 'text-indent':true, 'text-shadow':true, 'top':true, 'vertical-align':true, 'visibility':true, 'width':true, 'word-spacing':true, 
'z-index':true, 'zoom':true, 'transform':true}, constructor:function(data) {
  this.data = {};
  this.set(data);
}, setConfig:function(data) {
  this.set(data);
  return this;
}, setRaw:function(data) {
  this.data = data;
  return this;
}, clear:function() {
  return this.setRaw({});
}, setTransform:function(name, value) {
  var data = this.data, isArray = Ext.isArray(value), transform = data.transform, ln, key;
  if (!transform) {
    transform = data.transform = {translateX:0, translateY:0, translateZ:0, scaleX:1, scaleY:1, scaleZ:1, rotate:0, rotateX:0, rotateY:0, rotateZ:0, skewX:0, skewY:0};
  }
  if (typeof name == 'string') {
    switch(name) {
      case 'translate':
        if (isArray) {
          ln = value.length;
          if (ln == 0) {
            break;
          }
          transform.translateX = value[0];
          if (ln == 1) {
            break;
          }
          transform.translateY = value[1];
          if (ln == 2) {
            break;
          }
          transform.translateZ = value[2];
        } else {
          transform.translateX = value;
        }
        break;
      case 'rotate':
        if (isArray) {
          ln = value.length;
          if (ln == 0) {
            break;
          }
          transform.rotateX = value[0];
          if (ln == 1) {
            break;
          }
          transform.rotateY = value[1];
          if (ln == 2) {
            break;
          }
          transform.rotateZ = value[2];
        } else {
          transform.rotate = value;
        }
        break;
      case 'scale':
        if (isArray) {
          ln = value.length;
          if (ln == 0) {
            break;
          }
          transform.scaleX = value[0];
          if (ln == 1) {
            break;
          }
          transform.scaleY = value[1];
          if (ln == 2) {
            break;
          }
          transform.scaleZ = value[2];
        } else {
          transform.scaleX = value;
          transform.scaleY = value;
        }
        break;
      case 'skew':
        if (isArray) {
          ln = value.length;
          if (ln == 0) {
            break;
          }
          transform.skewX = value[0];
          if (ln == 1) {
            break;
          }
          transform.skewY = value[1];
        } else {
          transform.skewX = value;
        }
        break;
      default:
        transform[name] = value;
    }
  } else {
    for (key in name) {
      if (name.hasOwnProperty(key)) {
        value = name[key];
        this.setTransform(key, value);
      }
    }
  }
}, set:function(name, value) {
  var data = this.data, key;
  if (typeof name != 'string') {
    for (key in name) {
      value = name[key];
      if (key === 'transform') {
        this.setTransform(value);
      } else {
        data[key] = value;
      }
    }
  } else {
    if (name === 'transform') {
      this.setTransform(value);
    } else {
      data[name] = value;
    }
  }
  return this;
}, unset:function(name) {
  var data = this.data;
  if (data.hasOwnProperty(name)) {
    delete data[name];
  }
  return this;
}, getData:function() {
  return this.data;
}});
Ext.define('Ext.fx.animation.Abstract', {extend:Ext.Evented, mixins:[Ext.mixin.Factoryable], factoryConfig:{type:'animation'}, isAnimation:true, config:{name:'', element:null, before:null, from:{}, to:{}, after:null, states:{}, duration:300, easing:'linear', iteration:1, direction:'normal', delay:0, onBeforeStart:null, callback:null, onEnd:null, onBeforeEnd:null, scope:null, reverse:null, preserveEndState:false, replacePrevious:true}, STATE_FROM:'0%', STATE_TO:'100%', DIRECTION_UP:'up', DIRECTION_TOP:'top', 
DIRECTION_DOWN:'down', DIRECTION_BOTTOM:'bottom', DIRECTION_LEFT:'left', DIRECTION_RIGHT:'right', stateNameRegex:/^(?:[\d\.]+)%$/, constructor:function() {
  this.states = {};
  this.callParent(arguments);
  return this;
}, applyElement:function(element) {
  return Ext.get(element);
}, applyBefore:function(before, current) {
  if (before) {
    return Ext.factory(before, Ext.fx.State, current);
  }
}, applyAfter:function(after, current) {
  if (after) {
    return Ext.factory(after, Ext.fx.State, current);
  }
}, setFrom:function(from) {
  return this.setState(this.STATE_FROM, from);
}, setTo:function(to) {
  return this.setState(this.STATE_TO, to);
}, getFrom:function() {
  return this.getState(this.STATE_FROM);
}, getTo:function() {
  return this.getState(this.STATE_TO);
}, setStates:function(states) {
  var validNameRegex = this.stateNameRegex, name;
  for (name in states) {
    if (validNameRegex.test(name)) {
      this.setState(name, states[name]);
    }
  }
  return this;
}, getStates:function() {
  return this.states;
}, updateCallback:function(callback) {
  if (callback) {
    this.setOnEnd(callback);
  }
}, end:function() {
  this.stop();
}, stop:function() {
  this.fireEvent('stop', this);
}, destroy:function() {
  this.destroying = true;
  this.stop();
  this.callParent();
  this.destroying = false;
  this.destroyed = true;
}, setState:function(name, state) {
  var states = this.getStates(), stateInstance;
  stateInstance = Ext.factory(state, Ext.fx.State, states[name]);
  if (stateInstance) {
    states[name] = stateInstance;
  } else {
    if (name === this.STATE_TO) {
      Ext.Logger.error("Setting and invalid '100%' / 'to' state of: " + state);
    }
  }
  return this;
}, getState:function(name) {
  return this.getStates()[name];
}, getData:function() {
  var me = this, states = me.getStates(), statesData = {}, before = me.getBefore(), after = me.getAfter(), from = states[me.STATE_FROM], to = states[me.STATE_TO], fromData = from.getData(), toData = to.getData(), data, name, state;
  for (name in states) {
    if (states.hasOwnProperty(name)) {
      state = states[name];
      data = state.getData();
      statesData[name] = data;
    }
  }
  return {before:before ? before.getData() : {}, after:after ? after.getData() : {}, states:statesData, from:fromData, to:toData, duration:me.getDuration(), iteration:me.getIteration(), direction:me.getDirection(), easing:me.getEasing(), delay:me.getDelay(), onEnd:me.getOnEnd(), onBeforeEnd:me.getOnBeforeEnd(), onBeforeStart:me.getOnBeforeStart(), scope:me.getScope(), preserveEndState:me.getPreserveEndState(), replacePrevious:me.getReplacePrevious()};
}});
Ext.define('Ext.fx.animation.Slide', {extend:Ext.fx.animation.Abstract, alternateClassName:'Ext.fx.animation.SlideIn', alias:['animation.slide', 'animation.slideIn'], config:{direction:'left', out:false, offset:0, easing:'auto', containerBox:'auto', elementBox:'auto', isElementBoxFit:true, useCssTransform:true}, reverseDirectionMap:{up:'down', top:'down', down:'up', bottom:'up', left:'right', right:'left'}, applyEasing:function(easing) {
  if (easing === 'auto') {
    return 'ease-' + (this.getOut() ? 'in' : 'out');
  }
  return easing;
}, getContainerBox:function() {
  var box = this._containerBox;
  if (box === 'auto') {
    box = this.getElement().getParent().getBox();
  }
  return box;
}, getElementBox:function() {
  var box = this._elementBox;
  if (this.getIsElementBoxFit()) {
    return this.getContainerBox();
  }
  if (box === 'auto') {
    box = this.getElement().getBox();
  }
  return box;
}, getData:function() {
  var elementBox = this.getElementBox(), containerBox = this.getContainerBox(), box = elementBox ? elementBox : containerBox, from = this.getFrom(), to = this.getTo(), out = this.getOut(), offset = this.getOffset(), direction = this.getDirection(), useCssTransform = this.getUseCssTransform(), reverse = this.getReverse(), translateX = 0, translateY = 0, offsetPct, fromX, fromY, toX, toY;
  if (typeof offset === 'string') {
    offsetPct = true;
    offset = parseFloat(offset);
  }
  if (reverse) {
    direction = this.reverseDirectionMap[direction];
  }
  switch(direction) {
    case this.DIRECTION_UP:
    case this.DIRECTION_TOP:
      if (offsetPct) {
        offset = box.height * offset / 100;
      }
      if (out) {
        translateY = containerBox.top - box.top - box.height - offset;
      } else {
        translateY = containerBox.bottom - box.bottom + box.height + offset;
      }
      break;
    case this.DIRECTION_DOWN:
    case this.DIRECTION_BOTTOM:
      if (offsetPct) {
        offset = box.height * offset / 100;
      }
      if (out) {
        translateY = containerBox.bottom - box.bottom + box.height + offset;
      } else {
        translateY = containerBox.top - box.height - box.top - offset;
      }
      break;
    case this.DIRECTION_RIGHT:
      if (offsetPct) {
        offset = box.width * offset / 100;
      }
      if (out) {
        translateX = containerBox.right - box.right + box.width + offset;
      } else {
        translateX = containerBox.left - box.left - box.width - offset;
      }
      break;
    case this.DIRECTION_LEFT:
      if (offsetPct) {
        offset = box.width * offset / 100;
      }
      if (out) {
        translateX = containerBox.left - box.left - box.width - offset;
      } else {
        translateX = containerBox.right - box.right + box.width + offset;
      }
      break;
  }
  fromX = out ? 0 : translateX;
  fromY = out ? 0 : translateY;
  if (useCssTransform) {
    from.setTransform({translateX:fromX, translateY:fromY});
  } else {
    from.set('left', fromX);
    from.set('top', fromY);
  }
  toX = out ? translateX : 0;
  toY = out ? translateY : 0;
  if (useCssTransform) {
    to.setTransform({translateX:toX, translateY:toY});
  } else {
    to.set('left', toX);
    to.set('top', toY);
  }
  return this.callParent(arguments);
}});
Ext.define('Ext.fx.animation.SlideOut', {extend:Ext.fx.animation.Slide, alias:['animation.slideOut'], config:{out:true}});
Ext.define('Ext.fx.animation.Fade', {extend:Ext.fx.animation.Abstract, alternateClassName:'Ext.fx.animation.FadeIn', alias:['animation.fade', 'animation.fadeIn'], config:{out:false, before:{display:null, opacity:0}, after:{opacity:null}, reverse:null}, updateOut:function(newOut) {
  var to = this.getTo(), from = this.getFrom();
  if (newOut) {
    from.set('opacity', 1);
    to.set('opacity', 0);
  } else {
    from.set('opacity', 0);
    to.set('opacity', 1);
  }
}});
Ext.define('Ext.fx.animation.FadeOut', {extend:Ext.fx.animation.Fade, alias:'animation.fadeOut', config:{out:true, before:{}}});
Ext.define('Ext.fx.animation.Flip', {extend:Ext.fx.animation.Abstract, alias:'animation.flip', config:{easing:'ease-in', direction:'right', half:false, out:null}, getData:function() {
  var me = this, from = me.getFrom(), to = me.getTo(), direction = me.getDirection(), out = me.getOut(), half = me.getHalf(), rotate = half ? 90 : 180, fromScale = 1, toScale = 1, fromRotateX = 0, fromRotateY = 0, toRotateX = 0, toRotateY = 0;
  if (out) {
    toScale = 0.8;
  } else {
    fromScale = 0.8;
  }
  switch(direction) {
    case this.DIRECTION_UP:
    case this.DIRECTION_TOP:
      if (out) {
        toRotateX = rotate;
      } else {
        fromRotateX = -rotate;
      }
      break;
    case this.DIRECTION_DOWN:
    case this.DIRECTION_BOTTOM:
      if (out) {
        toRotateX = -rotate;
      } else {
        fromRotateX = rotate;
      }
      break;
    case this.DIRECTION_RIGHT:
      if (out) {
        toRotateY = rotate;
      } else {
        fromRotateY = -rotate;
      }
      break;
    case this.DIRECTION_LEFT:
      if (out) {
        toRotateY = -rotate;
      } else {
        fromRotateY = rotate;
      }
      break;
  }
  from.setTransform({rotateX:fromRotateX, rotateY:fromRotateY, scale:fromScale});
  to.setTransform({rotateX:toRotateX, rotateY:toRotateY, scale:toScale});
  return this.callParent();
}});
Ext.define('Ext.fx.animation.Pop', {extend:Ext.fx.animation.Abstract, alias:['animation.pop', 'animation.popIn'], alternateClassName:'Ext.fx.animation.PopIn', config:{out:false, before:{display:null, opacity:0}, after:{opacity:null}}, getData:function() {
  var to = this.getTo(), from = this.getFrom(), out = this.getOut();
  if (out) {
    from.set('opacity', 1);
    from.setTransform({scale:1});
    to.set('opacity', 0);
    to.setTransform({scale:0});
  } else {
    from.set('opacity', 0);
    from.setTransform({scale:0});
    to.set('opacity', 1);
    to.setTransform({scale:1});
  }
  return this.callParent(arguments);
}});
Ext.define('Ext.fx.animation.PopOut', {extend:Ext.fx.animation.Pop, alias:'animation.popOut', config:{out:true, before:{}}});
Ext.define('Ext.fx.Animation', {constructor:function(config) {
  var defaultClass = Ext.fx.animation.Abstract, type;
  if (typeof config == 'string') {
    type = config;
    config = {};
  } else {
    if (config && config.type) {
      type = config.type;
    }
  }
  if (type) {
    defaultClass = Ext.ClassManager.getByAlias('animation.' + type);
    if (!defaultClass) {
      Ext.Logger.error("Invalid animation type of: '" + type + "'");
    }
  }
  return Ext.factory(config, defaultClass);
}});
Ext.define('Ext.app.EventDomain', {statics:{instances:{}}, isEventDomain:true, isInstance:false, constructor:function() {
  var me = this;
  if (!me.isInstance) {
    Ext.app.EventDomain.instances[me.type] = me;
  }
  me.bus = {};
  me.monitoredClasses = [];
}, dispatch:function(target, ev, args) {
  ev = Ext.canonicalEventName(ev);
  var me = this, bus = me.bus, selectors = bus[ev], selector, controllers, id, info, events, len, i, event;
  if (!selectors) {
    return true;
  }
  for (selector in selectors) {
    if (selectors.hasOwnProperty(selector) && me.match(target, selector, me.controller)) {
      controllers = selectors[selector];
      for (id in controllers) {
        if (controllers.hasOwnProperty(id)) {
          info = controllers[id];
          if (info.controller.isActive()) {
            events = info.list;
            len = events.length;
            for (i = 0; i < len; i++) {
              event = events[i];
              if (event.fire.apply(event, args) === false) {
                return false;
              }
            }
          }
        }
      }
    }
  }
  return true;
}, listen:function(selectors, controller) {
  var me = this, bus = me.bus, idProperty = me.idProperty, monitoredClasses = me.monitoredClasses, monitoredClassesCount = monitoredClasses.length, controllerId = controller.getId(), isComponentDomain = me.type === 'component', refMap = isComponentDomain ? controller.getRefMap() : null, i, tree, info, selector, options, listener, scope, event, listeners, ev, classHasListeners;
  for (selector in selectors) {
    listeners = selectors[selector];
    if (isComponentDomain) {
      selector = refMap[selector] || selector;
    }
    if (listeners) {
      if (idProperty) {
        if (!/^[*#]/.test(selector)) {
          Ext.raise('Selectors containing id should begin with #');
        }
        selector = selector === '*' ? selector : selector.substring(1);
      }
      for (ev in listeners) {
        options = null;
        listener = listeners[ev];
        scope = controller;
        ev = Ext.canonicalEventName(ev);
        event = new Ext.util.Event(controller, ev);
        if (Ext.isObject(listener)) {
          options = listener;
          listener = options.fn;
          scope = options.scope || controller;
          delete options.fn;
          delete options.scope;
        }
        if ((!options || !options.scope) && typeof listener === 'string') {
          if (!scope[listener]) {
            Ext.raise('Cannot resolve "' + listener + '" on controller.');
          }
          scope = null;
        } else {
          if (typeof listener === 'string') {
            listener = scope[listener];
          }
        }
        event.addListener(listener, scope, options);
        for (i = 0; i < monitoredClassesCount; ++i) {
          classHasListeners = monitoredClasses[i].hasListeners;
          if (classHasListeners) {
            classHasListeners._incr_(ev);
          }
        }
        tree = bus[ev] || (bus[ev] = {});
        tree = tree[selector] || (tree[selector] = {});
        info = tree[controllerId] || (tree[controllerId] = {controller:controller, list:[]});
        info.list.push(event);
      }
    }
  }
}, match:function(target, selector) {
  var idProperty = this.idProperty;
  if (idProperty) {
    return selector === '*' || target[idProperty] === selector;
  }
  return false;
}, monitor:function(observable) {
  var domain = this, prototype = observable.isInstance ? observable : observable.prototype, doFireEvent = prototype.doFireEvent;
  domain.monitoredClasses.push(observable);
  prototype.doFireEvent = function(ev, args) {
    var me = this, ret;
    ret = doFireEvent.apply(me, arguments);
    if (ret !== false && !me.destroyed && !me.isSuspended(ev)) {
      ret = domain.dispatch(me, ev, args);
    }
    return ret;
  };
}, unlisten:function(controllerId) {
  var bus = this.bus, id = controllerId, monitoredClasses = this.monitoredClasses, monitoredClassesCount = monitoredClasses.length, controllers, ev, events, len, item, selector, selectors, i, j, info, classHasListeners;
  if (controllerId.isController) {
    id = controllerId.getId();
  }
  for (ev in bus) {
    ev = Ext.canonicalEventName(ev);
    if (bus.hasOwnProperty(ev) && (selectors = bus[ev])) {
      for (selector in selectors) {
        controllers = selectors[selector];
        info = controllers[id];
        if (info) {
          events = info.list;
          if (events) {
            for (i = 0, len = events.length; i < len; ++i) {
              item = events[i];
              item.clearListeners();
              for (j = 0; j < monitoredClassesCount; ++j) {
                classHasListeners = monitoredClasses[j].hasListeners;
                if (classHasListeners) {
                  classHasListeners._decr_(item.name);
                }
              }
            }
            delete controllers[id];
          }
        }
      }
    }
  }
}, destroy:function() {
  this.monitoredClasses = this.bus = null;
  this.callParent();
}});
Ext.define('Ext.app.domain.Component', {extend:Ext.app.EventDomain, singleton:true, type:'component', constructor:function() {
  this.callParent();
  this.monitor(Ext.Widget);
}, dispatch:function(target, ev, args) {
  var controller = target.lookupController(false), domain, view;
  while (controller) {
    domain = controller.compDomain;
    if (domain) {
      if (domain.dispatch(target, ev, args) === false) {
        return false;
      }
    }
    view = controller.getView();
    controller = view ? view.lookupController(true) : null;
  }
  return this.callParent([target, ev, args]);
}, match:function(target, selector) {
  return target.is(selector);
}});
Ext.define('Ext.app.EventBus', {singleton:true, constructor:function() {
  var me = this, domains = Ext.app.EventDomain.instances;
  me.callParent();
  me.domains = domains;
  me.bus = domains.component.bus;
}, control:function(selectors, controller) {
  return this.domains.component.listen(selectors, controller);
}, listen:function(to, controller) {
  var domains = this.domains, domain;
  for (domain in to) {
    if (to.hasOwnProperty(domain)) {
      domains[domain].listen(to[domain], controller);
    }
  }
}, unlisten:function(controllerId) {
  var domains = Ext.app.EventDomain.instances, domain;
  for (domain in domains) {
    domains[domain].unlisten(controllerId);
  }
}});
Ext.define('Ext.app.domain.Global', {extend:Ext.app.EventDomain, singleton:true, type:'global', constructor:function() {
  var me = this;
  me.callParent();
  me.monitor(Ext.GlobalEvents);
}, listen:function(listeners, controller) {
  this.callParent([{global:listeners}, controller]);
}, match:Ext.returnTrue});
Ext.define('Ext.route.Handler', {lazy:false, statics:{fromRouteConfig:function(config, scope) {
  var handler = {action:config.action, before:config.before, lazy:config.lazy, exit:config.exit, scope:scope, single:config.single};
  return new this(handler);
}}, constructor:function(config) {
  Ext.apply(this, config);
}});
Ext.define('Ext.route.Action', {config:{actions:null, befores:null, urlParams:[]}, started:false, stopped:false, constructor:function(config) {
  var me = this;
  me.deferred = new Ext.Deferred;
  me.resume = me.resume.bind(me);
  me.stop = me.stop.bind(me);
  me.initConfig(config);
  me.callParent([config]);
}, applyActions:function(actions) {
  if (actions) {
    actions = Ext.Array.from(actions);
  }
  return actions;
}, applyBefores:function(befores) {
  if (befores) {
    befores = Ext.Array.from(befores);
  }
  return befores;
}, destroy:function() {
  this.deferred = null;
  this.setBefores(null).setActions(null).setUrlParams(null);
  this.callParent();
}, resume:function() {
  return this.next();
}, stop:function() {
  this.stopped = true;
  return this.done();
}, next:function() {
  var me = this, actions = me.getActions(), befores = me.getBefores(), urlParams = me.getUrlParams(), config, ret, args;
  if (Ext.isArray(urlParams)) {
    args = urlParams.slice();
  } else {
    args = [urlParams];
  }
  if (me.stopped || (befores ? !befores.length : true) && (actions ? !actions.length : true)) {
    me.done();
  } else {
    if (befores && befores.length) {
      config = befores.shift();
      args.push(me);
      ret = Ext.callback(config.fn, config.scope, args);
      if (ret && ret.then) {
        ret.then(function(arg) {
          me.resume(arg);
        }, function(arg) {
          me.stop(arg);
        });
      }
    } else {
      if (actions && actions.length) {
        config = actions.shift();
        Ext.callback(config.fn, config.scope, args);
        me.next();
      } else {
        me.next();
      }
    }
  }
  return me;
}, run:function() {
  var deferred = this.deferred;
  if (!this.started) {
    this.next();
    this.started = true;
  }
  return deferred.promise;
}, done:function() {
  var deferred = this.deferred;
  if (this.stopped) {
    deferred.reject();
  } else {
    deferred.resolve();
  }
  this.destroy();
  return this;
}, before:function(first, fn, scope) {
  if (!Ext.isBoolean(first)) {
    scope = fn;
    fn = first;
    first = false;
  }
  var befores = this.getBefores(), config = {fn:fn, scope:scope};
  if (this.destroyed) {
    Ext.raise('This action has has already resolved and therefore will never execute this function.');
    return;
  }
  if (befores) {
    if (first) {
      befores.unshift(config);
    } else {
      befores.push(config);
    }
  } else {
    this.setBefores(config);
  }
  return this;
}, action:function(first, fn, scope) {
  if (!Ext.isBoolean(first)) {
    scope = fn;
    fn = first;
    first = false;
  }
  var actions = this.getActions(), config = {fn:fn, scope:scope};
  if (this.destroyed) {
    Ext.raise('This action has has already resolved and therefore will never execute this function.');
    return;
  }
  if (actions) {
    if (first) {
      actions.unshift(config);
    } else {
      actions.push(config);
    }
  } else {
    this.setActions(config);
  }
  return this;
}, then:function(resolve, reject) {
  if (this.destroyed) {
    Ext.raise('This action has has already resolved and therefore will never execute either function.');
    return;
  }
  return this.deferred.then(resolve, reject);
}});
Ext.define('Ext.route.Route', {config:{name:null, url:null, allowInactive:false, conditions:{}, caseInsensitive:false, handlers:[], types:{cached:true, $value:{alpha:{re:'([a-zA-Z]+)'}, alphanum:{re:'([a-zA-Z0-9]+|[0-9]+(?:\\.[0-9]+)?|[0-9]*(?:\\.[0-9]+){1})', parse:function(value) {
  var test;
  if (value && this.numRe.test(value)) {
    test = parseFloat(value);
    if (!isNaN(test)) {
      value = test;
    }
  }
  return value;
}}, num:{re:'([0-9]+(?:\\.[0-9]+)?|[0-9]*(?:\\.[0-9]+){1})', parse:function(value) {
  if (value) {
    value = parseFloat(value);
  }
  return value;
}}, '...':{re:'(.+)?', split:'/', parse:function(values) {
  var length, i, value;
  if (values) {
    length = values.length;
    for (i = 0; i < length; i++) {
      value = parseFloat(values[i]);
      if (!isNaN(value)) {
        values[i] = value;
      }
    }
  }
  return values;
}}}}}, defaultMatcher:'([%a-zA-Z0-9\\-\\_\\s,]+)', numRe:/^[0-9]*(?:\.[0-9]*)?$/, typeParamRegex:/:{([0-9A-Za-z_]+)(?::?([0-9A-Za-z_]+|.{3})?)}/g, optionalGroupRegex:/\((.+?)\)/g, paramMatchingRegex:/:([0-9A-Za-z_]+)/g, isRoute:true, constructor:function(config) {
  var me = this, url;
  this.initConfig(config);
  url = me.getUrl().replace(me.optionalGroupRegex, function(match, middle) {
    return '(?:' + middle + ')?';
  });
  if (url.match(me.typeParamRegex)) {
    me.handleNamedPattern(url);
  } else {
    me.handlePositionalPattern(url);
  }
}, handlePositionalPattern:function(url) {
  var me = this;
  me.paramsInMatchString = url.match(me.paramMatchingRegex) || [];
  me.matcherRegex = me.createMatcherRegex(url);
  me.mode = 'positional';
}, handleNamedPattern:function(url) {
  var me = this, typeParamRegex = me.typeParamRegex, conditions = me.getConditions(), types = me.getTypes(), defaultMatcher = me.defaultMatcher, params = {}, re = url.replace(typeParamRegex, function(match, param, typeMatch) {
    var type = typeMatch && types[typeMatch], matcher = conditions[param] || type || defaultMatcher;
    if (params[param]) {
      Ext.raise('"' + param + '" already defined in route "' + url + '"');
    }
    if (typeMatch && !type) {
      Ext.raise('Unknown parameter type "' + typeMatch + '" in route "' + url + '"');
    }
    if (Ext.isObject(matcher)) {
      matcher = matcher.re;
    }
    params[param] = {matcher:matcher, type:typeMatch};
    return matcher;
  });
  if (re.search(me.paramMatchingRegex) !== -1) {
    Ext.raise('URL parameter mismatch. Positional url parameter found while in named mode.');
  }
  me.paramsInMatchString = params;
  me.matcherRegex = new RegExp('^' + re + '$', me.getCaseInsensitive() ? 'i' : '');
  me.mode = 'named';
}, recognize:function(url) {
  var me = this, recognized = me.recognizes(url), handlers, length, hasHandler, i, handler, matches, urlParams, arg, params;
  if (recognized) {
    handlers = me.getHandlers();
    length = handlers.length;
    for (i = 0; i < length; i++) {
      handler = handlers[i];
      if (handler.lastToken !== url) {
        hasHandler = true;
        break;
      }
    }
    if (!hasHandler && url === me.lastToken) {
      return true;
    }
    matches = me.matchesFor(url);
    urlParams = me.getUrlParams(url);
    return Ext.applyIf(matches, {historyUrl:url, urlParams:urlParams});
  }
  return false;
}, getUrlParams:function(url) {
  if (this.mode === 'named') {
    return this.getNamedUrlParams(url);
  } else {
    return this.getPositionalUrlParams(url);
  }
}, getPositionalUrlParams:function(url) {
  var params = [], conditions = this.getConditions(), keys = this.paramsInMatchString, values = url.match(this.matcherRegex), length = keys.length, i, key, type, value;
  values.shift();
  for (i = 0; i < length; i++) {
    key = keys[i];
    value = values[i];
    if (conditions[key]) {
      type = conditions[key];
    } else {
      if (key[0] === ':') {
        key = key.substr(1);
        if (conditions[key]) {
          type = conditions[key];
        }
      }
    }
    value = this.parseValue(value, type);
    if (Ext.isDefined(value) && value !== '') {
      if (Ext.isArray(value)) {
        params.push.apply(params, value);
      } else {
        params.push(value);
      }
    }
  }
  return params;
}, getNamedUrlParams:function(url) {
  var conditions = this.getConditions(), types = this.getTypes(), params = {}, keys = this.paramsInMatchString, values = url.match(this.matcherRegex), name, obj, value, type, condition;
  values.shift();
  for (name in keys) {
    obj = keys[name];
    value = values.shift();
    condition = conditions[name];
    type = types[obj.type];
    if (condition || type) {
      type = Ext.merge({}, condition, types[obj.type]);
    }
    params[name] = this.parseValue(value, type);
  }
  return params;
}, parseValue:function(value, type) {
  if (type) {
    if (value && type.split) {
      value = value.split(type.split);
      if (!value[0]) {
        value.shift();
      }
      if (!value[value.length - 1]) {
        value.pop();
      }
    }
    if (type.parse) {
      value = type.parse.call(this, value);
    }
  }
  if (!value && Ext.isString(value)) {
    value = undefined;
  }
  return value;
}, recognizes:function(url) {
  return this.matcherRegex.test(url);
}, execute:function(token, argConfig) {
  var me = this, allowInactive = me.getAllowInactive(), handlers = me.getHandlers(), queue = Ext.route.Router.getQueueRoutes(), length = handlers.length, befores = [], actions = [], urlParams = argConfig && argConfig.urlParams || [], i, handler, scope, action, promises, single, remover;
  me.lastToken = token;
  if (!queue) {
    promises = [];
  }
  return new Ext.Promise(function(resolve, reject) {
    if (argConfig === false) {
      reject();
    } else {
      if (queue) {
        action = new Ext.route.Action({urlParams:urlParams});
      }
      for (i = 0; i < length; i++) {
        handler = handlers[i];
        if (token != null && handler.lastToken === token) {
          continue;
        }
        scope = handler.scope;
        handler.lastToken = token;
        if (!allowInactive && scope.isActive && !scope.isActive()) {
          continue;
        }
        if (!queue) {
          action = new Ext.route.Action({urlParams:urlParams});
        }
        single = handler.single;
        if (handler.before) {
          action.before(handler.before, scope);
        }
        if (handler.action) {
          action.action(handler.action, scope);
        }
        if (single) {
          remover = Ext.bind(me.removeHandler, me, [null, handler]);
          if (single === true) {
            if (handler.action) {
              action.action(remover, me);
            } else {
              action.before(function() {
                remover();
                return Ext.Promise.resolve();
              }, me);
            }
          } else {
            action.before(single === 'before', function() {
              remover();
              return Ext.Promise.resolve();
            }, me);
          }
        }
        if (!queue) {
          if (Ext.fireEvent('beforeroute', action, me) === false) {
            action.destroy();
          } else {
            promises.push(action.run());
          }
        }
      }
      if (queue) {
        if (Ext.fireEvent('beforeroute', action, me) === false) {
          action.destroy();
          reject();
        } else {
          action.run().then(resolve, reject);
        }
      } else {
        Ext.Promise.all(promises).then(resolve, reject);
      }
    }
  });
}, matchesFor:function(url) {
  var params = {}, keys = this.mode === 'named' ? Ext.Object.getKeys(this.paramsInMatchString) : this.paramsInMatchString, values = url.match(this.matcherRegex), length = keys.length, i;
  values.shift();
  for (i = 0; i < length; i++) {
    params[keys[i].replace(':', '')] = values[i];
  }
  return params;
}, createMatcherRegex:function(url) {
  var me = this, paramsInMatchString = me.paramsInMatchString, conditions = me.getConditions(), defaultMatcher = me.defaultMatcher, length = paramsInMatchString.length, modifiers = me.getCaseInsensitive() ? 'i' : '', i, param, matcher;
  if (url === '*') {
    url = url.replace('*', '\\*');
  } else {
    for (i = 0; i < length; i++) {
      param = paramsInMatchString[i];
      if (conditions[param]) {
        matcher = conditions[param];
      } else {
        if (param[0] === ':' && conditions[param.substr(1)]) {
          matcher = conditions[param.substr(1)];
        } else {
          matcher = defaultMatcher;
        }
      }
      if (Ext.isObject(matcher)) {
        matcher = matcher.re;
      }
      url = url.replace(new RegExp(param), matcher || defaultMatcher);
    }
  }
  return new RegExp('^' + url + '$', modifiers);
}, addHandler:function(handler) {
  var handlers = this.getHandlers();
  if (!handler.isInstance) {
    handler = new Ext.route.Handler(handler);
  }
  handlers.push(handler);
  return handler.route = this;
}, removeHandler:function(scope, handler) {
  var handlers = this.getHandlers(), length = handlers.length, newHandlers = [], i, item;
  for (i = 0; i < length; i++) {
    item = handlers[i];
    if (handler) {
      if (item !== handler) {
        newHandlers.push(item);
      }
    } else {
      if (item.scope !== scope) {
        newHandlers.push(item);
      }
    }
  }
  this.setHandlers(newHandlers);
  return this;
}, clearLastTokens:function() {
  var handlers = this.getHandlers(), length = handlers.length, i;
  for (i = 0; i < length; i++) {
    handlers[i].lastToken = null;
  }
  this.lastToken = null;
}, onExit:function() {
  var me = this, handlers = me.getHandlers(), allowInactive = me.getAllowInactive(), length = handlers.length, action = new Ext.route.Action({urlParams:[me.lastToken]}), i, handler, scope;
  me.clearLastTokens();
  for (i = 0; i < length; i++) {
    handler = handlers[i];
    if (handler.exit) {
      scope = handler.scope;
      if (!allowInactive && scope.isActive && !scope.isActive()) {
        continue;
      }
      action.action(handler.exit, scope);
    }
  }
  if (Ext.fireEvent('beforerouteexit', action, me) === false) {
    action.destroy();
  } else {
    action.run();
  }
}});
Ext.define('Ext.util.Observable', {extend:Ext.mixin.Observable, $applyConfigs:true}, function(Observable) {
  var Super = Ext.mixin.Observable;
  Observable.releaseCapture = Super.releaseCapture;
  Observable.capture = Super.capture;
  Observable.captureArgs = Super.captureArgs;
  Observable.observe = Observable.observeClass = Super.observe;
});
Ext.define('Ext.util.History', {singleton:true, alternateClassName:'Ext.History', mixins:{observable:Ext.util.Observable}, useTopWindow:false, hashRe:/^(#?!?)/, constructor:function() {
  var me = this;
  me.ready = false;
  me.currentToken = null;
  me.mixins.observable.constructor.call(me);
}, getHash:function() {
  return (this.win.location.hash || '').replace(this.hashRe, '');
}, setHash:function(hash, replace) {
  var me = this, hashRe = me.hashRe, loc = me.win.location;
  hash = hash.replace(hashRe, me.hashbang ? '#!' : '#');
  try {
    if (replace) {
      loc.replace(hash);
    } else {
      loc.hash = hash;
    }
    me.currentToken = hash.replace(hashRe, '');
  } catch (e$26) {
  }
}, handleStateChange:function(token) {
  token = token.replace(this.hashRe, '');
  this.fireEvent('change', this.currentToken = token);
}, startUp:function() {
  var me = this;
  me.currentToken = me.getHash();
  Ext.get(me.win).on('hashchange', me.onHashChange, me);
  me.ready = true;
  me.fireEvent('ready', me);
}, onHashChange:function() {
  var me = this, newHash = me.getHash();
  if (newHash !== me.hash) {
    me.hash = newHash;
    me.handleStateChange(newHash);
  }
}, init:function(onReady, scope) {
  var me = this;
  if (me.ready) {
    Ext.callback(onReady, scope, [me]);
    return;
  }
  if (!Ext.isReady) {
    Ext.onInternalReady(function() {
      me.init(onReady, scope);
    });
    return;
  }
  me.win = me.useTopWindow ? window.top : window;
  me.hash = me.getHash();
  if (onReady) {
    me.on('ready', onReady, scope, {single:true});
  }
  me.startUp();
}, add:function(token, preventDuplicates) {
  var me = this, set = false;
  if (preventDuplicates === false || me.getToken() !== token) {
    me.setHash(token);
    set = true;
  }
  return set;
}, replace:function(token, preventDuplicates) {
  var me = this, set = false;
  if (preventDuplicates === false || me.getToken() !== token) {
    this.setHash(token, true);
    set = true;
  }
  return set;
}, back:function() {
  this.win.history.go(-1);
}, forward:function() {
  this.win.history.go(1);
}, getToken:function() {
  return this.ready ? this.currentToken : this.getHash();
}});
Ext.define('Ext.route.Router', {singleton:true, config:{hashbang:null, multipleToken:'|', queueRoutes:true}, constructor:function() {
  var History = Ext.util.History;
  if (!History.ready) {
    History.init();
  }
  History.on('change', this.onStateChange, this);
  this.initConfig();
  this.clear();
}, updateHashbang:function(hashbang) {
  Ext.util.History.hashbang = hashbang;
}, onStateChange:function(token) {
  var me = this, tokens = token.split(me.getMultipleToken()), queue, i, length;
  if (me.isSuspended) {
    queue = me.suspendedQueue;
    i = 0;
    length = tokens.length;
    if (queue) {
      for (; i < length; i++) {
        token = tokens[i];
        if (!Ext.Array.contains(queue, token)) {
          queue.push(token);
        }
      }
    }
  } else {
    me.handleBefore(tokens);
  }
}, handleBefore:function(tokens) {
  var me = this, action = new Ext.route.Action;
  if (Ext.fireEvent('beforeroutes', action, tokens) === false) {
    action.destroy();
  } else {
    action.run().then(me.handleBeforeRoute.bind(me, tokens), Ext.emptyFn);
  }
}, handleBeforeRoute:function(tokens) {
  var me = this, beforeRoute = me.getByName('*');
  if (beforeRoute) {
    beforeRoute.execute().then(me.doRun.bind(me, tokens), Ext.emptyFn);
  } else {
    me.doRun(tokens);
  }
}, doRun:function(tokens) {
  var me = this, app = me.application, routes = me.routes, i = 0, length = tokens.length, matched = {}, unmatched = [], token, found, name, route, recognize;
  for (; i < length; i++) {
    token = tokens[i];
    found = false;
    for (name in routes) {
      route = routes[name];
      recognize = route.recognize(token);
      if (recognize) {
        found = true;
        if (recognize !== true) {
          route.execute(token, recognize).then(null, Ext.bind(me.onRouteRejection, me, [route], 0));
        }
        Ext.Array.remove(unmatched, route);
        if (!matched[name]) {
          matched[name] = 1;
        }
      } else {
        if (!matched[name]) {
          unmatched.push(route);
        }
      }
    }
    if (!found) {
      if (app) {
        app.fireEvent('unmatchedroute', token);
      }
      Ext.fireEvent('unmatchedroute', token);
    }
  }
  i = 0;
  length = unmatched.length;
  for (; i < length; i++) {
    unmatched[i].onExit();
  }
}, onRouteRejection:function(route, error) {
  Ext.fireEvent('routereject', route, error);
  if (error) {
    Ext.raise(error);
  }
}, connect:function(url, config, instance) {
  var routes = this.routes, delimiter = this.getMultipleToken(), name = config.name || url, handler, route;
  if (url[0] === '!') {
    if (!Ext.util.History.hashbang) {
      Ext.log({level:'error', msg:'Route found with "!" ("' + url + '"). Should use new hashbang functionality instead. ' + 'Please see the router guide for more: https://docs.sencha.com/extjs/' + Ext.getVersion().version + '/guides/application_architecture/router.html'});
    }
    url = url.substr(1);
    this.setHashbang(true);
  }
  if (Ext.isString(config)) {
    config = {action:config};
  }
  handler = Ext.route.Handler.fromRouteConfig(config, instance);
  route = routes[name];
  if (!route) {
    config.name = name;
    config.url = url;
    route = routes[name] = new Ext.route.Route(config);
  }
  route.addHandler(handler);
  if (handler.lazy) {
    var currentHash = Ext.util.History.getToken(), tokens = currentHash.split(delimiter), length = tokens.length, matched = [], i, token;
    for (i = 0; i < length; i++) {
      token = tokens[i];
      if (Ext.Array.indexOf(matched, token) === -1 && route.recognize(token)) {
        matched.push(token);
      }
    }
    this.onStateChange(matched.join(delimiter));
  }
  return handler;
}, disconnect:function(instance, config) {
  var routes = this.routes, route, name;
  if (config) {
    route = config.route || this.getByName(config.name || config.url);
    if (route) {
      route.removeHandler(instance, config);
    }
  } else {
    for (name in routes) {
      route = routes[name];
      route.removeHandler(instance);
    }
  }
}, recognize:function(url) {
  var routes = this.routes, matches = [], name, arr, i, length, route, urlParams;
  for (name in routes) {
    arr = routes[name];
    length = arr && arr.length;
    if (length) {
      i = 0;
      for (; i < length; i++) {
        route = arr[i];
        urlParams = route.recognize(url);
        if (urlParams) {
          matches.push({route:route, urlParams:urlParams});
        }
      }
    }
  }
  return matches.length ? matches : false;
}, draw:function(fn) {
  fn.call(this, this);
}, clear:function() {
  this.routes = {};
}, clearLastTokens:function(token) {
  var routes = this.routes, name, route;
  for (name in routes) {
    route = routes[name];
    if (!token || route.recognize(token)) {
      route.clearLastTokens();
    }
  }
}, getByName:function(name) {
  var routes = this.routes;
  if (routes) {
    return routes[name];
  }
}, suspend:function(trackTokens) {
  this.isSuspended = true;
  if (!this.suspendedQueue && trackTokens !== false) {
    this.suspendedQueue = [];
  }
}, resume:function(discardQueue) {
  var me = this, queue = me.suspendedQueue, token;
  if (me.isSuspended) {
    me.isSuspended = false;
    me.suspendedQueue = null;
    if (!discardQueue && queue) {
      token = queue.join(me.getMultipleToken());
      me.onStateChange(token);
    }
  }
}});
Ext.define('Ext.route.Mixin', {extend:Ext.Mixin, mixinConfig:{id:'routerable', before:{destroy:'destroyRouterable'}}, config:{routes:null}, destroyRouterable:function() {
  Ext.route.Router.disconnect(this);
}, applyRoutes:function(routes, oldRoutes) {
  var Router = Ext.route.Router, url;
  if (routes) {
    for (url in routes) {
      routes[url] = Router.connect(url, routes[url], this);
    }
  }
  if (oldRoutes) {
    for (url in oldRoutes) {
      Router.disconnect(this, oldRoutes[url]);
    }
  }
  return routes;
}, redirectTo:function(hash, opt) {
  var me = this, currentHash = Ext.util.History.getToken(), Router = Ext.route.Router, delimiter = Router.getMultipleToken(), tokens = currentHash ? currentHash.split(delimiter) : [], length = tokens.length, force, i, name, obj, route, token, match;
  if (hash === -1) {
    return Ext.util.History.back();
  } else {
    if (hash === 1) {
      return Ext.util.History.forward();
    } else {
      if (hash.isModel) {
        hash = hash.toUrl();
      } else {
        if (Ext.isObject(hash)) {
          for (name in hash) {
            obj = hash[name];
            if (!Ext.isObject(obj)) {
              obj = {token:obj};
            }
            if (length) {
              route = Router.getByName(name);
              if (route) {
                match = false;
                for (i = 0; i < length; i++) {
                  token = tokens[i];
                  if (route.matcherRegex.test(token)) {
                    match = true;
                    if (obj.token) {
                      if (obj.fn && obj.fn.call(this, token, tokens, obj) === false) {
                        continue;
                      }
                      tokens[i] = obj.token;
                      if (obj.force) {
                        route.lastToken = null;
                      }
                    } else {
                      tokens.splice(i, 1);
                      i--;
                      length--;
                      route.lastToken = null;
                    }
                  }
                }
                if (obj && obj.token && !match) {
                  tokens.push(obj.token);
                }
              }
            } else {
              if (obj && obj.token) {
                tokens.push(obj.token);
              }
            }
          }
          hash = tokens.join(delimiter);
        }
      }
    }
  }
  if (opt === true) {
    force = opt;
    opt = null;
  } else {
    if (opt) {
      force = opt.force;
    }
  }
  length = tokens.length;
  if (force && length) {
    for (i = 0; i < length; i++) {
      token = tokens[i];
      Router.clearLastTokens(token);
    }
  }
  if (currentHash === hash) {
    if (force) {
      Router.onStateChange(hash);
    }
    return false;
  }
  if (opt && opt.replace) {
    Ext.util.History.replace(hash);
  } else {
    Ext.util.History.add(hash);
  }
  return true;
}, privates:{afterClassMixedIn:function(targetClass) {
  var proto = targetClass.prototype, routes = proto.routes;
  if (routes) {
    delete proto.routes;
    targetClass.getConfigurator().add({routes:routes});
  }
}}});
Ext.define('Ext.app.BaseController', {mixins:[Ext.mixin.Observable, Ext.route.Mixin], isController:true, config:{id:undefined, control:null, listen:null}, constructor:function(config) {
  var me = this;
  Ext.apply(me, config);
  delete me.control;
  delete me.listen;
  me.eventbus = Ext.app.EventBus;
  me.mixins.observable.constructor.call(me, config);
}, updateId:function(id) {
  this.id = id;
}, applyListen:function(listen) {
  if (Ext.isObject(listen)) {
    listen = Ext.clone(listen);
  }
  return listen;
}, applyControl:function(control) {
  if (Ext.isObject(control)) {
    control = Ext.clone(control);
  }
  return control;
}, updateControl:function(control) {
  this.getId();
  if (control) {
    this.control(control);
  }
}, updateListen:function(listen) {
  this.getId();
  if (listen) {
    this.listen(listen);
  }
}, isActive:function() {
  return true;
}, control:function(selectors, listeners, controller) {
  var me = this, ctrl = controller, obj;
  if (Ext.isString(selectors)) {
    obj = {};
    obj[selectors] = listeners;
  } else {
    obj = selectors;
    ctrl = listeners;
  }
  me.eventbus.control(obj, ctrl || me);
}, listen:function(to, controller) {
  this.eventbus.listen(to, controller || this);
}, destroy:function() {
  var me = this, bus = me.eventbus;
  if (bus) {
    bus.unlisten(me);
    me.eventbus = null;
  }
  me.callParent();
}});
Ext.define('Ext.app.Util', {}, function() {
  Ext.apply(Ext.app, {namespaces:{Ext:{}}, addNamespaces:function(namespace) {
    var namespaces = Ext.app.namespaces, i, l;
    if (!Ext.isArray(namespace)) {
      namespace = [namespace];
    }
    for (i = 0, l = namespace.length; i < l; i++) {
      namespaces[namespace[i]] = true;
    }
  }, clearNamespaces:function() {
    Ext.app.namespaces = {};
  }, getNamespace:function(className) {
    var namespaces = Ext.apply({}, Ext.ClassManager.paths, Ext.app.namespaces), deepestPrefix = '', prefix;
    for (prefix in namespaces) {
      if (namespaces.hasOwnProperty(prefix) && prefix.length > deepestPrefix.length && prefix + '.' === className.substring(0, prefix.length + 1)) {
        deepestPrefix = prefix;
      }
    }
    return deepestPrefix === '' ? undefined : deepestPrefix;
  }, setupPaths:function(appName, appFolder, paths) {
    var manifestPaths = Ext.manifest, ns;
    if (appName && appFolder !== null) {
      manifestPaths = manifestPaths && manifestPaths.paths;
      if (!manifestPaths || appFolder !== undefined) {
        Ext.Loader.setPath(appName, appFolder === undefined ? 'app' : appFolder);
      }
    }
    if (paths) {
      for (ns in paths) {
        if (paths.hasOwnProperty(ns)) {
          Ext.Loader.setPath(ns, paths[ns]);
        }
      }
    }
  }});
  Ext.getNamespace = Ext.app.getNamespace;
});
Ext.define('Ext.util.Filter', {isFilter:true, config:{property:null, value:null, filterFn:null, id:null, anyMatch:false, exactMatch:false, caseSensitive:false, disabled:false, disableOnEmpty:false, operator:null, root:null, serializer:null, convert:null}, scope:null, $configStrict:false, generation:0, statics:{createFilterFn:function(filters) {
  if (!filters) {
    return Ext.returnTrue;
  }
  return function(candidate) {
    var items = filters.isCollection ? filters.items : filters, length = items.length, match = true, i, filter;
    for (i = 0; match && i < length; i++) {
      filter = items[i];
      if (!filter.getDisabled()) {
        match = filter.filter(candidate);
      }
    }
    return match;
  };
}, isEqual:function(filter1, filter2) {
  if (filter1.getProperty() !== filter2.getProperty()) {
    return false;
  }
  if (filter1.getOperator() !== filter2.getOperator()) {
    return false;
  }
  if (filter1.getValue() === filter2.getValue()) {
    return true;
  } else {
    if (Ext.isArray(filter1) && Ext.isArray(filter2) && Ext.Array.equals(filter1, filter2)) {
      return true;
    }
  }
  return false;
}, isInvalid:function(cfg) {
  if (!cfg.filterFn) {
    if (!cfg.property) {
      return 'A Filter requires either a property or a filterFn to be set';
    }
    if (!cfg.hasOwnProperty('value') && !cfg.operator) {
      return 'A Filter requires either a property and value, or a filterFn to be set';
    }
  }
  return false;
}}, constructor:function(config) {
  var warn = Ext.util.Filter.isInvalid(config);
  if (warn) {
    Ext.log.warn(warn);
  }
  this.initConfig(config);
}, preventConvert:{'in':1, notin:1}, filter:function(item) {
  var me = this, filterFn = me._filterFn || me.getFilterFn(), convert = me.getConvert(), value = me._value;
  me._filterValue = value;
  me.isDateValue = Ext.isDate(value);
  if (me.isDateValue) {
    me.dateValue = value.getTime();
  }
  if (convert && !me.preventConvert[me.getOperator()]) {
    me._filterValue = convert.call(me.scope || me, value);
  }
  return filterFn.call(me.scope || me, item);
}, getId:function() {
  var id = this._id;
  if (!id) {
    id = this.getProperty();
    if (!id) {
      id = Ext.id(null, 'ext-filter-');
    }
    this._id = id;
  }
  return id;
}, getFilterFn:function() {
  var me = this, filterFn = me._filterFn, operator;
  if (!filterFn) {
    operator = me.getOperator();
    if (operator) {
      filterFn = me.operatorFns[operator];
    } else {
      filterFn = me.createRegexFilter();
    }
    me._filterFn = filterFn;
    me.generatedFilterFn = true;
  }
  return filterFn;
}, createRegexFilter:function() {
  var me = this, anyMatch = !!me.getAnyMatch(), exact = !!me.getExactMatch(), value = me.getValue(), matcher = Ext.String.createRegex(value, !anyMatch, !anyMatch && exact, !me.getCaseSensitive());
  return function(item) {
    var val = me.getPropertyValue(item);
    return matcher ? matcher.test(val) : val == null;
  };
}, getPropertyValue:function(item) {
  var root = this._root, value = root == null ? item : item[root];
  return value[this._property];
}, getState:function() {
  var config = this.getInitialConfig(), result = {}, name;
  for (name in config) {
    if (config.hasOwnProperty(name)) {
      result[name] = config[name];
    }
  }
  delete result.root;
  result.value = this.getValue();
  return result;
}, getScope:function() {
  return this.scope;
}, serialize:function() {
  var result = this.getState(), serializer = this.getSerializer(), serialized;
  delete result.id;
  delete result.serializer;
  if (serializer) {
    serialized = serializer.call(this, result);
    if (serialized) {
      result = serialized;
    }
  }
  return result;
}, updateDisabled:function() {
  this.generation++;
}, updateOperator:function() {
  this.onConfigMutation();
}, updateConvert:function() {
  this.onConfigMutation();
}, updateProperty:function() {
  this.onConfigMutation();
}, updateAnyMatch:function() {
  this.onConfigMutation();
}, updateExactMatch:function() {
  this.onConfigMutation();
}, updateCaseSensitive:function() {
  this.onConfigMutation();
}, updateValue:function(value) {
  this.onConfigMutation();
  if (this.getDisableOnEmpty()) {
    this.setDisabled(Ext.isEmpty(value));
  }
}, updateFilterFn:function(filterFn) {
  delete this.generatedFilterFn;
}, onConfigMutation:function() {
  this.generation++;
  if (this.generatedFilterFn) {
    this._filterFn = null;
  }
}, updateDisableOnEmpty:function(disableOnEmpty) {
  if (disableOnEmpty) {
    this.setDisabled(Ext.isEmpty(this.getValue()));
  }
}, privates:{getCandidateValue:function(candidate, v, preventCoerce) {
  var me = this, convert = me._convert, result = me.getPropertyValue(candidate);
  if (convert) {
    result = convert.call(me.scope || me, result);
  } else {
    if (!preventCoerce) {
      result = Ext.coerce(result, v);
    }
  }
  return result;
}}}, function() {
  var prototype = this.prototype, operatorFns = prototype.operatorFns = {'\x3c':function(candidate) {
    var v = this._filterValue;
    return this.getCandidateValue(candidate, v) < v;
  }, '\x3c\x3d':function(candidate) {
    var v = this._filterValue;
    return this.getCandidateValue(candidate, v) <= v;
  }, '\x3d':function(candidate) {
    var me = this, v = me._filterValue;
    candidate = me.getCandidateValue(candidate, v);
    if (me.isDateValue && candidate instanceof Date) {
      candidate = candidate.getTime();
      v = me.dateValue;
    }
    return candidate == v;
  }, '\x3d\x3d\x3d':function(candidate) {
    var me = this, v = me._filterValue;
    candidate = me.getCandidateValue(candidate, v, true);
    if (me.isDateValue && candidate instanceof Date) {
      candidate = candidate.getTime();
      v = me.dateValue;
    }
    return candidate === v;
  }, '\x3e\x3d':function(candidate) {
    var v = this._filterValue;
    return this.getCandidateValue(candidate, v) >= v;
  }, '\x3e':function(candidate) {
    var v = this._filterValue;
    return this.getCandidateValue(candidate, v) > v;
  }, '!\x3d':function(candidate) {
    var me = this, v = me._filterValue;
    candidate = me.getCandidateValue(candidate, v);
    if (me.isDateValue && candidate instanceof Date) {
      candidate = candidate.getTime();
      v = me.dateValue;
    }
    return candidate != v;
  }, '!\x3d\x3d':function(candidate) {
    var me = this, v = me._filterValue;
    candidate = me.getCandidateValue(candidate, v, true);
    if (me.isDateValue && candidate instanceof Date) {
      candidate = candidate.getTime();
      v = me.dateValue;
    }
    return candidate !== v;
  }, 'in':function(candidate) {
    var v = this._filterValue;
    return Ext.Array.contains(v, this.getCandidateValue(candidate, v));
  }, notin:function(candidate) {
    var v = this._filterValue;
    return !Ext.Array.contains(v, this.getCandidateValue(candidate, v));
  }, like:function(candidate) {
    var v = this._filterValue;
    return v && this.getCandidateValue(candidate, v).toLowerCase().indexOf(v.toLowerCase()) > -1;
  }, '/\x3d':function(candidate) {
    var me = this, v = me._filterValue;
    candidate = me.getCandidateValue(candidate, v);
    if (v !== me.lastRegExpSource) {
      me.lastRegExpSource = v;
      try {
        me.regex = new RegExp(v, 'i');
      } catch (e$27) {
        me.regex = null;
      }
    }
    return me.regex ? me.regex.test(candidate) : false;
  }};
  operatorFns['\x3d\x3d'] = operatorFns['\x3d'];
  operatorFns.gt = operatorFns['\x3e'];
  operatorFns.ge = operatorFns['\x3e\x3d'];
  operatorFns.lt = operatorFns['\x3c'];
  operatorFns.le = operatorFns['\x3c\x3d'];
  operatorFns.eq = operatorFns['\x3d'];
  operatorFns.ne = operatorFns['!\x3d'];
});
Ext.define('Ext.util.AbstractMixedCollection', {mixins:{observable:Ext.util.Observable}, isMixedCollection:true, generation:0, indexGeneration:0, constructor:function(allowFunctions, keyFn) {
  var me = this;
  if (arguments.length === 1 && Ext.isObject(allowFunctions)) {
    me.initialConfig = allowFunctions;
    Ext.apply(me, allowFunctions);
  } else {
    me.allowFunctions = allowFunctions === true;
    if (keyFn) {
      me.getKey = keyFn;
    }
    me.initialConfig = {allowFunctions:me.allowFunctions, getKey:me.getKey};
  }
  me.items = [];
  me.map = {};
  me.keys = [];
  me.indexMap = {};
  me.length = 0;
  me.mixins.observable.constructor.call(me);
}, destroy:function() {
  var me = this;
  me.items = me.map = me.keys = me.indexMap = null;
  me.callParent();
}, allowFunctions:false, add:function(key, obj) {
  var len = this.length, out;
  if (arguments.length === 1) {
    out = this.insert(len, key);
  } else {
    out = this.insert(len, key, obj);
  }
  return out;
}, getKey:function(item) {
  return item.id;
}, replace:function(key, o) {
  var me = this, old, index;
  if (arguments.length == 1) {
    o = arguments[0];
    key = me.getKey(o);
  }
  old = me.map[key];
  if (typeof key == 'undefined' || key === null || typeof old == 'undefined') {
    return me.add(key, o);
  }
  me.generation++;
  index = me.indexOfKey(key);
  me.items[index] = o;
  me.map[key] = o;
  if (me.hasListeners.replace) {
    me.fireEvent('replace', key, old, o);
  }
  return o;
}, reorder:function(mapping) {
  var me = this, items = me.items, index = 0, length = items.length, order = [], remaining = [], oldIndex;
  me.suspendEvents();
  for (oldIndex in mapping) {
    order[mapping[oldIndex]] = items[oldIndex];
  }
  for (index = 0; index < length; index++) {
    if (mapping[index] == undefined) {
      remaining.push(items[index]);
    }
  }
  for (index = 0; index < length; index++) {
    if (order[index] == undefined) {
      order[index] = remaining.shift();
    }
  }
  me.clear();
  me.addAll(order);
  me.resumeEvents();
}, updateKey:function(oldKey, newKey) {
  var me = this, map = me.map, index = me.indexOfKey(oldKey), indexMap = me.indexMap, item;
  if (index > -1) {
    item = map[oldKey];
    delete map[oldKey];
    delete indexMap[oldKey];
    map[newKey] = item;
    indexMap[newKey] = index;
    me.keys[index] = newKey;
    me.indexGeneration = ++me.generation;
  }
}, addAll:function(objs) {
  var me = this, key;
  if (arguments.length > 1 || Ext.isArray(objs)) {
    me.insert(me.length, arguments.length > 1 ? arguments : objs);
  } else {
    for (key in objs) {
      if (objs.hasOwnProperty(key)) {
        if (me.allowFunctions || typeof objs[key] != 'function') {
          me.add(key, objs[key]);
        }
      }
    }
  }
}, each:function(fn, scope) {
  var items = Ext.Array.push([], this.items), i = 0, len = items.length, item;
  for (; i < len; i++) {
    item = items[i];
    if (fn.call(scope || item, item, i, len) === false) {
      break;
    }
  }
}, eachKey:function(fn, scope) {
  var keys = this.keys, items = this.items, i = 0, len = keys.length;
  for (; i < len; i++) {
    fn.call(scope || window, keys[i], items[i], i, len);
  }
}, findBy:function(fn, scope) {
  var keys = this.keys, items = this.items, i = 0, len = items.length;
  for (; i < len; i++) {
    if (fn.call(scope || window, items[i], keys[i])) {
      return items[i];
    }
  }
  return null;
}, insert:function(index, key, obj) {
  var out;
  if (Ext.isIterable(key)) {
    out = this.doInsert(index, key, obj);
  } else {
    if (arguments.length > 2) {
      out = this.doInsert(index, [key], [obj]);
    } else {
      out = this.doInsert(index, [key]);
    }
    out = out[0];
  }
  return out;
}, doInsert:function(index, keys, objects) {
  var me = this, itemKey, removeIndex, i, len = keys.length, deDupedLen = len, fireAdd = me.hasListeners.add, syncIndices, newKeys = {}, passedDuplicates, oldKeys, oldObjects;
  if (objects != null) {
    me.useLinearSearch = true;
  } else {
    objects = keys;
    keys = new Array(len);
    for (i = 0; i < len; i++) {
      keys[i] = this.getKey(objects[i]);
    }
  }
  me.suspendEvents();
  for (i = 0; i < len; i++) {
    itemKey = keys[i];
    removeIndex = me.indexOfKey(itemKey);
    if (removeIndex !== -1) {
      if (removeIndex < index) {
        index--;
      }
      me.removeAt(removeIndex);
    }
    if (itemKey != null) {
      if (newKeys[itemKey] != null) {
        passedDuplicates = true;
        deDupedLen--;
      }
      newKeys[itemKey] = i;
    }
  }
  me.resumeEvents();
  if (passedDuplicates) {
    oldKeys = keys;
    oldObjects = objects;
    keys = new Array(deDupedLen);
    objects = new Array(deDupedLen);
    i = 0;
    for (itemKey in newKeys) {
      keys[i] = oldKeys[newKeys[itemKey]];
      objects[i] = oldObjects[newKeys[itemKey]];
      i++;
    }
    len = deDupedLen;
  }
  syncIndices = index === me.length && me.indexGeneration === me.generation;
  Ext.Array.insert(me.items, index, objects);
  Ext.Array.insert(me.keys, index, keys);
  me.length += len;
  me.generation++;
  if (syncIndices) {
    me.indexGeneration = me.generation;
  }
  for (i = 0; i < len; i++, index++) {
    itemKey = keys[i];
    if (itemKey != null) {
      me.map[itemKey] = objects[i];
      if (syncIndices) {
        me.indexMap[itemKey] = index;
      }
    }
    if (fireAdd) {
      me.fireEvent('add', index, objects[i], itemKey);
    }
  }
  return objects;
}, remove:function(o) {
  var me = this, removeKey, index;
  if (!me.useLinearSearch && (removeKey = me.getKey(o))) {
    index = me.indexOfKey(removeKey);
  } else {
    index = Ext.Array.indexOf(me.items, o);
  }
  return index === -1 ? false : me.removeAt(index);
}, removeAll:function(items) {
  var me = this, i;
  if (items || me.hasListeners.remove) {
    if (items) {
      for (i = items.length - 1; i >= 0; --i) {
        me.remove(items[i]);
      }
    } else {
      while (me.length) {
        me.removeAt(0);
      }
    }
  } else {
    me.length = me.items.length = me.keys.length = 0;
    me.map = {};
    me.indexMap = {};
    me.generation++;
    me.indexGeneration = me.generation;
  }
}, removeAt:function(index) {
  var me = this, o, key;
  if (index < me.length && index >= 0) {
    me.length--;
    o = me.items[index];
    Ext.Array.erase(me.items, index, 1);
    key = me.keys[index];
    if (typeof key != 'undefined') {
      delete me.map[key];
    }
    Ext.Array.erase(me.keys, index, 1);
    if (me.hasListeners.remove) {
      me.fireEvent('remove', o, key);
    }
    me.generation++;
    return o;
  }
  return false;
}, removeRange:function(index, removeCount) {
  var me = this, o, key, i, limit, syncIndices, trimming;
  if (index < me.length && index >= 0) {
    if (!removeCount) {
      removeCount = 1;
    }
    limit = Math.min(index + removeCount, me.length);
    removeCount = limit - index;
    trimming = limit === me.length;
    syncIndices = trimming && me.indexGeneration === me.generation;
    for (i = index; i < limit; i++) {
      key = me.keys[i];
      if (key != null) {
        delete me.map[key];
        if (syncIndices) {
          delete me.indexMap[key];
        }
      }
    }
    o = me.items[i - 1];
    me.length -= removeCount;
    me.generation++;
    if (syncIndices) {
      me.indexGeneration = me.generation;
    }
    if (trimming) {
      me.items.length = me.keys.length = me.length;
    } else {
      me.items.splice(index, removeCount);
      me.keys.splice(index, removeCount);
    }
    return o;
  }
  return false;
}, removeAtKey:function(key) {
  var me = this, keys = me.keys, i;
  if (key == null) {
    for (i = keys.length - 1; i >= 0; i--) {
      if (keys[i] == null) {
        me.removeAt(i);
      }
    }
  } else {
    return me.removeAt(me.indexOfKey(key));
  }
}, getCount:function() {
  return this.length;
}, indexOf:function(o) {
  var me = this, key;
  if (o != null) {
    if (!me.useLinearSearch && (key = me.getKey(o))) {
      return this.indexOfKey(key);
    }
    return Ext.Array.indexOf(me.items, o);
  }
  return -1;
}, indexOfKey:function(key) {
  if (!this.map.hasOwnProperty(key)) {
    return -1;
  }
  if (this.indexGeneration !== this.generation) {
    this.rebuildIndexMap();
  }
  return this.indexMap[key];
}, rebuildIndexMap:function() {
  var me = this, indexMap = me.indexMap = {}, keys = me.keys, len = keys.length, i;
  for (i = 0; i < len; i++) {
    indexMap[keys[i]] = i;
  }
  me.indexGeneration = me.generation;
}, get:function(key) {
  var me = this, mk = me.map[key], item = mk !== undefined ? mk : typeof key == 'number' ? me.items[key] : undefined;
  return typeof item != 'function' || me.allowFunctions ? item : null;
}, getAt:function(index) {
  return this.items[index];
}, getByKey:function(key) {
  return this.map[key];
}, contains:function(o) {
  var me = this, key;
  if (o != null) {
    if (!me.useLinearSearch && (key = me.getKey(o))) {
      return this.map[key] != null;
    }
    return Ext.Array.indexOf(this.items, o) !== -1;
  }
  return false;
}, containsKey:function(key) {
  return this.map.hasOwnProperty(key);
}, clear:function() {
  var me = this;
  if (me.generation) {
    me.length = 0;
    me.items = [];
    me.keys = [];
    me.map = {};
    me.indexMap = {};
    me.generation++;
    me.indexGeneration = me.generation;
  }
  if (me.hasListeners.clear) {
    me.fireEvent('clear');
  }
}, first:function() {
  return this.items[0];
}, last:function() {
  return this.items[this.length - 1];
}, sum:function(property, root, start, end) {
  var values = this.extractValues(property, root), length = values.length, sum = 0, i;
  start = start || 0;
  end = end || end === 0 ? end : length - 1;
  for (i = start; i <= end; i++) {
    sum += values[i];
  }
  return sum;
}, collect:function(property, root, allowNull) {
  var values = this.extractValues(property, root), length = values.length, hits = {}, unique = [], value, strValue, i;
  for (i = 0; i < length; i++) {
    value = values[i];
    strValue = String(value);
    if ((allowNull || !Ext.isEmpty(value)) && !hits[strValue]) {
      hits[strValue] = true;
      unique.push(value);
    }
  }
  return unique;
}, extractValues:function(property, root) {
  var values = this.items;
  if (root) {
    values = Ext.Array.pluck(values, root);
  }
  return Ext.Array.pluck(values, property);
}, hasRange:function(start, end) {
  return end < this.length;
}, getRange:function(start, end) {
  var me = this, items = me.items, range = [], len = items.length, tmp, reverse;
  if (len < 1) {
    return range;
  }
  if (start > end) {
    reverse = true;
    tmp = start;
    start = end;
    end = tmp;
  }
  if (start < 0) {
    start = 0;
  }
  if (end == null || end >= len) {
    end = len - 1;
  }
  range = items.slice(start, end + 1);
  if (reverse && range.length) {
    range.reverse();
  }
  return range;
}, filter:function(property, value, anyMatch, caseSensitive) {
  var filters = [];
  if (Ext.isString(property)) {
    filters.push(new Ext.util.Filter({property:property, value:value, anyMatch:anyMatch, caseSensitive:caseSensitive}));
  } else {
    if (Ext.isArray(property) || property instanceof Ext.util.Filter) {
      filters = filters.concat(property);
    }
  }
  return this.filterBy(Ext.util.Filter.createFilterFn(filters));
}, filterBy:function(fn, scope) {
  var me = this, newMC = new me.self(me.initialConfig), keys = me.keys, items = me.items, length = items.length, i;
  newMC.getKey = me.getKey;
  for (i = 0; i < length; i++) {
    if (fn.call(scope || me, items[i], keys[i])) {
      newMC.add(keys[i], items[i]);
    }
  }
  newMC.useLinearSearch = me.useLinearSearch;
  return newMC;
}, findIndex:function(property, value, start, anyMatch, caseSensitive) {
  if (Ext.isEmpty(value, false)) {
    return -1;
  }
  value = this.createValueMatcher(value, anyMatch, caseSensitive);
  return this.findIndexBy(function(o) {
    return o && value.test(o[property]);
  }, null, start);
}, findIndexBy:function(fn, scope, start) {
  var me = this, keys = me.keys, items = me.items, i = start || 0, len = items.length;
  for (; i < len; i++) {
    if (fn.call(scope || me, items[i], keys[i])) {
      return i;
    }
  }
  return -1;
}, createValueMatcher:function(value, anyMatch, caseSensitive, exactMatch) {
  if (!value.exec) {
    var er = Ext.String.escapeRegex;
    value = String(value);
    if (anyMatch === true) {
      value = er(value);
    } else {
      value = '^' + er(value);
      if (exactMatch === true) {
        value += '$';
      }
    }
    value = new RegExp(value, caseSensitive ? '' : 'i');
  }
  return value;
}, clone:function() {
  var me = this, copy = new me.self(me.initialConfig);
  copy.add(me.keys, me.items);
  copy.useLinearSearch = me.useLinearSearch;
  return copy;
}});
Ext.define('Ext.util.Sorter', {isSorter:true, config:{property:null, sorterFn:null, root:null, transform:null, direction:'ASC', id:undefined}, statics:{createComparator:function(sorters, nextFn) {
  nextFn = nextFn || 0;
  return function(lhs, rhs) {
    var items = sorters.isCollection ? sorters.items : sorters, n = items.length, comp, i;
    for (i = 0; i < n; ++i) {
      comp = items[i].sort(lhs, rhs);
      if (comp) {
        return comp;
      }
    }
    return nextFn && nextFn(lhs, rhs);
  };
}}, multiplier:1, constructor:function(config) {
  if (config && !this.isGrouper) {
    if (!config.property === !config.sorterFn) {
      Ext.raise('A Sorter requires either a property or a sorterFn.');
    }
  }
  this.initConfig(config);
}, getId:function() {
  var id = this._id;
  if (!id) {
    id = this.getProperty();
    if (!id) {
      id = Ext.id(null, 'ext-sorter-');
    }
    this._id = id;
  }
  return id;
}, sort:function(lhs, rhs) {
  return this.multiplier * this.sortFn(lhs, rhs);
}, sortFn:function(item1, item2) {
  var me = this, transform = me._transform, root = me._root, property = me._property, lhs, rhs;
  if (root) {
    item1 = item1[root];
    item2 = item2[root];
  }
  lhs = item1[property];
  rhs = item2[property];
  if (transform) {
    lhs = transform(lhs);
    rhs = transform(rhs);
  }
  return lhs > rhs ? 1 : lhs < rhs ? -1 : 0;
}, applyDirection:function(direction) {
  return direction ? direction : 'ASC';
}, updateDirection:function(direction) {
  this.multiplier = direction.toUpperCase() === 'DESC' ? -1 : 1;
}, updateProperty:function(property) {
  if (property) {
    delete this.sortFn;
  }
}, updateSorterFn:function(sorterFn) {
  this.sortFn = sorterFn;
}, toggle:function() {
  this.setDirection(Ext.String.toggle(this.getDirection(), 'ASC', 'DESC'));
}, getState:function() {
  var me = this, result = {root:me.getRoot(), property:me.getProperty(), direction:me.getDirection()};
  if (me._id) {
    result.id = me._id;
  }
  return result;
}, serialize:function() {
  return {property:this.getProperty(), direction:this.getDirection()};
}});
Ext.define('Ext.util.Sortable', {isSortable:true, $configPrefixed:false, $configStrict:false, config:{sorters:null}, defaultSortDirection:'ASC', multiSortLimit:3, statics:{createComparator:function(sorters) {
  return sorters && sorters.length ? function(r1, r2) {
    var result = sorters[0].sort(r1, r2), length = sorters.length, i = 1;
    for (; !result && i < length; i++) {
      result = sorters[i].sort.call(sorters[i], r1, r2);
    }
    return result;
  } : function() {
    return 0;
  };
}}, applySorters:function(sorters) {
  var me = this, sortersCollection = me.getSorters() || new Ext.util.MixedCollection(false, Ext.returnId);
  if (sorters) {
    sortersCollection.addAll(me.decodeSorters(sorters));
  }
  return sortersCollection;
}, sort:function(sorters, direction, insertionPosition, doSort) {
  var me = this, sorter, overFlow, currentSorters = me.getSorters();
  if (!currentSorters) {
    me.setSorters(null);
    currentSorters = me.getSorters();
  }
  if (Ext.isArray(sorters)) {
    doSort = insertionPosition;
    insertionPosition = direction;
  } else {
    if (Ext.isObject(sorters)) {
      sorters = [sorters];
      doSort = insertionPosition;
      insertionPosition = direction;
    } else {
      if (Ext.isString(sorters)) {
        sorter = currentSorters.get(sorters);
        if (!sorter) {
          sorter = {property:sorters, direction:direction};
        } else {
          if (direction == null) {
            sorter.toggle();
          } else {
            sorter.setDirection(direction);
          }
        }
        sorters = [sorter];
      }
    }
  }
  if (sorters && sorters.length) {
    sorters = me.decodeSorters(sorters);
    switch(insertionPosition) {
      case 'multi':
        currentSorters.insert(0, sorters[0]);
        overFlow = currentSorters.getCount() - me.multiSortLimit;
        if (overFlow > 0) {
          currentSorters.removeRange(me.multiSortLimit, overFlow);
        }
        break;
      case 'prepend':
        currentSorters.insert(0, sorters);
        break;
      case 'append':
        currentSorters.addAll(sorters);
        break;
      case undefined:
      case null:
      case 'replace':
        currentSorters.clear();
        currentSorters.addAll(sorters);
        break;
      default:
        Ext.raise('Sorter insertion point must be "multi", "prepend", "append" or "replace"');
    }
  }
  if (doSort !== false) {
    me.fireEvent('beforesort', me, sorters);
    me.onBeforeSort(sorters);
    if (me.getSorterCount()) {
      me.doSort(me.generateComparator());
    }
  }
  return sorters;
}, getSorterCount:function() {
  return this.getSorters().items.length;
}, generateComparator:function() {
  var sorters = this.getSorters().getRange();
  return sorters.length ? this.createComparator(sorters) : this.emptyComparator;
}, emptyComparator:function() {
  return 0;
}, onBeforeSort:Ext.emptyFn, decodeSorters:function(sorters) {
  if (!Ext.isArray(sorters)) {
    if (sorters === undefined) {
      sorters = [];
    } else {
      sorters = [sorters];
    }
  }
  var length = sorters.length, Sorter = Ext.util.Sorter, model = this.getModel ? this.getModel() : this.model, field, config, i;
  for (i = 0; i < length; i++) {
    config = sorters[i];
    if (!(config instanceof Sorter)) {
      if (Ext.isString(config)) {
        config = {property:config};
      }
      Ext.applyIf(config, {root:this.sortRoot, direction:'ASC'});
      if (config.fn) {
        config.sorterFn = config.fn;
      }
      if (typeof config == 'function') {
        config = {sorterFn:config};
      }
      if (model && !config.transform) {
        field = model.getField(config.property);
        config.transform = field && field.sortType !== Ext.identityFn ? field.sortType : undefined;
      }
      sorters[i] = new Ext.util.Sorter(config);
    }
  }
  return sorters;
}, getFirstSorter:function() {
  var sorters = this.getSorters().items, len = sorters.length, i = 0, sorter;
  for (; i < len; ++i) {
    sorter = sorters[i];
    if (!sorter.isGrouper) {
      return sorter;
    }
  }
  return null;
}}, function() {
  this.prototype.createComparator = this.createComparator;
});
Ext.define('Ext.util.MixedCollection', {extend:Ext.util.AbstractMixedCollection, mixins:{sortable:Ext.util.Sortable}, constructor:function() {
  this.initConfig();
  this.callParent(arguments);
}, doSort:function(sorterFn) {
  this.sortBy(sorterFn);
}, _sort:function(property, dir, fn) {
  var me = this, i, len, dsc = String(dir).toUpperCase() == 'DESC' ? -1 : 1, c = [], keys = me.keys, items = me.items, o;
  fn = fn || function(a, b) {
    return a - b;
  };
  for (i = 0, len = items.length; i < len; i++) {
    c[c.length] = {key:keys[i], value:items[i], index:i};
  }
  Ext.Array.sort(c, function(a, b) {
    return fn(a[property], b[property]) * dsc || (a.index < b.index ? -1 : 1);
  });
  for (i = 0, len = c.length; i < len; i++) {
    o = c[i];
    items[i] = o.value;
    keys[i] = o.key;
    me.indexMap[o.key] = i;
  }
  me.generation++;
  me.indexGeneration = me.generation;
  me.fireEvent('sort', me);
}, sortBy:function(sorterFn) {
  var me = this, items = me.items, item, keys = me.keys, key, length = items.length, i;
  for (i = 0; i < length; i++) {
    items[i].$extCollectionIndex = i;
  }
  Ext.Array.sort(items, function(a, b) {
    return sorterFn(a, b) || (a.$extCollectionIndex < b.$extCollectionIndex ? -1 : 1);
  });
  for (i = 0; i < length; i++) {
    item = items[i];
    key = me.getKey(item);
    keys[i] = key;
    me.indexMap[key] = i;
    delete item.$extCollectionIndex;
  }
  me.generation++;
  me.indexGeneration = me.generation;
  me.fireEvent('sort', me, items, keys);
}, findInsertionIndex:function(newItem, sorterFn) {
  var me = this, items = me.items, start = 0, end = items.length - 1, middle, comparison;
  if (!sorterFn) {
    sorterFn = me.generateComparator();
  }
  while (start <= end) {
    middle = start + end >> 1;
    comparison = sorterFn(newItem, items[middle]);
    if (comparison >= 0) {
      start = middle + 1;
    } else {
      if (comparison < 0) {
        end = middle - 1;
      }
    }
  }
  return start;
}, reorder:function(mapping) {
  this.callParent([mapping]);
  this.fireEvent('sort', this);
}, sortByKey:function(dir, fn) {
  this._sort('key', dir, fn || function(a, b) {
    var v1 = String(a).toUpperCase(), v2 = String(b).toUpperCase();
    return v1 > v2 ? 1 : v1 < v2 ? -1 : 0;
  });
}});
Ext.define('Ext.util.CollectionKey', {mixins:[Ext.mixin.Identifiable], isCollectionKey:true, observerPriority:-200, config:{collection:null, keyFn:null, property:null, rootProperty:null, unique:true}, generation:0, map:null, mapRebuilds:0, constructor:function(config) {
  this.initConfig(config);
  if (!Ext.isFunction(this.getKey)) {
    Ext.raise('CollectionKey requires a keyFn or property config');
  }
}, get:function(key) {
  var map = this.map || this.getMap();
  return map[key] || null;
}, clear:function() {
  this.map = null;
}, getRootProperty:function() {
  var me = this, root = this.callParent();
  return root !== null ? root : me.getCollection().getRootProperty();
}, indexOf:function(key, startAt) {
  var map = this.map || this.getMap(), item = map[key], collection = this.getCollection(), length = collection.length, i, index, items, n;
  if (!item) {
    return -1;
  }
  if (startAt === undefined) {
    startAt = -1;
  }
  if (item instanceof Array) {
    items = item;
    index = length;
    for (n = items.length; n-- > 0;) {
      i = collection.indexOf(items[n]);
      if (i < index && i > startAt) {
        index = i;
      }
    }
    if (index === length) {
      return -1;
    }
  } else {
    index = collection.indexOf(item);
  }
  return index > startAt ? index : -1;
}, updateKey:function(item, oldKey) {
  var me = this, map = me.map, bucket, index;
  if (map) {
    bucket = map[oldKey];
    if (bucket instanceof Array) {
      index = Ext.Array.indexOf(bucket, item);
      if (index >= 0) {
        if (bucket.length > 2) {
          bucket.splice(index, 1);
        } else {
          map[oldKey] = bucket[1 - index];
        }
      }
    } else {
      if (bucket) {
        if (me.getUnique() && bucket !== item) {
          Ext.raise('Incorrect oldKey "' + oldKey + '" for item with newKey "' + me.getKey(item) + '"');
        }
        delete map[oldKey];
      }
    }
    me.add([item]);
  }
}, onCollectionAdd:function(collection, add) {
  if (this.map) {
    this.add(add.items);
  }
}, onCollectionItemChange:function(collection, details) {
  this.map = null;
}, onCollectionRefresh:function() {
  this.map = null;
}, onCollectionRemove:function(collection, remove) {
  var me = this, map = me.map, items = remove.items, length = items.length, i, item, key;
  if (map) {
    if (me.getUnique() && length < collection.length / 2) {
      for (i = 0; i < length; ++i) {
        key = me.getKey(item = items[i]);
        delete map[key];
      }
    } else {
      me.map = null;
    }
  }
}, add:function(items) {
  var me = this, map = me.map, bucket, i, item, key, length, unique;
  length = items.length;
  unique = me.getUnique();
  for (i = 0; i < length; ++i) {
    key = me.getKey(item = items[i]);
    if (unique || !(key in map)) {
      map[key] = item;
    } else {
      if (!((bucket = map[key]) instanceof Array)) {
        map[key] = bucket = [bucket];
      }
      bucket.push(item);
    }
  }
}, applyKeyFn:function(keyFn) {
  if (Ext.isString(keyFn)) {
    this.getKey = function(item) {
      return item[keyFn]();
    };
  } else {
    this.getKey = keyFn;
  }
}, updateProperty:function(property) {
  var root = this.getRootProperty();
  this.getKey = function(item) {
    return (root ? item[root] : item)[property];
  };
}, getMap:function() {
  var me = this, map = me.map;
  if (!map) {
    me.map = map = {};
    me.keysByItemKey = {};
    ++me.mapRebuilds;
    me.add(me.getCollection().items);
  }
  return map;
}, updateCollection:function(collection, oldCollection) {
  if (collection) {
    collection.addObserver(this);
  }
  if (oldCollection) {
    oldCollection.removeObserver(this);
  }
}, clone:function() {
  return new Ext.util.CollectionKey(this.getCurrentConfig());
}, destroy:function() {
  this.clear();
  this.getCollection().removeObserver(this);
  this.destroyed = true;
}});
Ext.define('Ext.util.Grouper', {extend:Ext.util.Sorter, isGrouper:true, config:{groupFn:null, sortProperty:null}, constructor:function(config) {
  if (config) {
    if (config.getGroupString) {
      Ext.raise('Cannot set getGroupString - use groupFn instead');
    }
  }
  this.callParent(arguments);
}, getGroupString:function(item) {
  var group = this._groupFn(item);
  return group != null ? String(group) : '';
}, sortFn:function(item1, item2) {
  var me = this, lhs = me._groupFn(item1), rhs = me._groupFn(item2), property = me._sortProperty, root = me._root, sorterFn = me._sorterFn, transform = me._transform;
  if (lhs === rhs) {
    return 0;
  }
  if (property || sorterFn) {
    if (sorterFn) {
      return sorterFn.call(this, item1, item2);
    }
    if (root) {
      item1 = item1[root];
      item2 = item2[root];
    }
    lhs = item1[property];
    rhs = item2[property];
    if (transform) {
      lhs = transform(lhs);
      rhs = transform(rhs);
    }
  }
  return lhs > rhs ? 1 : lhs < rhs ? -1 : 0;
}, standardGroupFn:function(item) {
  var root = this._root;
  return (root ? item[root] : item)[this._property];
}, updateSorterFn:function() {
}, updateProperty:function() {
  if (!this.getGroupFn()) {
    this.setGroupFn(this.standardGroupFn);
  }
}});
Ext.define('Ext.util.Collection', {mixins:[Ext.mixin.Observable], isCollection:true, config:{autoFilter:true, autoSort:true, autoGroup:true, decoder:null, extraKeys:null, filters:null, grouper:null, groups:null, groupConfig:null, rootProperty:null, sorters:null, multiSortLimit:3, defaultSortDirection:'ASC', source:null, trackGroups:true}, generation:0, indices:null, indexRebuilds:0, updating:0, grouped:false, sorted:false, filtered:false, $endUpdatePriority:1001, manageSorters:true, constructor:function(config) {
  var me = this;
  me.callParent([config]);
  me.items = [];
  me.map = {};
  me.length = 0;
  if (config && config.keyFn) {
    me.getKey = config.keyFn;
  }
  me.mixins.observable.constructor.call(me, config);
}, destroy:function() {
  var me = this, filters = me._filters, sorters = me._sorters, groups = me._groups;
  if (filters) {
    filters.destroy();
    me._filters = null;
  }
  if (sorters) {
    me.grouped = me.sorted = false;
    me.setSorters(null);
    if (me.manageSorters) {
      sorters.destroy();
    }
  }
  if (groups) {
    groups.destroy();
    me._groups = null;
  }
  me.setSource(null);
  me.observers = me.items = me.map = null;
  me.callParent();
}, add:function(item) {
  var me = this, items = me.decodeItems(arguments, 0), ret = items;
  if (items.length) {
    me.splice(me.length, 0, items);
    ret = items.length === 1 ? items[0] : items;
  }
  return ret;
}, replaceAll:function() {
  var me = this, ret, items;
  items = me.decodeItems(arguments, 0);
  ret = items;
  if (items.length) {
    me.splice(0, me.length, items);
    ret = items.length === 1 ? items[0] : items;
  } else {
    me.removeAll();
  }
  return ret;
}, aggregate:function(property, operation, begin, end, scope) {
  var me = this, args = Ext.Array.slice(arguments);
  args.unshift(me.items);
  return me.aggregateItems.apply(me, args);
}, aggregateByGroup:function(property, operation, scope) {
  var groups = this.getGroups();
  return this.aggregateGroups(groups, property, operation, scope);
}, aggregateItems:function(items, property, operation, begin, end, scope) {
  var me = this, range = Ext.Number.clipIndices(items.length, [begin, end]), subsetRequested = begin !== 0 && end !== items.length, i, j, rangeLen, root, value, values, valueItems;
  begin = range[0];
  end = range[1];
  if (!Ext.isFunction(operation)) {
    operation = me._aggregators[operation];
    return operation.call(me, items, begin, end, property, me.getRootProperty());
  }
  root = me.getRootProperty();
  values = new Array(rangeLen);
  valueItems = subsetRequested ? new Array(rangeLen) : items;
  for (i = begin, j = 0; i < end; ++i, j++) {
    if (subsetRequested) {
      valueItems[j] = value = items[i];
    }
    values[j] = (root ? value[root] : value)[property];
  }
  return operation.call(scope || me, items, values, 0);
}, aggregateGroups:function(groups, property, operation, scope) {
  var items = groups.items, len = items.length, callDirect = !Ext.isFunction(operation), out = {}, i, group, result;
  for (i = 0; i < len; ++i) {
    group = items[i];
    if (!callDirect) {
      result = this.aggregateItems(group.items, property, operation, null, null, scope);
    } else {
      result = group[operation](property);
    }
    out[group.getGroupKey()] = result;
  }
  return out;
}, beginUpdate:function() {
  if (!this.updating++) {
    this.notify('beginupdate');
  }
}, clear:function() {
  var me = this, generation = me.generation, ret = generation ? me.items : [], extraKeys, indexName;
  if (generation) {
    me.items.length = me.length = 0;
    me.map = {};
    me.indices = {};
    me.generation++;
    extraKeys = me.getExtraKeys();
    if (extraKeys) {
      for (indexName in extraKeys) {
        extraKeys[indexName].clear();
      }
    }
  }
  return ret;
}, clone:function() {
  var me = this, copy = new me.self(me.initialConfig);
  copy.add(me.items);
  return copy;
}, collect:function(property, root, allowNull) {
  var items = this.items, length = items.length, map = {}, ret = [], i, strValue, value;
  for (i = 0; i < length; ++i) {
    value = items[i];
    value = (root ? value[root] : value)[property];
    strValue = String(value);
    if ((allowNull || !Ext.isEmpty(value)) && !map[strValue]) {
      map[strValue] = 1;
      ret.push(value);
    }
  }
  return ret;
}, contains:function(item) {
  var ret = false, key;
  if (item != null) {
    key = this.getKey(item);
    ret = this.map[key] === item;
  }
  return ret;
}, containsAll:function(items) {
  var all = Ext.isArray(items) ? items : arguments, i;
  for (i = all.length; i-- > 0;) {
    if (!this.contains(all[i])) {
      return false;
    }
  }
  return true;
}, containsKey:function(key) {
  return key in this.map;
}, createFiltered:function(property, value, anyMatch, caseSensitive, exactMatch) {
  var me = this, ret = new me.self(me.initialConfig), root = me.getRootProperty(), items = me.items, length, i, filters, fn, scope;
  if (Ext.isFunction(property)) {
    fn = property;
    scope = value;
  } else {
    if (Ext.isString(property)) {
      filters = [new Ext.util.Filter({property:property, value:value, root:root, anyMatch:anyMatch, caseSensitive:caseSensitive, exactMatch:exactMatch})];
    } else {
      if (property instanceof Ext.util.Filter) {
        filters = [property];
        property.setRoot(root);
      } else {
        if (Ext.isArray(property)) {
          filters = property.slice(0);
          for (i = 0, length = filters.length; i < length; ++i) {
            filters[i].setRoot(root);
          }
        }
      }
    }
    fn = Ext.util.Filter.createFilterFn(filters);
  }
  scope = scope || me;
  for (i = 0, length = items.length; i < length; i++) {
    if (fn.call(scope, items[i])) {
      ret.add(items[i]);
    }
  }
  return ret;
}, filterBy:function(fn, scope) {
  return this.createFiltered(fn, scope);
}, each:function(fn, scope) {
  var items = this.items, len = items.length, i, ret;
  if (len) {
    scope = scope || this;
    items = items.slice(0);
    for (i = 0; i < len; i++) {
      ret = fn.call(scope, items[i], i, len);
      if (ret === false) {
        break;
      }
    }
  }
  return ret;
}, eachKey:function(fn, scope) {
  var me = this, items = me.items, len = items.length, i, item, key, ret;
  if (len) {
    scope = scope || me;
    items = items.slice(0);
    for (i = 0; i < len; i++) {
      key = me.getKey(item = items[i]);
      ret = fn.call(scope, key, item, i, len);
      if (ret === false) {
        break;
      }
    }
  }
  return ret;
}, endUpdate:function() {
  if (!--this.updating) {
    this.notify('endupdate');
  }
}, find:function(property, value, start, startsWith, endsWith, ignoreCase) {
  if (Ext.isEmpty(value, false)) {
    return null;
  }
  var regex = Ext.String.createRegex(value, startsWith, endsWith, ignoreCase), root = this.getRootProperty();
  return this.findBy(function(item) {
    return item && regex.test((root ? item[root] : item)[property]);
  }, null, start);
}, findBy:function(fn, scope, start) {
  var me = this, items = me.items, len = items.length, i, item, key;
  scope = scope || me;
  for (i = start || 0; i < len; i++) {
    key = me.getKey(item = items[i]);
    if (fn.call(scope, item, key)) {
      return items[i];
    }
  }
  return null;
}, findIndex:function(property, value, start, startsWith, endsWith, ignoreCase) {
  var item = this.find(property, value, start, startsWith, endsWith, ignoreCase);
  return item ? this.indexOf(item) : -1;
}, findIndexBy:function(fn, scope, start) {
  var item = this.findBy(fn, scope, start);
  return item ? this.indexOf(item) : -1;
}, first:function(grouped) {
  var groups = grouped ? this.getGroups() : undefined;
  return groups ? this.aggregateGroups(groups, null, 'first') : this.items[0];
}, last:function(grouped) {
  var groups = grouped ? this.getGroups() : undefined;
  return groups ? this.aggregateGroups(groups, null, 'last') : this.items[this.length - 1];
}, get:function(key) {
  return this.map[key];
}, getAt:function(index) {
  return this.items[index];
}, getByKey:function(key) {
  return this.map[key];
}, getCount:function() {
  return this.length;
}, getKey:function(item) {
  var id = item.id;
  return id === 0 || id ? id : (id = item._id) === 0 || id ? id : item.getId();
}, getRange:function(begin, end) {
  var items = this.items, length = items.length, range;
  if (begin > end) {
    Ext.raise('Inverted range passed to Collection.getRange: [' + begin + ',' + end + ']');
  }
  if (!length) {
    range = [];
  } else {
    range = Ext.Number.clipIndices(length, [begin, end]);
    range = items.slice(range[0], range[1]);
  }
  return range;
}, getValues:function(property, root, start, end) {
  var items = this.items, range = Ext.Number.clipIndices(items.length, [start, end]), ret = [], i, value;
  for (i = range[0], end = range[1]; i < end; ++i) {
    value = items[i];
    value = (root ? value[root] : value)[property];
    ret.push(value);
  }
  return ret;
}, indexOf:function(item) {
  if (!item) {
    return -1;
  }
  var key = this.getKey(item);
  return this.indexOfKey(key);
}, indexOfKey:function(key) {
  var me = this, indices = me.indices;
  if (key in me.map) {
    if (!indices) {
      indices = me.getIndices();
    }
    return indices[key];
  }
  return -1;
}, insert:function(index, item) {
  var me = this, items = me.decodeItems(arguments, 1), ret = items;
  if (items.length) {
    me.splice(index, 0, items);
    ret = items.length === 1 ? items[0] : items;
  }
  return ret;
}, itemChanged:function(item, modified, oldKey, meta) {
  var me = this, keyChanged = oldKey !== undefined, filtered = me.filtered && me.getAutoFilter(), filterChanged = false, itemMovement = 0, items = me.items, last = me.length - 1, sorted = me.sorted && last > 0 && me.getAutoSort(), source = me.getSource(), toRemove = 0, itemFiltered = false, wasFiltered = false, details, newKey, sortFn, toAdd, index, newIndex;
  if (source && !source.updating) {
    me.sourceUpdating = true;
    source.itemChanged(item, modified, oldKey, meta);
    me.sourceUpdating = false;
  } else {
    newKey = me.getKey(item);
    if (filtered) {
      index = me.indexOfKey(keyChanged ? oldKey : newKey);
      wasFiltered = index < 0;
      itemFiltered = me.isItemFiltered(item);
      filterChanged = wasFiltered !== itemFiltered;
    }
    if (filterChanged) {
      if (itemFiltered) {
        toRemove = [item];
        newIndex = -1;
      } else {
        toAdd = [item];
        newIndex = me.length;
      }
    } else {
      if (sorted && !itemFiltered) {
        if (!filtered) {
          index = me.indexOfKey(keyChanged ? oldKey : newKey);
        }
        sortFn = me.getSortFn();
        if (index !== -1) {
          if (index && sortFn(items[index - 1], items[index]) > 0) {
            itemMovement = -1;
            newIndex = Ext.Array.binarySearch(items, item, 0, index, sortFn);
          } else {
            if (index < last && sortFn(items[index], items[index + 1]) > 0) {
              itemMovement = 1;
              newIndex = Ext.Array.binarySearch(items, item, index + 1, sortFn);
            }
          }
          if (itemMovement) {
            toAdd = [item];
          }
        }
      }
    }
    details = {item:item, key:newKey, index:newIndex, filterChanged:filterChanged, keyChanged:keyChanged, indexChanged:!!itemMovement, filtered:itemFiltered, oldIndex:index, newIndex:newIndex, wasFiltered:wasFiltered, meta:meta};
    if (keyChanged) {
      details.oldKey = oldKey;
    }
    if (modified) {
      details.modified = modified;
    }
    ++me.generation;
    me.beginUpdate();
    me.notify('beforeitemchange', [details]);
    if (keyChanged) {
      me.updateKey(item, oldKey, details);
    }
    if (toAdd || toRemove) {
      me.splice(newIndex, toRemove, toAdd);
    }
    if (itemMovement > 0) {
      details.newIndex--;
    } else {
      if (itemMovement < 0) {
        details.oldIndex++;
      }
    }
    me.notify(itemFiltered ? 'filtereditemchange' : 'itemchange', [details]);
    me.endUpdate();
  }
}, remove:function(item) {
  var me = this, items = me.decodeRemoveItems(arguments, 0), length = me.length;
  me.splice(0, items);
  return length - me.length;
}, removeAll:function() {
  var me = this, length = me.length;
  if (me.generation && length) {
    me.splice(0, length);
  }
  return me;
}, removeAt:function(index, count) {
  var me = this, length = me.length, Num = Ext.Number, range = Num.clipIndices(length, [index, count === undefined ? 1 : count], Num.Clip.COUNT), n = range[0], removeCount = range[1] - n, item = removeCount === 1 && me.getAt(n), removed;
  me.splice(n, removeCount);
  removed = me.length - length;
  return item && removed ? item : removed;
}, removeByKey:function(key) {
  var item = this.getByKey(key);
  if (!item || !this.remove(item)) {
    return false;
  }
  return item;
}, replace:function(item) {
  var index = this.indexOf(item);
  if (index === -1) {
    this.add(item);
  } else {
    this.insert(index, item);
  }
}, splice:function(index, toRemove, toAdd) {
  var me = this, autoSort = me.sorted && me.getAutoSort(), map = me.map, items = me.items, length = me.length, removeItems = toRemove instanceof Array ? me.decodeRemoveItems(toRemove) : null, isRemoveCount = !removeItems, Num = Ext.Number, range = Num.clipIndices(length, [index, isRemoveCount ? toRemove : 0], Num.Clip.COUNT), begin = range[0], end = range[1], removeCount = end - begin, newItems = me.decodeItems(arguments, 2), newCount = newItems ? newItems.length : 0, addItems, newItemsMap, removeMap, 
  insertAt = begin, indices = me.indices || (newCount || removeItems ? me.getIndices() : null), adds = null, removes = removeCount ? [begin] : null, newKeys = null, source = me.getSource(), chunk, chunkItems, chunks, i, item, itemIndex, k, key, keys, n, duplicates, sorters;
  if (source && !source.updating) {
    if (isRemoveCount) {
      removeItems = [];
      for (i = 0; i < removeCount; ++i) {
        removeItems.push(items[begin + i]);
      }
    }
    if (begin < length) {
      i = source.indexOf(items[begin]);
    } else {
      i = source.length;
    }
    me.requestedIndex = index;
    source.splice(i, removeItems, newItems);
    delete me.requestedIndex;
    return me;
  }
  if (newCount) {
    addItems = newItems;
    newKeys = [];
    newItemsMap = {};
    if (autoSort) {
      sorters = me.getSorters();
      if (newCount > 1) {
        if (!addItems.$cloned) {
          newItems = addItems = addItems.slice(0);
        }
        me.sortData(addItems);
      }
    }
    for (i = 0; i < newCount; ++i) {
      key = me.getKey(item = newItems[i]);
      if ((k = newItemsMap[key]) !== undefined) {
        (duplicates || (duplicates = {}))[k] = 1;
      } else {
        itemIndex = indices[key];
        if (itemIndex < begin || end <= itemIndex) {
          (removes || (removes = [])).push(itemIndex);
        }
      }
      newItemsMap[key] = i;
      newKeys.push(key);
    }
    if (duplicates) {
      keys = newKeys;
      addItems = [];
      newKeys = [];
      addItems.$cloned = true;
      for (i = 0; i < newCount; ++i) {
        if (!duplicates[i]) {
          item = newItems[i];
          addItems.push(item);
          newKeys.push(keys[i]);
        }
      }
      newCount = addItems.length;
    }
    adds = {items:addItems, keys:newKeys};
  }
  for (i = removeItems ? removeItems.length : 0; i-- > 0;) {
    key = me.getKey(removeItems[i]);
    if ((itemIndex = indices[key]) !== undefined) {
      (removes || (removes = [])).push(itemIndex);
    }
  }
  if (!adds && !removes) {
    return me;
  }
  me.beginUpdate();
  if (removes) {
    chunk = null;
    chunks = [];
    removeMap = {};
    if (removes.length > 1) {
      removes.sort(Ext.Array.numericSortFn);
    }
    for (i = 0, n = removes.length; i < n; ++i) {
      key = me.getKey(item = items[itemIndex = removes[i]]);
      if (!(key in map)) {
        continue;
      }
      delete map[key];
      if (!chunk || itemIndex > chunk.at + chunkItems.length) {
        chunks.push(chunk = {at:itemIndex, items:chunkItems = [], keys:keys = [], map:removeMap, next:chunk, replacement:adds});
        if (adds) {
          adds.replaced = chunk;
        }
      }
      chunkItems.push(removeMap[key] = item);
      keys.push(key);
      if (itemIndex < insertAt - 1) {
        --insertAt;
      }
      if (removeCount > 1 && itemIndex === begin) {
        --removeCount;
        removes[i--] = ++begin;
      }
    }
    if (adds) {
      adds.at = insertAt;
    }
    for (k = chunks.length; k-- > 0;) {
      chunk = chunks[k];
      i = chunk.at;
      n = chunk.items.length;
      if (i + n < length) {
        me.indices = indices = null;
      }
      me.length = length -= n;
      items.splice(i, n);
      if (indices) {
        keys = chunk.keys;
        for (i = 0; i < n; ++i) {
          delete indices[keys[i]];
        }
      }
      ++me.generation;
      me.notify('remove', [chunk]);
    }
  }
  if (adds) {
    if (autoSort && newCount > 1 && length) {
      me.spliceMerge(addItems, newKeys);
    } else {
      if (autoSort) {
        if (newCount > 1) {
          insertAt = 0;
          me.indices = indices = null;
        } else {
          insertAt = sorters.findInsertionIndex(adds.items[0], items, me.getSortFn(), index);
        }
      }
      if (insertAt === length) {
        end = insertAt;
        for (i = addItems.length - 1; i >= 0; --i) {
          items[end + i] = addItems[i];
        }
        indices = me.indices;
        if (indices) {
          for (i = 0; i < newCount; ++i) {
            indices[newKeys[i]] = insertAt + i;
          }
        }
      } else {
        me.indices = null;
        Ext.Array.insert(items, insertAt, addItems);
      }
      for (i = 0; i < newCount; ++i) {
        map[newKeys[i]] = addItems[i];
      }
      me.length += newCount;
      adds.at = insertAt;
      adds.atItem = insertAt === 0 ? null : items[insertAt - 1];
      ++me.generation;
      me.notify('add', [adds]);
    }
  }
  me.endUpdate();
  return me;
}, update:function(fn, scope) {
  var me = this;
  me.beginUpdate();
  try {
    return fn.call(scope || me, me);
  } catch (e$28) {
    Ext.log.error(this.$className + ': Unhandled Exception: ', e$28.description || e$28.message);
    throw e$28;
  } finally {
    me.endUpdate();
  }
}, updateKey:function(item, oldKey, details) {
  var me = this, map = me.map, indices = me.indices, source = me.getSource(), newKey;
  if (source && !source.updating) {
    source.updateKey(item, oldKey);
  } else {
    if ((newKey = me.getKey(item)) !== oldKey) {
      if (map[oldKey] === item && !(newKey in map)) {
        delete map[oldKey];
        me.updating++;
        me.generation++;
        map[newKey] = item;
        if (indices) {
          indices[newKey] = indices[oldKey];
          delete indices[oldKey];
        }
        me.notify('updatekey', [Ext.apply({item:item, newKey:newKey, oldKey:oldKey}, details)]);
        me.updating--;
      } else {
        if (newKey in map && map[newKey] !== item) {
          Ext.raise('Duplicate newKey "' + newKey + '" for item with oldKey "' + oldKey + '"');
        }
        if (oldKey in map && map[oldKey] !== item) {
          Ext.raise('Incorrect oldKey "' + oldKey + '" for item with newKey "' + newKey + '"');
        }
      }
    }
  }
}, findInsertIndex:function(item) {
  var source = this.getSource(), sourceItems = source.items, i = source.indexOf(item) - 1, sourceItem, index;
  while (i > -1) {
    sourceItem = sourceItems[i];
    index = this.indexOf(sourceItem);
    if (index > -1) {
      return index + 1;
    }
    --i;
  }
  return 0;
}, onCollectionAdd:function(source, details) {
  var me = this, atItem = details.atItem, items = details.items, requestedIndex = me.requestedIndex, filtered, index, copy, i, item, n;
  if (!me.sorted) {
    if (requestedIndex !== undefined) {
      index = requestedIndex;
    } else {
      if (atItem) {
        index = me.indexOf(atItem);
        if (index === -1) {
          index = me.findInsertIndex(items[0]);
        } else {
          ++index;
        }
      } else {
        index = 0;
      }
    }
  }
  if (me.getAutoFilter() && me.filtered) {
    for (i = 0, n = items.length; i < n; ++i) {
      item = items[i];
      if (me.isItemFiltered(item)) {
        if (!copy) {
          copy = items.slice(0, i);
        }
        if (!filtered) {
          filtered = [];
        }
        filtered.push(item);
      } else {
        if (copy) {
          copy.push(item);
        }
      }
    }
  }
  me.splice(index < 0 ? me.length : index, 0, copy || items);
  if (filtered) {
    me.notify('filteradd', [filtered]);
  }
}, onCollectionBeforeItemChange:function(source, details) {
  this.onCollectionUpdateKey = null;
  if (!this.sourceUpdating) {
    this.notify('beforeitemchange', [details]);
  }
}, onCollectionBeginUpdate:function() {
  this.beginUpdate();
}, onCollectionEndUpdate:function() {
  this.endUpdate();
}, onCollectionItemChange:function(source, details) {
  delete this.onCollectionUpdateKey;
  this.itemChanged(details.item, details.modified, details.oldKey, details.meta);
}, onCollectionFilteredItemChange:function() {
  delete this.onCollectionUpdateKey;
}, onCollectionRefresh:function(source) {
  var me = this, map = {}, indices = {}, items = me.items, sourceItems = source.items, filterFn = me.getFilterFn(), i, item, key, length, newLength;
  if (me.filtered && me.getAutoFilter()) {
    for (i = 0, newLength = 0, length = sourceItems.length; i < length; i++) {
      if (filterFn(sourceItems[i])) {
        items[newLength++] = sourceItems[i];
      }
    }
    items.length = newLength;
  } else {
    items.length = 0;
    items.push.apply(items, sourceItems);
  }
  if (me.sorted) {
    me.sortData(items);
  }
  me.length = length = items.length;
  me.map = map;
  me.indices = indices;
  for (i = 0; i < length; ++i) {
    key = me.getKey(item = items[i]);
    map[key] = item;
    indices[key] = i;
  }
  ++me.generation;
  me.notify('refresh');
}, onCollectionRemove:function(source, details) {
  this.splice(0, details.items);
}, onCollectionUpdateKey:function(source, details) {
  this.updateKey(details.item, details.oldKey, details);
}, _aggregators:{average:function(items, begin, end, property, root) {
  var n = end - begin;
  return n && this._aggregators.sum.call(this, items, begin, end, property, root) / n;
}, bounds:function(items, begin, end, property, root) {
  for (var value, max, min, i = begin; i < end; ++i) {
    value = items[i];
    value = (root ? value[root] : value)[property];
    if (!(value < max)) {
      max = value;
    }
    if (!(value > min)) {
      min = value;
    }
  }
  return [min, max];
}, count:function(items) {
  return items.length;
}, extremes:function(items, begin, end, property, root) {
  var most = null, least = null, i, item, max, min, value;
  for (i = begin; i < end; ++i) {
    item = items[i];
    value = (root ? item[root] : item)[property];
    if (!(value < max)) {
      max = value;
      most = item;
    }
    if (!(value > min)) {
      min = value;
      least = item;
    }
  }
  return [least, most];
}, max:function(items, begin, end, property, root) {
  var b = this._aggregators.bounds.call(this, items, begin, end, property, root);
  return b[1];
}, maxItem:function(items, begin, end, property, root) {
  var b = this._aggregators.extremes.call(this, items, begin, end, property, root);
  return b[1];
}, min:function(items, begin, end, property, root) {
  var b = this._aggregators.bounds.call(this, items, begin, end, property, root);
  return b[0];
}, minItem:function(items, begin, end, property, root) {
  var b = this._aggregators.extremes.call(this, items, begin, end, property, root);
  return b[0];
}, sum:function(items, begin, end, property, root) {
  for (var value, sum = 0, i = begin; i < end; ++i) {
    value = items[i];
    value = (root ? value[root] : value)[property];
    sum += value;
  }
  return sum;
}}, _eventToMethodMap:{add:'onCollectionAdd', beforeitemchange:'onCollectionBeforeItemChange', beginupdate:'onCollectionBeginUpdate', endupdate:'onCollectionEndUpdate', itemchange:'onCollectionItemChange', filtereditemchange:'onCollectionFilteredItemChange', refresh:'onCollectionRefresh', remove:'onCollectionRemove', beforesort:'beforeCollectionSort', sort:'onCollectionSort', filter:'onCollectionFilter', filteradd:'onCollectionFilterAdd', updatekey:'onCollectionUpdateKey'}, addObserver:function(observer) {
  var me = this, observers = me.observers;
  if (!observers) {
    me.observers = observers = [];
  }
  if (Ext.Array.contains(observers, observer)) {
    Ext.Error.raise('Observer already added');
  }
  if (me.notifying) {
    me.observers = observers = observers.slice(0);
  }
  observers.push(observer);
  if (observers.length > 1) {
    Ext.Array.sort(observers, me.prioritySortFn);
  }
}, prioritySortFn:function(o1, o2) {
  var a = o1.observerPriority || 0, b = o2.observerPriority || 0;
  return a - b;
}, applyExtraKeys:function(extraKeys, oldExtraKeys) {
  var me = this, ret = oldExtraKeys || {}, config, name, value;
  for (name in extraKeys) {
    value = extraKeys[name];
    if (!value.isCollectionKey) {
      config = {collection:me};
      if (Ext.isString(value)) {
        config.property = value;
      } else {
        config = Ext.apply(config, value);
      }
      value = new Ext.util.CollectionKey(config);
    } else {
      value.setCollection(me);
    }
    ret[name] = me[name] = value;
    value.name = name;
  }
  return ret;
}, applyGrouper:function(grouper) {
  if (grouper) {
    grouper = this.getSorters().decodeSorter(grouper, Ext.util.Grouper);
  }
  return grouper;
}, decodeItems:function(args, index) {
  var me = this, ret = index === undefined ? args : args[index], cloned, decoder, i;
  if (!ret || !ret.$cloned) {
    cloned = args.length > index + 1 || !Ext.isIterable(ret);
    if (cloned) {
      ret = Ext.Array.slice(args, index);
      if (ret.length === 1 && ret[0] === undefined) {
        ret.length = 0;
      }
    }
    decoder = me.getDecoder();
    if (decoder) {
      if (!cloned) {
        ret = ret.slice(0);
        cloned = true;
      }
      for (i = ret.length; i-- > 0;) {
        if ((ret[i] = decoder.call(me, ret[i])) === false) {
          ret.splice(i, 1);
        }
      }
    }
    if (cloned) {
      ret.$cloned = true;
    }
  }
  return ret;
}, getIndices:function() {
  var me = this, indices = me.indices, items = me.items, n = items.length, i, key;
  if (!indices) {
    me.indices = indices = {};
    ++me.indexRebuilds;
    for (i = 0; i < n; ++i) {
      key = me.getKey(items[i]);
      indices[key] = i;
    }
  }
  return indices;
}, notify:function(eventName, args) {
  var me = this, observers = me.observers, methodName = me._eventToMethodMap[eventName], added = 0, index, length, method, observer;
  args = args || [];
  if (observers && methodName) {
    me.notifying = true;
    for (index = 0, length = observers.length; index < length; ++index) {
      method = (observer = observers[index])[methodName];
      if (method) {
        if (!added++) {
          args.unshift(me);
        }
        method.apply(observer, args);
      }
    }
    me.notifying = false;
  }
  if (!me.hasListeners) {
    return;
  }
  if (me.hasListeners[eventName]) {
    if (!added) {
      args.unshift(me);
    }
    me.fireEventArgs(eventName, args);
  }
}, getFilterFn:function() {
  return this.getFilters().getFilterFn();
}, getFilters:function(autoCreate) {
  var ret = this._filters;
  if (!ret && autoCreate !== false) {
    ret = new Ext.util.FilterCollection;
    this.setFilters(ret);
  }
  return ret;
}, isItemFiltered:function(item) {
  return !this.getFilters().filterFn(item);
}, onFilterChange:function(filters) {
  var me = this, source = me.getSource(), extraKeys, newKeys, key;
  if (!source) {
    extraKeys = me.getExtraKeys();
    if (extraKeys) {
      newKeys = {};
      for (key in extraKeys) {
        newKeys[key] = extraKeys[key].clone(me);
      }
    }
    source = new Ext.util.Collection({keyFn:me.getKey, extraKeys:newKeys, rootProperty:me.getRootProperty()});
    if (me.length) {
      source.add(me.items);
    }
    me.setSource(source);
    me.autoSource = source;
  } else {
    if (source.destroyed) {
      return;
    }
    if (source.length || me.length) {
      me.onCollectionRefresh(source);
    }
  }
  me.notify('filter');
}, applyFilters:function(filters, collection) {
  if (!filters || filters.isFilterCollection) {
    return filters;
  }
  if (filters) {
    if (!collection) {
      collection = this.getFilters();
    }
    collection.splice(0, collection.length, filters);
  }
  return collection;
}, updateFilters:function(newFilters, oldFilters) {
  var me = this;
  if (oldFilters) {
    oldFilters.un('endupdate', 'onEndUpdateFilters', me);
  }
  if (newFilters) {
    newFilters.on({endupdate:'onEndUpdateFilters', scope:me, priority:me.$endUpdatePriority});
    newFilters.$filterable = me;
  }
  me.onEndUpdateFilters(newFilters);
}, onEndUpdateFilters:function(filters) {
  var me = this, was = me.filtered, is = !!filters && filters.getFilterCount() > 0;
  if (was || is) {
    me.filtered = is;
    me.onFilterChange(filters);
  }
}, getSortFn:function() {
  return this._sortFn || this.createSortFn();
}, getSorters:function(autoCreate) {
  var ret = this._sorters;
  if (!ret && autoCreate !== false) {
    ret = new Ext.util.SorterCollection;
    this.setSorters(ret);
  }
  return ret;
}, onSortChange:function() {
  if (this.sorted) {
    this.sortItems();
  }
}, sort:function(property, direction, mode) {
  var sorters = this.getSorters();
  sorters.addSort.apply(sorters, arguments);
  return this;
}, sortData:function(data) {
  Ext.Array.sort(data, this.getSortFn());
  return data;
}, sortItems:function(sortFn) {
  var me = this;
  if (me.sorted) {
    if (sortFn) {
      Ext.raise('Collections with sorters cannot resorted');
    }
    sortFn = me.getSortFn();
  }
  me.indices = null;
  me.notify('beforesort', [me.getSorters(false)]);
  if (me.length) {
    Ext.Array.sort(me.items, sortFn);
  }
  me.notify('sort');
}, sortBy:function(sortFn) {
  return this.sortItems(sortFn);
}, findInsertionIndex:function(item, items, comparatorFn, index) {
  return Ext.Array.findInsertionIndex(item, items || this.items, comparatorFn || this.getSortFn(), index);
}, applySorters:function(sorters, collection) {
  if (!sorters || sorters.isSorterCollection) {
    return sorters;
  }
  if (sorters) {
    if (!collection) {
      collection = this.getSorters();
    }
    collection.splice(0, collection.length, sorters);
  }
  return collection;
}, createSortFn:function() {
  var me = this, grouper = me.getGrouper(), sorters = me.getSorters(false), sorterFn = sorters ? sorters.getSortFn() : null;
  if (!grouper) {
    return sorterFn;
  }
  return function(lhs, rhs) {
    var ret = grouper.sort(lhs, rhs);
    if (!ret && sorterFn) {
      ret = sorterFn(lhs, rhs);
    }
    return ret;
  };
}, updateGrouper:function(grouper) {
  var me = this, groups = me.getGroups(), sorters = me.getSorters(), populate;
  me.onSorterChange();
  me.grouped = !!grouper;
  if (grouper) {
    if (me.getTrackGroups()) {
      if (!groups) {
        groups = new Ext.util.GroupCollection({itemRoot:me.getRootProperty(), groupConfig:me.getGroupConfig()});
        groups.$groupable = me;
        me.setGroups(groups);
      }
      groups.setGrouper(grouper);
      populate = true;
    }
  } else {
    if (groups) {
      me.removeObserver(groups);
      groups.destroy();
    }
    me.setGroups(null);
  }
  if (!sorters.updating) {
    me.onEndUpdateSorters(sorters);
  }
  if (populate) {
    groups.onCollectionRefresh(me);
  }
}, updateSorters:function(newSorters, oldSorters) {
  var me = this;
  if (oldSorters && !oldSorters.destroyed) {
    oldSorters.un('endupdate', 'onEndUpdateSorters', me);
  }
  if (newSorters) {
    newSorters.on({endupdate:'onEndUpdateSorters', scope:me, priority:me.$endUpdatePriority});
    if (me.manageSorters) {
      newSorters.$sortable = me;
    }
  }
  me.onSorterChange();
  me.onEndUpdateSorters(newSorters);
}, onSorterChange:function() {
  this._sortFn = null;
}, onEndUpdateSorters:function(sorters) {
  var me = this, was = me.sorted, is = me.grouped && me.getAutoGroup() || sorters && sorters.length > 0;
  if (was || is) {
    me.sorted = !!is;
    me.onSortChange(sorters);
  }
}, removeObserver:function(observer) {
  var observers = this.observers;
  if (observers) {
    Ext.Array.remove(observers, observer);
  }
}, spliceMerge:function(newItems, newKeys) {
  var me = this, map = me.map, newLength = newItems.length, oldIndex = 0, oldItems = me.items, oldLength = oldItems.length, adds = [], count = 0, items = [], sortFn = me.getSortFn(), addItems, end, i, newItem, oldItem, newIndex;
  me.items = items;
  for (newIndex = 0; newIndex < newLength; newIndex = end) {
    newItem = newItems[newIndex];
    for (; oldIndex < oldLength; ++oldIndex) {
      if (sortFn(newItem, oldItem = oldItems[oldIndex]) < 0) {
        break;
      }
      items.push(oldItem);
    }
    if (oldIndex === oldLength) {
      adds[count++] = {at:items.length, itemAt:items[items.length - 1], items:addItems = []};
      if (count > 1) {
        adds[count - 2].next = adds[count - 1];
      }
      for (; newIndex < newLength; ++newIndex) {
        addItems.push(newItem = newItems[newIndex]);
        items.push(newItem);
      }
      break;
    }
    adds[count++] = {at:items.length, itemAt:items[items.length - 1], items:addItems = [newItem]};
    if (count > 1) {
      adds[count - 2].next = adds[count - 1];
    }
    items.push(newItem);
    for (end = newIndex + 1; end < newLength; ++end) {
      if (sortFn(newItem = newItems[end], oldItem) >= 0) {
        break;
      }
      items.push(newItem);
      addItems.push(newItem);
    }
  }
  for (; oldIndex < oldLength; ++oldIndex) {
    items.push(oldItems[oldIndex]);
  }
  for (i = 0; i < newLength; ++i) {
    map[newKeys[i]] = newItems[i];
  }
  me.length = items.length;
  ++me.generation;
  me.indices = null;
  for (i = 0; i < count; ++i) {
    me.notify('add', [adds[i]]);
  }
}, getGroups:function() {
  return this.callParent() || null;
}, updateAutoGroup:function(autoGroup) {
  var groups = this.getGroups();
  if (groups) {
    groups.setAutoGroup(autoGroup);
  }
  this.onEndUpdateSorters(this._sorters);
}, updateGroups:function(newGroups, oldGroups) {
  if (oldGroups) {
    this.removeObserver(oldGroups);
  }
  if (newGroups) {
    this.addObserver(newGroups);
  }
}, updateSource:function(newSource, oldSource) {
  var auto = this.autoSource;
  if (oldSource) {
    if (!oldSource.destroyed) {
      oldSource.removeObserver(this);
    }
    if (oldSource === auto) {
      auto.destroy();
      this.autoSource = null;
    }
  }
  if (newSource) {
    newSource.addObserver(this);
    if (newSource.length || this.length) {
      this.onCollectionRefresh(newSource);
    }
  }
}}, function() {
  var prototype = this.prototype;
  prototype.removeAtKey = prototype.removeByKey;
  prototype.decodeRemoveItems = prototype.decodeItems;
  Ext.Object.each(prototype._aggregators, function(name) {
    prototype[name] = function(property, begin, end) {
      return this.aggregate(property, name, begin, end);
    };
    prototype[name + 'ByGroup'] = function(property) {
      return this.aggregateByGroup(property, name);
    };
  });
});
Ext.define('Ext.data.Range', {isDataRange:true, begin:0, buffer:0, end:0, length:0, store:null, constructor:function(config) {
  var me = this, activeRanges, store;
  Ext.apply(me, config);
  store = me.store;
  if (!(activeRanges = store.activeRanges)) {
    store.activeRanges = activeRanges = [];
  }
  activeRanges.push(me);
  me.refresh();
  if ('begin' in config) {
    me.begin = me.end = 0;
    me['goto'](config.begin, config.end);
  }
}, destroy:function() {
  var me = this, store = me.store, activeRanges = store && store.activeRanges;
  Ext.destroy(me.storeListeners);
  if (activeRanges) {
    Ext.Array.remove(activeRanges, me);
  }
  me.callParent();
}, 'goto':function(begin, end) {
  var me = this, buffer = me.buffer, task = me.task;
  me.begin = begin;
  me.end = end;
  me.length = end - begin;
  if (buffer > 0) {
    if (!task) {
      me.task = task = new Ext.util.DelayedTask(me.doGoto, me);
    }
    task.delay(buffer);
  } else {
    me.doGoto();
  }
}, privates:{lastBegin:0, lastEnd:0, doGoto:Ext.privateFn, refresh:function() {
  this.records = this.store.getData().items;
}}});
Ext.define('Ext.util.ObjectTemplate', {isObjectTemplate:true, excludeProperties:{}, valueRe:/^[{][a-z\.]+[}]$/i, statics:{create:function(template, options) {
  if (!Ext.isObject(template)) {
    Ext.raise('The template is not an Object');
  }
  return template.isObjectTemplate ? template : new Ext.util.ObjectTemplate(template, options);
}}, constructor:function(template, options) {
  Ext.apply(this, options);
  this.template = template;
}, apply:function(context) {
  var me = this;
  delete me.apply;
  me.apply = me.compile(me.template);
  return me.apply(context);
}, privates:{compile:function(template) {
  var me = this, exclude = me.excludeProperties, compiled, i, len, fn;
  if (Ext.isString(template)) {
    if (template.indexOf('{') < 0) {
      fn = function() {
        return template;
      };
    } else {
      if (me.valueRe.test(template)) {
        template = template.substring(1, template.length - 1).split('.');
        fn = function(context) {
          for (var v = context, i = 0; v && i < template.length; ++i) {
            v = v[template[i]];
          }
          return v;
        };
      } else {
        template = new Ext.XTemplate(template);
        fn = function(context) {
          return template.apply(context);
        };
      }
    }
  } else {
    if (!template || Ext.isPrimitive(template) || Ext.isFunction(template)) {
      fn = function() {
        return template;
      };
    } else {
      if (template instanceof Array) {
        compiled = [];
        for (i = 0, len = template.length; i < len; ++i) {
          compiled[i] = me.compile(template[i]);
        }
        fn = function(context) {
          var ret = [], i;
          for (i = 0; i < len; ++i) {
            ret[i] = compiled[i](context);
          }
          return ret;
        };
      } else {
        compiled = {};
        for (i in template) {
          if (!exclude[i]) {
            compiled[i] = me.compile(template[i]);
          }
        }
        fn = function(context) {
          var ret = {}, i, v;
          for (i in template) {
            v = exclude[i] ? template[i] : compiled[i](context);
            if (v !== undefined) {
              ret[i] = v;
            }
          }
          return ret;
        };
      }
    }
  }
  return fn;
}}});
Ext.define('Ext.data.schema.Role', {isRole:true, left:true, owner:false, side:'left', isMany:false, defaultReaderType:'json', _internalReadOptions:{recordsOnly:true, asRoot:true}, constructor:function(association, config) {
  var me = this, extra = config.extra;
  Ext.apply(me, config);
  if (extra) {
    extra = Ext.apply({}, extra);
    delete extra.type;
    Ext.apply(me, extra);
    delete me.extra;
  }
  me.association = association;
  if (association.owner === me.side) {
    association.owner = me;
    me.owner = true;
  }
}, processUpdate:function() {
  Ext.raise('Only the "many" for an association may be processed. "' + this.role + '" is not valid.');
}, processLoad:function(store, associatedEntity, records, session) {
  return records;
}, checkMembership:Ext.emptyFn, adoptAssociated:function(record, session) {
  var other = this.getAssociatedItem(record);
  if (other) {
    session.adopt(other);
  }
}, $roleFilterId:'$associationRoleFilter', createAssociationStore:function(session, from, records, isComplete) {
  var me = this, association = me.association, foreignKeyName = association.getFieldName(), isMany = association.isManyToMany, storeConfig = me.storeConfig, id = from.getId(), config = {asynchronousLoad:false, model:me.cls, role:me, session:session, associatedEntity:from, disableMetaChangeEvent:true, pageSize:null, remoteFilter:true, trackRemoved:!session}, store;
  if (isMany) {
    config.filters = [{id:me.$roleFilterId, property:me.inverse.field, value:id, exactMatch:true}];
  } else {
    if (foreignKeyName) {
      config.filters = [{id:me.$roleFilterId, property:foreignKeyName, value:id, exactMatch:true}];
      config.foreignKeyName = foreignKeyName;
    }
  }
  if (storeConfig) {
    Ext.apply(config, storeConfig);
  }
  store = Ext.Factory.store(config);
  me.onStoreCreate(store, session, id);
  if (!isMany || session) {
    store.on({scope:me, add:'onAddToMany', remove:'onRemoveFromMany', clear:'onRemoveFromMany'});
  }
  if (records) {
    store.loadData(records);
  }
  store.complete = !!isComplete;
  return store;
}, onStoreCreate:Ext.emptyFn, getAssociatedStore:function(inverseRecord, options, scope, records, allowInfer) {
  var me = this, storeName = me.getStoreName(), store = inverseRecord[storeName], hadStore = store, session = inverseRecord.session, load = options && options.reload, source = inverseRecord.$source, isComplete = false, phantom = false, hadSourceStore, args, i, len, raw, rec, sourceStore, hadRecords, isLoading;
  if (!store) {
    if (session) {
      if (source) {
        phantom = source.phantom;
      }
      if (!records && source) {
        sourceStore = source[storeName];
        if (sourceStore && !sourceStore.isLoading()) {
          records = [];
          raw = sourceStore.getData().items;
          for (i = 0, len = raw.length; i < len; ++i) {
            rec = raw[i];
            records.push(session.getRecord(rec.self, rec.id));
          }
          isComplete = !!sourceStore.complete;
          hadSourceStore = true;
        }
      }
      if (!hadSourceStore) {
        hadRecords = !!records;
        records = me.findRecords(session, inverseRecord, records, allowInfer);
        if (!hadRecords && (!records || !records.length)) {
          records = null;
        }
        isComplete = phantom || hadRecords;
      }
    } else {
      isComplete = !!records;
    }
    store = me.createAssociationStore(session, inverseRecord, records, isComplete || inverseRecord.phantom);
    store.$source = sourceStore;
    if (!records && (me.autoLoad || options)) {
      load = true;
    }
    inverseRecord[storeName] = store;
  }
  if (options) {
    if (load || store.isLoading()) {
      store.on('load', function(store, records, success, operation) {
        args = [store, operation];
        scope = scope || options.scope || inverseRecord;
        if (success) {
          Ext.callback(options.success, scope, args);
        } else {
          Ext.callback(options.failure, scope, args);
        }
        args.push(success);
        Ext.callback(options, scope, args);
        Ext.callback(options.callback, scope, args);
      }, null, {single:true});
    } else {
      args = [store, null];
      scope = scope || options.scope || inverseRecord;
      Ext.callback(options.success, scope, args);
      args.push(true);
      Ext.callback(options, scope, args);
      Ext.callback(options.callback, scope, args);
    }
  }
  isLoading = store.isLoading();
  if (load) {
    if (!isLoading) {
      store.load();
    }
  } else {
    if (hadStore && records && !isLoading) {
      store.loadData(records);
    }
  }
  return store;
}, getAssociatedItem:function(rec) {
  var key = this.isMany ? this.getStoreName() : this.getInstanceName();
  return rec[key] || null;
}, onDrop:Ext.emptyFn, onIdChanged:Ext.emptyFn, getReaderRoot:function() {
  var me = this;
  return me.associationKey || (me.associationKey = me.association.schema.getNamer().readerRoot(me.role));
}, getReader:function() {
  var me = this, reader = me.reader, Model = me.cls, useSimpleAccessors = !me.associationKey, root = this.getReaderRoot();
  if (reader && !reader.isReader) {
    if (Ext.isString(reader)) {
      reader = {type:reader};
    }
    Ext.applyIf(reader, {model:Model, rootProperty:root, useSimpleAccessors:useSimpleAccessors, type:me.defaultReaderType});
    reader = me.reader = Ext.createByAlias('reader.' + reader.type, reader);
  }
  return reader;
}, getInstanceName:function() {
  var me = this;
  return me.instanceName || (me.instanceName = me.association.schema.getNamer().instanceName(me.role));
}, getOldInstanceName:function() {
  return this.oldInstanceName || (this.oldInstanceName = '$old' + this.getInstanceName());
}, getStoreName:function() {
  var me = this;
  return me.storeName || (me.storeName = me.association.schema.getNamer().storeName(me.role));
}, constructReader:function(fromReader) {
  var me = this, reader = me.getReader(), Model = me.cls, useSimpleAccessors = !me.associationKey, root = me.getReaderRoot(), proxyReader, proxy;
  if (!reader) {
    proxy = Model.getProxy();
    if (proxy) {
      proxyReader = proxy.getReader();
      reader = new proxyReader.self;
      reader.copyFrom(proxyReader);
      reader.setRootProperty(root);
    } else {
      reader = new fromReader.self({model:Model, useSimpleAccessors:useSimpleAccessors, rootProperty:root});
    }
    me.reader = reader;
  }
  return reader;
}, read:function(record, data, fromReader, readOptions) {
  var reader = this.constructReader(fromReader), root = reader.getRoot(data);
  if (root) {
    return reader.readRecords(root, readOptions, this._internalReadOptions);
  }
}, getCallbackOptions:function(options, scope, defaultScope) {
  if (typeof options === 'function') {
    options = {callback:options, scope:scope || defaultScope};
  } else {
    if (options) {
      options = Ext.apply({}, options);
      options.scope = scope || options.scope || defaultScope;
    }
  }
  return options;
}, doGetFK:function(leftRecord, options, scope) {
  var me = this, cls = me.cls, foreignKey = me.association.getFieldName(), instanceName = me.getInstanceName(), rightRecord = leftRecord[instanceName], reload = options && options.reload, done = rightRecord !== undefined && !reload, session = leftRecord.session, foreignKeyId, args;
  if (!done) {
    if (session) {
      foreignKeyId = leftRecord.get(foreignKey);
      if (foreignKeyId || foreignKeyId === 0) {
        done = session.peekRecord(cls, foreignKeyId, true) && !reload;
        rightRecord = session.getRecord(cls, foreignKeyId, false);
      } else {
        done = true;
        leftRecord[instanceName] = rightRecord = null;
      }
    } else {
      if (foreignKey) {
        foreignKeyId = leftRecord.get(foreignKey);
        if (!foreignKeyId && foreignKeyId !== 0) {
          done = true;
          leftRecord[instanceName] = rightRecord = null;
        } else {
          if (!rightRecord) {
            rightRecord = cls.createWithId(foreignKeyId);
          }
        }
      } else {
        done = true;
        rightRecord = null;
      }
    }
  } else {
    if (rightRecord) {
      done = !rightRecord.isLoading();
    }
  }
  if (done) {
    if (options) {
      args = [rightRecord, null];
      scope = scope || options.scope || leftRecord;
      Ext.callback(options.success, scope, args);
      args.push(true);
      Ext.callback(options, scope, args);
      Ext.callback(options.callback, scope, args);
    }
  } else {
    leftRecord[instanceName] = rightRecord;
    options = me.getCallbackOptions(options, scope, leftRecord);
    rightRecord.load(options);
  }
  return rightRecord;
}, doSetFK:function(leftRecord, rightRecord, options, scope) {
  var me = this, foreignKey = me.association.getFieldName(), instanceName = me.getInstanceName(), current = leftRecord[instanceName], inverse = me.inverse, inverseSetter = inverse.setterName, session = leftRecord.session, modified, oldInstanceName;
  if (rightRecord && rightRecord.isEntity) {
    if (current !== rightRecord) {
      oldInstanceName = me.getOldInstanceName();
      leftRecord[oldInstanceName] = current;
      leftRecord[instanceName] = rightRecord;
      if (current && current.isEntity) {
        current[inverse.getInstanceName()] = undefined;
      }
      if (foreignKey) {
        leftRecord.set(foreignKey, rightRecord.getId());
      }
      delete leftRecord[oldInstanceName];
      leftRecord.onAssociatedRecordSet(rightRecord, me);
      if (inverseSetter) {
        rightRecord[inverseSetter](leftRecord);
      }
    }
  } else {
    if (!foreignKey) {
      Ext.raise('No foreignKey specified for "' + me.association.left.role + '" by ' + leftRecord.$className);
    }
    modified = leftRecord.changingKey && !inverse.isMany || leftRecord.set(foreignKey, rightRecord);
    if (modified && current && current.isEntity && !current.isEqual(current.getId(), rightRecord)) {
      leftRecord[instanceName] = undefined;
      if (!inverse.isMany) {
        current[inverse.getInstanceName()] = undefined;
      }
    }
  }
  if (options) {
    if (Ext.isFunction(options)) {
      options = {callback:options, scope:scope || leftRecord};
    }
    return leftRecord.save(options);
  }
}});
Ext.define('Ext.data.schema.Association', {isOneToOne:false, isManyToOne:false, isManyToMany:false, owner:null, field:null, constructor:function(config) {
  var me = this, left, right;
  Ext.apply(me, config);
  me.left = left = new me.Left(me, me.left);
  me.right = right = new me.Right(me, me.right);
  left.inverse = right;
  right.inverse = left;
}, hasField:function() {
  return !!this.field;
}, getFieldName:function() {
  var field = this.field;
  return field ? field.name : '';
}});
Ext.define('Ext.data.schema.OneToOne', {extend:Ext.data.schema.Association, isOneToOne:true, isToOne:true, kind:'one-to-one', Left:Ext.define(null, {extend:'Ext.data.schema.Role', onDrop:function(rightRecord, session) {
  var leftRecord = this.getAssociatedItem(rightRecord);
  rightRecord[this.getInstanceName()] = null;
  if (leftRecord) {
    leftRecord[this.inverse.getInstanceName()] = null;
  }
}, onIdChanged:function(rightRecord, oldId, newId) {
  var leftRecord = this.getAssociatedItem(rightRecord), fieldName = this.association.getFieldName();
  if (!rightRecord.session && leftRecord && fieldName) {
    leftRecord.set(fieldName, newId);
  }
}, createGetter:function() {
  var me = this;
  return function() {
    return me.doGet(this);
  };
}, createSetter:function() {
  var me = this;
  return function(value) {
    return me.doSet(this, value);
  };
}, doGet:function(rightRecord) {
  var instanceName = this.getInstanceName(), ret = rightRecord[instanceName], session = rightRecord.session;
  if (!ret && session) {
  }
  return ret || null;
}, doSet:function(rightRecord, leftRecord) {
  var instanceName = this.getInstanceName(), ret = rightRecord[instanceName], inverseSetter = this.inverse.setterName;
  if (ret !== leftRecord) {
    rightRecord[instanceName] = leftRecord;
    if (inverseSetter) {
      leftRecord[inverseSetter](rightRecord);
    }
    rightRecord.onAssociatedRecordSet(leftRecord, this);
  }
  return ret;
}, read:function(rightRecord, node, fromReader, readOptions) {
  var me = this, leftRecords = me.callParent([rightRecord, node, fromReader, readOptions]), leftRecord;
  if (leftRecords) {
    leftRecord = leftRecords[0];
    if (leftRecord) {
      leftRecord[me.inverse.getInstanceName()] = rightRecord;
      rightRecord[me.getInstanceName()] = leftRecord;
      delete rightRecord.data[me.role];
    }
  }
}}), Right:Ext.define(null, {extend:'Ext.data.schema.Role', left:false, side:'right', createGetter:function() {
  var me = this;
  return function(options, scope) {
    return me.doGetFK(this, options, scope);
  };
}, createSetter:function() {
  var me = this;
  return function(value, options, scope) {
    return me.doSetFK(this, value, options, scope);
  };
}, onDrop:function(leftRecord, session) {
  var me = this, field = me.association.field, rightRecord = me.getAssociatedItem(leftRecord), id;
  if (me.inverse.owner) {
    if (session && field) {
      id = leftRecord.get(field.name);
      if (id || id === 0) {
        rightRecord = session.getEntry(me.cls, id).record;
        if (rightRecord) {
          rightRecord.drop();
        }
      }
    } else {
      if (rightRecord) {
        rightRecord.drop();
      }
    }
  }
  if (field) {
    leftRecord.set(field.name, null);
  }
  leftRecord[me.getInstanceName()] = null;
  if (rightRecord) {
    rightRecord[me.inverse.getInstanceName()] = null;
  }
}, onValueChange:function(leftRecord, session, newValue) {
  var me = this, rightRecord = leftRecord[me.getOldInstanceName()] || me.getAssociatedItem(leftRecord), hasNewValue = newValue || newValue === 0, instanceName = me.getInstanceName(), cls = me.cls;
  leftRecord.changingKey = true;
  me.doSetFK(leftRecord, newValue);
  if (!hasNewValue) {
    leftRecord[instanceName] = null;
  } else {
    if (session && cls) {
      leftRecord[instanceName] = session.peekRecord(cls, newValue) || undefined;
    }
  }
  if (me.inverse.owner && rightRecord) {
    me.association.schema.queueKeyCheck(rightRecord, me);
  }
  leftRecord.changingKey = false;
}, checkKeyForDrop:function(rightRecord) {
  var leftRecord = this.inverse.getAssociatedItem(rightRecord);
  if (!leftRecord) {
    rightRecord.drop();
  }
}, read:function(leftRecord, node, fromReader, readOptions) {
  var me = this, rightRecords = me.callParent([leftRecord, node, fromReader, readOptions]), rightRecord, field, fieldName, session, refs, id, oldId, setKey, data;
  if (rightRecords) {
    rightRecord = rightRecords[0];
    field = me.association.field;
    if (field) {
      fieldName = field.name;
    }
    session = leftRecord.session;
    data = leftRecord.data;
    if (rightRecord) {
      if (session) {
        refs = session.getRefs(rightRecord, this.inverse, true);
        setKey = refs && refs[leftRecord.id] || data[fieldName] === undefined;
      } else {
        setKey = true;
      }
      if (setKey) {
        if (field) {
          oldId = data[fieldName];
          id = rightRecord.id;
          if (oldId !== id) {
            data[fieldName] = id;
            if (session) {
              session.updateReference(leftRecord, field, id, oldId);
            }
          }
        }
        rightRecord[me.inverse.getInstanceName()] = leftRecord;
        leftRecord[me.getInstanceName()] = rightRecord;
      }
      delete data[me.role];
    }
  }
}})});
Ext.define('Ext.data.schema.ManyToOne', {extend:Ext.data.schema.Association, isManyToOne:true, isToOne:true, kind:'many-to-one', Left:Ext.define(null, {extend:'Ext.data.schema.Role', isMany:true, onDrop:function(rightRecord, session) {
  var me = this, store = me.getAssociatedItem(rightRecord), leftRecords, len, i, refs, id;
  if (store) {
    leftRecords = store.removeAll();
    if (leftRecords && me.inverse.owner) {
      for (i = 0, len = leftRecords.length; i < len; ++i) {
        leftRecords[i].drop();
      }
    }
    store.destroy();
    rightRecord[me.getStoreName()] = null;
  } else {
    if (session) {
      leftRecords = session.getRefs(rightRecord, me);
      if (leftRecords) {
        for (id in leftRecords) {
          leftRecords[id].drop();
        }
      }
    }
  }
}, onIdChanged:function(rightRecord, oldId, newId) {
  var fieldName = this.association.getFieldName(), store = this.getAssociatedItem(rightRecord), leftRecords, i, len, filter;
  if (store) {
    filter = store.getFilters().get(this.$roleFilterId);
    if (filter) {
      filter.setValue(newId);
    }
    if (!rightRecord.session && fieldName) {
      leftRecords = store.getDataSource().items;
      for (i = 0, len = leftRecords.length; i < len; ++i) {
        leftRecords[i].set(fieldName, newId);
      }
    }
  }
}, processUpdate:function(session, associationData) {
  var me = this, entityType = me.inverse.cls, items = associationData.R, id, rightRecord, store, leftRecords;
  if (items) {
    for (id in items) {
      rightRecord = session.peekRecord(entityType, id);
      if (rightRecord) {
        leftRecords = session.getEntityList(me.cls, items[id]);
        store = me.getAssociatedItem(rightRecord);
        if (store) {
          store.loadData(leftRecords);
          store.complete = true;
        } else {
          rightRecord[me.getterName](null, null, leftRecords);
        }
      } else {
        session.onInvalidAssociationEntity(entityType, id);
      }
    }
  }
}, findRecords:function(session, rightRecord, leftRecords, allowInfer) {
  var ret = leftRecords, refs = session.getRefs(rightRecord, this, true), field = this.association.field, fieldName, leftRecord, id, i, len, seen;
  if (field && (refs || allowInfer)) {
    fieldName = field.name;
    ret = [];
    if (leftRecords) {
      seen = {};
      for (i = 0, len = leftRecords.length; i < len; ++i) {
        leftRecord = leftRecords[i];
        id = leftRecord.id;
        if (refs && refs[id]) {
          ret.push(leftRecord);
        } else {
          if (allowInfer && leftRecord.data[fieldName] === undefined) {
            ret.push(leftRecord);
            leftRecord.data[fieldName] = rightRecord.id;
            session.updateReference(leftRecord, field, rightRecord.id, undefined);
          }
        }
        seen[id] = true;
      }
    }
    if (refs) {
      for (id in refs) {
        if (!seen || !seen[id]) {
          ret.push(refs[id]);
        }
      }
    }
  }
  return ret;
}, processLoad:function(store, rightRecord, leftRecords, session) {
  var ret = leftRecords;
  if (session) {
    ret = this.findRecords(session, rightRecord, leftRecords, true);
  }
  this.onLoadMany(rightRecord, ret, session);
  return ret;
}, adoptAssociated:function(rightRecord, session) {
  var store = this.getAssociatedItem(rightRecord), leftRecords, i, len;
  if (store) {
    store.setSession(session);
    leftRecords = store.getData().items;
    for (i = 0, len = leftRecords.length; i < len; ++i) {
      session.adopt(leftRecords[i]);
    }
  }
}, createGetter:function() {
  var me = this;
  return function(options, scope, leftRecords) {
    return me.getAssociatedStore(this, options, scope, leftRecords, true);
  };
}, createSetter:null, onAddToMany:function(store, leftRecords) {
  var rightRecord = store.getAssociatedEntity();
  if (this.association.field) {
    this.syncFK(leftRecords, rightRecord, false);
  } else {
    this.setInstances(rightRecord, leftRecords);
  }
}, onLoadMany:function(rightRecord, leftRecords, session) {
  this.setInstances(rightRecord, leftRecords, session);
}, onRemoveFromMany:function(store, leftRecords) {
  if (this.association.field) {
    this.syncFK(leftRecords, store.getAssociatedEntity(), true);
  } else {
    this.setInstances(null, leftRecords);
  }
}, read:function(rightRecord, node, fromReader, readOptions) {
  var me = this, instanceName = me.inverse.getInstanceName(), leftRecords = me.callParent([rightRecord, node, fromReader, readOptions]), store, len, i;
  if (leftRecords) {
    store = rightRecord[me.getterName](null, null, leftRecords);
    delete rightRecord.data[me.role];
    leftRecords = store.getData().items;
    for (i = 0, len = leftRecords.length; i < len; ++i) {
      leftRecords[i][instanceName] = rightRecord;
    }
  }
}, setInstances:function(rightRecord, leftRecords, session) {
  var instanceName = this.inverse.getInstanceName(), id = rightRecord ? rightRecord.getId() : null, field = this.association.field, len = leftRecords.length, i, leftRecord, oldId, data, name;
  for (i = 0; i < len; ++i) {
    leftRecord = leftRecords[i];
    leftRecord[instanceName] = rightRecord;
    if (field) {
      name = field.name;
      data = leftRecord.data;
      oldId = data[name];
      if (oldId !== id) {
        data[name] = id;
        if (session) {
          session.updateReference(leftRecord, field, id, oldId);
        }
      }
    }
  }
}, syncFK:function(leftRecords, rightRecord, clearing) {
  var foreignKeyName = this.association.getFieldName(), inverse = this.inverse, setter = inverse.setterName, instanceName = inverse.getInstanceName(), i = leftRecords.length, id = rightRecord.getId(), different, leftRecord, val;
  while (i-- > 0) {
    leftRecord = leftRecords[i];
    different = !leftRecord.isEqual(id, leftRecord.get(foreignKeyName));
    val = clearing ? null : rightRecord;
    if (different !== clearing) {
      leftRecord.changingKey = true;
      leftRecord[setter](val);
      leftRecord.changingKey = false;
    } else {
      leftRecord[instanceName] = val;
    }
  }
}}), Right:Ext.define(null, {extend:'Ext.data.schema.Role', left:false, side:'right', onDrop:function(leftRecord, session) {
  var field = this.association.field;
  if (field) {
    leftRecord.set(field.name, null);
  }
  leftRecord[this.getInstanceName()] = null;
}, createGetter:function() {
  var me = this;
  return function(options, scope) {
    return me.doGetFK(this, options, scope);
  };
}, createSetter:function() {
  var me = this;
  return function(rightRecord, options, scope) {
    return me.doSetFK(this, rightRecord, options, scope);
  };
}, checkMembership:function(session, leftRecord) {
  var field = this.association.field, store;
  if (field) {
    store = this.getSessionStore(session, leftRecord.get(field.name));
    if (store && !store.contains(leftRecord)) {
      store.add(leftRecord);
    }
  }
}, onValueChange:function(leftRecord, session, newValue, oldValue) {
  var me = this, instanceName = me.getInstanceName(), cls = me.cls, hasNewValue, joined, store, i, associated, rightRecord;
  if (!leftRecord.changingKey) {
    hasNewValue = newValue || newValue === 0;
    if (!hasNewValue) {
      leftRecord[instanceName] = null;
    }
    if (session) {
      store = me.getSessionStore(session, oldValue);
      if (store) {
        store.remove(leftRecord);
      }
      if (hasNewValue) {
        store = me.getSessionStore(session, newValue);
        if (store && !store.isLoading()) {
          store.add(leftRecord);
        }
        if (cls) {
          rightRecord = session.peekRecord(cls, newValue);
        }
        leftRecord[instanceName] = rightRecord || undefined;
      }
    } else {
      joined = leftRecord.joined;
      if (joined) {
        for (i = joined.length - 1; i >= 0; i--) {
          store = joined[i];
          if (store.isStore) {
            associated = store.getAssociatedEntity();
            if (associated && associated.self === me.cls && associated.getId() === oldValue) {
              store.remove(leftRecord);
            }
          }
        }
      }
    }
  }
  if (me.owner && newValue === null) {
    me.association.schema.queueKeyCheck(leftRecord, me);
  }
}, checkKeyForDrop:function(leftRecord) {
  var field = this.association.field;
  if (leftRecord.get(field.name) === null) {
    leftRecord.drop();
  }
}, getSessionStore:function(session, value) {
  var cls = this.cls, rec;
  if (cls) {
    rec = session.peekRecord(cls, value);
    if (rec) {
      return this.inverse.getAssociatedItem(rec);
    }
  }
}, read:function(leftRecord, node, fromReader, readOptions) {
  var rightRecords = this.callParent([leftRecord, node, fromReader, readOptions]), rightRecord;
  if (rightRecords) {
    rightRecord = rightRecords[0];
    if (rightRecord) {
      leftRecord[this.getInstanceName()] = rightRecord;
      delete leftRecord.data[this.role];
    }
  }
}})});
Ext.define('Ext.data.schema.ManyToMany', {extend:Ext.data.schema.Association, isManyToMany:true, isToMany:true, kind:'many-to-many', Left:Ext.define(null, {extend:'Ext.data.schema.Role', isMany:true, digitRe:/^\d+$/, findRecords:function(session, rightRecord, leftRecords) {
  var slice = session.getMatrixSlice(this.inverse, rightRecord.id), members = slice.members, ret = [], cls = this.cls, seen, i, len, id, member, leftRecord;
  if (leftRecords) {
    seen = {};
    for (i = 0, len = leftRecords.length; i < len; ++i) {
      leftRecord = leftRecords[i];
      id = leftRecord.id;
      member = members[id];
      if (!(member && member[2] === -1)) {
        ret.push(leftRecord);
      }
      seen[id] = true;
    }
  }
  for (id in members) {
    member = members[id];
    if (!seen || !seen[id] && (member && member[2] !== -1)) {
      leftRecord = session.peekRecord(cls, id);
      if (leftRecord) {
        ret.push(leftRecord);
      }
    }
  }
  return ret;
}, onIdChanged:function(rightRecord, oldId, newId) {
  var store = this.getAssociatedItem(rightRecord);
  if (store) {
    store.getFilters().get(this.$roleFilterId).setValue(newId);
  }
}, processLoad:function(store, rightRecord, leftRecords, session) {
  var ret = leftRecords;
  if (session) {
    ret = this.findRecords(session, rightRecord, leftRecords);
    this.onAddToMany(store, ret, true);
  }
  return ret;
}, processUpdate:function(session, associationData) {
  var me = this, entityType = me.inverse.cls, items = associationData.R, id, rightRecord, store, leftRecords;
  if (items) {
    for (id in items) {
      rightRecord = session.peekRecord(entityType, id);
      if (rightRecord) {
        leftRecords = session.getEntityList(me.cls, items[id]);
        store = me.getAssociatedItem(rightRecord);
        if (store) {
          store.loadData(leftRecords);
          store.complete = true;
        } else {
          rightRecord[me.getterName](null, null, leftRecords);
        }
      } else {
        session.onInvalidAssociationEntity(entityType, id);
      }
    }
  }
  me.processMatrixBlock(session, associationData.C, 1);
  me.processMatrixBlock(session, associationData.D, -1);
}, checkMembership:function(session, rightRecord) {
  var matrix = session.getMatrix(this.association, true), side, entityType, inverse, slice, slices, id, members, member, leftRecord, store;
  if (!matrix) {
    return;
  }
  side = this.left ? matrix.right : matrix.left;
  entityType = side.inverse.role.cls;
  inverse = this.inverse;
  slices = side.slices;
  if (slices) {
    slice = slices[rightRecord.id];
    if (slice) {
      members = slice.members;
      for (id in members) {
        member = members[id];
        if (member[2] !== -1) {
          leftRecord = session.peekRecord(entityType, id);
          if (leftRecord) {
            store = inverse.getAssociatedItem(leftRecord);
            if (store) {
              store.matrixUpdate = 1;
              store.add(rightRecord);
              store.matrixUpdate = 0;
            }
          }
        }
      }
    }
  }
}, onStoreCreate:function(store, session, id) {
  var me = this, matrix;
  if (session) {
    matrix = session.getMatrixSlice(me.inverse, id);
    matrix.attach(store);
    matrix.notify = me.onMatrixUpdate;
    matrix.scope = me;
  }
}, processMatrixBlock:function(session, leftKeys, state) {
  var inverse = this.inverse, digitRe = this.digitRe, slice, id;
  if (leftKeys) {
    for (id in leftKeys) {
      if (digitRe.test(id)) {
        id = parseInt(id, 10);
      }
      slice = session.getMatrixSlice(inverse, id);
      slice.update(leftKeys[id], state);
    }
  }
}, createGetter:function() {
  var me = this;
  return function(options, scope, leftRecords) {
    return me.getAssociatedStore(this, options, scope, leftRecords, false);
  };
}, onAddToMany:function(store, leftRecords, load) {
  if (!store.matrixUpdate) {
    store.matrixUpdate = 1;
    store.matrix.update(leftRecords, load === true ? 0 : 1);
    store.matrixUpdate = 0;
  }
}, onRemoveFromMany:function(store, records) {
  if (!store.matrixUpdate) {
    store.matrixUpdate = 1;
    store.matrix.update(records, -1);
    store.matrixUpdate = 0;
  }
}, read:function(rightRecord, node, fromReader, readOptions) {
  var me = this, leftRecords = me.callParent([rightRecord, node, fromReader, readOptions]);
  if (leftRecords) {
    rightRecord[me.getterName](null, null, leftRecords);
    delete rightRecord.data[me.role];
  }
}, onMatrixUpdate:function(matrixSlice, id, state) {
  var store = matrixSlice.store, index, leftRecord, entry;
  if (store && !store.loading && !store.matrixUpdate) {
    store.matrixUpdate = 1;
    index = store.indexOfId(id);
    if (state < 0) {
      if (index >= 0) {
        store.remove([index]);
      }
    } else {
      if (index < 0) {
        entry = store.getSession().getEntry(this.type, id);
        leftRecord = entry && entry.record;
        if (leftRecord) {
          store.add(leftRecord);
        }
      }
    }
    store.matrixUpdate = 0;
  }
}, adoptAssociated:function(record, session) {
  var store = this.getAssociatedItem(record), records, i, len;
  if (store) {
    store.setSession(session);
    this.onStoreCreate(store, session, record.getId());
    records = store.getData().items;
    for (i = 0, len = records.length; i < len; ++i) {
      session.adopt(records[i]);
    }
  }
}}, function() {
  var Left = this;
  Ext.ClassManager.onCreated(function() {
    Ext.data.schema.ManyToMany.prototype.Right = Ext.define(null, {extend:Left, left:false, side:'right'});
  }, null, 'Ext.data.schema.ManyToMany');
})});
Ext.define('Ext.util.Inflector', {singleton:true, plurals:[[/(quiz)$/i, '$1zes'], [/^(ox)$/i, '$1en'], [/([m|l])ouse$/i, '$1ice'], [/(matr|vert|ind)ix|ex$/i, '$1ices'], [/(x|ch|ss|sh)$/i, '$1es'], [/([^aeiouy]|qu)y$/i, '$1ies'], [/(hive)$/i, '$1s'], [/(?:([^f])fe|([lr])f)$/i, '$1$2ves'], [/sis$/i, 'ses'], [/([ti])um$/i, '$1a'], [/(buffal|tomat|potat)o$/i, '$1oes'], [/(bu)s$/i, '$1ses'], [/(alias|status|sex)$/i, '$1es'], [/(octop|vir)us$/i, '$1i'], [/(ax|test)is$/i, '$1es'], [/^(p)erson$/i, '$1eople'], 
[/^(m)an$/i, '$1en'], [/(.*)(child)(ren)?$/i, '$1$2ren'], [/s$/i, 's'], [/$/, 's']], singulars:[[/(address)$/i, '$1'], [/(quiz)zes$/i, '$1'], [/(matr)ices$/i, '$1ix'], [/(vert|ind)ices$/i, '$1ex'], [/^(ox)en/i, '$1'], [/(alias|status)es$/i, '$1'], [/(octop|vir)i$/i, '$1us'], [/(cris|ax|test)es$/i, '$1is'], [/(shoe)s$/i, '$1'], [/(o)es$/i, '$1'], [/(bus)es$/i, '$1'], [/([m|l])ice$/i, '$1ouse'], [/(x|ch|ss|sh)es$/i, '$1'], [/(m)ovies$/i, '$1ovie'], [/(s)eries$/i, '$1eries'], [/([^aeiouy]|qu)ies$/i, 
'$1y'], [/([lr])ves$/i, '$1f'], [/(tive)s$/i, '$1'], [/(hive)s$/i, '$1'], [/([^f])ves$/i, '$1fe'], [/(^analy)ses$/i, '$1sis'], [/((a)naly|(b)a|(d)iagno|(p)arenthe|(p)rogno|(s)ynop|(t)he)ses$/i, '$1$2sis'], [/([ti])a$/i, '$1um'], [/(n)ews$/i, '$1ews'], [/(p)eople$/i, '$1erson'], [/s$/i, '']], uncountable:['sheep', 'fish', 'series', 'species', 'money', 'rice', 'information', 'equipment', 'grass', 'mud', 'offspring', 'deer', 'means'], singular:function(matcher, replacer) {
  this.singulars.unshift([matcher, replacer]);
}, plural:function(matcher, replacer) {
  this.plurals.unshift([matcher, replacer]);
}, clearSingulars:function() {
  this.singulars = [];
}, clearPlurals:function() {
  this.plurals = [];
}, isTransnumeral:function(word) {
  return Ext.Array.indexOf(this.uncountable, word) != -1;
}, pluralize:function(word) {
  if (this.isTransnumeral(word)) {
    return word;
  }
  var plurals = this.plurals, length = plurals.length, tuple, regex, i;
  for (i = 0; i < length; i++) {
    tuple = plurals[i];
    regex = tuple[0];
    if (regex == word || regex.test && regex.test(word)) {
      return word.replace(regex, tuple[1]);
    }
  }
  return word;
}, singularize:function(word) {
  if (this.isTransnumeral(word)) {
    return word;
  }
  var singulars = this.singulars, length = singulars.length, tuple, regex, i;
  for (i = 0; i < length; i++) {
    tuple = singulars[i];
    regex = tuple[0];
    if (regex == word || regex.test && regex.test(word)) {
      return word.replace(regex, tuple[1]);
    }
  }
  return word;
}, classify:function(word) {
  return Ext.String.capitalize(this.singularize(word));
}, ordinalize:function(number) {
  var parsed = parseInt(number, 10), mod10 = parsed % 10, mod100 = parsed % 100;
  if (11 <= mod100 && mod100 <= 13) {
    return number + 'th';
  } else {
    switch(mod10) {
      case 1:
        return number + 'st';
      case 2:
        return number + 'nd';
      case 3:
        return number + 'rd';
      default:
        return number + 'th';
    }
  }
}}, function() {
  var irregulars = {alumnus:'alumni', cactus:'cacti', focus:'foci', nucleus:'nuclei', radius:'radii', stimulus:'stimuli', ellipsis:'ellipses', paralysis:'paralyses', oasis:'oases', appendix:'appendices', index:'indexes', beau:'beaux', bureau:'bureaux', tableau:'tableaux', woman:'women', child:'children', man:'men', corpus:'corpora', criterion:'criteria', curriculum:'curricula', genus:'genera', memorandum:'memoranda', phenomenon:'phenomena', foot:'feet', goose:'geese', tooth:'teeth', antenna:'antennae', 
  formula:'formulae', nebula:'nebulae', vertebra:'vertebrae', vita:'vitae'}, singular;
  for (singular in irregulars) {
    if (irregulars.hasOwnProperty(singular)) {
      this.plural(singular, irregulars[singular]);
      this.singular(irregulars[singular], singular);
    }
  }
});
Ext.define('Ext.data.schema.Namer', {mixins:[Ext.mixin.Factoryable], alias:'namer.default', isNamer:true, capitalize:function(name) {
  return Ext.String.capitalize(name);
}, fieldRole:function(name) {
  var match = name.match(this.endsWithIdRe, '');
  if (match) {
    name = name.substr(0, name.length - (match[1] || match[2]).length);
  }
  return this.apply('uncapitalize', name);
}, idField:function(name) {
  return this.apply('uncapitalize,singularize', name) + 'Id';
}, instanceName:function(roleName) {
  return this.apply('underscore', roleName);
}, multiRole:function(name) {
  return this.apply('undotted,uncapitalize,pluralize', name);
}, pluralize:function(name) {
  return Ext.util.Inflector.pluralize(name);
}, readerRoot:function(roleName) {
  return this.apply('uncapitalize', roleName);
}, singularize:function(name) {
  return Ext.util.Inflector.singularize(name);
}, storeName:function(roleName) {
  return this.apply('underscore', roleName);
}, uncapitalize:function(name) {
  return Ext.String.uncapitalize(name);
}, underscore:function(name) {
  return '_' + name;
}, uniRole:function(name) {
  return this.apply('undotted,uncapitalize,singularize', name);
}, undotted:function(name) {
  if (name.indexOf('.') < 0) {
    return name;
  }
  var parts = name.split('.'), index = parts.length;
  while (index-- > 1) {
    parts[index] = this.apply('capitalize', parts[index]);
  }
  return parts.join('');
}, getterName:function(role) {
  var name = role.role;
  if (role && role.isMany) {
    return name;
  }
  return 'get' + this.apply('capitalize', name);
}, inverseFieldRole:function(leftType, unique, rightRole, rightType) {
  var me = this, leftRole = me.apply(unique ? 'uniRole' : 'multiRole', leftType), s1 = me.apply('pluralize', rightRole), s2 = me.apply('undotted,pluralize', rightType);
  if (s1.toLowerCase() !== s2.toLowerCase()) {
    leftRole = rightRole + me.apply('capitalize', leftRole);
  }
  return leftRole;
}, manyToMany:function(relation, leftType, rightType) {
  var me = this, ret = me.apply('undotted,capitalize,singularize', leftType) + me.apply('undotted,capitalize,pluralize', rightType);
  if (relation) {
    ret = me.apply('capitalize', relation + ret);
  }
  return ret;
}, manyToOne:function(leftType, leftRole, rightType, rightRole) {
  return this.apply('capitalize,singularize', rightType) + this.apply('capitalize', leftRole);
}, matrixRole:function(relation, entityType) {
  var ret = this.apply(relation ? 'multiRole,capitalize' : 'multiRole', entityType);
  return relation ? relation + ret : ret;
}, oneToOne:function(leftType, leftRole, rightType, rightRole) {
  return this.apply('undotted,capitalize,singularize', rightType) + this.apply('capitalize', leftRole);
}, setterName:function(role) {
  return 'set' + this.apply('capitalize', role.role);
}, endsWithIdRe:/(?:(_id)|[^A-Z](Id))$/, cache:{}, apply:function(operation, name) {
  var me = this, cache = me.cache, entry = cache[name] || (cache[name] = {}), ret = entry[operation], i, length, operations;
  if (!ret) {
    if (operation.indexOf(',') < 0) {
      ret = me[operation](name);
    } else {
      length = (operations = operation.split(',')).length;
      ret = name;
      for (i = 0; i < length; ++i) {
        ret = me.apply(operations[i], ret);
      }
    }
    entry[operation] = ret;
  }
  return ret;
}});
Ext.define('Ext.data.schema.Schema', {mixins:[Ext.mixin.Factoryable], alias:'schema.default', aliasPrefix:'schema.', isSchema:true, type:'default', statics:{instances:{}, clearInstance:function(id) {
  var schema = this.instances[id];
  delete this.instances[id];
  if (schema) {
    schema.clear(true);
    schema.destroy();
  }
}, get:function(config) {
  var Schema = this, cache = Schema.instances, id = 'default', isString = config && Ext.isString(config), instance, newConfig;
  if (config) {
    if (config.isSchema) {
      return config;
    }
    id = isString ? config : config.id || id;
  }
  if (!(instance = cache[id])) {
    cache[id] = instance = Schema.create(config);
    instance.id = id;
  } else {
    if (config && !isString) {
      if (id !== 'default') {
        Ext.raise('Only the default Schema instance can be reconfigured');
      }
      newConfig = Ext.merge({}, instance.config);
      Ext.merge(newConfig, config);
      instance.setConfig(newConfig);
      instance.config = newConfig;
      instance.setConfig = function() {
        Ext.raise('The schema can only be reconfigured once');
      };
    }
  }
  return instance;
}, lookupEntity:function(entity) {
  var ret = null, instances = this.instances, match, name, schema;
  if (entity) {
    if (entity.isEntity) {
      ret = entity.self;
    } else {
      if (Ext.isFunction(entity)) {
        ret = entity;
      } else {
        if (Ext.isString(entity)) {
          ret = Ext.ClassManager.get(entity);
          if (ret && (!ret.prototype || !ret.prototype.isEntity)) {
            ret = null;
          }
          if (!ret) {
            for (name in instances) {
              schema = instances[name];
              match = schema.getEntity(entity);
              if (match) {
                if (ret) {
                  Ext.raise('Ambiguous entity name "' + entity + '". Defined by schema "' + ret.schema.type + '" and "' + name + '"');
                }
                ret = match;
              }
            }
          }
          if (!ret) {
            Ext.raise('No such Entity "' + entity + '".');
          }
        }
      }
    }
  }
  return ret;
}}, assocCount:0, entityCount:0, config:{defaultIdentifier:null, keyCheckDelay:10, namer:'default', namespace:null, proxy:{type:'ajax', url:'{prefix}/{entityName}'}, urlPrefix:''}, onClassExtended:function(cls, data) {
  var alias = data.alias;
  if (alias && !data.type) {
    if (!Ext.isString(alias)) {
      alias = alias[0];
    }
    cls.prototype.type = alias.substring(this.prototype.aliasPrefix.length);
  }
}, constructor:function(config) {
  this.initConfig(config);
  this.clear();
}, applyDefaultIdentifier:function(identifier) {
  return identifier && Ext.Factory.dataIdentifier(identifier);
}, applyNamer:function(namer) {
  var ret = Ext.data.schema.Namer.create(namer);
  ret.schema = this;
  return ret;
}, applyNamespace:function(namespace) {
  if (namespace) {
    var end = namespace.length - 1;
    if (namespace.charAt(end) !== '.') {
      namespace += '.';
    }
  }
  return namespace;
}, applyProxy:function(proxy) {
  return Ext.util.ObjectTemplate.create(proxy);
}, eachAssociation:function(fn, scope) {
  var associations = this.associations, name;
  for (name in associations) {
    if (associations.hasOwnProperty(name)) {
      if (fn.call(scope, name, associations[name]) === false) {
        break;
      }
    }
  }
}, eachEntity:function(fn, scope) {
  var entities = this.entities, name;
  for (name in entities) {
    if (entities.hasOwnProperty(name)) {
      if (fn.call(scope, name, entities[name].cls) === false) {
        break;
      }
    }
  }
}, getAssociation:function(name) {
  var entry = this.associations[name];
  return entry || null;
}, getEntity:function(name) {
  var entry = this.entityClasses[name] || this.entities[name];
  return entry && entry.cls || null;
}, getEntityName:function(cls) {
  var ns = this.getNamespace(), index, name;
  if (typeof cls === 'string') {
    name = cls;
  } else {
    name = cls.$className || null;
  }
  if (name) {
    if (ns) {
      index = ns.length;
      if (name.substring(0, index) !== ns) {
        return name;
      }
    }
    if (index) {
      name = name.substring(index);
    }
  }
  return name;
}, hasAssociations:function(name) {
  name = name.entityName || name;
  return !!this.associationEntityMap[name];
}, hasEntity:function(entity) {
  var name = this.getEntityName(entity);
  return !!(this.entities[name] || this.entityClasses[name]);
}, addMatrix:function(entityType, matrixName, relation, left, right) {
  var me = this, namer = me.getNamer(), associations = me.associations, entities = me.entities, leftType = left.type, rightType = right.type, leftField = left.field || namer.apply('idField', leftType), rightField = right.field || namer.apply('idField', rightType), leftRole = left.role || namer.matrixRole(relation, leftType), rightRole = right.role || namer.matrixRole(relation, rightType), matrix, leftEntry, rightEntry;
  leftEntry = entities[leftType] || (entities[leftType] = {cls:null, name:leftType, associations:{}});
  rightEntry = entities[rightType] || (entities[rightType] = {cls:null, name:rightType, associations:{}});
  ++me.assocCount;
  associations[matrixName] = matrix = new Ext.data.schema.ManyToMany({name:matrixName, schema:me, definedBy:entityType, left:{cls:leftEntry.cls, type:leftType, role:leftRole, field:leftField, associationKey:left.associationKey}, right:{cls:rightEntry.cls, type:rightType, role:rightRole, field:rightField, associationKey:right.associationKey}});
  leftEntry.associations[matrix.right.role] = matrix.right;
  rightEntry.associations[matrix.left.role] = matrix.left;
  if (leftEntry.cls) {
    me.associationEntityMap[leftEntry.cls.entityName] = true;
  }
  if (rightEntry.cls) {
    me.associationEntityMap[rightEntry.cls.entityName] = true;
  }
  me.decorateModel(matrix);
}, addReference:function(entityType, referenceField, descr, unique, dupeCheck) {
  var me = this, namer = me.getNamer(), entities = me.entities, associations = me.associations, entityName = entityType.entityName, association = descr.association, child = descr.child, parent = descr.parent, rightRole = descr.role, rightType = descr.type || parent || child, leftVal = descr.inverse, left = Ext.isString(leftVal) ? {role:leftVal} : leftVal, leftRole = left && left.role, entry, T;
  if (!rightRole) {
    if (!referenceField || descr.legacy) {
      rightRole = namer.apply('uncapitalize', rightType);
    } else {
      rightRole = namer.apply('fieldRole', referenceField.name);
    }
  }
  if (!leftRole) {
    leftRole = namer.inverseFieldRole(entityName, unique, rightRole, rightType);
  }
  if (!association) {
    if (unique) {
      association = namer.oneToOne(entityType, leftRole, rightType, rightRole);
    } else {
      association = namer.manyToOne(entityType, leftRole, rightType, rightRole);
    }
  }
  if (dupeCheck && association in associations) {
    if (dupeCheck(associations[association], association, leftRole, rightRole) !== false) {
      return;
    }
  }
  if (association in associations) {
    Ext.raise('Duplicate association: "' + association + '" declared by ' + entityName + (referenceField ? '.' + referenceField.name : '') + ' (collides with ' + associations[association].definedBy.entityName + ')');
  }
  if (referenceField && referenceField.definedBy === entities[rightType]) {
    Ext.raise('ForeignKey reference should not be owned by the target model');
  }
  entry = entities[rightType] || (entities[rightType] = {cls:null, name:rightType, associations:{}});
  T = unique ? Ext.data.schema.OneToOne : Ext.data.schema.ManyToOne;
  association = new T({name:association, owner:child ? 'left' : parent ? 'right' : null, definedBy:entityType, schema:me, field:referenceField, nullable:referenceField ? !!referenceField.allowBlank : true, left:{cls:entityType, type:entityName, role:leftRole, extra:left}, right:{cls:entry.cls, type:rightType, role:rightRole, extra:descr}, meta:descr});
  entityType.associations[rightRole] = association.right;
  entry.associations[leftRole] = association.left;
  if (referenceField) {
    referenceField.reference = association.right;
    entityType.references.push(referenceField);
  }
  ++me.assocCount;
  me.associationEntityMap[entityName] = true;
  if (entry.cls) {
    me.associationEntityMap[entry.cls.entityName] = true;
  }
  associations[association.name] = association;
  if (association.right.cls) {
    me.decorateModel(association);
  }
}, privates:{addEntity:function(entityType) {
  var me = this, entities = me.entities, entityName = entityType.entityName, entry = entities[entityName], fields = entityType.fields, associations, field, i, length, name;
  if (!entry) {
    entities[entityName] = entry = {name:entityName, associations:{}};
  } else {
    if (entry.cls) {
      Ext.raise('Duplicate entity name "' + entityName + '": ' + entry.cls.$className + ' and ' + entityType.$className);
    } else {
      associations = entry.associations;
      for (name in associations) {
        associations[name].inverse.cls = entityType;
        me.associationEntityMap[entityName] = true;
        me.decorateModel(associations[name].association);
      }
    }
  }
  entry.cls = entityType;
  entityType.prototype.associations = entityType.associations = entry.associations;
  me.entityClasses[entityType.$className] = entry;
  ++me.entityCount;
  for (i = 0, length = fields.length; i < length; ++i) {
    field = fields[i];
    if (field.reference) {
      me.addReferenceDescr(entityType, field);
    }
  }
}, addMatrices:function(entityType, matrices) {
  var me = this, i, length, matrixName;
  if (Ext.isString(matrices)) {
    me.addMatrixDescr(entityType, null, matrices);
  } else {
    if (matrices[0]) {
      for (i = 0, length = matrices.length; i < length; ++i) {
        me.addMatrixDescr(entityType, null, matrices[i]);
      }
    } else {
      for (matrixName in matrices) {
        me.addMatrixDescr(entityType, matrixName, matrices[matrixName]);
      }
    }
  }
}, addMatrixDescr:function(entityType, matrixName, matrixDef) {
  var me = this, entityName = entityType.entityName, associations = me.associations, namer = me.getNamer(), left = matrixDef.left, right = matrixDef.right, last, relation;
  if (Ext.isString(matrixDef)) {
    if (matrixDef.charAt(0) === '#') {
      left = {type:entityName};
      right = {type:matrixDef.substring(1)};
    } else {
      if (matrixDef.charAt(last = matrixDef.length - 1) === '#') {
        left = {type:matrixDef.substring(0, last)};
        right = {type:entityName};
      } else {
        if (namer.apply('multiRole', entityName) < namer.apply('multiRole', matrixDef)) {
          left = {type:entityName};
          right = {type:matrixDef};
        } else {
          left = {type:matrixDef};
          right = {type:entityName};
        }
      }
    }
  } else {
    Ext.Assert.isString(matrixDef.type, 'No "type" for manyToMany in ' + entityName);
    relation = matrixDef.relation;
    if (left || !right && namer.apply('multiRole', entityName) < namer.apply('multiRole', matrixDef.type)) {
      if (!left || left === true) {
        left = {type:entityName};
      } else {
        left = Ext.apply({type:entityName}, left);
      }
      right = matrixDef;
    } else {
      if (!right || right === true) {
        right = {type:entityName};
      } else {
        right = Ext.apply({type:entityName}, right);
      }
      left = matrixDef;
    }
  }
  if (!matrixName) {
    matrixName = namer.manyToMany(relation, left.type, right.type);
  }
  if (!(matrixName in associations)) {
    me.addMatrix(entityType, matrixName, relation, left, right);
  } else {
    var entry = associations[matrixName], before = [entry.kind, entry.left.type, entry.left.role, entry.left.field, entry.right.type, entry.right.role, entry.right.field].join('|');
    delete associations[matrixName];
    me.addMatrix(entityType, matrixName, relation, left, right);
    var after = associations[matrixName];
    associations[matrixName] = entry;
    entry.left.cls.associations[entry.right.role] = entry.right;
    entry.right.cls.associations[entry.left.role] = entry.left;
    --me.assocCount;
    after = [after.kind, after.left.type, after.left.role, after.left.field, after.right.type, after.right.role, after.right.field].join('|');
    if (before != after) {
      Ext.log.warn(matrixName + '(' + entry.definedBy.entityName + '): ' + before);
      Ext.log.warn(matrixName + '(' + entityName + '): ' + after);
      Ext.raise('Conflicting association: "' + matrixName + '" declared by ' + entityName + ' was previously declared by ' + entry.definedBy.entityName);
    }
  }
}, addReferenceDescr:function(entityType, referenceField) {
  var me = this, descr = referenceField.$reference;
  if (Ext.isString(descr)) {
    descr = {type:descr};
  } else {
    descr = Ext.apply({}, descr);
  }
  me.addReference(entityType, referenceField, descr, referenceField.unique);
}, addBelongsTo:function(entityType, assoc) {
  this.addKeylessSingle(entityType, assoc, false);
}, addHasOne:function(entityType, assoc) {
  this.addKeylessSingle(entityType, assoc, true);
}, addKeylessSingle:function(entityType, assoc, unique) {
  var foreignKey, referenceField;
  assoc = Ext.apply({}, this.checkLegacyAssociation(entityType, assoc));
  assoc.type = this.getEntityName(assoc.child || assoc.parent || assoc.type);
  foreignKey = assoc.foreignKey || assoc.type.toLowerCase() + '_id';
  referenceField = entityType.getField(foreignKey);
  assoc.fromSingle = true;
  if (referenceField) {
    referenceField.$reference = assoc;
    referenceField.unique = true;
    assoc.legacy = true;
    Ext.log.warn('Using foreignKey is deprecated, use a keyed association. See Ext.data.field.Field.reference');
  }
  this.addReference(entityType, referenceField, assoc, unique);
}, addHasMany:function(entityType, assoc) {
  var me = this, entities = me.entities, pending = me.pending, cls, name, referenceField, target, foreignKey, inverseOptions, child, declaredInverse;
  assoc = Ext.apply({}, this.checkLegacyAssociation(entityType, assoc));
  assoc.type = this.getEntityName(assoc.child || assoc.parent || assoc.type);
  name = assoc.type;
  target = entities[name];
  cls = target && target.cls;
  if (cls) {
    name = entityType.entityName;
    foreignKey = assoc.foreignKey || name.toLowerCase() + '_id';
    delete assoc.foreignKey;
    declaredInverse = Ext.apply({}, assoc.inverse);
    delete assoc.inverse;
    inverseOptions = Ext.apply({}, assoc);
    delete inverseOptions.type;
    assoc = Ext.apply({type:name, inverse:inverseOptions}, declaredInverse);
    child = inverseOptions.child;
    if (child) {
      delete inverseOptions.child;
      assoc.parent = name;
    }
    referenceField = cls.getField(foreignKey);
    if (referenceField) {
      referenceField.$reference = assoc;
      assoc.legacy = true;
      Ext.log.warn('Using foreignKey is deprecated, use a keyed association. See Ext.data.field.Field.reference');
    }
    me.addReference(cls, referenceField, assoc, false, function(association, name, leftRole, rightRole) {
      var result = !!association.meta.fromSingle && cls === association.left.cls, l, r;
      if (result) {
        l = cls.entityName;
        r = entityType.entityName;
        Ext.raise('hasMany ("' + r + '") and belongsTo ("' + l + '") should not be used in conjunction to declare a relationship. Use only one.');
      }
      return result;
    });
  } else {
    if (!pending[name]) {
      pending[name] = [];
    }
    pending[name].push([entityType, assoc]);
  }
}, checkLegacyAssociation:function(entityType, assoc) {
  if (Ext.isString(assoc)) {
    assoc = {type:assoc};
  } else {
    assoc = Ext.apply({}, assoc);
  }
  if (assoc.model) {
    assoc.type = assoc.model;
    delete assoc.model;
  }
  var name = assoc.associatedName || assoc.name;
  if (name) {
    delete assoc.associatedName;
    delete assoc.name;
    assoc.role = name;
  }
  return assoc;
}, afterKeylessAssociations:function(cls) {
  var pending = this.pending, name = cls.entityName, mine = pending[name], i, len;
  if (mine) {
    for (i = 0, len = mine.length; i < len; ++i) {
      this.addHasMany.apply(this, mine[i]);
    }
    delete pending[name];
  }
}, clear:function(clearNamespace) {
  var me = this, timer = me.timer;
  delete me.setConfig;
  if (timer) {
    window.clearTimeout(timer);
    me.timer = null;
  }
  me.associations = {};
  me.associationEntityMap = {};
  me.entities = {};
  me.entityClasses = {};
  me.pending = {};
  me.assocCount = me.entityCount = 0;
  if (clearNamespace) {
    me.setNamespace(null);
  }
}, constructProxy:function(Model) {
  var me = this, data = Ext.Object.chain(Model), proxy = me.getProxy();
  data.schema = me;
  data.prefix = me.getUrlPrefix();
  return proxy.apply(data);
}, applyDecoration:function(role) {
  var me = this, cls = role.inverse.cls, namer = me.getNamer(), getterName, setterName, proto;
  if (cls && !role.decorated) {
    role.decorated = true;
    proto = cls.prototype;
    if (!(getterName = role.getterName)) {
      role.getterName = getterName = namer.getterName(role);
    }
    proto[getterName] = role.createGetter();
    if (role.createSetter) {
      if (!(setterName = role.setterName)) {
        role.setterName = setterName = namer.setterName(role);
      }
      proto[setterName] = role.createSetter();
    }
  }
}, decorateModel:function(association) {
  this.applyDecoration(association.left);
  this.applyDecoration(association.right);
}, processKeyChecks:function(processAll) {
  var me = this, keyCheckQueue = me.keyCheckQueue, timer = me.timer, len, i, item;
  if (timer) {
    window.clearTimeout(timer);
    me.timer = null;
  }
  if (!keyCheckQueue) {
    return;
  }
  do {
    keyCheckQueue = me.keyCheckQueue;
    me.keyCheckQueue = [];
    for (i = 0, len = keyCheckQueue.length; i < len; ++i) {
      item = keyCheckQueue[i];
      item.role.checkKeyForDrop(item.record);
    }
  } while (processAll && me.keyCheckQueue.length);
}, queueKeyCheck:function(record, role) {
  var me = this, keyCheckQueue = me.keyCheckQueue, timer = me.timer;
  if (!keyCheckQueue) {
    me.keyCheckQueue = keyCheckQueue = [];
  }
  keyCheckQueue.push({record:record, role:role});
  if (!timer) {
    me.timer = timer = Ext.defer(me.processKeyChecks, me.getKeyCheckDelay(), me);
  }
}, rankEntities:function() {
  var me = this, entities = me.entities, entityNames = Ext.Object.getKeys(entities), length = entityNames.length, entityType, i;
  me.nextRank = 1;
  entityNames.sort();
  for (i = 0; i < length; ++i) {
    entityType = entities[entityNames[i]].cls;
    if (!entityType.rank) {
      me.rankEntity(entityType);
    }
  }
  me.topoStack = null;
}, rankEntity:function(entityType) {
  var associations = entityType.associations, associatedType, role, roleName;
  var topoStack = this.topoStack || (this.topoStack = []), entityName = entityType.entityName;
  topoStack.push(entityName);
  if (entityType.rank === 0) {
    Ext.raise(entityName + ' has circular foreign-key references: ' + topoStack.join(' --\x3e '));
  }
  entityType.rank = 0;
  for (roleName in associations) {
    role = associations[roleName];
    if (!role.left && role.association.field) {
      associatedType = role.cls;
      if (!associatedType.rank) {
        this.rankEntity(associatedType);
      }
    }
  }
  entityType.rank = this.nextRank++;
  topoStack.pop();
}}});
Ext.define('Ext.data.AbstractStore', {mixins:[Ext.mixin.Observable, Ext.mixin.Factoryable], factoryConfig:{defaultType:'store', type:'store'}, $configPrefixed:false, $configStrict:false, config:{filters:null, autoDestroy:undefined, storeId:null, statefulFilters:false, sorters:null, remoteSort:{lazy:true, $value:false}, remoteFilter:{lazy:true, $value:false}, groupField:undefined, groupDir:'ASC', grouper:null, pageSize:25, autoSort:null, reloadOnClearSorters:false}, currentPage:1, loading:false, isStore:true, 
updating:0, constructor:function(config) {
  var me = this, storeId;
  me.callParent([config]);
  me.isInitializing = true;
  me.mixins.observable.constructor.call(me, config);
  me.isInitializing = false;
  storeId = me.getStoreId();
  if (!storeId && (config && config.id)) {
    me.setStoreId(storeId = config.id);
  }
  if (storeId) {
    Ext.data.StoreManager.register(me);
  }
}, createActiveRange:function(config) {
  var range = Ext.apply({store:this}, config);
  return new Ext.data.Range(range);
}, syncActiveRanges:function() {
  var activeRanges = this.activeRanges, len = activeRanges && activeRanges.length, i;
  for (i = 0; i < len; i++) {
    activeRanges[i].refresh();
  }
}, getCount:function() {
  var data = this.getData();
  return data ? data.getCount() : 0;
}, rangeCached:function(start, end) {
  return this.getData().getCount() >= Math.max(start, end);
}, find:function(property, value, startIndex, anyMatch, caseSensitive, exactMatch) {
  var startsWith = !anyMatch, endsWith = !!(startsWith && exactMatch);
  return this.getData().findIndex(property, value, startIndex, startsWith, endsWith, !caseSensitive);
}, findRecord:function() {
  var me = this, index = me.find.apply(me, arguments);
  return index !== -1 ? me.getAt(index) : null;
}, findExact:function(fieldName, value, startIndex) {
  return this.getData().findIndexBy(function(rec) {
    return rec.isEqual(rec.get(fieldName), value);
  }, this, startIndex);
}, findBy:function(fn, scope, start) {
  return this.getData().findIndexBy(fn, scope, start);
}, getAt:function(index) {
  return this.getData().getAt(index) || null;
}, getRange:function(start, end, options) {
  var result = this.getData().getRange(start, Ext.isNumber(end) ? end + 1 : end);
  if (options && options.callback) {
    options.callback.call(options.scope || this, result, start, end, options);
  }
  return result;
}, getFilters:function(autoCreate) {
  var result = this.callParent();
  if (!result && autoCreate !== false) {
    this.setFilters([]);
    result = this.callParent();
  }
  return result;
}, applyFilters:function(filters, filtersCollection) {
  var created;
  if (!filtersCollection) {
    filtersCollection = this.createFiltersCollection();
    created = true;
  }
  filtersCollection.add(filters);
  if (created) {
    this.onRemoteFilterSet(filtersCollection, this.getRemoteFilter());
  }
  return filtersCollection;
}, getSorters:function(autoCreate) {
  var result = this.callParent();
  if (!result && autoCreate !== false) {
    this.setSorters([]);
    result = this.callParent();
  }
  return result;
}, applySorters:function(sorters, sortersCollection) {
  var created;
  if (!sortersCollection) {
    sortersCollection = this.createSortersCollection();
    created = true;
  }
  sortersCollection.add(sorters);
  if (created) {
    this.onRemoteSortSet(sortersCollection, this.getRemoteSort());
  }
  return sortersCollection;
}, filter:function(filters, value, suppressEvent) {
  if (Ext.isString(filters)) {
    filters = {property:filters, value:value};
  }
  this.suppressNextFilter = !!suppressEvent;
  this.getFilters().add(filters);
  this.suppressNextFilter = false;
}, removeFilter:function(toRemove, suppressEvent) {
  var me = this, filters = me.getFilters();
  me.suppressNextFilter = !!suppressEvent;
  if (toRemove instanceof Ext.util.Filter) {
    filters.remove(toRemove);
  } else {
    filters.removeByKey(toRemove);
  }
  me.suppressNextFilter = false;
}, updateAutoSort:function(autoSort) {
  this.getData().setAutoSort(autoSort);
}, updateRemoteSort:function(remoteSort) {
  this.onRemoteSortSet(this.getSorters(false), remoteSort);
}, updateRemoteFilter:function(remoteFilter) {
  this.onRemoteFilterSet(this.getFilters(false), remoteFilter);
}, addFilter:function(filters, suppressEvent) {
  this.suppressNextFilter = !!suppressEvent;
  this.getFilters().add(filters);
  this.suppressNextFilter = false;
}, filterBy:function(fn, scope) {
  this.getFilters().add({filterFn:fn, scope:scope || this});
}, clearFilter:function(suppressEvent) {
  var me = this, filters = me.getFilters(false);
  if (!filters || filters.getCount() === 0) {
    return;
  }
  me.suppressNextFilter = !!suppressEvent;
  filters.removeAll();
  me.suppressNextFilter = false;
}, isFiltered:function() {
  return this.getFilters().getCount() > 0;
}, isSorted:function() {
  var sorters = this.getSorters(false);
  return !!(sorters && sorters.length > 0) || this.isGrouped();
}, addFieldTransform:function(sorter) {
  if (sorter.getTransform()) {
    return;
  }
  var fieldName = sorter.getProperty(), Model = this.getModel(), field, sortType;
  if (Model) {
    field = Model.getField(fieldName);
    sortType = field ? field.getSortType() : null;
  }
  if (sortType && sortType !== Ext.identityFn) {
    sorter.setTransform(sortType);
  }
}, beginUpdate:function() {
  if (!this.updating++ && this.hasListeners.beginupdate) {
    this.fireEvent('beginupdate');
  }
}, endUpdate:function() {
  if (this.updating && !--this.updating) {
    if (this.hasListeners.endupdate) {
      this.fireEvent('endupdate');
    }
    this.onEndUpdate();
  }
}, getState:function() {
  var me = this, sorters = [], filters = me.getFilters(), grouper = me.getGrouper(), filterState, hasState, result;
  me.getSorters().each(function(s) {
    sorters[sorters.length] = s.getState();
    hasState = true;
  });
  if (me.statefulFilters && me.saveStatefulFilters) {
    hasState = true;
    filterState = [];
    filters.each(function(f) {
      filterState[filterState.length] = f.getState();
    });
  }
  if (grouper) {
    hasState = true;
  }
  if (hasState) {
    result = {};
    if (sorters.length) {
      result.sorters = sorters;
    }
    if (filterState) {
      result.filters = filterState;
    }
    if (grouper) {
      result.grouper = grouper.getState();
    }
  }
  return result;
}, applyState:function(state) {
  var me = this, stateSorters = state.sorters, stateFilters = state.filters, stateGrouper = state.grouper;
  if (stateSorters) {
    me.getSorters().replaceAll(stateSorters);
  }
  if (stateFilters) {
    me.saveStatefulFilters = true;
    me.getFilters().replaceAll(stateFilters);
  }
  if (stateGrouper) {
    me.setGrouper(stateGrouper);
  }
}, hasPendingLoad:Ext.emptyFn, isLoaded:Ext.emptyFn, isLoading:Ext.emptyFn, destroy:function() {
  var me = this;
  if (me.hasListeners.beforedestroy) {
    me.fireEvent('beforedestroy', me);
  }
  me.destroying = true;
  if (me.getStoreId()) {
    Ext.data.StoreManager.unregister(me);
  }
  me.doDestroy();
  if (me.hasListeners.destroy) {
    me.fireEvent('destroy', me);
  }
  me.destroying = false;
  me.callParent();
}, doDestroy:Ext.emptyFn, sort:function(field, direction, mode) {
  var me = this;
  if (arguments.length === 0) {
    if (me.getRemoteSort()) {
      me.load();
    } else {
      me.forceLocalSort();
    }
  } else {
    me.getSorters().addSort(field, direction, mode);
  }
}, onBeforeCollectionSort:function(store, sorters) {
  if (sorters) {
    this.fireEvent('beforesort', this, sorters.getRange());
  }
}, onSorterEndUpdate:function() {
  var me = this, fireSort = true, sorters = me.getSorters(false), sorterCount;
  if (me.settingGroups || !sorters) {
    return;
  }
  sorters = sorters.getRange();
  sorterCount = sorters.length;
  if (me.getRemoteSort()) {
    if (sorters.length || me.getReloadOnClearSorters()) {
      fireSort = false;
      me.load({callback:function() {
        me.fireEvent('sort', me, sorters);
      }});
    }
  } else {
    if (sorterCount) {
      me.fireEvent('datachanged', me);
      me.fireEvent('refresh', me);
    }
  }
  if (fireSort) {
    me.fireEvent('sort', me, sorters);
  }
}, onFilterEndUpdate:function() {
  var me = this, suppressNext = me.suppressNextFilter, filters = me.getFilters(false);
  if (!filters) {
    return;
  }
  if (me.getRemoteFilter()) {
    me.getFilters().each(function(filter) {
      if (filter.getInitialConfig().filterFn) {
        Ext.raise('Unable to use a filtering function in conjunction with remote filtering.');
      }
    });
    me.currentPage = 1;
    if (!suppressNext) {
      me.load();
    }
  } else {
    if (!suppressNext) {
      me.fireEvent('datachanged', me);
      me.fireEvent('refresh', me);
    }
  }
  if (me.trackStateChanges) {
    me.saveStatefulFilters = true;
  }
  me.fireEvent('filterchange', me, me.getFilters().getRange());
}, updateGroupField:function(field) {
  if (field) {
    this.setGrouper({property:field, direction:this.getGroupDir()});
  } else {
    this.setGrouper(null);
  }
}, getGrouper:function() {
  return this.getData().getGrouper();
}, group:function(grouper, direction) {
  var me = this, sorters = me.getSorters(false), change = grouper || sorters && sorters.length, data = me.getData();
  if (grouper && typeof grouper === 'string') {
    grouper = {property:grouper, direction:direction || me.getGroupDir()};
  }
  me.settingGroups = true;
  if (grouper === data.getGrouper()) {
    data.updateGrouper(grouper);
  } else {
    data.setGrouper(grouper);
  }
  delete me.settingGroups;
  if (change) {
    if (me.getRemoteSort()) {
      if (!me.isInitializing) {
        me.load({scope:me, callback:me.fireGroupChange});
      }
    } else {
      me.fireEvent('datachanged', me);
      me.fireEvent('refresh', me);
      me.fireGroupChange();
    }
  } else {
    me.fireGroupChange();
  }
}, fireGroupChange:function() {
  if (!this.destroyed) {
    this.fireEvent('groupchange', this, this.getGrouper());
  }
}, clearGrouping:function() {
  this.group(null);
}, getGroupField:function() {
  var grouper = this.getGrouper(), group = '';
  if (grouper) {
    group = grouper.getProperty();
  }
  return group;
}, isGrouped:function() {
  return !!this.getGrouper();
}, applyGrouper:function(grouper) {
  this.group(grouper);
  return this.getData().getGrouper();
}, getGroups:function() {
  return this.getData().getGroups();
}, onEndUpdate:Ext.emptyFn, privates:{_metaProperties:{count:'getCount', first:'first', last:'last', loading:'hasPendingLoad', totalCount:'getTotalCount'}, interpret:function(name) {
  var me = this, accessor = me._metaProperties[name];
  return accessor && me[accessor]();
}, loadsSynchronously:Ext.privateFn, onRemoteFilterSet:function(filters, remoteFilter) {
  if (filters) {
    filters[remoteFilter ? 'on' : 'un']('endupdate', 'onFilterEndUpdate', this);
  }
}, onRemoteSortSet:function(sorters, remoteSort) {
  var me = this, data;
  if (sorters) {
    sorters[remoteSort ? 'on' : 'un']('endupdate', 'onSorterEndUpdate', me);
    data = me.getData();
    if (data) {
      data[remoteSort ? 'un' : 'on']('beforesort', 'onBeforeCollectionSort', me);
    }
  }
}}, deprecated:{5:{methods:{destroyStore:function() {
  this.destroy();
}}}}});
Ext.define('Ext.data.Error', {isError:true, $configPrefixed:false, config:{field:null, message:''}, constructor:function(config) {
  this.initConfig(config);
  this.msg = this.message;
}});
Ext.define('Ext.data.ErrorCollection', {extend:Ext.util.MixedCollection, alternateClassName:'Ext.data.Errors', init:function(record) {
  var me = this, fields = record.fields, data = record.data, before, field, item, i, len, msg, val, name;
  for (i = 0, len = fields.length; i < len; ++i) {
    field = fields[i];
    name = field.name;
    val = data[name];
    if (field.validate && !field.validate.$nullFn) {
      before = me.length;
      msg = field.validate(val, null, me, record);
      if (before === me.length && msg !== true) {
        me.add(name, msg);
      }
    }
  }
  return me;
}, add:function(key, value) {
  var me = this, defaultMessage = Ext.data.field.Field.defaultInvalidMessage, obj = key, current;
  if (Ext.isString(key)) {
    obj = new Ext.data.Error({field:key, message:value || defaultMessage});
  } else {
    if (!obj.isError) {
      obj = new Ext.data.Error({field:obj.field || obj.name, message:obj.error || obj.message || obj.msg || defaultMessage});
    }
    key = obj.field;
  }
  current = me.get(key);
  if (current) {
    if (Ext.isArray(current)) {
      current.push(obj);
      return current;
    }
    me.removeAtKey(key);
    obj = [current, obj];
    obj.field = key;
    obj = [obj];
  }
  return me.callParent([obj]);
}, getKey:function(item) {
  return item.field;
}, isValid:function() {
  return this.length === 0;
}, getByField:function(fieldName) {
  var values = this.get(fieldName);
  if (values && !Ext.isArray(values)) {
    values = [values];
  }
  return values || [];
}});
Ext.define('Ext.data.operation.Operation', {alternateClassName:'Ext.data.Operation', isOperation:true, config:{synchronous:false, url:'', params:undefined, callback:undefined, scope:undefined, resultSet:null, response:null, request:null, records:null, id:undefined, proxy:null, batch:null, recordCreator:null, internalCallback:null, internalScope:null}, order:0, foreignKeyDirection:1, started:false, running:false, complete:false, success:undefined, exception:false, error:undefined, idPrefix:'ext-operation-', 
constructor:function(config) {
  var scope = config && config.scope;
  this.initConfig(config);
  if (config) {
    config.scope = scope;
  }
  if (scope) {
    this.setScope(scope);
    this.initialConfig.scope = scope;
  }
  this._internalId = Ext.id(this, this.idPrefix);
}, getAction:function() {
  return this.action;
}, execute:function() {
  var me = this, request;
  delete me.error;
  delete me.success;
  me.complete = me.exception = false;
  me.setStarted();
  me.request = request = me.doExecute();
  if (request) {
    request.setOperation(me);
  }
  return request;
}, doExecute:Ext.emptyFn, abort:function() {
  var me = this, request = me.request, proxy;
  me.aborted = true;
  if (me.running && request) {
    proxy = me.getProxy();
    if (proxy && !proxy.destroyed) {
      proxy.abort(request);
    }
    me.request = null;
  }
  me.running = false;
}, process:function(resultSet, request, response, autoComplete) {
  var me = this;
  autoComplete = autoComplete !== false;
  me.setResponse(response);
  me.setResultSet(resultSet);
  if (resultSet.getSuccess()) {
    me.doProcess(resultSet, request, response);
    me.setSuccessful(autoComplete);
  } else {
    if (autoComplete) {
      me.setException(resultSet.getMessage());
    }
  }
}, _commitSetOptions:{convert:true, commit:true}, doProcess:function(resultSet, request, response) {
  var me = this, commitSetOptions = me._commitSetOptions, clientRecords = me.getRecords(), clientLen = clientRecords.length, clientIdProperty = clientRecords[0].clientIdProperty, serverRecords = resultSet.getRecords(), serverLen = serverRecords ? serverRecords.length : 0, clientMap, serverRecord, clientRecord, i;
  if (serverLen && clientIdProperty) {
    clientMap = Ext.Array.toValueMap(clientRecords, 'id');
    for (i = 0; i < serverLen; ++i) {
      serverRecord = serverRecords[i];
      clientRecord = clientMap[serverRecord[clientIdProperty]];
      if (clientRecord) {
        delete clientMap[clientRecord.id];
        delete serverRecord[clientIdProperty];
        clientRecord.set(serverRecord, commitSetOptions);
      } else {
        Ext.log.warn('Ignoring server record: ' + Ext.encode(serverRecord));
      }
    }
    for (i in clientMap) {
      clientMap[i].commit();
    }
  } else {
    for (i = 0; i < clientLen; ++i) {
      clientRecord = clientRecords[i];
      if (serverLen === 0 || !(serverRecord = serverRecords[i])) {
        clientRecord.commit();
      } else {
        clientRecord.set(serverRecord, commitSetOptions);
      }
    }
  }
}, setStarted:function() {
  this.started = this.running = true;
}, setCompleted:function() {
  var me = this, proxy;
  me.complete = true;
  me.running = false;
  if (!me.destroying) {
    me.triggerCallbacks();
  }
  if (me.destroyed) {
    return;
  }
  proxy = me.getProxy();
  if (proxy && !proxy.destroyed) {
    proxy.completeOperation(me);
  }
}, setSuccessful:function(complete) {
  this.success = true;
  if (complete) {
    this.setCompleted();
  }
}, setException:function(error) {
  var me = this;
  me.exception = true;
  me.success = me.running = false;
  me.error = error;
  me.setCompleted();
}, triggerCallbacks:function() {
  var me = this, callback = me.getInternalCallback();
  if (callback) {
    callback.call(me.getInternalScope() || me, me);
    if (me.destroyed) {
      return;
    }
    me.setInternalCallback(null);
    me.setInternalScope(null);
  }
  if (callback = me.getCallback()) {
    callback.call(me.getScope() || me, me.getRecords(), me, me.wasSuccessful());
    if (me.destroyed) {
      return;
    }
    me.setCallback(null);
    me.setScope(null);
  }
}, hasException:function() {
  return this.exception;
}, getError:function() {
  return this.error;
}, getRecords:function() {
  var resultSet;
  return this._records || ((resultSet = this.getResultSet()) ? resultSet.getRecords() : null);
}, isStarted:function() {
  return this.started;
}, isRunning:function() {
  return this.running;
}, isComplete:function() {
  return this.complete;
}, wasSuccessful:function() {
  return this.isComplete() && this.success === true;
}, allowWrite:function() {
  return true;
}, destroy:function() {
  var me = this;
  me.destroying = true;
  if (me.running) {
    me.abort();
  }
  me._params = me._callback = me._scope = me._resultSet = me._response = null;
  me.request = me._request = me._records = me._proxy = me._batch = null;
  me._recordCreator = me._internalCallback = me._internalScope = null;
  me.callParent();
}});
Ext.define('Ext.data.operation.Create', {extend:Ext.data.operation.Operation, alias:'data.operation.create', action:'create', isCreateOperation:true, order:10, config:{recordCreator:Ext.identityFn}, doExecute:function() {
  return this.getProxy().create(this);
}});
Ext.define('Ext.data.operation.Destroy', {extend:Ext.data.operation.Operation, alias:'data.operation.destroy', action:'destroy', isDestroyOperation:true, order:30, foreignKeyDirection:-1, doProcess:function() {
  var clientRecords = this.getRecords(), clientLen = clientRecords.length, i;
  for (i = 0; i < clientLen; ++i) {
    clientRecords[i].setErased();
  }
}, doExecute:function() {
  return this.getProxy().erase(this);
}, getRecordData:function(record, operation) {
  var data = {}, idField = record.idField, nameProperty = this.getNameProperty() || 'name';
  data[idField[nameProperty]] = record.id;
  return data;
}});
Ext.define('Ext.data.operation.Read', {extend:Ext.data.operation.Operation, alias:'data.operation.read', action:'read', isReadOperation:true, config:{filters:undefined, sorters:undefined, grouper:undefined, start:undefined, limit:undefined, page:undefined, addRecords:false}, doExecute:function() {
  return this.getProxy().read(this);
}, doProcess:Ext.emptyFn, allowWrite:function() {
  return false;
}});
Ext.define('Ext.data.operation.Update', {extend:Ext.data.operation.Operation, alias:'data.operation.update', action:'update', isUpdateOperation:true, order:20, config:{recordCreator:Ext.identityFn}, doExecute:function() {
  return this.getProxy().update(this);
}});
Ext.define('Ext.data.SortTypes', function() {
  var me;
  return {singleton:true, constructor:function() {
    me = this;
  }, none:Ext.identityFn, stripCommasRe:/,/g, stripTagsRE:/<\/?[^>]+>/gi, asText:function(s) {
    return s != null ? String(s).replace(me.stripTagsRE, '') : '\x00';
  }, asUCText:function(s) {
    return s != null ? String(s).toUpperCase().replace(me.stripTagsRE, '') : '\x00';
  }, asUCString:function(s) {
    return s != null ? String(s).toUpperCase() : '\x00';
  }, asDate:function(s) {
    if (!s) {
      return 0;
    }
    if (Ext.isDate(s)) {
      return s.getTime();
    }
    return Date.parse(String(s));
  }, asFloat:function(s) {
    var val = parseFloat(String(s).replace(me.stripCommasRe, ''));
    return isNaN(val) ? 0 : val;
  }, asInt:function(s) {
    var val = parseInt(String(s).replace(me.stripCommasRe, ''), 10);
    return isNaN(val) ? 0 : val;
  }};
});
Ext.define('Ext.data.validator.Validator', {mixins:[Ext.mixin.Factoryable], alias:'data.validator.base', isValidator:true, factoryConfig:{cacheable:true}, type:'base', constructor:function(config) {
  if (typeof config === 'function') {
    this.fnOnly = true;
    this.validate = config;
  } else {
    this.initConfig(config);
  }
}, validate:function() {
  return true;
}, clone:function() {
  var me = this;
  if (me.fnOnly) {
    return new Ext.data.validator.Validator(me.validate);
  }
  return new me.self(me.getCurrentConfig());
}}, function(Validator) {
  Ext.Factory.validator = Ext.Factory.dataValidator;
});
Ext.define('Ext.data.field.Field', {mixins:[Ext.mixin.Factoryable], alternateClassName:'Ext.data.Field', alias:'data.field.auto', aliasPrefix:'data.field.', type:'auto', factoryConfig:{defaultProperty:'name'}, isDataField:true, isField:true, allowBlank:true, allowNull:false, critical:false, defaultInvalidMessage:'This field is invalid', defaultValue:undefined, definedBy:null, depends:null, dependents:null, mapping:null, name:null, ordinal:undefined, persist:null, reference:null, summary:null, summaryField:'', 
unique:false, rank:null, stripRe:/[\$,%]/g, calculated:false, evil:false, identifier:false, onClassExtended:function(cls, data) {
  var sortType = data.sortType, proto = cls.prototype, superValidators = proto.validators, validators = data.validators;
  if (sortType && Ext.isString(sortType)) {
    proto.sortType = Ext.data.SortTypes[sortType];
  }
  if (validators) {
    if (!Ext.isArray(validators)) {
      validators = [validators];
    }
    delete data.validators;
    if (superValidators) {
      validators = superValidators.concat(validators);
    }
    proto.validators = validators;
  }
}, argumentNamesRe:/^function\s*\(\s*([^,\)\s]+)/, calculateRe:/[^\.a-z0-9_]([a-z_][a-z_0-9]*)\.([a-z_][a-z_0-9]*)/gi, constructor:function(config) {
  var me = this, calculateRe = me.calculateRe, calculate, calculated, defaultValue, sortType, depends, map, match, dataProp, str, fld, validators;
  if (config) {
    if (Ext.isString(config)) {
      me.name = config;
    } else {
      validators = config.validators;
      if (validators) {
        delete config.validators;
        me.instanceValidators = validators;
      }
      Ext.apply(me, config);
    }
  }
  if (!me.allowNull) {
    me.allowNull = !!me.reference;
  }
  calculate = me.calculate;
  depends = me.depends;
  if (calculate) {
    me.convert = me.doCalculate;
    if (!depends) {
      if (!(depends = calculate.$depends)) {
        map = {};
        str = Ext.Function.toCode(calculate);
        calculate.$depends = depends = [];
        match = me.argumentNamesRe.exec(str);
        dataProp = match ? match[1] : 'data';
        while (match = calculateRe.exec(str)) {
          if (dataProp === match[1] && !map[fld = match[2]]) {
            map[fld] = 1;
            depends.push(fld);
          }
        }
      }
      me.depends = depends;
    }
  }
  defaultValue = me.defaultValue;
  if (me.convert) {
    me.calculated = calculated = me.convert.length > 1;
    me.evil = calculated && !depends;
  }
  if (me.persist === null) {
    me.persist = !calculate;
  }
  sortType = me.sortType;
  if (!me.sortType) {
    me.sortType = Ext.data.SortTypes.none;
  } else {
    if (Ext.isString(sortType)) {
      me.sortType = Ext.data.SortTypes[sortType];
    }
  }
  if (depends && typeof depends === 'string') {
    me.depends = [depends];
  }
  me.cloneDefaultValue = defaultValue !== undefined && (Ext.isDate(defaultValue) || Ext.isArray(defaultValue) || Ext.isObject(defaultValue));
}, setModelValidators:function(modelValidators) {
  this._validators = null;
  this.modelValidators = modelValidators;
}, constructValidators:function(validators) {
  if (validators) {
    if (!(validators instanceof Array)) {
      validators = [validators];
    }
    var length = validators.length, all = this._validators, i, item, validator, presence;
    for (i = 0; i < length; ++i) {
      item = validators[i];
      if (item.fn) {
        item = item.fn;
      }
      validator = Ext.Factory.dataValidator(item);
      if (!validator.isPresence) {
        all.push(validator);
      } else {
        presence = validator;
      }
    }
    if (presence) {
      this.presence = [presence];
    }
  }
}, collate:function(value1, value2) {
  var me = this, lhs = value1, rhs = value2;
  if (me.sortType) {
    lhs = me.sortType(lhs);
    rhs = me.sortType(rhs);
  }
  return lhs === rhs ? 0 : lhs < rhs ? -1 : 1;
}, compare:function(value1, value2) {
  return value1 === value2 ? 0 : value1 < value2 ? -1 : 1;
}, isEqual:function(value1, value2) {
  return this.compare(value1, value2) === 0;
}, convert:null, serialize:null, validate:function(value, separator, errors, record) {
  var me = this, validators = me.getValidators(), result, presence;
  presence = this.presence;
  if (presence && (value == null || value === '')) {
    result = me.validateGroup(presence, value, separator, errors, record);
    if (result !== true) {
      return result;
    }
  }
  return me.validateGroup(validators, value, separator, errors, record);
}, validateGroup:function(validators, value, separator, errors, record) {
  var ret = '', validator, length, i, result;
  for (i = 0, length = validators.length; i < length; ++i) {
    validator = validators[i];
    result = validator.validate(value, record);
    if (result !== true) {
      result = result || this.defaultInvalidMessage;
      if (errors) {
        if (errors.isMixedCollection) {
          errors.add(this.name, result);
        } else {
          if (errors.isCollection) {
            errors.add(result);
          } else {
            errors.push(result);
          }
        }
        ret = ret || result;
      } else {
        if (separator) {
          if (ret) {
            ret += separator;
          }
          ret += result;
        } else {
          ret = result;
          break;
        }
      }
    }
  }
  return ret || true;
}, doCalculate:function(v, rec) {
  return rec ? this.calculate(rec.data) : v;
}, getName:function() {
  return this.name;
}, getAllowBlank:function() {
  return this.allowBlank;
}, getAllowNull:function() {
  return this.allowNull;
}, getConvert:function() {
  return this.convert;
}, getDefaultValue:function() {
  return this.defaultValue;
}, getDepends:function() {
  return this.depends;
}, getMapping:function() {
  return this.mapping;
}, hasMapping:function() {
  var map = this.mapping;
  return !!(map || map === 0);
}, getPersist:function() {
  return this.persist;
}, getSortType:function() {
  return this.sortType;
}, getSummary:function() {
  var me = this, doneSummary = me.doneSummary, summary = me.summary;
  if (!doneSummary) {
    me.doneSummary = true;
    if (summary) {
      me.summary = summary = Ext.Factory.dataSummary(summary);
    }
  }
  return summary || null;
}, getType:function() {
  return 'auto';
}, privates:{getValidators:function() {
  var me = this, validators = me._validators;
  if (!validators) {
    me._validators = validators = [];
    me.constructValidators(me.validators);
    me.constructValidators(me.modelValidators);
    me.constructValidators(me.instanceValidators);
  }
  return validators;
}}, deprecated:{'5.1':{methods:{getSortDir:function() {
  return this.sortDir;
}}}}});
Ext.define('Ext.data.field.Boolean', {extend:Ext.data.field.Field, alias:['data.field.bool', 'data.field.boolean'], isBooleanField:true, trueRe:/^\s*(?:true|yes|on|1)\s*$/i, convert:function(v) {
  if (typeof v === 'boolean') {
    return v;
  }
  if (this.allowNull && (v === undefined || v === null || v === '')) {
    return null;
  }
  return this.trueRe.test(String(v));
}, getType:function() {
  return 'bool';
}});
Ext.define('Ext.data.field.Date', {extend:Ext.data.field.Field, alias:'data.field.date', sortType:'asDate', isDateField:true, dateFormat:null, dateReadFormat:null, dateWriteFormat:null, compare:function(lhs, rhs) {
  var lhsIsDate = lhs instanceof Date, rhsIsDate = rhs instanceof Date, result;
  if (rhsIsDate && lhsIsDate) {
    result = lhs.getTime() - rhs.getTime();
    if (result === 0) {
      result = 0;
    } else {
      result = result < 0 ? -1 : 1;
    }
  } else {
    if (lhsIsDate === rhsIsDate) {
      result = 0;
    } else {
      result = lhsIsDate ? 1 : -1;
    }
  }
  return result;
}, convert:function(v) {
  if (!v) {
    return null;
  }
  if (v instanceof Date) {
    return v;
  }
  var dateFormat = this.dateReadFormat || this.dateFormat, parsed;
  if (dateFormat) {
    return Ext.Date.parse(v, dateFormat, this.useStrict);
  }
  parsed = Date.parse(v);
  return parsed ? new Date(parsed) : null;
}, serialize:function(value) {
  var result = null, format;
  if (Ext.isDate(value)) {
    format = this.getDateWriteFormat();
    result = format ? Ext.Date.format(value, format) : value;
  }
  return result;
}, getDateFormat:function() {
  return this.dateFormat;
}, getDateReadFormat:function() {
  return this.dateReadFormat;
}, getDateWriteFormat:function() {
  var me = this;
  if (me.hasOwnProperty('dateWriteFormat')) {
    return me.dateWriteFormat;
  }
  if (me.hasOwnProperty('dateFormat')) {
    return me.dateFormat;
  }
  return me.dateWriteFormat || me.dateFormat || 'timestamp';
}, getType:function() {
  return 'date';
}});
Ext.define('Ext.data.field.Integer', {extend:Ext.data.field.Field, alias:['data.field.int', 'data.field.integer'], isNumeric:true, isIntegerField:true, numericType:'int', convert:function(v) {
  if (typeof v === 'number') {
    return this.getNumber(v);
  }
  var empty = v == null || v === '', allowNull = this.allowNull, out;
  if (empty) {
    out = allowNull ? null : 0;
  } else {
    out = this.parse(v);
    if (allowNull && isNaN(out)) {
      out = null;
    }
  }
  return out;
}, getNumber:function(v) {
  return parseInt(v, 10);
}, getType:function() {
  return this.numericType;
}, parse:function(v) {
  return parseInt(String(v).replace(this.stripRe, ''), 10);
}, sortType:function(s) {
  if (s == null) {
    s = Infinity;
  }
  return s;
}});
Ext.define('Ext.data.field.Number', {extend:Ext.data.field.Integer, alias:['data.field.float', 'data.field.number'], isIntegerField:false, isNumberField:true, numericType:'float', getNumber:Ext.identityFn, parse:function(v) {
  return parseFloat(String(v).replace(this.stripRe, ''));
}});
Ext.define('Ext.data.field.String', {extend:Ext.data.field.Field, alias:'data.field.string', sortType:'asUCString', isStringField:true, convert:function(v) {
  var defaultValue = this.allowNull ? null : '';
  return v === undefined || v === null ? defaultValue : String(v);
}, getType:function() {
  return 'string';
}});
Ext.define('Ext.data.identifier.Generator', {'abstract':true, mixins:[Ext.mixin.Factoryable], alias:'data.identifier.default', factoryConfig:{defaultType:'sequential'}, isGenerator:true, config:{id:null}, constructor:function(config) {
  var me = this, id;
  me.initConfig(config);
  id = me.getId();
  if (id) {
    Ext.data.identifier.Generator.all[id] = me;
  }
}, privates:{clone:function(config) {
  var cfg = this.getInitialConfig();
  cfg = config ? Ext.apply({}, config, cfg) : cfg;
  return new this.self(cfg);
}, statics:{all:{}}}}, function() {
  var Generator = this, Factory = Ext.Factory, factory = Factory.dataIdentifier;
  Factory.dataIdentifier = function(config) {
    var id = Ext.isString(config) ? config : config && config.id, existing = id && Generator.all[id];
    return existing || factory(config);
  };
});
Ext.define('Ext.data.identifier.Sequential', {extend:Ext.data.identifier.Generator, alias:'data.identifier.sequential', config:{increment:1, prefix:null, seed:1}, generate:function() {
  var me = this, seed = me._seed, prefix = me._prefix;
  me._seed += me._increment;
  return prefix !== null ? prefix + seed : seed;
}});
Ext.define('Ext.data.Model', {alternateClassName:'Ext.data.Record', isEntity:true, isModel:true, validIdRe:null, erasing:false, loadOperation:null, loadCount:0, observableType:'record', crudState:'R', crudStateWas:null, constructor:function(data, session) {
  var me = this, cls = me.self, identifier = cls.identifier, Model = Ext.data.Model, modelIdentifier = Model.identifier, idProperty = me.idField.name, array, id, initializeFn, internalId, len, i, fields;
  me.data = me.data = data || (data = {});
  me.internalId = internalId = modelIdentifier.generate();
  var dataId = data[idProperty];
  if (session && !session.isSession) {
    Ext.raise('Bad Model constructor argument 2 - "session" is not a Session');
  }
  if ((array = data) instanceof Array) {
    me.data = data = {};
    fields = me.getFields();
    len = Math.min(fields.length, array.length);
    for (i = 0; i < len; ++i) {
      data[fields[i].name] = array[i];
    }
  }
  if (!(initializeFn = cls.initializeFn)) {
    cls.initializeFn = initializeFn = Model.makeInitializeFn(cls);
  }
  if (!initializeFn.$nullFn) {
    cls.initializeFn(me);
  }
  if (!me.isSummaryModel) {
    if (!(me.id = id = data[idProperty]) && id !== 0) {
      if (dataId) {
        Ext.raise('The model ID configured in data ("' + dataId + '") has been rejected by the ' + me.fieldsMap[idProperty].type + ' field converter for the ' + idProperty + ' field');
      }
      if (session) {
        identifier = session.getIdentifier(cls);
        id = identifier.generate();
      } else {
        if (modelIdentifier === identifier) {
          id = internalId;
        } else {
          id = identifier.generate();
        }
      }
      data[idProperty] = me.id = id;
      me.phantom = true;
      me.crudState = 'C';
    }
    if (session) {
      session.add(me);
    }
    if (me.phantom) {
      me.crudStateWas = 'C';
    }
  }
  if (me.init && Ext.isFunction(me.init)) {
    me.init();
  }
}, editing:false, dirty:false, session:null, dropped:false, erased:false, clientIdProperty:null, evented:false, phantom:false, idProperty:'id', manyToMany:null, identifier:null, previousValues:undefined, proxy:undefined, schema:'default', summary:null, versionProperty:null, generation:1, validationSeparator:null, convertOnSet:true, beginEdit:function() {
  var me = this, modified = me.modified, previousValues = me.previousValues;
  if (!me.editing) {
    me.editing = true;
    me.editMemento = {dirty:me.dirty, data:Ext.apply({}, me.data), generation:me.generation, modified:modified && Ext.apply({}, modified), previousValues:previousValues && Ext.apply({}, previousValues)};
  }
}, calculateSummary:function(records) {
  var fields = this.getFields(), len = fields.length, recLen = records.length, i, result, summary, prop, name, field;
  for (i = 0; i < len; ++i) {
    field = fields[i];
    summary = field.getSummary();
    if (summary) {
      result = result || {};
      name = field.name;
      prop = field.summaryField || name;
      result[name] = summary.calculate(records, prop, 'data', 0, recLen);
    }
  }
  if (result) {
    this.set(result, this._commitOptions);
  }
}, cancelEdit:function() {
  var me = this, editMemento = me.editMemento, validation = me.validation;
  if (editMemento) {
    me.editing = false;
    Ext.apply(me, editMemento);
    me.editMemento = null;
    if (validation && validation.syncGeneration !== me.generation) {
      validation.syncGeneration = 0;
    }
  }
}, endEdit:function(silent, modifiedFieldNames) {
  var me = this, editMemento = me.editMemento;
  if (editMemento) {
    me.editing = false;
    me.editMemento = null;
    me.previousValues = editMemento.previousValues;
    if (!silent) {
      if (!modifiedFieldNames) {
        modifiedFieldNames = me.getModifiedFieldNames(editMemento.data);
      }
      if (me.dirty || modifiedFieldNames && modifiedFieldNames.length) {
        me.callJoined('afterEdit', [modifiedFieldNames]);
      }
    }
  }
}, getField:function(name) {
  return this.self.getField(name);
}, getFields:function() {
  return this.self.getFields();
}, getFieldsMap:function() {
  return this.fieldsMap;
}, getIdProperty:function() {
  return this.idProperty;
}, getId:function() {
  return this.id;
}, getObservableId:function() {
  return this.internalId;
}, setId:function(id, options) {
  this.set(this.idProperty, id, options);
}, getPrevious:function(fieldName) {
  var previousValues = this.previousValues;
  return previousValues && previousValues[fieldName];
}, isModified:function(fieldName) {
  var modified = this.modified;
  return !!(modified && modified.hasOwnProperty(fieldName));
}, getModified:function(fieldName) {
  var out;
  if (this.isModified(fieldName)) {
    out = this.modified[fieldName];
  }
  return out;
}, get:function(fieldName) {
  return this.data[fieldName];
}, _singleProp:{}, _rejectOptions:{convert:false, silent:true}, set:function(fieldName, newValue, options) {
  var me = this, cls = me.self, data = me.data, modified = me.modified, prevVals = me.previousValues, session = me.session, single = Ext.isString(fieldName), opt = single ? options : newValue, convertOnSet = opt ? opt.convert !== false : me.convertOnSet, fieldsMap = me.fieldsMap, silent = opt && opt.silent, commit = opt && opt.commit, updateRefs = !(opt && opt.refs === false) && session, dirty = !(opt && opt.dirty === false && !commit), modifiedFieldNames = null, dirtyRank = 0, associations = me.associations, 
  currentValue, field, idChanged, key, name, oldId, comparator, dep, dependents, i, numFields, newId, rankedFields, reference, value, values, roleName;
  if (single) {
    values = me._singleProp;
    values[fieldName] = newValue;
  } else {
    values = fieldName;
  }
  if (!(rankedFields = cls.rankedFields)) {
    rankedFields = cls.rankFields();
  }
  numFields = rankedFields.length;
  do {
    for (name in values) {
      value = values[name];
      currentValue = data[name];
      comparator = me;
      field = fieldsMap[name];
      if (field) {
        if (convertOnSet && field.convert) {
          value = field.convert(value, me);
        }
        comparator = field;
        reference = field.reference;
      } else {
        reference = null;
      }
      if (comparator.isEqual(currentValue, value)) {
        continue;
      }
      data[name] = value;
      (modifiedFieldNames || (modifiedFieldNames = [])).push(name);
      (prevVals || (me.previousValues = prevVals = {}))[name] = currentValue;
      if (reference && reference.cls) {
        if (updateRefs) {
          session.updateReference(me, field, value, currentValue);
        }
        reference.onValueChange(me, session, value, currentValue);
      }
      i = (dependents = field && field.dependents) && dependents.length;
      while (i-- > 0) {
        (dep = dependents[i]).dirty = true;
        dirtyRank = dirtyRank ? Math.min(dirtyRank, dep.rank) : dep.rank;
      }
      if (!field || field.persist) {
        if (modified && modified.hasOwnProperty(name)) {
          if (!dirty || comparator.isEqual(modified[name], value)) {
            delete modified[name];
            me.dirty = -1;
          }
        } else {
          if (dirty) {
            if (!modified) {
              me.modified = modified = {};
            }
            me.dirty = true;
            modified[name] = currentValue;
          }
        }
      }
      if (name === me.idField.name) {
        idChanged = true;
        oldId = currentValue;
        newId = value;
      }
    }
    if (!dirtyRank) {
      break;
    }
    field = rankedFields[dirtyRank - 1];
    field.dirty = false;
    if (single) {
      delete values[fieldName];
    } else {
      values = me._singleProp;
      single = true;
    }
    fieldName = field.name;
    values[fieldName] = data[fieldName];
    convertOnSet = true;
    for (; dirtyRank < numFields; ++dirtyRank) {
      if (rankedFields[dirtyRank].dirty) {
        break;
      }
    }
    if (dirtyRank < numFields) {
      ++dirtyRank;
    } else {
      dirtyRank = 0;
    }
  } while (1);
  if (me.dirty < 0) {
    me.dirty = false;
    for (key in modified) {
      if (modified.hasOwnProperty(key)) {
        me.dirty = true;
        break;
      }
    }
  }
  if (single) {
    delete values[fieldName];
  }
  ++me.generation;
  if (idChanged) {
    me.id = newId;
    me.onIdChanged(newId, oldId);
    me.callJoined('onIdChanged', [oldId, newId]);
    if (associations) {
      for (roleName in associations) {
        associations[roleName].onIdChanged(me, oldId, newId);
      }
    }
  }
  if (commit) {
    me.commit(silent, modifiedFieldNames);
  } else {
    if (!silent && !me.editing && modifiedFieldNames) {
      me.callJoined('afterEdit', [modifiedFieldNames]);
    }
  }
  return modifiedFieldNames;
}, reject:function(silent) {
  var me = this, modified = me.modified;
  if (me.erased) {
    Ext.raise('Cannot reject once a record has been erased.');
  }
  if (modified) {
    me.set(modified, me._rejectOptions);
  }
  me.dropped = false;
  me.clearState();
  if (!silent) {
    me.callJoined('afterReject');
  }
}, commit:function(silent, modifiedFieldNames) {
  var me = this, versionProperty = me.versionProperty, data = me.data, erased;
  me.clearState();
  if (versionProperty && !me.phantom && !isNaN(data[versionProperty])) {
    ++data[versionProperty];
  }
  me.phantom = false;
  if (me.dropped) {
    me.erased = erased = true;
  }
  if (!silent) {
    if (erased) {
      me.callJoined('afterErase');
    } else {
      me.callJoined('afterCommit', [modifiedFieldNames]);
    }
  }
}, clearState:function() {
  var me = this;
  me.dirty = me.editing = false;
  me.editMemento = me.modified = null;
}, drop:function(cascade) {
  var me = this, associations = me.associations, session = me.session, roleName;
  if (me.erased || me.dropped) {
    return;
  }
  me.dropped = true;
  if (associations && cascade !== false) {
    for (roleName in associations) {
      associations[roleName].onDrop(me, session);
    }
  }
  me.callJoined('afterDrop');
  if (me.phantom) {
    me.setErased();
  }
}, join:function(owner) {
  var me = this, joined = me.joined;
  if (!joined) {
    joined = me.joined = [owner];
  } else {
    if (!joined.length) {
      joined[0] = owner;
    } else {
      Ext.Array.include(joined, owner);
    }
  }
  if (owner.isStore && !me.store) {
    me.store = owner;
  }
}, unjoin:function(owner) {
  var me = this, joined = me.joined, len = joined && joined.length, store = me.store, i;
  if (owner === me.session) {
    me.session = null;
  } else {
    if (len === 1 && joined[0] === owner) {
      joined.length = 0;
    } else {
      if (len) {
        Ext.Array.remove(joined, owner);
      }
    }
    if (store === owner) {
      store = null;
      if (joined) {
        for (i = 0, len = joined.length; i < len; ++i) {
          owner = joined[i];
          if (owner.isStore) {
            store = owner;
            break;
          }
        }
      }
      me.store = store;
    }
  }
}, clone:function(session) {
  var me = this, modified = me.modified, ret = me.copy(me.id, session);
  if (modified) {
    ret.modified = Ext.apply({}, modified);
  }
  ret.dirty = me.dirty;
  ret.dropped = me.dropped;
  ret.phantom = me.phantom;
  return ret;
}, copy:function(newId, session) {
  var me = this, data = Ext.apply({}, me.data), idProperty = me.idProperty, T = me.self;
  if (newId || newId === 0) {
    data[idProperty] = newId;
  } else {
    if (newId === null) {
      delete data[idProperty];
    }
  }
  return new T(data, session);
}, getProxy:function() {
  return this.self.getProxy();
}, getValidation:function(refresh) {
  var me = this, ret = me.validation;
  if (!ret) {
    me.validation = ret = new Ext.data.Validation;
    ret.attach(me);
  }
  if (refresh === true || refresh !== false && ret.syncGeneration !== me.generation) {
    ret.refresh(refresh);
  }
  return ret;
}, validate:function() {
  return (new Ext.data.ErrorCollection).init(this);
}, isValid:function() {
  return this.getValidation().isValid();
}, toUrl:function() {
  var pieces = this.$className.split('.'), name = pieces[pieces.length - 1].toLowerCase();
  return name + '/' + this.getId();
}, erase:function(options) {
  var me = this;
  me.erasing = true;
  me.drop();
  me.erasing = false;
  return me.save(options);
}, setErased:function() {
  this.erased = true;
  this.callJoined('afterErase');
}, getChanges:function() {
  return this.getData(this._getChangesOptions);
}, getCriticalFields:function() {
  var cls = this.self, ret = cls.criticalFields;
  if (!ret) {
    cls.rankFields();
    ret = cls.criticalFields;
  }
  return ret;
}, getAssociatedData:function(result, options) {
  var me = this, associations = me.associations, deep, i, item, items, itemData, length, record, role, roleName, opts, clear, associated;
  result = result || {};
  me.$gathering = 1;
  if (options) {
    options = Ext.apply({}, options);
  }
  for (roleName in associations) {
    role = associations[roleName];
    item = role.getAssociatedItem(me);
    if (!item || item.$gathering) {
      continue;
    }
    if (item.isStore) {
      item.$gathering = 1;
      items = item.getData().items;
      length = items.length;
      itemData = [];
      for (i = 0; i < length; ++i) {
        record = items[i];
        deep = !record.$gathering;
        record.$gathering = 1;
        if (options) {
          associated = options.associated;
          if (associated === undefined) {
            options.associated = deep;
            clear = true;
          } else {
            if (!deep) {
              options.associated = false;
              clear = true;
            }
          }
          opts = options;
        } else {
          opts = deep ? me._getAssociatedOptions : me._getNotAssociatedOptions;
        }
        itemData.push(record.getData(opts));
        if (clear) {
          options.associated = associated;
          clear = false;
        }
        delete record.$gathering;
      }
      delete item.$gathering;
    } else {
      opts = options || me._getAssociatedOptions;
      if (options && options.associated === undefined) {
        opts.associated = true;
      }
      itemData = item.getData(opts);
    }
    result[roleName] = itemData;
  }
  delete me.$gathering;
  return result;
}, getData:function(options) {
  var me = this, ret = {}, opts = options === true ? me._getAssociatedOptions : options || ret, data = me.data, associated = opts.associated, changes = opts.changes, critical = changes && opts.critical, content = changes ? me.modified : data, fieldsMap = me.fieldsMap, persist = opts.persist, serialize = opts.serialize, criticalFields, field, n, name, value;
  if (content) {
    for (name in content) {
      value = data[name];
      field = fieldsMap[name];
      if (field) {
        if (persist && !field.persist) {
          continue;
        }
        if (serialize && field.serialize) {
          value = field.serialize(value, me);
        }
      }
      ret[name] = value;
    }
  }
  if (critical) {
    criticalFields = me.self.criticalFields || me.getCriticalFields();
    for (n = criticalFields.length; n-- > 0;) {
      name = (field = criticalFields[n]).name;
      if (!(name in ret)) {
        value = data[name];
        if (serialize && field.serialize) {
          value = field.serialize(value, me);
        }
        ret[name] = value;
      }
    }
  }
  if (associated) {
    if (typeof associated === 'object') {
      me.getNestedData(opts, ret);
    } else {
      me.getAssociatedData(ret, opts);
    }
  }
  return ret;
}, getNestedData:function(options, result) {
  var me = this, associations = me.associations, graph = options.associated, i, item, items, itemData, length, record, role, roleName, opts;
  result = result || {};
  for (roleName in graph) {
    role = associations[roleName];
    opts = graph[roleName];
    if (opts === true) {
      delete options.associated;
    } else {
      options.associated = opts;
    }
    item = role.getAssociatedItem(me);
    if (item.isStore) {
      items = item.getData().items;
      length = items.length;
      itemData = [];
      for (i = 0; i < length; ++i) {
        record = items[i];
        itemData.push(record.getData(options));
      }
    } else {
      itemData = item.getData(options);
    }
    result[roleName] = itemData;
  }
  options.associated = graph;
  return result;
}, getTransientFields:function() {
  var cls = this.self, ret = cls.transientFields;
  if (!ret) {
    cls.rankFields();
    ret = cls.transientFields;
  }
  return ret;
}, isLoading:function() {
  return !!this.loadOperation;
}, abort:function() {
  var operation = this.loadOperation;
  if (operation) {
    operation.abort();
  }
}, load:function(options) {
  options = Ext.apply({}, options);
  var me = this, scope = options.scope || me, proxy = me.getProxy(), callback = options.callback, operation = me.loadOperation, id = me.getId(), extras;
  if (operation) {
    extras = operation.extraCalls;
    if (!extras) {
      extras = operation.extraCalls = [];
    }
    extras.push(options);
    return operation;
  }
  var doIdCheck = true;
  if (me.phantom) {
    doIdCheck = false;
  }
  options.id = id;
  options.recordCreator = function(data, type, readOptions) {
    var session = me.session;
    if (readOptions) {
      readOptions.recordCreator = session ? session.recordCreator : null;
    }
    me.set(data, me._commitOptions);
    if (doIdCheck && me.getId() !== id) {
      Ext.raise('Invalid record id returned for ' + id + '@' + me.entityName);
    }
    return me;
  };
  options.internalCallback = function(operation) {
    var success = operation.wasSuccessful() && operation.getRecords().length > 0, op = me.loadOperation, extras = op.extraCalls, successFailArgs = [me, operation], callbackArgs = [me, operation, success], i, len;
    me.loadOperation = null;
    ++me.loadCount;
    if (success) {
      Ext.callback(options.success, scope, successFailArgs);
    } else {
      Ext.callback(options.failure, scope, successFailArgs);
    }
    Ext.callback(callback, scope, callbackArgs);
    if (extras) {
      for (i = 0, len = extras.length; i < len; ++i) {
        options = extras[i];
        if (success) {
          Ext.callback(options.success, scope, successFailArgs);
        } else {
          Ext.callback(options.failure, scope, successFailArgs);
        }
        Ext.callback(options.callback, scope, callbackArgs);
      }
    }
    me.callJoined('afterLoad');
  };
  delete options.callback;
  me.loadOperation = operation = proxy.createOperation('read', options);
  operation.execute();
  return operation;
}, mergeData:function(data) {
  if (!this.dirty) {
    this.set(data, this._commitOptions);
  }
}, save:function(options) {
  options = Ext.apply({}, options);
  var me = this, phantom = me.phantom, dropped = me.dropped, action = dropped ? 'destroy' : phantom ? 'create' : 'update', scope = options.scope || me, callback = options.callback, proxy = me.getProxy(), operation;
  options.records = [me];
  options.internalCallback = function(operation) {
    var args = [me, operation], success = operation.wasSuccessful();
    if (success) {
      Ext.callback(options.success, scope, args);
    } else {
      Ext.callback(options.failure, scope, args);
    }
    args.push(success);
    Ext.callback(callback, scope, args);
  };
  delete options.callback;
  operation = proxy.createOperation(action, options);
  if (dropped && phantom) {
    operation.setResultSet(Ext.data.reader.Reader.prototype.nullResultSet);
    me.setErased();
    operation.setSuccessful(true);
  } else {
    operation.execute();
  }
  return operation;
}, statics:{defaultProxy:'memory'}, inheritableStatics:{_associatedReadOptions:{recordsOnly:true, asRoot:true}, loadData:function(data, session) {
  var rec;
  if (data) {
    rec = this.getProxy().getReader().readRecords([data], session ? {recordCreator:session.recordCreator} : undefined, this._associatedReadOptions)[0];
  } else {
    rec = new this(data, session);
  }
  return rec;
}, getSummaryModel:function() {
  var me = this, proto = me.prototype, summaryModel = me.summaryModel;
  if (!summaryModel) {
    summaryModel = Ext.define(null, {extend:me, fields:proto.summaryFields || [], isSummaryModel:true});
    summaryModel.isSummaryModel = true;
    me.summaryModel = proto.summaryModel = summaryModel;
  }
  return summaryModel || null;
}, addFields:function(newFields) {
  this.replaceFields(newFields);
}, replaceFields:function(newFields, removeFields) {
  var me = this, proto = me.prototype, Field = Ext.data.field.Field, fields = me.fields, fieldsMap = me.fieldsMap, ordinals = me.fieldOrdinals, field, i, idField, len, name, ordinal, cleared;
  if (removeFields === true) {
    fields.length = 0;
    me.fieldsMap = fieldsMap = {};
    me.fieldOrdinals = ordinals = {};
    cleared = true;
  } else {
    if (removeFields) {
      for (i = removeFields.length; i-- > 0;) {
        name = removeFields[i];
        if (name in ordinals) {
          delete ordinals[name];
          delete fieldsMap[name];
        }
      }
      for (i = 0, len = fields.length; i < len; ++i) {
        name = (field = fields[i]).name;
        if (name in ordinals) {
          ordinals[name] = i;
        } else {
          fields.splice(i, 1);
          --i;
          --len;
        }
      }
    }
  }
  for (i = 0, len = newFields ? newFields.length : 0; i < len; i++) {
    name = (field = newFields[i]).name;
    if (!(name in ordinals)) {
      ordinals[name] = ordinal = fields.length;
      fields.push(field = Field.create(field));
      fieldsMap[name] = field;
      field.ordinal = ordinal;
      field.definedBy = field.owner = this;
    }
  }
  if (!cleared) {
    for (i = 0, len = fields.length; i < len; ++i) {
      fields[i].rank = null;
    }
  }
  me.idField = proto.idField = idField = fieldsMap[proto.idProperty];
  if (idField) {
    idField.allowNull = idField.critical = idField.identifier = true;
    idField.defaultValue = null;
  }
  me.initializeFn = me.rankedFields = me.transientFields = me.criticalFields = null;
}, removeFields:function(removeFields) {
  this.replaceFields(null, removeFields);
}, getIdFromData:function(data) {
  var T = this, idField = T.idField, id = idField.calculated ? (new T(data)).id : data[idField.name];
  return id;
}, createWithId:function(id, data, session) {
  var d = data, T = this;
  if (id || id === 0) {
    d = {};
    if (data) {
      Ext.apply(d, data);
    }
    d[T.idField.name] = id;
  }
  return new T(d, session);
}, getFields:function() {
  return this.fields;
}, getFieldsMap:function() {
  return this.fieldsMap;
}, getField:function(name) {
  return this.fieldsMap[name] || null;
}, getProxy:function() {
  var me = this, proxy = me.proxy, defaultProxy = me.defaultProxy, defaults;
  if (!proxy) {
    proxy = me.proxyConfig;
    if (!proxy && defaultProxy) {
      proxy = defaultProxy;
    }
    if (!proxy || !proxy.isProxy) {
      if (typeof proxy === 'string') {
        proxy = {type:proxy};
      }
      defaults = Ext.merge(me.schema.constructProxy(me), proxy);
      if (proxy && proxy.type) {
        proxy = proxy.schema === false ? proxy : defaults;
      } else {
        proxy = defaults;
      }
    }
    proxy = me.setProxy(proxy);
  }
  return proxy;
}, setProxy:function(proxy) {
  var me = this, model;
  if (proxy) {
    if (!proxy.isProxy) {
      proxy = Ext.Factory.proxy(proxy);
    } else {
      model = proxy.getModel();
      if (model && model !== me) {
        proxy = proxy.clone();
      }
    }
    proxy.setModel(me);
  }
  return me.prototype.proxy = me.proxy = proxy;
}, load:function(id, options, session) {
  var data = {}, rec;
  if (session) {
    rec = session.peekRecord(this, id);
  }
  if (!rec) {
    data[this.prototype.idProperty] = id;
    rec = new this(data, session);
  }
  rec.load(options);
  return rec;
}}, deprecated:{5:{methods:{hasId:null, markDirty:null, setDirty:null, eachStore:function(callback, scope) {
  var me = this, stores = me.stores, len = stores.length, i;
  for (i = 0; i < len; ++i) {
    callback.call(scope, stores[i]);
  }
}, join:function(item) {
  var me = this, stores = me.stores, joined = me.joined;
  if (!joined) {
    joined = me.joined = [item];
  } else {
    joined.push(item);
  }
  if (item.isStore) {
    me.store = me.store || item;
    if (!stores) {
      stores = me.stores = [];
    }
    stores.push(item);
  }
}, unjoin:function(item) {
  var me = this, stores = me.stores, joined = me.joined;
  if (joined.length === 1) {
    joined.length = 0;
  } else {
    Ext.Array.remove(joined, item);
  }
  if (item.isStore) {
    Ext.Array.remove(stores, item);
    me.store = stores[0] || null;
  }
}}, properties:{persistenceProperty:null}, inheritableStatics:{methods:{setFields:null}}}}, privates:{_commitOptions:{commit:true}, _getChangesOptions:{changes:true}, _getAssociatedOptions:{associated:true}, _getNotAssociatedOptions:{associated:false}, _metaProperties:{dirty:'isDirty', phantom:'isPhantom', valid:'isValid'}, copyFrom:function(sourceRecord) {
  var me = this, fields = me.fields, fieldCount = fields.length, modifiedFieldNames = [], field, i = 0, myData, sourceData, idProperty = me.idProperty, name, value;
  if (sourceRecord) {
    myData = me.data;
    sourceData = sourceRecord.data;
    for (; i < fieldCount; i++) {
      field = fields[i];
      name = field.name;
      if (name !== idProperty) {
        value = sourceData[name];
        if (value !== undefined && !me.isEqual(myData[name], value)) {
          myData[name] = value;
          modifiedFieldNames.push(name);
        }
      }
    }
    if (me.phantom && !sourceRecord.phantom) {
      me.beginEdit();
      me.setId(sourceRecord.getId());
      me.endEdit(true);
      me.commit(true);
    }
  }
  return modifiedFieldNames;
}, callJoined:function(funcName, args) {
  var me = this, joined = me.joined, session = me.session, state = me.dropped ? 'D' : me.phantom ? 'C' : me.dirty ? 'U' : 'R', i, len, fn, item;
  me.crudState = state;
  if (joined || session) {
    if (args) {
      args.unshift(me);
    } else {
      args = [me];
    }
    fn = session && session[funcName];
    if (fn) {
      fn.apply(session, args);
    }
    if (joined) {
      for (i = 0, len = joined.length; i < len; ++i) {
        item = joined[i];
        if (item && (fn = item[funcName])) {
          fn.apply(item, args);
        }
      }
    }
  }
  me.crudStateWas = state;
}, hasPendingLoad:function() {
  return this.isLoading();
}, interpret:function(name) {
  var me = this, accessor = me._metaProperties[name];
  if (!accessor) {
    accessor = me.associations;
    accessor = accessor && accessor[name] && accessor[name].getterName;
  }
  if (accessor) {
    return me[accessor]();
  }
  return me.data[name];
}, isDirty:function() {
  return this.dirty;
}, isPhantom:function() {
  return this.phantom;
}, onAssociatedRecordSet:function(record, role) {
  this.callJoined('afterAssociatedRecordSet', [record, role]);
}, onIdChanged:Ext.privateFn, setSession:function(session) {
  if (session) {
    if (this.session) {
      Ext.raise('This model already belongs to a session.');
    }
    if (!this.id) {
      Ext.raise('The model must have an id to participate in a session.');
    }
  }
  this.session = session;
  if (session) {
    session.add(this);
  }
}, getModifiedFieldNames:function(old) {
  var me = this, data = me.data, modified = [], oldData = old || me.editMemento.data, key;
  for (key in data) {
    if (data.hasOwnProperty(key)) {
      if (!me.isEqual(data[key], oldData[key], key)) {
        modified.push(key);
      }
    }
  }
  return modified;
}, isEqual:function(lhs, rhs, field) {
  var f;
  if (field) {
    f = field.isField ? field : this.fieldsMap[field];
    if (f) {
      return f.isEqual(lhs, rhs);
    }
  }
  if (lhs instanceof Date && rhs instanceof Date) {
    return lhs.getTime() === rhs.getTime();
  }
  return lhs === rhs;
}, statics:{EDIT:'edit', REJECT:'reject', COMMIT:'commit', rankFields:function() {
  var cls = this, prototype = cls.prototype, fields = cls.fields, length = fields.length, rankedFields = [], criticalFields = [], transientFields = [], evilFields, field, i;
  cls.rankedFields = prototype.rankedFields = rankedFields;
  cls.criticalFields = prototype.criticalFields = criticalFields;
  cls.transientFields = prototype.transientFields = transientFields;
  for (i = 0; i < length; ++i) {
    field = fields[i];
    if (field.critical) {
      criticalFields.push(field);
    }
    if (!field.persist) {
      transientFields.push(field);
    }
    if (field.evil) {
      (evilFields || (evilFields = [])).push(field);
    } else {
      if (!field.depends) {
        rankedFields.push(field);
        field.rank = rankedFields.length;
      }
    }
  }
  for (i = 0; i < length; ++i) {
    if (!(field = fields[i]).rank && !field.evil) {
      cls.topoAdd(field);
    }
  }
  if (evilFields) {
    for (i = 0, length = evilFields.length; i < length; ++i) {
      rankedFields.push(field = evilFields[i]);
      field.rank = rankedFields.length;
    }
  }
  cls.topoStack = null;
  return rankedFields;
}, topoAdd:function(field) {
  var cls = this, dep = field.depends, dependsLength = dep ? dep.length : 0, rankedFields = cls.rankedFields, i, targetField;
  var topoStack = cls.topoStack || (cls.topoStack = []);
  topoStack.push(field.name);
  if (field.rank === 0) {
    Ext.raise(cls.$className + ' has circular field dependencies: ' + topoStack.join(' --\x3e '));
  }
  if (topoStack.length && field.evil) {
    Ext.raise(cls.$className + ': Field ' + topoStack[topoStack.length - 1] + ' cannot depend on depends-less field ' + field.name);
  }
  field.rank = 0;
  for (i = 0; i < dependsLength; ++i) {
    targetField = cls.fieldsMap[dep[i]];
    if (!targetField) {
      Ext.raise(cls.$className + ': Field ' + field.name + ' depends on undefined field ' + dep[i]);
    }
    (targetField.dependents || (targetField.dependents = [])).push(field);
    if (!targetField.rank) {
      cls.topoAdd(targetField);
    }
  }
  rankedFields.push(field);
  field.rank = rankedFields.length;
  topoStack.pop();
}, initFields:function(data, cls, proto) {
  var Field = Ext.data.field.Field, fieldDefs = data.fields, fields = [], fieldOrdinals = {}, fieldsMap = {}, references = [], superFields = proto.fields, versionProperty = data.versionProperty || proto.versionProperty, idProperty = cls.idProperty, idField, field, i, length, name, ordinal, reference, superIdField, superIdFieldName, superIdDeclared, idDeclared;
  cls.fields = proto.fields = fields;
  cls.fieldOrdinals = proto.fieldOrdinals = fieldOrdinals;
  cls.fieldsMap = proto.fieldsMap = fieldsMap;
  cls.references = proto.references = references;
  if (superFields) {
    for (i = 0, length = superFields.length; i < length; ++i) {
      fields[i] = field = Ext.Object.chain(superFields[i]);
      field.dependents = null;
      field.owner = cls;
      fieldOrdinals[name = field.name] = i;
      fieldsMap[name] = field;
      field.rank = null;
      if (field.generated) {
        superIdField = field;
        superIdFieldName = field.name;
      }
    }
  }
  delete data.fields;
  if (fieldDefs) {
    for (i = 0, length = fieldDefs.length; i < length; ++i) {
      field = fieldDefs[i];
      reference = field.reference;
      if (reference && typeof reference !== 'string') {
        reference = Ext.merge({}, reference);
      }
      field.$reference = reference;
      field = Field.create(fieldDefs[i]);
      name = field.name;
      ordinal = fieldOrdinals[name];
      if (ordinal === undefined) {
        fieldOrdinals[name] = ordinal = fields.length;
      }
      fieldsMap[name] = field;
      fields[ordinal] = field;
      field.definedBy = field.owner = cls;
      field.ordinal = ordinal;
      if (name === idProperty) {
        idDeclared = field;
      }
      if (name === superIdFieldName) {
        superIdDeclared = true;
      }
    }
  }
  idField = fieldsMap[idProperty];
  if (!idField) {
    if (superIdField && superIdField.generated) {
      ordinal = superIdField.ordinal;
    } else {
      ordinal = fields.length;
    }
    delete fieldsMap[superIdFieldName];
    delete fieldOrdinals[superIdFieldName];
    idField = new Field(idProperty);
    fields[ordinal] = idField;
    fieldOrdinals[idProperty] = ordinal;
    fieldsMap[idProperty] = idField;
    idField.definedBy = cls;
    idField.ordinal = ordinal;
    idField.generated = true;
  } else {
    if (idDeclared && !superIdDeclared && superIdField && superIdField.generated) {
      Ext.Array.remove(fields, superIdField);
      delete fieldsMap[superIdFieldName];
      delete fieldOrdinals[superIdFieldName];
      fieldsMap[idProperty] = idDeclared;
      for (i = 0, length = fields.length; i < length; ++i) {
        field = fields[i];
        fields.ordinal = i;
        fieldOrdinals[field.name] = i;
      }
    }
  }
  idField.allowNull = idField.critical = idField.identifier = true;
  idField.defaultValue = null;
  cls.idField = proto.idField = idField;
  if (versionProperty) {
    field = fieldsMap[versionProperty];
    if (!field) {
      ordinal = fields.length;
      field = new Field({name:versionProperty, type:'int'});
      fields[ordinal] = field;
      fieldOrdinals[versionProperty] = ordinal;
      fieldsMap[versionProperty] = field;
      field.definedBy = cls;
      field.ordinal = ordinal;
      field.generated = true;
    }
    field.defaultValue = 1;
    field.critical = true;
  }
}, initSummaries:function(data, cls, proto) {
  var summaryDefs = data.summary, superSummaries = proto.summaryFields, summaries, summaryMap, name, summary, len, i, index, field;
  if (superSummaries) {
    summaries = [];
    summaryMap = {};
    for (i = 0, len = superSummaries.length; i < len; ++i) {
      summary = superSummaries[i];
      summaries.push(summary);
      summaries[summary.name] = i;
    }
  }
  if (summaryDefs) {
    delete data.summary;
    summaries = summaries || [];
    summaryMap = summaryMap || {};
    for (name in summaryDefs) {
      summary = summaryDefs[name];
      if (typeof summary === 'function') {
        summary = {summary:summary};
      }
      index = summaryMap[name];
      summary = Ext.apply({name:name}, summary);
      field = summary.field;
      if (field) {
        delete summary.field;
        summary.summaryField = field;
      }
      if (index === undefined) {
        index = summaries.length;
        summaryMap[name] = summary;
      }
      summaries[index] = summary;
    }
  }
  if (summaries) {
    for (i = 0, len = summaries.length; i < len; ++i) {
      if (summaries[i].name in proto.fieldsMap) {
        Ext.raise('Cannot redefine field, use the summary property on the field.');
      }
    }
    proto.summaryFields = summaries;
  }
}, initValidators:function(data, cls, proto) {
  var superValidators = proto.validators, validators, field, copy, validatorDefs, i, length, fieldValidator, name, validator, item;
  if (superValidators) {
    validators = {};
    for (field in superValidators) {
      validators[field] = Ext.Array.clone(superValidators[field]);
    }
  }
  validatorDefs = data.validators || data.validations;
  if (data.validations) {
    delete data.validations;
    Ext.log.warn((cls.$className || 'Ext.data.Model') + ': validations has been deprecated. Please use validators instead.');
  }
  if (validatorDefs) {
    delete data.validators;
    validators = validators || {};
    if (Ext.isArray(validatorDefs)) {
      copy = {};
      for (i = 0, length = validatorDefs.length; i < length; ++i) {
        item = validatorDefs[i];
        name = item.field;
        if (!copy[name]) {
          copy[name] = [];
        }
        item = item.fn || item;
        copy[name].push(item);
      }
      validatorDefs = copy;
    }
    for (name in validatorDefs) {
      fieldValidator = validatorDefs[name];
      if (!Ext.isArray(fieldValidator)) {
        fieldValidator = [fieldValidator];
      }
      validator = validators[name];
      if (validator) {
        Ext.Array.push(validator, fieldValidator);
      } else {
        validators[name] = fieldValidator;
      }
    }
  }
  if (validators) {
    for (name in validators) {
      field = cls.getField(name);
      if (field) {
        field.setModelValidators(validators[name]);
      }
    }
  }
  cls.validators = proto.validators = validators;
}, initAssociations:function(schema, data, cls) {
  var associations = data.associations, belongsTo = data.belongsTo, hasMany = data.hasMany, hasOne = data.hasOne, matrices = data.manyToMany, i, length, assoc, o;
  delete data.associations;
  delete data.belongsTo;
  delete data.hasMany;
  delete data.hasOne;
  delete data.manyToMany;
  if (matrices) {
    schema.addMatrices(cls, matrices);
  }
  if (associations) {
    associations = Ext.isArray(associations) ? associations : [associations];
    for (i = 0, length = associations.length; i < length; ++i) {
      assoc = associations[i];
      o = Ext.apply({}, assoc);
      delete o.type;
      switch(assoc.type) {
        case 'belongsTo':
          schema.addBelongsTo(cls, o);
          break;
        case 'hasMany':
          schema.addHasMany(cls, o);
          break;
        case 'hasOne':
          schema.addHasOne(cls, o);
          break;
        default:
          Ext.raise('Invalid association type: "' + assoc.type + '"');
      }
    }
  }
  if (belongsTo) {
    belongsTo = Ext.isArray(belongsTo) ? belongsTo : [belongsTo];
    for (i = 0, length = belongsTo.length; i < length; ++i) {
      schema.addBelongsTo(cls, belongsTo[i]);
    }
  }
  if (hasMany) {
    hasMany = Ext.isArray(hasMany) ? hasMany : [hasMany];
    for (i = 0, length = hasMany.length; i < length; ++i) {
      schema.addHasMany(cls, hasMany[i]);
    }
  }
  if (hasOne) {
    hasOne = Ext.isArray(hasOne) ? hasOne : [hasOne];
    for (i = 0, length = hasOne.length; i < length; ++i) {
      schema.addHasOne(cls, hasOne[i]);
    }
  }
  schema.afterKeylessAssociations(cls);
}, initIdentifier:function(data, cls, proto) {
  var identifier = data.identifier || data.idgen, superIdent = proto.identifier || cls.schema._defaultIdentifier, generatorPrefix;
  if (data.idgen) {
    Ext.log.warn('Ext.data.Model: idgen has been deprecated. Please use identifier instead.');
  }
  if (identifier) {
    delete data.identifier;
    delete data.idgen;
    identifier = Ext.Factory.dataIdentifier(identifier);
  } else {
    if (superIdent) {
      if (superIdent.clone && !superIdent.getId()) {
        identifier = superIdent.clone();
      } else {
        if (superIdent.isGenerator) {
          identifier = superIdent;
        } else {
          identifier = Ext.Factory.dataIdentifier(superIdent);
        }
      }
    }
  }
  cls.identifier = proto.identifier = identifier;
  if (!identifier) {
    generatorPrefix = cls.entityName;
    if (!generatorPrefix) {
      generatorPrefix = Ext.id(null, 'extModel');
    }
    cls.identifier = Ext.Factory.dataIdentifier({type:'sequential', prefix:generatorPrefix + '-'});
  }
}, findValidator:function(validators, name, cfg) {
  var type = cfg.type || cfg, field = validators[name], len, i, item;
  if (field) {
    for (i = 0, len = field.length; i < len; ++i) {
      item = field[i];
      if (item.type === type) {
        return item;
      }
    }
  }
  return null;
}, makeInitializeFn:function(cls) {
  var code = ['var '], body = ['\nreturn function (e) {\n    var data \x3d e.data, v;\n'], work = 0, bc, ec, convert, expr, factory, field, fields, fs, hasDefValue, i, length;
  if (!(fields = cls.rankedFields)) {
    fields = cls.rankFields();
  }
  for (i = 0, length = fields.length; i < length; ++i) {
    field = fields[i];
    fs = 'f' + i;
    convert = field.convert;
    if (i) {
      code.push(',  \n    ');
    }
    code.push(fs, ' \x3d $fields[' + i + ']');
    code.push('  /*  ', field.name, '  */');
    if ((hasDefValue = field.defaultValue !== undefined) || convert) {
      expr = 'data["' + field.name + '"]';
      ++work;
      bc = ec = '';
      if (field.cloneDefaultValue) {
        bc = 'Ext.clone(';
        ec = ')';
      }
      body.push('\n');
      if (convert && hasDefValue) {
        body.push('    v \x3d ', expr, ';\n' + '    if (v !\x3d\x3d undefined) {\n' + '        v \x3d ', fs, '.convert(v, e);\n' + '    }\n' + '    if (v \x3d\x3d\x3d undefined) {\n' + '        v \x3d ', bc, fs, '.defaultValue', ec, ';\n' + '    }\n' + '    ', expr, ' \x3d v;');
      } else {
        if (convert) {
          body.push('    v \x3d ', fs, '.convert(', expr, ',e);\n' + '    if (v !\x3d\x3d undefined) {\n' + '        ', expr, ' \x3d v;\n' + '    }\n');
        } else {
          if (hasDefValue) {
            body.push('    if (', expr, ' \x3d\x3d\x3d undefined) {\n' + '        ', expr, ' \x3d ', bc, fs, '.defaultValue', ec, ';\n' + '    }\n');
          }
        }
      }
    }
  }
  if (!work) {
    return Ext.emptyFn;
  }
  code.push(';\n');
  code.push.apply(code, body);
  code.push('}');
  code = code.join('');
  factory = new Function('$fields', 'Ext', code);
  return factory(fields, Ext);
}}}}, function() {
  var Model = this, proto = Model.prototype, Schema = Ext.data.schema.Schema, defaultSchema;
  Model.proxyConfig = proto.proxy;
  delete proto.proxy;
  Model.fields = [];
  Model.fieldsMap = proto.fieldsMap = {};
  Model.schema = proto.schema = Schema.get(proto.schema);
  proto.idField = new Ext.data.field.Field(proto.idProperty);
  Model.identifier = new Ext.data.identifier.Sequential;
  Model.onExtended(function(cls, data) {
    var proto = cls.prototype, schemaName = data.schema, superCls = proto.superclass.self, schema, entityName, proxy;
    cls.idProperty = data.idProperty || proto.idProperty;
    if (schemaName) {
      delete data.schema;
      schema = Schema.get(schemaName);
    } else {
      if (!(schema = proto.schema)) {
        schema = defaultSchema || (defaultSchema = Schema.get('default'));
      }
    }
    cls.rankFields = Model.rankFields;
    cls.topoAdd = Model.topoAdd;
    proto.schema = cls.schema = schema;
    if (!(entityName = data.entityName)) {
      proto.entityName = entityName = schema.getEntityName(cls);
      if (!entityName) {
        if (data.associations) {
          Ext.raise('Anonymous entities cannot specify "associations"');
        }
        if (data.belongsTo) {
          Ext.raise('Anonymous entities cannot specify "belongsTo"');
        }
        if (data.hasMany) {
          Ext.raise('Anonymous entities cannot specify "hasMany"');
        }
        if (data.hasOne) {
          Ext.raise('Anonymous entities cannot specify "hasOne"');
        }
        if (data.matrices) {
          Ext.raise('Anonymous entities cannot specify "manyToMany"');
        }
      }
    }
    cls.entityName = entityName;
    cls.fieldExtractors = {};
    Model.initIdentifier(data, cls, proto);
    Model.initFields(data, cls, proto);
    Model.initValidators(data, cls, proto);
    if (!data.isSummaryModel) {
      Model.initSummaries(data, cls, proto);
    }
    cls.fields.items = cls.fields;
    if (entityName) {
      schema.addEntity(cls);
      Model.initAssociations(schema, data, cls);
    }
    proxy = data.proxy;
    if (proxy) {
      delete data.proxy;
    } else {
      if (superCls !== Model) {
        proxy = superCls.proxyConfig || superCls.proxy;
      }
    }
    cls.proxyConfig = proxy;
  });
});
Ext.define('Ext.data.ResultSet', {isResultSet:true, $configPrefixed:false, config:{loaded:true, count:null, total:null, remoteTotal:null, success:false, records:null, message:null, metadata:null, groupData:null, summaryData:null}, constructor:function(config) {
  this.initConfig(config);
}, getCount:function() {
  var count = this.callParent(), records;
  if (!count) {
    records = this.getRecords();
    if (records) {
      count = records.length;
    }
  }
  return count;
}});
Ext.define('Ext.data.reader.Reader', {alternateClassName:['Ext.data.Reader', 'Ext.data.DataReader'], mixins:[Ext.mixin.Observable, Ext.mixin.Factoryable], alias:'reader.base', factoryConfig:{defaultType:null}, config:{groupRootProperty:'', implicitIncludes:true, keepRawData:null, messageProperty:'', model:null, proxy:null, readRecordsOnFailure:true, rootProperty:'', successProperty:'success', summaryRootProperty:'', totalProperty:'total', transform:null, typeProperty:''}, isReader:true, constructor:function(config) {
  if (config && config.hasOwnProperty('root')) {
    config = Ext.apply({}, config);
    config.rootProperty = config.root;
    delete config.root;
    Ext.log.error('Ext.data.reader.Reader: Using the deprecated "root" configuration. Use "rootProperty" instead.');
  }
  var me = this;
  me.duringInit = 1;
  me.mixins.observable.constructor.call(me, config);
  --me.duringInit;
  me.buildExtractors();
}, forceBuildExtractors:function() {
  if (!this.duringInit) {
    this.buildExtractors(true);
  }
}, updateGroupRootProperty:function() {
  this.forceBuildExtractors();
}, updateMessageProperty:function() {
  this.forceBuildExtractors();
}, applyModel:function(model) {
  return Ext.data.schema.Schema.lookupEntity(model);
}, updateSuccessProperty:function() {
  this.forceBuildExtractors();
}, updateTotalProperty:function() {
  this.forceBuildExtractors();
}, applyTransform:function(transform) {
  if (transform) {
    if (Ext.isFunction(transform)) {
      transform = {fn:transform};
    } else {
      if (transform.charAt) {
        transform = {fn:this[transform]};
      }
    }
    return transform.fn.bind(transform.scope || this);
  }
  return transform;
}, read:function(response, readOptions) {
  var data, result, responseText;
  if (response) {
    responseText = response.responseText;
    if (response.responseType || responseText) {
      result = this.getResponseData(response);
      if (result && result.__$isError) {
        return new Ext.data.ResultSet({total:0, count:0, records:[], success:false, message:result.msg});
      } else {
        data = this.readRecords(result, readOptions);
      }
    } else {
      if (responseText !== '') {
        data = this.readRecords(response, readOptions);
      }
    }
  }
  return data || this.nullResultSet;
}, getNullResultSet:function() {
  return this.nullResultSet;
}, createReadError:function(msg) {
  return {__$isError:true, msg:msg};
}, readRecords:function(data, readOptions, internalReadOptions) {
  var me = this, recordsOnly = internalReadOptions && internalReadOptions.recordsOnly, asRoot = internalReadOptions && internalReadOptions.asRoot, groupData = null, summaryData = null, success, recordCount, records, root, remoteTotal, total, value, message, transform, meta, summaryOptions;
  meta = me.getMeta ? me.getMeta(data) : data.metaData;
  if (meta) {
    me.onMetaChange(meta);
  }
  transform = me.getTransform();
  if (transform) {
    data = transform(data);
  }
  me.buildExtractors();
  if (me.getKeepRawData()) {
    me.rawData = data;
  }
  if (me.hasListeners.rawdata) {
    me.fireEventArgs('rawdata', [data]);
  }
  data = me.getData(data);
  success = true;
  recordCount = 0;
  records = [];
  if (me.getSuccessProperty()) {
    value = me.getSuccess(data);
    if (value === false || value === 'false') {
      success = false;
    }
  }
  if (me.getMessageProperty()) {
    message = me.getMessage(data);
  }
  if (success || me.getReadRecordsOnFailure()) {
    root = asRoot || Ext.isArray(data) ? data : me.getRoot(data);
    if (root) {
      total = root.length;
    }
    if (me.getTotalProperty()) {
      value = parseInt(me.getTotal(data), 10);
      if (!isNaN(value)) {
        remoteTotal = total = value;
      }
    }
    if (root) {
      records = me.extractData(root, readOptions);
      recordCount = records.length;
    }
    if (me.getGroupRootProperty()) {
      root = me.getGroupRoot(data);
      if (root) {
        summaryOptions = {includes:false, model:me.getModel().getSummaryModel()};
        groupData = me.extractData(root, summaryOptions) || null;
      }
    }
    if (me.getSummaryRootProperty()) {
      root = me.getSummaryRoot(data);
      if (root) {
        summaryOptions = summaryOptions || {includes:false, model:me.getModel().getSummaryModel()};
        summaryData = me.extractData(root, summaryOptions) || null;
        if (summaryData) {
          summaryData = summaryData[0];
        }
      }
    }
  }
  return recordsOnly ? records : new Ext.data.ResultSet({total:total || recordCount, remoteTotal:remoteTotal, metadata:meta, count:recordCount, records:records, success:success, message:message, groupData:groupData, summaryData:summaryData});
}, extractData:function(root, readOptions) {
  var me = this, entityType = readOptions && readOptions.model ? Ext.data.schema.Schema.lookupEntity(readOptions.model) : me.getModel(), schema = entityType.schema, includes = readOptions && 'includes' in readOptions ? readOptions.includes : schema.hasAssociations(entityType) && me.getImplicitIncludes(), fieldExtractorInfo = me.getFieldExtractorInfo(entityType), length = root.length, records = new Array(length), typeProperty = me.getTypeProperty(), reader, node, nodeType, record, i;
  if (!length && Ext.isObject(root)) {
    root = [root];
    length = 1;
  }
  for (i = 0; i < length; i++) {
    record = root[i];
    if (!record.isModel) {
      node = record;
      if (typeProperty && (nodeType = me.getChildType(schema, node, typeProperty))) {
        reader = nodeType.getProxy().getReader();
        record = reader.extractRecord(node, readOptions, nodeType, schema.hasAssociations(nodeType) && reader.getImplicitIncludes(), reader.getFieldExtractorInfo(nodeType));
      } else {
        record = me.extractRecord(node, readOptions, entityType, includes, fieldExtractorInfo);
      }
      if (record.isModel && record.isNode) {
        record.raw = node;
      }
    }
    if (record.onLoad) {
      record.onLoad();
    }
    records[i] = record;
  }
  return records;
}, getChildType:function(schema, rawNode, typeProperty) {
  var namespace;
  switch(typeof typeProperty) {
    case 'string':
      return schema.getEntity(rawNode[typeProperty]);
    case 'object':
      namespace = typeProperty.namespace;
      return schema.getEntity((namespace ? namespace + '.' : '') + rawNode[typeProperty.name]);
    case 'function':
      return schema.getEntity(typeProperty(rawNode));
  }
}, extractRecordData:function(node, readOptions) {
  var entityType = readOptions && readOptions.model ? Ext.data.schema.Schema.lookupEntity(readOptions.model) : this.getModel(), fieldExtractorInfo = this.getFieldExtractorInfo(entityType);
  return this.extractRecord(node, readOptions, entityType, false, fieldExtractorInfo);
}, extractRecord:function(node, readOptions, entityType, includes, fieldExtractorInfo) {
  var me = this, creatorFn = readOptions && readOptions.recordCreator || me.defaultRecordCreator, modelData, record;
  modelData = me.extractModelData(node, fieldExtractorInfo);
  record = creatorFn.call(me, modelData, entityType || me.getModel(), readOptions);
  if (includes && record.isModel) {
    me.readAssociated(record, node, readOptions);
  }
  return record;
}, getFieldExtractorInfo:function(entityType) {
  var extractors = entityType.fieldExtractors, type, extractor;
  if (!extractors) {
    return;
  }
  type = this.$className;
  extractor = extractors[type];
  if (extractor === undefined) {
    extractors[type] = extractor = this.buildFieldExtractors(entityType);
  }
  return extractor;
}, buildFieldExtractors:function(entityType) {
  var fields = entityType.getFields(), len = fields.length, buffer = [], extractors = [], out = null, cnt = 0, field, name, i, extractor;
  for (i = 0; i < len; ++i) {
    field = fields[i];
    extractor = this.createFieldAccessor(field);
    if (extractor) {
      name = field.name;
      buffer.push('val \x3d extractors[' + cnt + "](raw, self); if (val !\x3d\x3d undefined) { data['" + name + "'] \x3d val; }");
      extractors.push(extractor);
      ++cnt;
    }
  }
  if (buffer.length) {
    out = {extractors:extractors, fn:new Function('raw', 'data', 'extractors', 'self', 'var val;' + buffer.join('\n'))};
  }
  return out;
}, defaultRecordCreator:function(data, Model) {
  return new Model(data);
}, defaultRecordCreatorFromServer:function(data, Model) {
  var record = new Model(data);
  record.phantom = false;
  return record;
}, getModelData:function(raw) {
  return {};
}, extractModelData:function(raw, fieldExtractorInfo) {
  var data = this.getModelData(raw), fn;
  if (fieldExtractorInfo) {
    fn = fieldExtractorInfo.fn;
    fn(raw, data, fieldExtractorInfo.extractors, this);
  }
  return data;
}, readAssociated:function(record, data, readOptions) {
  var roles = record.associations, key, role;
  for (key in roles) {
    if (roles.hasOwnProperty(key)) {
      role = roles[key];
      if (role.cls) {
        role.read(record, data, this, readOptions);
      }
    }
  }
}, getData:Ext.identityFn, getRoot:Ext.identityFn, getResponseData:function(response) {
  Ext.raise('getResponseData must be implemented in the Ext.data.reader.Reader subclass');
}, onMetaChange:function(meta) {
  var me = this, fields = meta.fields, model, newModel, clientIdProperty, proxy;
  me.metaData = meta;
  if (meta.root) {
    me.setRootProperty(meta.root);
  }
  if (meta.totalProperty) {
    me.setTotalProperty(meta.totalProperty);
  }
  if (meta.successProperty) {
    me.setSuccessProperty(meta.successProperty);
  }
  if (meta.messageProperty) {
    me.setMessageProperty(meta.messageProperty);
  }
  clientIdProperty = meta.clientIdProperty;
  if (fields) {
    newModel = Ext.define(null, {extend:'Ext.data.Model', fields:fields, clientIdProperty:clientIdProperty});
    me.setModel(newModel);
    proxy = me.getProxy();
    if (proxy) {
      proxy.setModel(newModel);
    }
  } else {
    if (clientIdProperty) {
      model = me.getModel();
      if (model) {
        model.self.prototype.clientIdProperty = clientIdProperty;
      }
    }
  }
}, buildExtractors:function(force) {
  var me = this, totalProp, successProp, messageProp;
  if (force || !me.hasExtractors) {
    totalProp = me.getTotalProperty();
    successProp = me.getSuccessProperty();
    messageProp = me.getMessageProperty();
    if (totalProp) {
      me.getTotal = me.getAccessor(totalProp);
    }
    if (successProp) {
      me.getSuccess = me.getAccessor(successProp);
    }
    if (messageProp) {
      me.getMessage = me.getAccessor(messageProp);
    }
    me.hasExtractors = true;
    return true;
  }
}, getAccessor:function(prop) {
  var me = this, cache = me.extractorCache, ret, key;
  if (typeof prop === 'string') {
    key = me.getAccessorKey(prop);
    if (key) {
      ret = cache.get(key);
    }
    if (!ret) {
      ret = me.createAccessor(prop);
      if (key) {
        cache.add(key, ret);
      }
    }
  } else {
    ret = me.createAccessor(prop);
  }
  return ret;
}, getAccessorKey:function(prop) {
  var className = this.$className;
  return className ? className + prop : '';
}, createAccessor:Ext.emptyFn, createFieldAccessor:Ext.emptyFn, destroy:function() {
  var me = this;
  me.model = me.getTotal = me.getSuccess = me.getMessage = me.rawData = null;
  me.onMetaChange = null;
  me.transform = null;
  me.callParent();
}, privates:{copyFrom:function(reader) {
  var me = this;
  reader.buildExtractors();
  me.getTotal = reader.getTotal;
  me.getSuccess = reader.getSuccess;
  me.getMessage = reader.getMessage;
  ++me.duringInit;
  me.setConfig(reader.getConfig());
  --me.duringInit;
  me.hasExtractors = true;
}, getGroupRoot:Ext.privateFn, getSummaryRoot:Ext.privateFn}}, function(Cls) {
  var proto = Cls.prototype;
  Ext.apply(proto, {nullResultSet:new Ext.data.ResultSet({total:0, count:0, records:[], success:true, message:''})});
  proto.extractorCache = new Ext.util.LruCache;
});
Ext.define('Ext.data.writer.Writer', {mixins:[Ext.mixin.Factoryable], alias:'writer.base', factoryConfig:{defaultType:null}, alternateClassName:['Ext.data.DataWriter', 'Ext.data.Writer'], config:{clientIdProperty:null, allDataOptions:{persist:true}, partialDataOptions:{changes:true, critical:true}, writeAllFields:false, dateFormat:null, nameProperty:'name', writeRecordId:true, transform:null}, isWriter:true, constructor:function(config) {
  this.initConfig(config);
}, applyTransform:function(transform) {
  if (transform) {
    if (Ext.isFunction(transform)) {
      transform = {fn:transform};
    }
    return transform.fn.bind(transform.scope || this);
  }
  return transform;
}, write:function(request) {
  var operation = request.getOperation(), records = operation.getRecords() || [], len = records.length, data = [], i;
  for (i = 0; i < len; i++) {
    data.push(this.getRecordData(records[i], operation));
  }
  return this.writeRecords(request, data);
}, writeRecords:Ext.emptyFn, getRecordData:function(record, operation) {
  var me = this, nameProperty = me.getNameProperty(), mapping = nameProperty !== 'name', idField = record.self.idField, key = idField[nameProperty] || idField.name, value = record.id, writeAll = me.getWriteAllFields(), ret, dateFormat, phantom, options, clientIdProperty, fieldsMap, data, field;
  if (idField.serialize) {
    value = idField.serialize(value);
  }
  if (!writeAll && operation && operation.isDestroyOperation) {
    ret = {};
    ret[key] = value;
  } else {
    dateFormat = me.getDateFormat();
    phantom = record.phantom;
    options = phantom || writeAll ? me.getAllDataOptions() : me.getPartialDataOptions();
    clientIdProperty = phantom && me.getClientIdProperty();
    fieldsMap = record.getFieldsMap();
    options.serialize = false;
    data = record.getData(options);
    ret = mapping ? {} : data;
    if (clientIdProperty) {
      ret[clientIdProperty] = value;
      delete data[key];
    } else {
      if (!me.getWriteRecordId()) {
        delete data[key];
      }
    }
    for (key in data) {
      value = data[key];
      if (!(field = fieldsMap[key])) {
        if (mapping) {
          ret[key] = value;
        }
      } else {
        if (field.isDateField && dateFormat && Ext.isDate(value)) {
          value = Ext.Date.format(value, dateFormat);
        } else {
          if (field.serialize) {
            value = field.serialize(value, record);
          }
        }
        if (mapping) {
          key = field[nameProperty] || key;
        }
        ret[key] = value;
      }
    }
  }
  return ret;
}});
Ext.define('Ext.data.proxy.Proxy', {mixins:[Ext.mixin.Factoryable, Ext.mixin.Observable], $configPrefixed:false, alias:'proxy.proxy', alternateClassName:['Ext.data.DataProxy', 'Ext.data.Proxy'], config:{batchOrder:'create,update,destroy', batchActions:true, model:undefined, reader:{type:'json'}, writer:{type:'json'}}, isProxy:true, isSynchronous:false, constructor:function(config) {
  this.mixins.observable.constructor.call(this, config);
  this.pendingOperations = {};
}, applyModel:function(model) {
  return Ext.data.schema.Schema.lookupEntity(model);
}, updateModel:function(model) {
  if (model) {
    var reader = this.getReader();
    if (reader && !reader.getModel()) {
      reader.setModel(model);
    }
  }
}, applyReader:function(reader) {
  if (this.isSynchronous) {
    reader = reader || {};
    reader.keepRawData = true;
  }
  return Ext.Factory.reader(reader);
}, updateReader:function(reader) {
  if (reader) {
    var me = this, model = me.getModel();
    if (!model) {
      model = reader.getModel();
      if (model) {
        me.setModel(model);
      }
    } else {
      reader.setModel(model);
    }
    if (reader.responseType != null) {
      me.responseType = reader.responseType;
    }
  }
}, applyWriter:function(writer) {
  var reader = this.getReader();
  writer = Ext.Factory.writer(writer);
  if (writer.getRecord && !writer.getRecord() && reader && reader.getRecord) {
    reader = reader.getRecord();
    if (reader) {
      writer.setRecord(reader);
    }
  }
  return writer;
}, abort:Ext.emptyFn, onMetaChange:function(meta) {
  this.fireEvent('metachange', this, meta);
}, create:Ext.emptyFn, read:Ext.emptyFn, update:Ext.emptyFn, erase:Ext.emptyFn, batch:function(options, listeners) {
  var me = this, useBatch = me.getBatchActions(), batch, records, actions, aLen, action, a, r, rLen, record;
  if (options.operations === undefined) {
    options = {operations:options, listeners:listeners};
  }
  if (options.batch) {
    if (Ext.isDefined(options.batch.runOperation)) {
      batch = Ext.applyIf(options.batch, {proxy:me, listeners:{}});
    }
  } else {
    options.batch = {proxy:me, listeners:options.listeners || {}};
  }
  if (!batch) {
    batch = new Ext.data.Batch(options.batch);
  }
  batch.on('complete', Ext.bind(me.onBatchComplete, me, [options], 0), null, {single:true, priority:1000});
  batch.$destroyOwner = options.$destroyOwner;
  actions = me.getBatchOrder().split(',');
  aLen = actions.length;
  for (a = 0; a < aLen; a++) {
    action = actions[a];
    records = options.operations[action];
    if (records) {
      if (useBatch) {
        batch.add(me.createOperation(action, {records:records, params:options.params}));
      } else {
        rLen = records.length;
        for (r = 0; r < rLen; r++) {
          record = records[r];
          batch.add(me.createOperation(action, {records:[record], params:options.params}));
        }
      }
    }
  }
  batch.start();
  return batch;
}, onBatchComplete:function(batchOptions, batch) {
  var scope = batchOptions.scope || this;
  if (batch.hasException()) {
    if (Ext.isFunction(batchOptions.failure)) {
      Ext.callback(batchOptions.failure, scope, [batch, batchOptions]);
    }
  } else {
    if (Ext.isFunction(batchOptions.success)) {
      Ext.callback(batchOptions.success, scope, [batch, batchOptions]);
    }
  }
  if (Ext.isFunction(batchOptions.callback)) {
    Ext.callback(batchOptions.callback, scope, [batch, batchOptions]);
  }
  if (!batch.$destroyOwner) {
    batch.destroy();
  }
}, createOperation:function(action, config) {
  var operation = Ext.createByAlias('data.operation.' + action, config);
  operation.setProxy(this);
  this.pendingOperations[operation._internalId] = operation;
  return operation;
}, completeOperation:function(operation) {
  delete this.pendingOperations[operation._internalId];
}, clone:function() {
  return new this.self(this.getInitialConfig());
}, destroy:function() {
  var ops = this.pendingOperations, opId, op;
  for (opId in ops) {
    op = ops[opId];
    if (op && op.isRunning()) {
      op.abort();
    }
    op.destroy();
  }
  this.pendingOperations = null;
  this.callParent();
}});
Ext.define('Ext.data.proxy.Client', {extend:Ext.data.proxy.Proxy, alternateClassName:'Ext.data.ClientProxy', isSynchronous:true, clear:function() {
  Ext.raise("The Ext.data.proxy.Client subclass that you are using has not defined a 'clear' function. See src/data/ClientProxy.js for details.");
}});
Ext.define('Ext.data.proxy.Memory', {extend:Ext.data.proxy.Client, alias:'proxy.memory', alternateClassName:'Ext.data.MemoryProxy', isMemoryProxy:true, config:{enablePaging:null, data:{$value:null, merge:function(newValue, currentValue, target, mixinClass) {
  return newValue ? Ext.clone(newValue) : newValue;
}}, clearOnRead:null}, finishOperation:function(operation) {
  var recs = operation.getRecords(), len = recs.length, i;
  for (i = 0; i < len; i++) {
    recs[i].dropped = !!operation.isDestroyOperation;
    recs[i].commit();
  }
  operation.setSuccessful(true);
}, create:function(operation) {
  this.finishOperation(operation);
}, update:function(operation) {
  this.finishOperation(operation);
}, erase:function(operation) {
  this.finishOperation(operation);
}, read:function(operation) {
  var me = this, reader = me.getReader(), resultSet = reader.read(me.getData(), {recordCreator:reader.defaultRecordCreatorFromServer}), records = resultSet.getRecords(), sorters = operation.getSorters(), grouper = operation.getGrouper(), filters = operation.getFilters(), start = operation.getStart(), limit = operation.getLimit(), meta;
  if (operation.process(resultSet, null, null, false) !== false) {
    if (operation.success && me.getClearOnRead()) {
      this.setData(null);
    }
    if (filters && filters.length) {
      resultSet.setRecords(records = Ext.Array.filter(records, Ext.util.Filter.createFilterFn(filters)));
      resultSet.setTotal(records.length);
    }
    if (grouper) {
      sorters = sorters ? sorters.concat(grouper) : sorters;
    }
    if (sorters && sorters.length) {
      resultSet.setRecords(records = Ext.Array.sort(records, Ext.util.Sortable.createComparator(sorters)));
    }
    if (me.getEnablePaging() && start !== undefined && limit !== undefined) {
      if (start >= resultSet.getTotal()) {
        resultSet.setConfig({success:false, records:[], total:0});
      } else {
        resultSet.setRecords(Ext.Array.slice(records, start, start + limit));
      }
    }
    operation.setCompleted();
    if (meta = resultSet.getMetadata()) {
      me.onMetaChange(meta);
    }
  }
}, clear:Ext.emptyFn});
Ext.define('Ext.data.ProxyStore', {extend:Ext.data.AbstractStore, config:{model:undefined, fields:null, proxy:undefined, autoLoad:undefined, autoSync:false, batchUpdateMode:'operation', sortOnLoad:true, trackRemoved:true, asynchronousLoad:undefined}, onClassExtended:function(cls, data, hooks) {
  var model = data.model, onBeforeClassCreated;
  if (typeof model === 'string') {
    onBeforeClassCreated = hooks.onBeforeCreated;
    hooks.onBeforeCreated = function() {
      var me = this, args = arguments;
      Ext.require(model, function() {
        onBeforeClassCreated.apply(me, args);
      });
    };
  }
}, implicitModel:'Ext.data.Model', autoSyncSuspended:0, removed:null, constructor:function(config) {
  var me = this;
  var configModel = me.model;
  me.callParent(arguments);
  if (me.getAsynchronousLoad() === false) {
    me.flushLoad();
  }
  if (!me.getModel() && me.useModelWarning !== false && me.getStoreId() !== 'ext-empty-store') {
    var logMsg = [Ext.getClassName(me) || 'Store', ' created with no model.'];
    if (typeof configModel === 'string') {
      logMsg.push(" The name '", configModel, "'", ' does not correspond to a valid model.');
    }
    Ext.log.warn(logMsg.join(''));
  }
}, doDestroy:function() {
  var me = this, proxy = me.getProxy();
  me.clearLoadTask();
  Ext.destroy(me.getData());
  me.data = null;
  me.setProxy(null);
  if (proxy.autoCreated) {
    proxy.destroy();
  }
  me.setModel(null);
  me.callParent();
}, applyAsynchronousLoad:function(asynchronousLoad) {
  if (asynchronousLoad == null) {
    asynchronousLoad = !this.loadsSynchronously();
  }
  return asynchronousLoad;
}, updateAutoLoad:function(autoLoad) {
  this.getData();
  if (autoLoad) {
    this.load(Ext.isObject(autoLoad) ? autoLoad : undefined);
  }
}, getTotalCount:function() {
  return this.totalCount || 0;
}, applyFields:function(fields) {
  if (fields) {
    this.createImplicitModel(fields);
  }
}, applyModel:function(model) {
  if (model) {
    model = Ext.data.schema.Schema.lookupEntity(model);
  } else {
    if (!this.destroying) {
      this.getFields();
      model = this.getModel() || this.createImplicitModel();
    }
  }
  return model;
}, applyProxy:function(proxy) {
  var model = this.getModel();
  if (proxy !== null) {
    if (proxy) {
      if (proxy.isProxy) {
        proxy.setModel(model);
      } else {
        if (Ext.isString(proxy)) {
          proxy = {type:proxy, model:model};
        } else {
          if (!proxy.model) {
            proxy = Ext.apply({model:model}, proxy);
          }
        }
        proxy = Ext.createByAlias('proxy.' + proxy.type, proxy);
        proxy.autoCreated = true;
      }
    } else {
      if (model) {
        proxy = model.getProxy();
        this.useModelProxy = true;
      }
    }
    if (!proxy) {
      proxy = Ext.createByAlias('proxy.memory');
      proxy.autoCreated = true;
    }
  }
  return proxy;
}, applyState:function(state) {
  var me = this;
  me.callParent([state]);
  if (me.getAutoLoad() || me.isLoaded()) {
    me.load();
  }
}, updateProxy:function(proxy, oldProxy) {
  this.proxyListeners = Ext.destroy(this.proxyListeners);
}, updateTrackRemoved:function(track) {
  this.cleanRemoved();
  this.removed = track ? [] : null;
}, onMetaChange:function(proxy, meta) {
  this.fireEvent('metachange', this, meta);
}, create:function(data, options) {
  var me = this, Model = me.getModel(), instance = new Model(data), operation;
  options = Ext.apply({}, options);
  if (!options.records) {
    options.records = [instance];
  }
  options.internalScope = me;
  options.internalCallback = me.onProxyWrite;
  operation = me.createOperation('create', options);
  return operation.execute();
}, read:function() {
  return this.load.apply(this, arguments);
}, update:function(options) {
  var me = this, operation;
  options = Ext.apply({}, options);
  if (!options.records) {
    options.records = me.getUpdatedRecords();
  }
  options.internalScope = me;
  options.internalCallback = me.onProxyWrite;
  operation = me.createOperation('update', options);
  return operation.execute();
}, onProxyWrite:function(operation) {
  var me = this, success = operation.wasSuccessful(), records = operation.getRecords();
  switch(operation.getAction()) {
    case 'create':
      me.onCreateRecords(records, operation, success);
      break;
    case 'update':
      me.onUpdateRecords(records, operation, success);
      break;
    case 'destroy':
      me.onDestroyRecords(records, operation, success);
      break;
  }
  if (success) {
    me.fireEvent('write', me, operation);
    me.fireEvent('datachanged', me);
  }
}, onCreateRecords:Ext.emptyFn, onUpdateRecords:Ext.emptyFn, onDestroyRecords:function(records, operation, success) {
  if (success) {
    this.cleanRemoved();
  }
}, erase:function(options) {
  var me = this, operation;
  options = Ext.apply({}, options);
  if (!options.records) {
    options.records = me.getRemovedRecords();
  }
  options.internalScope = me;
  options.internalCallback = me.onProxyWrite;
  operation = me.createOperation('destroy', options);
  return operation.execute();
}, onBatchOperationComplete:function(batch, operation) {
  return this.onProxyWrite(operation);
}, onBatchComplete:function(batch, operation) {
  var me = this, operations = batch.operations, length = operations.length, i;
  if (me.batchUpdateMode !== 'operation') {
    me.suspendEvents();
    for (i = 0; i < length; i++) {
      me.onProxyWrite(operations[i]);
    }
    me.resumeEvents();
  }
  me.isSyncing = false;
  if (batch.$destroyOwner === me) {
    batch.destroy();
  }
  me.fireEvent('datachanged', me);
}, onBatchException:function(batch, operation) {
}, filterNew:function(item) {
  return item.phantom && item.isValid();
}, getNewRecords:function() {
  return [];
}, getUpdatedRecords:function() {
  return [];
}, getModifiedRecords:function() {
  return [].concat(this.getNewRecords(), this.getUpdatedRecords());
}, filterUpdated:function(item) {
  return item.dirty && !item.phantom && item.isValid();
}, getRemovedRecords:function() {
  var removed = this.getRawRemovedRecords();
  return removed ? Ext.Array.clone(removed) : [];
}, sync:function(options) {
  var me = this, operations = {}, toCreate = me.getNewRecords(), toUpdate = me.getUpdatedRecords(), toDestroy = me.getRemovedRecords(), needsSync = false;
  if (me.isSyncing) {
    Ext.log.warn('Sync called while a sync operation is in progress. Consider configuring autoSync as false.');
  }
  me.needsSync = false;
  if (toCreate.length > 0) {
    operations.create = toCreate;
    needsSync = true;
  }
  if (toUpdate.length > 0) {
    operations.update = toUpdate;
    needsSync = true;
  }
  if (toDestroy.length > 0) {
    operations.destroy = toDestroy;
    needsSync = true;
  }
  if (needsSync && me.fireEvent('beforesync', operations) !== false) {
    me.isSyncing = true;
    options = options || {};
    me.proxy.batch(Ext.apply(options, {operations:operations, listeners:me.getBatchListeners(), $destroyOwner:me}));
  }
  return me;
}, getBatchListeners:function() {
  var me = this, listeners = {scope:me, exception:me.onBatchException, complete:me.onBatchComplete};
  if (me.batchUpdateMode === 'operation') {
    listeners.operationcomplete = me.onBatchOperationComplete;
  }
  return listeners;
}, save:function() {
  return this.sync.apply(this, arguments);
}, load:function(options) {
  var me = this;
  if (typeof options === 'function') {
    options = {callback:options};
  } else {
    options = options ? Ext.Object.chain(options) : {};
  }
  me.pendingLoadOptions = options;
  if (me.getAsynchronousLoad()) {
    if (!me.loadTimer) {
      me.loadTimer = Ext.asap(me.flushLoad, me);
    }
  } else {
    me.flushLoad();
  }
  return me;
}, flushLoad:function() {
  var me = this, options = me.pendingLoadOptions, operation;
  if (me.destroying || me.destroyed) {
    return;
  }
  me.clearLoadTask();
  if (!options) {
    return;
  }
  me.setLoadOptions(options);
  if (me.getRemoteSort() && options.sorters) {
    me.fireEvent('beforesort', me, options.sorters);
  }
  operation = Ext.apply({internalScope:me, internalCallback:me.onProxyLoad, scope:me}, options);
  me.lastOptions = operation;
  operation = me.createOperation('read', operation);
  if (me.fireEvent('beforeload', me, operation) !== false) {
    me.onBeforeLoad(operation);
    me.loading = true;
    if (me.hasListeners.beginload) {
      me.fireEvent('beginload', me, operation);
    }
    operation.execute();
  }
}, reload:function(options) {
  return this.load(Ext.apply({}, options, this.lastOptions));
}, onEndUpdate:function() {
  var me = this;
  if (me.needsSync && me.autoSync && !me.autoSyncSuspended) {
    me.sync();
  }
}, afterReject:function(record) {
  var me = this;
  if (me.contains(record)) {
    me.onUpdate(record, Ext.data.Model.REJECT, null);
    me.fireEvent('update', me, record, Ext.data.Model.REJECT, null);
    me.fireEvent('datachanged', me);
  }
}, afterCommit:function(record, modifiedFieldNames) {
  var me = this;
  if (!modifiedFieldNames) {
    modifiedFieldNames = null;
  }
  if (me.contains(record)) {
    me.onUpdate(record, Ext.data.Model.COMMIT, modifiedFieldNames);
    me.fireEvent('update', me, record, Ext.data.Model.COMMIT, modifiedFieldNames);
    me.fireEvent('datachanged', me);
  }
}, afterErase:function(record) {
  this.onErase(record);
}, onErase:Ext.emptyFn, onUpdate:Ext.emptyFn, hasPendingLoad:function() {
  return !!this.pendingLoadOptions || this.isLoading();
}, isLoading:function() {
  return !!this.loading;
}, isLoaded:function() {
  return this.loadCount > 0;
}, suspendAutoSync:function() {
  ++this.autoSyncSuspended;
}, resumeAutoSync:function(syncNow) {
  var me = this;
  if (!me.autoSyncSuspended) {
    Ext.log.warn('Mismatched call to resumeAutoSync - auto synchronization is currently not suspended.');
  }
  if (me.autoSyncSuspended && !--me.autoSyncSuspended) {
    if (syncNow) {
      me.sync();
    }
  }
}, removeAll:Ext.emptyFn, clearData:Ext.emptyFn, privates:{getRawRemovedRecords:function() {
  return this.removed;
}, onExtraParamsChanged:function() {
}, clearLoadTask:function() {
  this.pendingLoadOptions = this.loadTimer = Ext.unasap(this.loadTimer);
}, cleanRemoved:function() {
  var removed = this.getRawRemovedRecords(), len, i;
  if (removed) {
    for (i = 0, len = removed.length; i < len; ++i) {
      removed[i].unjoin(this);
    }
    removed.length = 0;
  }
}, createOperation:function(type, options) {
  var me = this, proxy = me.getProxy(), listeners;
  if (!me.proxyListeners) {
    listeners = {scope:me, destroyable:true, beginprocessresponse:me.beginUpdate, endprocessresponse:me.endUpdate};
    if (!me.disableMetaChangeEvent) {
      listeners.metachange = me.onMetaChange;
    }
    me.proxyListeners = proxy.on(listeners);
  }
  return proxy.createOperation(type, options);
}, createImplicitModel:function(fields) {
  var me = this, modelCfg = {extend:me.implicitModel, statics:{defaultProxy:'memory'}}, proxy, model;
  if (fields) {
    modelCfg.fields = fields;
  }
  model = Ext.define(null, modelCfg);
  me.setModel(model);
  proxy = me.getProxy();
  if (proxy) {
    model.setProxy(proxy);
  } else {
    me.setProxy(model.getProxy());
  }
}, loadsSynchronously:function() {
  return this.getProxy().isSynchronous;
}, onBeforeLoad:Ext.privateFn, removeFromRemoved:function(record) {
  var removed = this.getRawRemovedRecords();
  if (removed) {
    Ext.Array.remove(removed, record);
    record.unjoin(this);
  }
}, setLoadOptions:function(options) {
  var me = this, filters, sorters;
  if (me.getRemoteFilter()) {
    filters = me.getFilters(false);
    if (filters && filters.getCount()) {
      options.filters = filters.getRange();
    }
  }
  if (me.getRemoteSort()) {
    sorters = me.getSorters(false);
    if (sorters && sorters.getCount()) {
      options.sorters = sorters.getRange();
    }
  }
}}});
Ext.define('Ext.util.Group', {extend:Ext.util.Collection, config:{groupKey:null}, $endUpdatePriority:2001, manageSorters:false});
Ext.define('Ext.data.Group', {extend:Ext.util.Group, store:null, getSummaryRecord:function() {
  var me = this, summaryRecord = me.summaryRecord, store = me.store, generation = store.getData().generation, M, T;
  if (!summaryRecord) {
    M = store.getModel();
    T = M.getSummaryModel();
    me.summaryRecord = summaryRecord = new T;
  }
  if (!summaryRecord.isRemote && summaryRecord.summaryGeneration !== generation) {
    summaryRecord.calculateSummary(me.items);
    summaryRecord.summaryGeneration = generation;
  }
  return summaryRecord;
}});
Ext.define('Ext.data.LocalStore', {extend:Ext.Mixin, mixinConfig:{id:'localstore'}, config:{extraKeys:null}, applyExtraKeys:function(extraKeys) {
  var indexName, data = this.getData();
  data.setExtraKeys(extraKeys);
  extraKeys = data.getExtraKeys();
  for (indexName in extraKeys) {
    this[indexName] = extraKeys[indexName];
  }
}, add:function(record) {
  return this.insert(this.getCount(), arguments.length === 1 ? record : arguments);
}, constructDataCollection:function() {
  var result = new Ext.util.Collection({rootProperty:'data', groupConfig:{xclass:'Ext.data.Group', store:this}});
  result.addObserver(this);
  return result;
}, createModel:function(record) {
  var session = this.getSession(), Model;
  if (!record.isModel) {
    Model = this.getModel();
    record = new Model(record, session);
  }
  return record;
}, createFiltersCollection:function() {
  return this.getData().getFilters();
}, createSortersCollection:function() {
  var sorters = this.getData().getSorters();
  sorters.setSorterConfigure(this.addFieldTransform, this);
  return sorters;
}, getSummaryRecord:function() {
  var me = this, summaryRecord = me.summaryRecord, data = me.getData(), generation = data.generation, T;
  if (!summaryRecord) {
    T = me.getModel().getSummaryModel();
    me.summaryRecord = summaryRecord = new T;
  }
  if (!summaryRecord.isRemote && summaryRecord.summaryGeneration !== generation) {
    summaryRecord.calculateSummary(data.items);
    summaryRecord.summaryGeneration = generation;
  }
  return summaryRecord;
}, onCollectionBeginUpdate:function() {
  this.beginUpdate();
}, onCollectionEndUpdate:function() {
  this.endUpdate();
}, onCollectionSort:function() {
  this.onSorterEndUpdate();
}, onCollectionFilter:function() {
  this.onFilterEndUpdate();
}, notifySorterChange:function() {
  this.getData().onSorterChange();
}, forceLocalSort:function() {
  var sorters = this.getSorters();
  sorters.beginUpdate();
  sorters.endUpdate();
}, contains:function(record) {
  return this.indexOf(record) > -1;
}, each:function(fn, scope, includeOptions) {
  var data = this.getData(), bypassFilters = includeOptions, len, record, i;
  if (typeof includeOptions === 'object') {
    bypassFilters = includeOptions.filtered;
  }
  if (bypassFilters && data.filtered) {
    data = data.getSource();
  }
  data = data.items.slice(0);
  len = data.length;
  for (i = 0; i < len; ++i) {
    record = data[i];
    if (fn.call(scope || record, record, i, len) === false) {
      break;
    }
  }
}, collect:function(property, includeOptions, filtered) {
  var me = this, allowNull = includeOptions, data = me.getData();
  if (typeof includeOptions === 'object') {
    filtered = includeOptions.filtered;
    allowNull = includeOptions.allowNull;
  }
  if (filtered && data.filtered) {
    data = data.getSource();
  }
  return data.collect(property, 'data', allowNull);
}, getById:function(id) {
  var data = this.getData();
  if (data.filtered) {
    data = data.getSource();
  }
  return data.get(id) || null;
}, getByInternalId:function(internalId) {
  var data = this.getData(), keyCfg;
  if (data.filtered) {
    if (!data.$hasExtraKeys) {
      keyCfg = this.makeInternalKeyCfg();
      data.setExtraKeys(keyCfg);
      data.$hasExtraKeys = true;
    }
    data = data.getSource();
  }
  if (!data.$hasExtraKeys) {
    data.setExtraKeys(keyCfg || this.makeInternalKeyCfg());
    data.$hasExtraKeys = true;
  }
  return data.byInternalId.get(internalId) || null;
}, getDataSource:function() {
  var data = this.getData();
  return data.getSource() || data;
}, indexOf:function(record) {
  return this.getData().indexOf(record);
}, indexOfId:function(id) {
  return this.indexOf(this.getById(id));
}, insert:function(index, records) {
  var me = this, len, i;
  if (records) {
    if (!Ext.isIterable(records)) {
      records = [records];
    } else {
      records = Ext.Array.clone(records);
    }
    len = records.length;
  }
  if (!len) {
    return [];
  }
  for (i = 0; i < len; ++i) {
    records[i] = me.createModel(records[i]);
  }
  me.getData().insert(index, records);
  return records;
}, queryBy:function(fn, scope) {
  var data = this.getData();
  return (data.getSource() || data).createFiltered(fn, scope);
}, query:function(property, value, anyMatch, caseSensitive, exactMatch) {
  var data = this.getData();
  return (data.getSource() || data).createFiltered(property, value, anyMatch, caseSensitive, exactMatch);
}, first:function(grouped) {
  return this.getData().first(grouped) || null;
}, last:function(grouped) {
  return this.getData().last(grouped) || null;
}, sum:function(field, grouped) {
  var data = this.getData();
  return grouped && this.isGrouped() ? data.sumByGroup(field) : data.sum(field);
}, count:function(grouped) {
  var data = this.getData();
  return grouped && this.isGrouped() ? data.countByGroup() : data.count();
}, min:function(field, grouped) {
  var data = this.getData();
  return grouped && this.isGrouped() ? data.minByGroup(field) : data.min(field);
}, max:function(field, grouped) {
  var data = this.getData();
  return grouped && this.isGrouped() ? data.maxByGroup(field) : data.max(field);
}, average:function(field, grouped) {
  var data = this.getData();
  return grouped && this.isGrouped() ? data.averageByGroup(field) : data.average(field);
}, aggregate:function(fn, scope, grouped, field) {
  var me = this, groups, len, out, group, i;
  if (grouped && me.isGrouped()) {
    groups = me.getGroups().items;
    len = groups.length;
    out = {};
    for (i = 0; i < len; ++i) {
      group = groups[i];
      out[group.getGroupKey()] = me.getAggregate(fn, scope || me, group.items, field);
    }
    return out;
  } else {
    return me.getAggregate(fn, scope, me.getData().items, field);
  }
}, getAggregate:function(fn, scope, records, field) {
  var values = [], len = records.length, i;
  for (i = 0; i < len; ++i) {
    values[i] = records[i].get(field);
  }
  return fn.call(scope || this, records, values);
}, addObserver:function(observer) {
  var observers = this.observers;
  if (!observers) {
    this.observers = observers = new Ext.util.Collection;
  }
  observers.add(observer);
}, removeObserver:function(observer) {
  var observers = this.observers;
  if (observers) {
    observers.remove(observer);
  }
}, callObservers:function(action, args) {
  var observers = this.observers, len, items, i, methodName, item;
  if (observers) {
    items = observers.items;
    if (args) {
      args.unshift(this);
    } else {
      args = [this];
    }
    for (i = 0, len = items.length; i < len; ++i) {
      item = items[i];
      methodName = 'onSource' + action;
      if (item[methodName]) {
        item[methodName].apply(item, args);
      }
    }
  }
}, queryRecordsBy:function(fn, scope) {
  var data = this.getData(), matches = [], len, i, record;
  data = (data.getSource() || data).items;
  scope = scope || this;
  for (i = 0, len = data.length; i < len; ++i) {
    record = data[i];
    if (fn.call(scope, record) === true) {
      matches.push(record);
    }
  }
  return matches;
}, queryRecords:function(field, value) {
  var data = this.getData(), matches = [], len, i, record;
  data = (data.getSource() || data).items;
  for (i = 0, len = data.length; i < len; ++i) {
    record = data[i];
    if (record.get(field) === value) {
      matches.push(record);
    }
  }
  return matches;
}, privates:{isLast:function(record) {
  return record === this.last();
}, makeInternalKeyCfg:function() {
  return {byInternalId:{property:'internalId', rootProperty:''}};
}}});
Ext.define('Ext.data.proxy.Server', {extend:Ext.data.proxy.Proxy, alias:'proxy.server', alternateClassName:'Ext.data.ServerProxy', isRemote:true, config:{url:'', pageParam:'page', startParam:'start', limitParam:'limit', groupParam:'group', groupDirectionParam:'groupDir', sortParam:'sort', filterParam:'filter', directionParam:'dir', idParam:'id', simpleSortMode:false, simpleGroupMode:false, noCache:true, cacheString:'_dc', timeout:30000, api:{create:undefined, read:undefined, update:undefined, destroy:undefined}, 
extraParams:{}}, primitiveRe:/string|number|boolean/, create:function() {
  return this.doRequest.apply(this, arguments);
}, read:function() {
  return this.doRequest.apply(this, arguments);
}, update:function() {
  return this.doRequest.apply(this, arguments);
}, erase:function() {
  return this.doRequest.apply(this, arguments);
}, setExtraParam:function(name, value) {
  var extraParams = this.getExtraParams();
  extraParams[name] = value;
  this.fireEvent('extraparamschanged', extraParams);
}, updateExtraParams:function(newExtraParams, oldExtraParams) {
  this.fireEvent('extraparamschanged', newExtraParams);
}, buildRequest:function(operation) {
  var me = this, initialParams = Ext.apply({}, operation.getParams()), params = Ext.applyIf(initialParams, me.getExtraParams() || {}), request, operationId, idParam;
  Ext.applyIf(params, me.getParams(operation));
  operationId = operation.getId();
  idParam = me.getIdParam();
  if (operationId !== undefined && params[idParam] === undefined) {
    params[idParam] = operationId;
  }
  request = new Ext.data.Request({params:params, action:operation.getAction(), records:operation.getRecords(), url:operation.getUrl(), operation:operation, proxy:me});
  request.setUrl(me.buildUrl(request));
  operation.setRequest(request);
  return request;
}, processResponse:function(success, operation, request, response) {
  var me = this, exception, reader, resultSet, meta, destroyOp;
  if (me.destroying || me.destroyed) {
    return;
  }
  me.fireEvent('beginprocessresponse', me, response, operation);
  if (success === true) {
    reader = me.getReader();
    if (response.status === 204) {
      resultSet = reader.getNullResultSet();
    } else {
      resultSet = reader.read(me.extractResponseData(response), {recordCreator:operation.getRecordCreator() || reader.defaultRecordCreatorFromServer});
    }
    if (!operation.$destroyOwner) {
      operation.$destroyOwner = me;
      destroyOp = true;
    }
    operation.process(resultSet, request, response);
    exception = !operation.wasSuccessful();
  } else {
    me.setException(operation, response);
    exception = true;
  }
  if (me.destroyed) {
    if (!operation.destroyed && destroyOp && operation.$destroyOwner === me) {
      operation.destroy();
    }
    return;
  }
  if (exception) {
    me.fireEvent('exception', me, response, operation);
  } else {
    meta = resultSet.getMetadata();
    if (meta) {
      me.onMetaChange(meta);
    }
  }
  if (me.destroyed) {
    if (!operation.destroyed && destroyOp && operation.$destroyOwner === me) {
      operation.destroy();
    }
    return;
  }
  me.afterRequest(request, success);
  me.fireEvent('endprocessresponse', me, response, operation);
  if (!operation.destroyed && destroyOp && operation.$destroyOwner === me) {
    operation.destroy();
  }
}, setException:function(operation, response) {
  operation.setException({status:response.status, statusText:response.statusText, response:response});
}, extractResponseData:Ext.identityFn, applyEncoding:function(value) {
  return Ext.encode(value);
}, encodeSorters:function(sorters, preventArray) {
  var out = [], length = sorters.length, i;
  for (i = 0; i < length; i++) {
    out[i] = sorters[i].serialize();
  }
  return this.applyEncoding(preventArray ? out[0] : out);
}, encodeFilters:function(filters) {
  var out = [], length = filters.length, needsEncoding, i, filter, encodedFilter;
  for (i = 0; i < length; i++) {
    filter = filters[i];
    filter.getFilterFn();
    if (filter.generatedFilterFn) {
      encodedFilter = filter.serialize();
      needsEncoding |= !this.primitiveRe.test(typeof encodedFilter);
      out.push(encodedFilter);
    }
  }
  return needsEncoding ? this.applyEncoding(out) : out;
}, getParams:function(operation) {
  if (!operation.isReadOperation) {
    return {};
  }
  var me = this, params = {}, grouper = operation.getGrouper(), sorters = operation.getSorters(), filters = operation.getFilters(), page = operation.getPage(), start = operation.getStart(), limit = operation.getLimit(), simpleSortMode = me.getSimpleSortMode(), simpleGroupMode = me.getSimpleGroupMode(), pageParam = me.getPageParam(), startParam = me.getStartParam(), limitParam = me.getLimitParam(), groupParam = me.getGroupParam(), groupDirectionParam = me.getGroupDirectionParam(), sortParam = me.getSortParam(), 
  filterParam = me.getFilterParam(), directionParam = me.getDirectionParam(), hasGroups, index;
  if (pageParam && page) {
    params[pageParam] = page;
  }
  if (startParam && (start || start === 0)) {
    params[startParam] = start;
  }
  if (limitParam && limit) {
    params[limitParam] = limit;
  }
  hasGroups = groupParam && grouper;
  if (hasGroups) {
    if (simpleGroupMode) {
      params[groupParam] = grouper.getProperty();
      if (groupDirectionParam === groupParam) {
        params[groupParam] += ' ' + grouper.getDirection();
      } else {
        params[groupDirectionParam] = grouper.getDirection();
      }
    } else {
      params[groupParam] = me.encodeSorters([grouper], true);
    }
  }
  if (sortParam && sorters && sorters.length > 0) {
    if (simpleSortMode) {
      for (index = sorters.length > 1 && hasGroups ? 1 : 0; index < sorters.length; index++) {
        if (directionParam === sortParam) {
          params[sortParam] = Ext.Array.push(params[sortParam] || [], sorters[index].getProperty() + ' ' + sorters[index].getDirection());
        } else {
          params[sortParam] = Ext.Array.push(params[sortParam] || [], sorters[index].getProperty());
          params[directionParam] = Ext.Array.push(params[directionParam] || [], sorters[index].getDirection());
        }
      }
    } else {
      params[sortParam] = me.encodeSorters(sorters);
    }
  }
  if (filterParam && filters && filters.length > 0) {
    params[filterParam] = me.encodeFilters(filters);
  }
  return params;
}, buildUrl:function(request) {
  var me = this, url = me.getUrl(request);
  if (!url) {
    Ext.raise('You are using a ServerProxy but have not supplied it with a url.');
  }
  if (me.getNoCache()) {
    url = Ext.urlAppend(url, Ext.String.format('{0}\x3d{1}', me.getCacheString(), Ext.Date.now()));
  }
  return url;
}, getUrl:function(request) {
  var url;
  if (request) {
    url = request.getUrl() || this.getApi()[request.getAction()];
  }
  return url ? url : this.callParent();
}, doRequest:function(operation, callback, scope) {
  Ext.raise('The doRequest function has not been implemented on your Ext.data.proxy.Server subclass. See src/data/ServerProxy.js for details');
}, afterRequest:Ext.emptyFn, destroy:function() {
  var me = this;
  me.destroying = true;
  me.reader = me.writer = Ext.destroy(me.reader, me.writer);
  me.callParent();
  me.destroying = false;
  me.destroyed = true;
}});
Ext.define('Ext.data.proxy.Ajax', {extend:Ext.data.proxy.Server, alias:'proxy.ajax', alternateClassName:['Ext.data.HttpProxy', 'Ext.data.AjaxProxy'], isAjaxProxy:true, defaultActionMethods:{create:'POST', read:'GET', update:'POST', destroy:'POST'}, config:{binary:false, headers:undefined, paramsAsJson:false, withCredentials:false, useDefaultXhrHeader:true, username:null, password:null, actionMethods:{create:'POST', read:'GET', update:'POST', destroy:'POST'}}, doRequest:function(operation) {
  var me = this, writer = me.getWriter(), request = me.buildRequest(operation), method = me.getMethod(request), jsonData, params;
  if (writer && operation.allowWrite()) {
    request = writer.write(request);
  }
  request.setConfig({binary:me.getBinary(), headers:me.getHeaders(), timeout:me.getTimeout(), scope:me, callback:me.createRequestCallback(request, operation), method:method, useDefaultXhrHeader:me.getUseDefaultXhrHeader(), disableCaching:false});
  if (me.responseType != null && Ext.supports.XHR2) {
    request.setResponseType(me.responseType);
  }
  if (method.toUpperCase() !== 'GET' && me.getParamsAsJson()) {
    params = request.getParams();
    if (params) {
      jsonData = request.getJsonData();
      if (jsonData) {
        jsonData = Ext.Object.merge({}, jsonData, params);
      } else {
        jsonData = params;
      }
      request.setJsonData(jsonData);
      request.setParams(undefined);
    }
  }
  if (me.getWithCredentials()) {
    request.setWithCredentials(true);
    request.setUsername(me.getUsername());
    request.setPassword(me.getPassword());
  }
  return me.sendRequest(request);
}, sendRequest:function(request) {
  request.setRawRequest(Ext.Ajax.request(request.getCurrentConfig()));
  this.lastRequest = request;
  return request;
}, abort:function(request) {
  request = request || this.lastRequest;
  if (request) {
    Ext.Ajax.abort(request.getRawRequest());
  }
}, getMethod:function(request) {
  var actions = this.getActionMethods(), action = request.getAction(), method;
  if (actions) {
    method = actions[action];
  }
  return method || this.defaultActionMethods[action];
}, createRequestCallback:function(request, operation) {
  return function(options, success, response) {
    var me = this;
    if (request === me.lastRequest) {
      me.lastRequest = null;
    }
    if (!me.destroying && !me.destroyed) {
      me.processResponse(success, operation, request, response);
    }
  };
}, destroy:function() {
  this.lastRequest = null;
  this.callParent();
}});
Ext.define('Ext.data.reader.Json', {extend:Ext.data.reader.Reader, alternateClassName:'Ext.data.JsonReader', alias:'reader.json', config:{record:null, metaProperty:'metaData', useSimpleAccessors:false, preserveRawData:false}, responseType:'json', updateRootProperty:function() {
  this.forceBuildExtractors();
}, updateMetaProperty:function() {
  this.forceBuildExtractors();
}, getResponseData:function(response) {
  var error;
  if (typeof response.responseJson === 'object') {
    return response.responseJson;
  }
  try {
    return Ext.decode(response.responseText);
  } catch (ex) {
    error = this.createReadError(ex.message);
    Ext.Logger.warn('Unable to parse the JSON returned by the server');
    this.fireEvent('exception', this, response, error);
    return error;
  }
}, buildExtractors:function(force) {
  var me = this, emptyFn = Ext.emptyFn, prop;
  if (me.callParent([force])) {
    me.getRoot = me.setupExtractor(me.getRootProperty(), Ext.identityFn);
    me.getGroupRoot = me.setupExtractor(me.getGroupRootProperty(), emptyFn);
    me.getSummaryRoot = me.setupExtractor(me.getSummaryRootProperty(), emptyFn);
    me.getMeta = me.setupExtractor(me.getMetaProperty(), emptyFn);
  }
}, extractData:function(root, readOptions) {
  var recordName = this.getRecord(), data = [], length, i;
  if (recordName) {
    length = root.length;
    if (!length && Ext.isObject(root)) {
      length = 1;
      root = [root];
    }
    for (i = 0; i < length; i++) {
      data[i] = root[i][recordName];
    }
  } else {
    data = root;
  }
  return this.callParent([data, readOptions]);
}, getModelData:function(raw) {
  return this.getPreserveRawData() ? Ext.apply({}, raw) : raw;
}, createAccessor:function() {
  var re = /[\[\.]/;
  return function(expr) {
    var simple = this.getUseSimpleAccessors(), operatorIndex, result, current, parts, part, inExpr, isDot, isLeft, isRight, special, c, i, bracketed, len;
    if (!(expr || expr === 0)) {
      return;
    }
    if (typeof expr === 'function') {
      return expr;
    }
    if (!simple) {
      operatorIndex = String(expr).search(re);
    }
    if (simple === true || operatorIndex < 0) {
      result = function(raw) {
        return raw == null ? null : raw[expr];
      };
    } else {
      current = 'raw';
      parts = [];
      part = '';
      inExpr = 0;
      len = expr.length;
      for (i = 0; i <= len; ++i) {
        c = expr[i];
        isDot = c === '.';
        isLeft = c === '[';
        isRight = c === ']';
        special = isDot || isLeft || isRight || !c;
        if (!special || inExpr > 1 || inExpr && !isRight) {
          part += c;
        } else {
          if (special) {
            bracketed = false;
            if (isLeft) {
              ++inExpr;
            } else {
              if (isRight) {
                --inExpr;
                bracketed = true;
              }
            }
            if (part) {
              if (bracketed) {
                part = '[' + part + ']';
              } else {
                part = '.' + part;
              }
              current += part;
              parts.push('' + current);
              part = '';
            }
          }
        }
      }
      result = parts.join(' \x26\x26 ');
      result = Ext.functionFactory('raw', 'return ' + result);
    }
    return result;
  };
}(), createFieldAccessor:function(field) {
  var me = this, mapping = field.mapping, hasMap = mapping || mapping === 0, map = hasMap ? mapping : field.name;
  if (hasMap) {
    if (typeof map === 'function') {
      return function(raw, self) {
        return field.mapping(raw, self);
      };
    } else {
      return me.createAccessor(map);
    }
  }
}, getAccessorKey:function(prop) {
  var simple = this.getUseSimpleAccessors() ? 'simple' : '';
  return this.callParent([simple + prop]);
}, privates:{copyFrom:function(reader) {
  this.callParent([reader]);
  this.getRoot = reader.getRoot;
}, setupExtractor:function(prop, defaultFn) {
  return prop ? this.getAccessor(prop) : defaultFn;
}}});
Ext.define('Ext.data.writer.Json', {extend:Ext.data.writer.Writer, alternateClassName:'Ext.data.JsonWriter', alias:'writer.json', config:{rootProperty:undefined, encode:false, allowSingle:true, expandData:false}, constructor:function(config) {
  if (config && config.hasOwnProperty('root')) {
    config = Ext.apply({}, config);
    config.rootProperty = config.root;
    delete config.root;
    Ext.log.warn('Ext.data.writer.Json: Using the deprecated "root" configuration. Use "rootProperty" instead.');
  }
  this.callParent([config]);
}, getExpandedData:function(data) {
  var dataLength = data.length, i = 0, item, prop, nameParts, j, tempObj, toObject = function(name, value) {
    var o = {};
    o[name] = value;
    return o;
  };
  for (; i < dataLength; i++) {
    item = data[i];
    for (prop in item) {
      if (item.hasOwnProperty(prop)) {
        nameParts = prop.split('.');
        j = nameParts.length - 1;
        if (j > 0) {
          tempObj = item[prop];
          for (; j > 0; j--) {
            tempObj = toObject(nameParts[j], tempObj);
          }
          item[nameParts[0]] = item[nameParts[0]] || {};
          Ext.Object.merge(item[nameParts[0]], tempObj);
          delete item[prop];
        }
      }
    }
  }
  return data;
}, writeRecords:function(request, data) {
  var me = this, root = me.getRootProperty(), json, single, transform;
  if (me.getExpandData()) {
    data = me.getExpandedData(data);
  }
  if (me.getAllowSingle() && data.length === 1) {
    data = data[0];
    single = true;
  }
  transform = this.getTransform();
  if (transform) {
    data = transform(data, request);
  }
  if (me.getEncode()) {
    if (root) {
      request.setParam(root, Ext.encode(data));
    } else {
      Ext.raise('Must specify a root when using encode');
    }
  } else {
    if (single || data && data.length) {
      json = request.getJsonData() || {};
      if (root) {
        json[root] = data;
      } else {
        json = data;
      }
      request.setJsonData(json);
    }
  }
  return request;
}});
Ext.define('Ext.util.SorterCollection', {extend:Ext.util.Collection, isSorterCollection:true, $sortable:null, sortFn:null, config:{sorterOptionsFn:null, sorterOptionsScope:null}, constructor:function(config) {
  var me = this;
  me.sortFn = Ext.util.Sorter.createComparator(me);
  me.callParent([config]);
  me.setDecoder(me.decodeSorter);
}, addSort:function(property, direction, mode) {
  var me = this, count, index, limit, options, primary, sorter, sorters;
  if (!property) {
    me.beginUpdate();
    me.endUpdate();
  } else {
    options = me.getOptions();
    if (property instanceof Array) {
      sorters = property;
      mode = direction;
      direction = null;
    } else {
      if (Ext.isString(property)) {
        if (!(sorter = me.get(property))) {
          sorters = [{property:property, direction:direction || options.getDefaultSortDirection()}];
        } else {
          sorters = [sorter];
        }
      } else {
        if (Ext.isFunction(property)) {
          sorters = [{sorterFn:property, direction:direction || options.getDefaultSortDirection()}];
        } else {
          if (!Ext.isObject(property)) {
            Ext.raise('Invalid sort descriptor: ' + property);
          }
          sorters = [property];
          mode = direction;
          direction = null;
        }
      }
    }
    if (mode && !me._sortModes[mode]) {
      Ext.raise('Sort mode should be "multi", "append", "prepend" or "replace", not "' + mode + '"');
    }
    mode = me._sortModes[mode || 'replace'];
    primary = me.getAt(0);
    count = me.length;
    index = mode.append ? count : 0;
    me.beginUpdate();
    me.splice(index, mode.replace ? count : 0, sorters);
    if (mode.multi) {
      count = me.length;
      limit = options.getMultiSortLimit();
      if (count > limit) {
        me.removeAt(limit, count);
      }
    }
    if (sorter && direction) {
      sorter.setDirection(direction);
    } else {
      if (index === 0 && primary && primary === me.getAt(0)) {
        primary.toggle();
      }
    }
    me.endUpdate();
  }
}, clear:function() {
  this.beginUpdate();
  this.callParent();
  this.endUpdate(this.items);
}, getSortFn:function() {
  return this.sortFn;
}, getByProperty:function(prop) {
  var items = this.items, len = items.length, i, item;
  for (i = 0; i < len; ++i) {
    item = items[i];
    if (item.getProperty() === prop) {
      return item;
    }
  }
  return null;
}, _sortModes:{append:{append:1}, multi:{multi:1}, prepend:{prepend:1}, replace:{replace:1}}, decodeSorter:function(sorter, xclass) {
  var me = this, options = me.getOptions(), root = options.getRootProperty(), sorterOptionsFn = me.getSorterOptionsFn(), currentSorter, sorterConfig, type;
  if (sorter.isSorter) {
    if (!sorter.getRoot()) {
      sorter.setRoot(root);
    }
  } else {
    sorterConfig = {direction:options.getDefaultSortDirection(), root:root};
    type = typeof sorter;
    if (type === 'string') {
      currentSorter = me.get(sorter);
      if (currentSorter) {
        return currentSorter;
      }
      sorterConfig.property = sorter;
    } else {
      if (type === 'function') {
        sorterConfig.sorterFn = sorter;
      } else {
        if (!Ext.isObject(sorter)) {
          Ext.raise('Invalid sorter specified: ' + sorter);
        }
        sorterConfig = Ext.apply(sorterConfig, sorter);
        if (sorterConfig.fn) {
          sorterConfig.sorterFn = sorterConfig.fn;
          delete sorterConfig.fn;
        }
      }
    }
    sorter = Ext.create(xclass || Ext.util.Sorter, sorterConfig);
  }
  if (sorterOptionsFn) {
    sorterOptionsFn.call(me.getSorterOptionsScope() || me, sorter);
  }
  return sorter;
}, setSorterConfigure:function(fn, scope) {
  this.setSorterOptionsFn(fn);
  this.setSorterOptionsScope(scope);
}, decodeRemoveItems:function(args, index) {
  var me = this, ret = index === undefined ? args : args[index];
  if (!ret || !ret.$cloned) {
    if (args.length > index + 1 || !Ext.isIterable(ret)) {
      ret = Ext.Array.slice(args, index);
    }
    var currentSorters = me.items, ln = ret.length, remove = [], i, item, n, sorter, type;
    for (i = 0; i < ln; i++) {
      sorter = ret[i];
      if (sorter && sorter.isSorter) {
        remove.push(sorter);
      } else {
        type = typeof sorter;
        if (type === 'string') {
          sorter = me.get(sorter);
          if (sorter) {
            remove.push(sorter);
          }
        } else {
          if (type === 'function') {
            for (n = currentSorters.length; n-- > 0;) {
              item = currentSorters[n];
              if (item.getSorterFn() === sorter) {
                remove.push(item);
              }
            }
          } else {
            Ext.raise('Invalid sorter specification: ' + sorter);
          }
        }
      }
    }
    ret = remove;
    ret.$cloned = true;
  }
  return ret;
}, getOptions:function() {
  return this.$sortable || this;
}});
Ext.define('Ext.util.FilterCollection', {extend:Ext.util.Collection, isFilterCollection:true, $filterable:null, filterFn:null, constructor:function(config) {
  var me = this;
  me.filterFn = Ext.util.Filter.createFilterFn(me);
  me.callParent([config]);
  me.setDecoder(me.decodeFilter);
}, filterData:function(data) {
  return this.filtered ? Ext.Array.filter(data, this.filterFn) : data;
}, getFilterFn:function() {
  return this.filterFn;
}, isItemFiltered:function(item) {
  return !this.filterFn(item);
}, getFilterCount:function() {
  var filters = this.items, len = filters.length, i;
  for (i = len - 1; i >= 0; i--) {
    if (filters[i].getDisabled()) {
      len--;
    }
  }
  return len;
}, decodeFilter:function(filter) {
  var options = this.getOptions(), filterRoot = options.getRootProperty(), filterConfig;
  if (filter.isFilter) {
    if (!filter.getRoot()) {
      filter.setRoot(filterRoot);
    }
  } else {
    filterConfig = {root:filterRoot};
    if (Ext.isFunction(filter)) {
      filterConfig.filterFn = filter;
    } else {
      if (!Ext.isObject(filter)) {
        Ext.raise('Invalid filter specified: ' + filter);
      }
      filterConfig = Ext.apply(filterConfig, filter);
      if (filterConfig.fn) {
        filterConfig.filterFn = filterConfig.fn;
        delete filterConfig.fn;
      }
      if (Ext.util.Filter.isInvalid(filterConfig)) {
        return false;
      }
    }
    filter = new Ext.util.Filter(filterConfig);
  }
  return filter;
}, decodeRemoveItems:function(args, index) {
  var me = this, ret = index === undefined ? args : args[index];
  if (!ret.$cloned) {
    if (args.length > index + 1 || !Ext.isIterable(ret)) {
      ret = Ext.Array.slice(args, index);
    }
    var currentFilters = me.items, ln = ret.length, remove = [], filter, i, isFunction, isProp, isString, item, match, n, type;
    for (i = 0; i < ln; i++) {
      filter = ret[i];
      if (filter && filter.isFilter) {
        remove.push(filter);
      } else {
        type = typeof filter;
        isFunction = type === 'function';
        isProp = filter.property !== undefined && filter.value !== undefined;
        isString = type === 'string';
        if (!isFunction && !isProp && !isString) {
          Ext.raise('Invalid filter specification: ' + filter);
        }
        for (n = currentFilters.length; n-- > 0;) {
          item = currentFilters[n];
          match = false;
          if (isString) {
            match = item.getProperty() === filter;
          } else {
            if (isFunction) {
              match = item.getFilterFn() === filter;
            } else {
              if (isProp) {
                match = item.getProperty() === filter.property && item.getValue() === filter.value;
              }
            }
          }
          if (match) {
            remove.push(item);
          }
        }
      }
    }
    ret = remove;
    ret.$cloned = true;
  }
  return ret;
}, getOptions:function() {
  return this.$filterable || this;
}});
Ext.define('Ext.util.GroupCollection', {extend:Ext.util.Collection, isGroupCollection:true, config:{grouper:null, groupConfig:null, itemRoot:null}, observerPriority:-100, emptyGroupRetainTime:300000, constructor:function(config) {
  this.emptyGroups = {};
  this.callParent([config]);
  this.on('remove', 'onGroupRemove', this);
}, getItemGroup:function(item) {
  var key = this.getGrouper().getGroupString(item);
  return this.get(key);
}, onCollectionAdd:function(source, details) {
  if (!this.isConfiguring) {
    this.addItemsToGroups(source, details.items, details.at);
  }
}, onCollectionBeforeItemChange:function(source, details) {
  this.changeDetails = details;
}, onCollectionBeginUpdate:function() {
  this.beginUpdate();
}, onCollectionEndUpdate:function() {
  this.endUpdate();
}, onCollectionItemChange:function(source, details) {
  if (!details.indexChanged) {
    this.syncItemGrouping(source, details);
  }
  this.changeDetails = null;
}, onCollectionRefresh:function(source) {
  if (source.generation) {
    var me = this, itemGroupKeys = me.itemGroupKeys = {}, groupData = me.createEntries(source, source.items), entries = groupData.entries, groupKey, i, len, entry, j;
    for (i = 0, len = entries.length; i < len; ++i) {
      entry = entries[i];
      entry.group.splice(0, 1.0E99, entry.items);
      for (j = 0; j < entry.items.length; j++) {
        itemGroupKeys[source.getKey(entry.items[j])] = entry.group;
      }
    }
    entries = null;
    for (groupKey in me.map) {
      if (!(groupKey in groupData.groups)) {
        (entries || (entries = [])).push(me.map[groupKey]);
      }
    }
    if (entries) {
      me.remove(entries);
    }
    me.sortItems();
  }
}, onCollectionRemove:function(source, details) {
  var me = this, changeDetails = me.changeDetails, itemGroupKeys = me.itemGroupKeys || (me.itemGroupKeys = {}), entries, entry, group, i, n, j, removeGroups, item;
  if (source.getCount()) {
    if (changeDetails) {
      item = changeDetails.item || changeDetails.items[0];
      entries = me.createEntries(source, [item]).entries;
      entries[0].group = itemGroupKeys['oldKey' in details ? details.oldKey : source.getKey(item)];
    } else {
      entries = me.createEntries(source, details.items).entries;
    }
    for (i = 0, n = entries.length; i < n; ++i) {
      group = (entry = entries[i]).group;
      if (group) {
        group.remove(entry.items);
      }
      for (j = 0; j < entry.items.length; j++) {
        delete itemGroupKeys[source.getKey(entry.items[j])];
      }
      if (group && !group.length) {
        (removeGroups || (removeGroups = [])).push(group);
      }
    }
  } else {
    me.itemGroupKeys = {};
    removeGroups = me.items;
    for (i = 0, n = removeGroups.length; i < n; ++i) {
      removeGroups[i].clear();
    }
  }
  if (removeGroups) {
    me.remove(removeGroups);
  }
}, onCollectionSort:function(source) {
  var me = this, sorters = source.getSorters(false), items, length, i, group;
  if (sorters) {
    items = me.items;
    length = me.length;
    for (i = 0; i < length; ++i) {
      group = items[i];
      if (group.getSorters() !== sorters) {
        group.setSorters(sorters);
      }
    }
  }
}, onCollectionUpdateKey:function(source, details) {
  if (!details.indexChanged) {
    details.oldIndex = source.indexOf(details.item);
    this.syncItemGrouping(source, details);
  }
}, addItemsToGroups:function(source, items, at, oldIndex) {
  var me = this, itemGroupKeys = me.itemGroupKeys || (me.itemGroupKeys = {}), entries = me.createEntries(source, items).entries, index = -1, sourceStartIndex, entry, i, len, j, group, firstIndex, item;
  for (i = 0, len = entries.length; i < len; ++i) {
    entry = entries[i];
    group = entry.group;
    if (oldIndex || oldIndex === 0) {
      item = items[0];
      if (group.getCount() > 0 && source.getSorters().getCount() === 0) {
        firstIndex = source.indexOf(group.items[0]);
        if (oldIndex < firstIndex) {
          index = 0;
        } else {
          index = oldIndex - firstIndex;
        }
      }
      if (index === -1) {
        group.add(item);
      } else {
        group.insert(index, item);
      }
    } else {
      if (me.length > 1 && at) {
        sourceStartIndex = source.indexOf(entries[0].group.getAt(0));
        at = Math.max(at - sourceStartIndex, 0);
      }
      entry.group.insert(at != null ? at : group.items.length, entry.items);
      for (j = 0; j < entry.items.length; j++) {
        itemGroupKeys[source.getKey(entry.items[j])] = entry.group;
      }
    }
  }
  me.sortItems();
}, createEntries:function(source, items) {
  var me = this, groups = {}, entries = [], grouper = me.getGrouper(), entry, group, groupKey, i, item, len;
  for (i = 0, len = items.length; i < len; ++i) {
    groupKey = grouper.getGroupString(item = items[i]);
    if (!(entry = groups[groupKey])) {
      group = me.getGroup(source, groupKey);
      entries.push(groups[groupKey] = entry = {group:group, items:[]});
    }
    entry.items.push(item);
  }
  return {groups:groups, entries:entries};
}, syncItemGrouping:function(source, details) {
  var me = this, itemGroupKeys = me.itemGroupKeys || (me.itemGroupKeys = {}), item = details.item, oldKey, itemKey, oldGroup, group;
  itemKey = source.getKey(item);
  oldKey = 'oldKey' in details ? details.oldKey : itemKey;
  oldGroup = itemGroupKeys[oldKey];
  group = me.getGroup(source, me.getGrouper().getGroupString(item));
  details.group = group;
  details.oldGroup = oldGroup;
  if (!(details.groupChanged = group !== oldGroup)) {
    oldGroup.itemChanged(item, details.modified, details.oldKey, details);
  } else {
    if (oldGroup) {
      oldGroup.updateKey(item, oldKey, itemKey);
      oldGroup.remove(item);
      if (!oldGroup.length) {
        me.remove(oldGroup);
      }
    }
    me.addItemsToGroups(source, [item], null, details.oldIndex);
  }
  delete itemGroupKeys[oldKey];
  itemGroupKeys[itemKey] = group;
}, getGroup:function(source, key) {
  var me = this, group = me.get(key), autoSort = me.getAutoSort();
  if (group) {
    group.setSorters(source.getSorters());
  } else {
    group = me.emptyGroups[key] || Ext.create(Ext.apply({xclass:'Ext.util.Group', groupKey:key, rootProperty:me.getItemRoot(), sorters:source.getSorters()}, me.getGroupConfig()));
    group.ejectTime = null;
    me.setAutoSort(false);
    me.add(group);
    me.setAutoSort(autoSort);
  }
  return group;
}, getKey:function(item) {
  return item.getGroupKey();
}, createSortFn:function() {
  var me = this, grouper = me.getGrouper(), sorterFn = me.getSorters().getSortFn();
  if (!grouper) {
    return sorterFn;
  }
  return function(lhs, rhs) {
    return grouper.sort(lhs.items[0], rhs.items[0]) || sorterFn(lhs, rhs);
  };
}, updateGrouper:function(grouper) {
  var me = this;
  me.grouped = !!(grouper && me.$groupable.getAutoGroup());
  me.onSorterChange();
  me.onEndUpdateSorters(me.getSorters());
}, destroy:function() {
  var me = this;
  me.$groupable = null;
  me.destroyGroups(me.items);
  Ext.undefer(me.checkRemoveQueueTimer);
  me.callParent();
}, privates:{destroyGroups:function(groups) {
  var len = groups.length, i;
  for (i = 0; i < len; ++i) {
    groups[i].destroy();
  }
}, onGroupRemove:function(collection, info) {
  var me = this, groups = info.items, emptyGroups = me.emptyGroups, len, group, i;
  groups = Ext.Array.from(groups);
  for (i = 0, len = groups.length; i < len; i++) {
    group = groups[i];
    group.setSorters(null);
    emptyGroups[group.getGroupKey()] = group;
    group.ejectTime = Ext.now();
  }
  me.checkRemoveQueue();
}, checkRemoveQueue:function() {
  var me = this, emptyGroups = me.emptyGroups, groupKey, group, reschedule;
  for (groupKey in emptyGroups) {
    group = emptyGroups[groupKey];
    if (!group.getCount() && Ext.now() - group.ejectTime > me.emptyGroupRetainTime) {
      Ext.destroy(group);
      delete emptyGroups[groupKey];
    } else {
      reschedule = true;
    }
  }
  if (reschedule) {
    Ext.undefer(me.checkRemoveQueueTimer);
    me.checkRemoveQueueTimer = Ext.defer(me.checkRemoveQueue, me.emptyGroupRetainTime, me);
  }
}}});
Ext.define('Ext.data.Store', {extend:Ext.data.ProxyStore, alias:'store.store', mixins:[Ext.data.LocalStore], config:{data:undefined, clearRemovedOnLoad:true, clearOnPageLoad:true, associatedEntity:null, role:null, session:null}, addRecordsOptions:{addRecords:true}, loadCount:0, complete:false, moveMapCount:0, constructor:function(config) {
  var me = this, data;
  if (config) {
    if (config.buffered) {
      if (this.self !== Ext.data.Store) {
        Ext.raise('buffered config not supported on derived Store classes. ' + 'Please derive from Ext.data.BufferedStore.');
      }
      return new Ext.data['BufferedStore'](config);
    }
    if (config.remoteGroup) {
      Ext.log.warn('Ext.data.Store: remoteGroup has been removed. Use remoteSort instead.');
    }
  }
  me.callParent([config]);
  data = me.inlineData;
  if (data) {
    delete me.inlineData;
    me.loadInlineData(data);
  }
}, applyData:function(data, dataCollection) {
  var me = this;
  me.getFields();
  me.getModel();
  if (data && data.isCollection) {
    dataCollection = data;
  } else {
    if (!dataCollection) {
      dataCollection = me.constructDataCollection();
    }
    if (data) {
      if (me.isInitializing) {
        me.inlineData = data;
      } else {
        me.loadData(data);
      }
    }
  }
  return dataCollection;
}, loadInlineData:function(data) {
  var me = this, proxy = me.getProxy();
  if (proxy && proxy.isMemoryProxy) {
    proxy.setData(data);
    me.suspendEvents();
    me.read();
    me.resumeEvents();
  } else {
    me.removeAll(true);
    me.suspendEvents();
    me.loadData(data);
    me.resumeEvents();
  }
}, onCollectionAdd:function(collection, info) {
  this.loadCount = this.loadCount || 1;
  this.onCollectionAddItems(collection, info.items, info);
}, onCollectionFilterAdd:function(collection, items) {
  this.onCollectionAddItems(collection, items);
}, onCollectionAddItems:function(collection, records, info) {
  var me = this, len = records.length, lastChunk = info ? !info.next : false, removed = me.removed, ignoreAdd = me.ignoreCollectionAdd, session = me.getSession(), replaced = info && info.replaced, i, sync, record, replacedItems;
  if (me.activeRanges) {
    me.syncActiveRanges();
  }
  for (i = 0; i < len; ++i) {
    record = records[i];
    if (session) {
      session.adopt(record);
    }
    if (!ignoreAdd) {
      record.join(me);
      if (removed && removed.length) {
        Ext.Array.remove(removed, record);
      }
      sync = sync || record.phantom || record.dirty;
    }
  }
  if (ignoreAdd) {
    return;
  }
  if (replaced) {
    replacedItems = [];
    do {
      Ext.Array.push(replacedItems, replaced.items);
      replaced = replaced.next;
    } while (replaced);
    me.setMoving(replacedItems, true);
  }
  if (info) {
    if (info.replaced) {
      if (lastChunk) {
        me.fireEvent('datachanged', me);
        me.fireEvent('refresh', me);
      }
    } else {
      me.fireEvent('add', me, records, info.at);
      if (lastChunk) {
        me.fireEvent('datachanged', me);
      }
    }
  }
  if (replacedItems) {
    me.setMoving(replacedItems, false);
  }
  me.needsSync = me.needsSync || sync;
}, onCollectionBeforeItemChange:function(collection, info) {
  var record = info.item, modifiedFieldNames = info.modified || null, type = info.meta;
  this.fireEvent('beforeupdate', this, record, type, modifiedFieldNames, info);
}, onCollectionFilteredItemChange:function() {
  this.onCollectionItemChange.apply(this, arguments);
}, onCollectionItemChange:function(collection, info) {
  var me = this, record = info.item, modifiedFieldNames = info.modified || null, type = info.meta;
  if (me.fireChangeEvent(record)) {
    me.onUpdate(record, type, modifiedFieldNames, info);
    me.fireEvent('update', me, record, type, modifiedFieldNames, info);
    me.fireEvent('datachanged', me);
  }
}, afterChange:function(record, modifiedFieldNames, type) {
  this.getData().itemChanged(record, modifiedFieldNames || null, undefined, type);
}, afterCommit:function(record, modifiedFieldNames) {
  this.afterChange(record, modifiedFieldNames, Ext.data.Model.COMMIT);
}, afterEdit:function(record, modifiedFieldNames) {
  this.needsSync = this.needsSync || record.dirty;
  this.afterChange(record, modifiedFieldNames, Ext.data.Model.EDIT);
}, afterReject:function(record) {
  this.afterChange(record, null, Ext.data.Model.REJECT);
}, afterDrop:function(record) {
  this.getData().remove(record);
}, afterErase:function(record) {
  this.removeFromRemoved(record);
}, addSorted:function(record) {
  var me = this, remote = me.getRemoteSort(), data = me.getData(), index;
  if (remote) {
    data.setSorters(me.getSorters());
  }
  index = data.findInsertionIndex(record);
  if (remote) {
    data.setSorters(null);
  }
  return me.insert(index, record);
}, remove:function(records, isMove, silent) {
  var me = this, data = me.getDataSource(), len, i, toRemove, record;
  if (records) {
    if (records.isModel) {
      if (data.indexOf(records) > -1) {
        toRemove = [records];
        len = 1;
      } else {
        len = 0;
      }
    } else {
      toRemove = [];
      for (i = 0, len = records.length; i < len; ++i) {
        record = records[i];
        if (record && record.isEntity) {
          if (!data.contains(record)) {
            continue;
          }
        } else {
          if (!(record = data.getAt(record))) {
            continue;
          }
        }
        toRemove.push(record);
      }
      len = toRemove.length;
    }
  }
  if (!len) {
    return [];
  }
  me.removeIsMove = isMove === true;
  me.removeIsSilent = silent;
  data.remove(toRemove);
  me.removeIsSilent = false;
  return toRemove;
}, onCollectionRemove:function(collection, info) {
  var me = this, removed = me.removed, records = info.items, len = records.length, index = info.at, replacement = info.replacement, isMove = me.removeIsMove || replacement && Ext.Array.equals(records, replacement.items), silent = me.removeIsSilent, lastChunk = !info.next, data = me.getDataSource(), i, record;
  if (me.ignoreCollectionRemove) {
    return;
  }
  if (replacement) {
    me.setMoving(replacement.items, true);
  }
  for (i = len - 1; i >= 0; i--) {
    record = records[i];
    if (!data.contains(record)) {
      if (removed && !isMove && !record.phantom && !record.erasing) {
        record.removedFrom = index + i;
        removed.push(record);
        me.needsSync = true;
      } else {
        record.unjoin(me);
      }
    }
  }
  if (!silent) {
    if (!replacement || !replacement.items.length) {
      me.fireEvent('remove', me, records, index, isMove);
      if (lastChunk) {
        me.fireEvent('datachanged', me);
      }
    }
  }
  if (replacement) {
    me.setMoving(replacement.items, false);
  }
}, onFilterEndUpdate:function() {
  var me = this;
  if (me.destroying || me.destroyed) {
    return;
  }
  if (me.activeRanges) {
    me.syncActiveRanges();
  }
  me.callParent(arguments);
  me.callObservers('Filter');
}, removeAt:function(index, count) {
  var data = this.getData();
  index = Math.max(index, 0);
  if (index < data.length) {
    if (arguments.length === 1) {
      count = 1;
    } else {
      if (!count) {
        return;
      }
    }
    data.removeAt(index, count);
  }
}, removeAll:function(silent) {
  var me = this, data = me.getData(), records = data.getRange();
  if (data.length) {
    me.removeIsSilent = true;
    me.callObservers('BeforeRemoveAll');
    data.removeAll();
    me.removeIsSilent = false;
    if (!silent) {
      me.fireEvent('clear', me, records);
      me.fireEvent('datachanged', me);
    }
    me.callObservers('AfterRemoveAll', [!!silent]);
  }
  return records;
}, setRecords:function(records) {
  var count = this.getCount();
  ++this.loadCount;
  if (count) {
    this.getData().splice(0, count, records);
  } else {
    this.add(records);
  }
}, splice:function(index, toRemove, toAdd) {
  return this.getData().splice(index, toRemove, toAdd);
}, onProxyLoad:function(operation) {
  var me = this, resultSet = operation.getResultSet(), records = operation.getRecords(), successful = operation.wasSuccessful();
  if (me.destroyed) {
    return;
  }
  if (resultSet) {
    me.totalCount = resultSet.getTotal();
  }
  if (successful) {
    records = me.processAssociation(records);
    me.loadRecords(records, operation.getAddRecords() ? {addRecords:true} : undefined);
    me.attachSummaryRecord(resultSet);
  } else {
    me.loading = false;
  }
  if (me.hasListeners.load) {
    me.fireEvent('load', me, records, successful, operation);
  }
  me.callObservers('AfterLoad', [records, successful, operation]);
}, onProxyWrite:function(operation) {
  if (operation.wasSuccessful()) {
    this.attachSummaryRecord(operation.getResultSet());
  }
  this.callParent([operation]);
}, filterDataSource:function(fn) {
  var source = this.getDataSource(), items = source.items, len = items.length, ret = [], i;
  for (i = 0; i < len; i++) {
    if (fn.call(source, items[i])) {
      ret.push(items[i]);
    }
  }
  return ret;
}, getNewRecords:function() {
  return this.filterDataSource(this.filterNew);
}, getRejectRecords:function() {
  return this.filterDataSource(this.filterRejects);
}, getUpdatedRecords:function() {
  return this.filterDataSource(this.filterUpdated);
}, loadData:function(data, append) {
  var me = this, length = data.length, newData = [], i;
  for (i = 0; i < length; i++) {
    newData.push(me.createModel(data[i]));
  }
  newData = me.processAssociation(newData);
  me.loadRecords(newData, append ? me.addRecordsOptions : undefined);
}, loadRawData:function(data, append) {
  var me = this, session = me.getSession(), result = me.getProxy().getReader().read(data, session ? {recordCreator:session.recordCreator} : undefined), records = result.getRecords(), success = result.getSuccess();
  if (success) {
    me.totalCount = result.getTotal();
    me.loadRecords(records, append ? me.addRecordsOptions : undefined);
  }
  return success;
}, loadRecords:function(records, options) {
  var me = this, length = records.length, data = me.getData(), addRecords, i, skipSort;
  if (options) {
    addRecords = options.addRecords;
  }
  if (!me.getRemoteSort() && !me.getSortOnLoad()) {
    skipSort = true;
    data.setAutoSort(false);
  }
  if (!addRecords) {
    me.clearData(true);
  }
  me.loading = false;
  me.ignoreCollectionAdd = true;
  me.callObservers('BeforePopulate');
  data.add(records);
  me.ignoreCollectionAdd = false;
  if (skipSort) {
    data.setAutoSort(true);
  }
  for (i = 0; i < length; i++) {
    records[i].join(me);
  }
  if (!me.isEmptyStore) {
    ++me.loadCount;
    me.complete = true;
  }
  if (me.hasListeners.datachanged) {
    me.fireEvent('datachanged', me);
  }
  if (me.hasListeners.refresh) {
    me.fireEvent('refresh', me);
  }
  me.callObservers('AfterPopulate');
}, loadPage:function(page, options) {
  var me = this, size = me.getPageSize();
  me.currentPage = page;
  options = Ext.apply({page:page, start:(page - 1) * size, limit:size, addRecords:!me.getClearOnPageLoad()}, options);
  me.read(options);
}, nextPage:function(options) {
  this.loadPage(this.currentPage + 1, options);
}, previousPage:function(options) {
  this.loadPage(this.currentPage - 1, options);
}, clearData:function(isLoad) {
  var me = this, removed = me.removed, data = me.getDataSource(), clearRemovedOnLoad = me.getClearRemovedOnLoad(), needsUnjoinCheck = removed && isLoad && !clearRemovedOnLoad, records, record, i, len;
  if (data) {
    records = data.items;
    for (i = 0, len = records.length; i < len; ++i) {
      record = records[i];
      if (needsUnjoinCheck && Ext.Array.contains(removed, record)) {
        continue;
      }
      record.unjoin(me);
    }
    me.ignoreCollectionRemove = true;
    me.callObservers('BeforeClear');
    data.removeAll();
    me.ignoreCollectionRemove = false;
    me.callObservers('AfterClear');
  }
  if (removed && (!isLoad || clearRemovedOnLoad)) {
    removed.length = 0;
  }
}, onIdChanged:function(rec, oldId, newId) {
  this.getData().updateKey(rec, oldId);
  this.fireEvent('idchanged', this, rec, oldId, newId);
}, commitChanges:function() {
  var me = this, recs = me.getModifiedRecords(), len = recs.length, i = 0;
  Ext.suspendLayouts();
  me.beginUpdate();
  for (; i < len; i++) {
    recs[i].commit();
  }
  me.cleanRemoved();
  me.endUpdate();
  Ext.resumeLayouts(true);
  me.fireEvent('commit', me);
}, filterNewOnly:function(item) {
  return item.phantom === true;
}, filterRejects:function(item) {
  return item.phantom || item.dirty;
}, rejectChanges:function() {
  var me = this, recs = me.getRejectRecords(), len = recs.length, i, rec, toRemove, sorted, data, currentAutoSort;
  Ext.suspendLayouts();
  me.beginUpdate();
  for (i = 0; i < len; i++) {
    rec = recs[i];
    if (rec.phantom) {
      toRemove = toRemove || [];
      toRemove.push(rec);
    } else {
      rec.reject();
    }
  }
  if (toRemove) {
    me.remove(toRemove);
    for (i = 0, len = toRemove.length; i < len; ++i) {
      toRemove[i].reject();
    }
  }
  recs = me.getRawRemovedRecords();
  if (recs) {
    len = recs.length;
    sorted = !me.getRemoteSort() && me.isSorted();
    if (sorted) {
      data = me.getData();
      currentAutoSort = data.getAutoSort();
      data.setAutoSort(false);
    }
    for (i = len - 1; i >= 0; i--) {
      rec = recs[i];
      rec.reject();
      if (!sorted) {
        me.insert(rec.removedFrom || 0, rec);
      }
    }
    if (sorted) {
      data.setAutoSort(currentAutoSort);
      me.add(recs);
    }
    recs.length = 0;
  }
  me.endUpdate();
  Ext.resumeLayouts(true);
  me.fireEvent('reject', me);
}, doDestroy:function() {
  var me = this, task = me.loadTask, data = me.getData(), source = data.getSource();
  me.clearData();
  me.setSession(null);
  me.observers = null;
  if (task) {
    task.cancel();
    me.loadTask = null;
  }
  if (source) {
    source.destroy();
  }
  me.callParent();
}, privates:{commitOptions:{commit:true}, attachSummaryRecord:function(resultSet) {
  if (!resultSet) {
    return;
  }
  var me = this, summary = resultSet.getSummaryData(), grouper = me.getGrouper(), current = me.summaryRecord, commitOptions = me.commitOptions, groups, len, i, rec, group;
  if (summary) {
    if (current) {
      current.set(summary.data, commitOptions);
    } else {
      me.summaryRecord = summary;
      summary.isRemote = true;
    }
  }
  if (grouper) {
    summary = resultSet.getGroupData();
    if (summary) {
      groups = me.getGroups();
      for (i = 0, len = summary.length; i < len; ++i) {
        rec = summary[i];
        group = groups.getItemGroup(rec);
        if (group) {
          current = group.summaryRecord;
          if (current) {
            current.set(rec.data, commitOptions);
          } else {
            group.summaryRecord = rec;
            rec.isRemote = true;
          }
        }
      }
    }
  }
}, fetch:function(options) {
  options = Ext.apply({}, options);
  this.setLoadOptions(options);
  var operation = this.createOperation('read', options);
  operation.execute();
}, fireChangeEvent:function(record) {
  return this.getDataSource().contains(record);
}, onBeforeLoad:function(operation) {
  this.callObservers('BeforeLoad', [operation]);
}, onRemoteFilterSet:function(filters, remoteFilter) {
  if (filters) {
    this.getData().setFilters(remoteFilter ? null : filters);
  }
  this.callParent([filters, remoteFilter]);
}, onRemoteSortSet:function(sorters, remoteSort) {
  var data = this.getData();
  if (sorters) {
    data.setSorters(remoteSort ? null : sorters);
  }
  data.setAutoGroup(!remoteSort);
  this.callParent([sorters, remoteSort]);
}, isMoving:function(records, getMap) {
  var map = this.moveMap, moving = 0, len, i;
  if (map) {
    if (records) {
      if (Ext.isArray(records)) {
        for (i = 0, len = records.length; i < len; ++i) {
          moving += map[records[i].id] ? 1 : 0;
        }
      } else {
        if (map[records.id]) {
          ++moving;
        }
      }
    } else {
      moving = getMap ? map : this.moveMapCount;
    }
  }
  return moving;
}, setLoadOptions:function(options) {
  var me = this, pageSize = me.getPageSize(), session, grouper;
  if (me.getRemoteSort() && !options.grouper) {
    grouper = me.getGrouper();
    if (grouper) {
      options.grouper = grouper;
    }
  }
  if (pageSize || 'start' in options || 'limit' in options || 'page' in options) {
    options.page = options.page != null ? options.page : me.currentPage;
    options.start = options.start !== undefined ? options.start : (options.page - 1) * pageSize;
    options.limit = options.limit != null ? options.limit : pageSize;
    me.currentPage = options.page;
  }
  options.addRecords = options.addRecords || false;
  if (!options.recordCreator) {
    session = me.getSession();
    if (session) {
      options.recordCreator = session.recordCreator;
    }
  }
  me.callParent([options]);
}, setMoving:function(records, isMoving) {
  var me = this, map = me.moveMap || (me.moveMap = {}), len = records.length, i, id;
  for (i = 0; i < len; ++i) {
    id = records[i].id;
    if (isMoving) {
      if (map[id]) {
        ++map[id];
      } else {
        map[id] = 1;
        ++me.moveMapCount;
      }
    } else {
      if (--map[id] === 0) {
        delete map[id];
        --me.moveMapCount;
      }
    }
  }
  if (me.moveMapCount === 0) {
    me.moveMap = null;
  }
}, processAssociation:function(records) {
  var me = this, associatedEntity = me.getAssociatedEntity();
  if (associatedEntity) {
    records = me.getRole().processLoad(me, associatedEntity, records, me.getSession());
  }
  return records;
}}});
Ext.define('Ext.data.reader.Array', {extend:Ext.data.reader.Json, alternateClassName:'Ext.data.ArrayReader', alias:'reader.array', config:{totalProperty:undefined, successProperty:undefined}, createFieldAccessor:function(field) {
  var oldMap = field.mapping, index = field.hasMapping() ? oldMap : field.ordinal, result;
  field.mapping = index;
  result = this.callParent(arguments);
  field.mapping = oldMap;
  return result;
}, getModelData:function(raw) {
  return {};
}});
Ext.define('Ext.data.ArrayStore', {extend:Ext.data.Store, alias:'store.array', alternateClassName:['Ext.data.SimpleStore'], config:{proxy:{type:'memory', reader:'array'}}, loadData:function(data, append) {
  if (this.expandData) {
    var r = [], i = 0, ln = data.length;
    for (; i < ln; i++) {
      r[r.length] = [data[i]];
    }
    data = r;
  }
  this.callParent([data, append]);
}});
Ext.define('Ext.data.StoreManager', {extend:Ext.util.MixedCollection, alternateClassName:['Ext.StoreMgr', 'Ext.data.StoreMgr', 'Ext.StoreManager'], singleton:true, register:function() {
  for (var i = 0, s; s = arguments[i]; i++) {
    this.add(s);
  }
}, unregister:function() {
  for (var i = 0, s; s = arguments[i]; i++) {
    this.remove(this.lookup(s));
  }
}, lookup:function(store, defaultType) {
  if (Ext.isArray(store)) {
    var first = store[0], data = store, arrays, fields, i, len;
    if (Ext.isObject(first)) {
      store = {data:data};
    } else {
      arrays = Ext.isArray(first);
      fields = ['field1'];
      if (arrays) {
        for (i = 2, len = first.length; i <= len; ++i) {
          fields.push('field' + i);
        }
      } else {
        data = [];
        for (i = 0, len = store.length; i < len; ++i) {
          data.push([store[i]]);
        }
      }
      return new Ext.data.ArrayStore({data:data, fields:fields, autoDestroy:true, autoCreated:true, expanded:!arrays});
    }
  }
  if (Ext.isString(store)) {
    return this.get(store);
  } else {
    return Ext.Factory.store(store, defaultType);
  }
}, getKey:function(o) {
  return o.storeId;
}, addEmptyStore:function() {
  var emptyStore = this.$emptyStore, destoryable = {destroy:Ext.emptyFn};
  if (!emptyStore) {
    emptyStore = this.$emptyStore = Ext.regStore('ext-empty-store', {proxy:'memory', useModelWarning:false});
    emptyStore.isEmptyStore = true;
    emptyStore.on = emptyStore.addListener = function() {
      return destoryable;
    };
    emptyStore.un = emptyStore.removeListener = Ext.emptyFn;
    emptyStore.add = emptyStore.remove = emptyStore.insert = emptyStore.destroy = emptyStore.loadData = function() {
      Ext.raise('Cannot modify ext-empty-store');
    };
  }
  this.add(emptyStore);
}, clear:function() {
  this.callParent();
  this.addEmptyStore();
}}, function() {
  Ext.regStore = function(id, config) {
    var store;
    if (Ext.isObject(id)) {
      config = id;
    } else {
      if (Ext.data.StoreManager.containsKey(id)) {
        return Ext.data.StoreManager.lookup(id);
      }
      config.storeId = id;
    }
    if (config instanceof Ext.data.Store) {
      store = config;
    } else {
      store = new Ext.data.Store(config);
    }
    Ext.data.StoreManager.register(store);
    return store;
  };
  Ext.getStore = function(name) {
    return Ext.data.StoreManager.lookup(name);
  };
  Ext.data.StoreManager.addEmptyStore();
});
Ext.define('Ext.app.domain.Store', {extend:Ext.app.EventDomain, singleton:true, type:'store', prefix:'store.', idMatchRe:/^#/, constructor:function() {
  var me = this;
  me.callParent();
  me.monitor(Ext.data.AbstractStore);
}, match:function(target, selector) {
  var result = false, alias = target.alias;
  if (selector === '*') {
    result = true;
  } else {
    if (this.idMatchRe.test(selector)) {
      result = target.getStoreId() === selector.substring(1);
    } else {
      if (alias) {
        result = Ext.Array.indexOf(alias, this.prefix + selector) > -1;
      }
    }
  }
  return result;
}});
Ext.define('Ext.app.Controller', {extend:Ext.app.BaseController, statics:{strings:{model:{getter:'getModel', upper:'Model'}, view:{getter:'getView', upper:'View'}, controller:{getter:'getController', upper:'Controller'}, store:{getter:'getStore', upper:'Store'}, profile:{getter:'getProfile', upper:'Profiles'}}, controllerRegex:/^(.*)\.controller\./, profileRegex:/^(.*)\.profile\./, createGetter:function(baseGetter, name) {
  return function() {
    return this[baseGetter](name);
  };
}, getGetterName:function(name, kindUpper) {
  var fn = 'get', parts = name.split('.'), numParts = parts.length, index;
  for (index = 0; index < numParts; index++) {
    fn += Ext.String.capitalize(parts[index]);
  }
  fn += kindUpper;
  return fn;
}, resolveNamespace:function(cls, data) {
  var Controller = Ext.app.Controller, namespaceRe = cls.prototype.isProfile ? Controller.profileRegex : Controller.controllerRegex, className, namespace, match;
  className = Ext.getClassName(cls);
  namespace = data.$namespace || data.namespace || Ext.app.getNamespace(className) || (match = namespaceRe.exec(className)) && match[1];
  if (!namespace) {
    Ext.log.warn('Missing namespace for ' + className + ', please define it ' + 'in namespaces property of your Application class.');
  }
  return namespace;
}, processDependencies:function(cls, requires, namespace, kind, names, profileName) {
  if (!names || !names.length) {
    return;
  }
  var me = this, strings = me.strings[kind], o, absoluteName, shortName, name, j, subLn, getterName, getter;
  if (!Ext.isArray(names)) {
    names = [names];
  }
  for (j = 0, subLn = names.length; j < subLn; j++) {
    name = names[j];
    o = me.getFullName(name, kind, namespace, profileName);
    names[j] = absoluteName = o.absoluteName;
    shortName = o.shortName;
    requires.push(absoluteName);
    getterName = me.getGetterName(shortName, strings.upper);
    if (!cls[getterName]) {
      cls[getterName] = getter = me.createGetter(strings.getter, name);
    } else {
      if (getterName === 'getMainView') {
        Ext.log.warn("Cannot have a view named 'Main' - getter conflicts with mainView config.");
      }
    }
    if (getter && kind !== 'controller') {
      getter['Ext.app.getter'] = true;
    }
  }
}, getFullName:function(name, kind, namespace, profileName) {
  var shortName = name, sep, absoluteName;
  if ((sep = name.indexOf('@')) > 0) {
    shortName = name.substring(0, sep);
    absoluteName = name.substring(sep + 1) + '.' + shortName;
  } else {
    if (name.indexOf('.') > 0 && (Ext.ClassManager.isCreated(name) || this.hasRegisteredPrefix(name))) {
      absoluteName = name;
      shortName = name.replace(namespace + '.' + kind + '.', '');
    } else {
      if (!namespace) {
        Ext.log.warn('Cannot find namespace for ' + kind + ' ' + name + ', ' + 'assuming it is fully qualified class name');
      }
      if (namespace) {
        absoluteName = namespace + '.' + kind + '.' + (profileName ? profileName + '.' + name : name);
        shortName = name;
      } else {
        absoluteName = name;
      }
    }
  }
  return {absoluteName:absoluteName, shortName:shortName};
}, hasRegisteredPrefix:function(className) {
  var inventory = Ext.ClassManager, prefix = inventory.getPrefix(className);
  return prefix && prefix !== className;
}}, models:null, views:null, stores:null, controllers:null, config:{application:null, refs:null, active:true, moduleClassName:null}, onClassExtended:function(cls, data, hooks) {
  var onBeforeClassCreated = hooks.onBeforeCreated;
  hooks.onBeforeCreated = function(cls, data) {
    var Controller = Ext.app.Controller, requires = [], namespace, proto;
    proto = cls.prototype;
    namespace = Controller.resolveNamespace(cls, data);
    if (namespace) {
      proto.$namespace = namespace;
    }
    Controller.processDependencies(proto, requires, namespace, 'model', data.models);
    Controller.processDependencies(proto, requires, namespace, 'view', data.views);
    Controller.processDependencies(proto, requires, namespace, 'store', data.stores);
    Controller.processDependencies(proto, requires, namespace, 'controller', data.controllers);
    Ext.require(requires, Ext.Function.pass(onBeforeClassCreated, arguments, this));
  };
}, constructor:function(config) {
  this.initAutoGetters();
  this.callParent([config]);
}, normalizeRefs:function(refs) {
  var me = this, newRefs = [];
  if (refs) {
    if (Ext.isObject(refs)) {
      Ext.Object.each(refs, function(key, value) {
        if (Ext.isString(value)) {
          value = {selector:value};
        }
        value.ref = key;
        newRefs.push(value);
      });
    } else {
      if (Ext.isArray(refs)) {
        newRefs = Ext.Array.merge(newRefs, refs);
      }
    }
  }
  refs = me.refs;
  if (refs) {
    me.refs = null;
    refs = me.normalizeRefs(refs);
    if (refs) {
      newRefs = Ext.Array.merge(newRefs, refs);
    }
  }
  return newRefs;
}, getRefMap:function() {
  var me = this, refMap = me._refMap, refs, ref, ln, i;
  if (!refMap) {
    refs = me.getRefs();
    refMap = me._refMap = {};
    if (refs) {
      for (i = 0, ln = refs.length; i < ln; i++) {
        ref = refs[i];
        refMap[ref.ref] = ref.selector;
      }
    }
  }
  return refMap;
}, applyId:function(id) {
  return id || Ext.app.Controller.getFullName(this.$className, 'controller', this.$namespace).shortName;
}, applyRefs:function(refs) {
  return this.normalizeRefs(Ext.clone(refs));
}, updateRefs:function(refs) {
  if (refs) {
    this.ref(refs);
  }
}, initAutoGetters:function() {
  var proto = this.self.prototype, prop, fn;
  for (prop in proto) {
    fn = proto[prop];
    if (fn && fn['Ext.app.getter']) {
      fn.call(this);
    }
  }
}, doInit:function(app) {
  var me = this;
  if (!me._initialized) {
    me.init(app);
    me._initialized = true;
  }
}, finishInit:function(app) {
  var me = this, controllers = me.controllers, controller, i, l;
  if (me._initialized && controllers && controllers.length) {
    for (i = 0, l = controllers.length; i < l; i++) {
      controller = me.getController(controllers[i]);
      controller.finishInit(app);
    }
  }
}, init:Ext.emptyFn, onLaunch:Ext.emptyFn, activate:function() {
  this.setActive(true);
}, deactivate:function() {
  this.setActive(false);
}, isActive:function() {
  return this.getActive();
}, ref:function(refs) {
  var me = this, i = 0, length = refs.length, info, ref, fn;
  refs = Ext.Array.from(refs);
  me.references = me.references || [];
  for (; i < length; i++) {
    info = refs[i];
    ref = info.ref;
    fn = 'get' + Ext.String.capitalize(ref);
    if (!me[fn]) {
      me[fn] = Ext.Function.pass(me.getRef, [ref, info], me);
    }
    me.references.push(ref.toLowerCase());
  }
}, addRef:function(refs) {
  this.ref(refs);
}, getRef:function(ref, info, config) {
  var me = this, refCache = me.refCache || (me.refCache = {}), cached = refCache[ref];
  info = info || {};
  config = config || {};
  Ext.apply(info, config);
  if (info.forceCreate) {
    return Ext.ComponentManager.create(info, 'component');
  }
  if (!cached) {
    if (info.selector) {
      refCache[ref] = cached = Ext.ComponentQuery.query(info.selector)[0];
    }
    if (!cached && info.autoCreate) {
      refCache[ref] = cached = Ext.ComponentManager.create(info, 'component');
    }
    if (cached) {
      cached.on('destroy', function() {
        refCache[ref] = null;
      });
    }
  }
  return cached;
}, hasRef:function(ref) {
  var references = this.references;
  return references && Ext.Array.indexOf(references, ref.toLowerCase()) !== -1;
}, getController:function(id) {
  var app = this.getApplication();
  if (id === this.getId()) {
    return this;
  }
  return app && app.getController(id);
}, getStore:function(name) {
  var storeId, store;
  storeId = name.indexOf('@') === -1 ? name : name.split('@')[0];
  store = Ext.StoreManager.get(storeId);
  if (!store) {
    name = Ext.app.Controller.getFullName(name, 'store', this.$namespace);
    if (name) {
      store = Ext.create(name.absoluteName, {id:storeId});
    }
  }
  return store;
}, getModel:function(modelName) {
  var name = Ext.app.Controller.getFullName(modelName, 'model', this.$namespace), ret = Ext.ClassManager.get(name.absoluteName);
  if (!ret) {
    ret = Ext.data.schema.Schema.lookupEntity(modelName);
  }
  return ret;
}, getProfile:function(name) {
  name = Ext.app.Controller.getFullName(name, 'profile', this.$namespace);
  return name;
}, getView:function(view) {
  var name = Ext.app.Controller.getFullName(view, 'view', this.$namespace);
  return name && Ext.ClassManager.get(name.absoluteName);
}, destroy:function(destroyRefs, fromApp) {
  var me = this, app = me.application, refCache, ref;
  if (!fromApp && app) {
    app.unregister(me);
  }
  me.application = null;
  if (destroyRefs) {
    refCache = me.refCache;
    for (ref in refCache) {
      if (refCache.hasOwnProperty(ref)) {
        Ext.destroy(refCache[ref]);
      }
    }
  }
  me.callParent();
}});
Ext.define('Ext.app.Application', {extend:Ext.app.Controller, isApplication:true, scope:undefined, namespaces:[], paths:null, config:{name:'', appProperty:'app', profiles:[], currentProfile:null, mainView:{$value:null, lazy:true}, defaultToken:null, glyphFontFamily:null, quickTips:true, router:null}, onClassExtended:function(cls, data, hooks) {
  var Controller = Ext.app.Controller, proto = cls.prototype, requires = [], onBeforeClassCreated, paths, namespace, ns;
  namespace = data.name || cls.superclass.name;
  if (namespace) {
    data.$namespace = namespace;
    Ext.app.addNamespaces(namespace);
  }
  if (data.namespaces) {
    Ext.app.addNamespaces(data.namespaces);
  }
  if (data['paths processed']) {
    delete data['paths processed'];
  } else {
    Ext.app.setupPaths(namespace, 'appFolder' in data ? data.appFolder : cls.superclass.appFolder, data.paths);
  }
  Controller.processDependencies(proto, requires, namespace, 'profile', data.profiles);
  proto.getDependencies(cls, data, requires);
  if (requires.length) {
    onBeforeClassCreated = hooks.onBeforeCreated;
    hooks.onBeforeCreated = function(cls, data) {
      var args = Ext.Array.clone(arguments);
      if (data.__handleRequires) {
        data.__handleRequires.call(this, requires, Ext.bind(function() {
          return onBeforeClassCreated.apply(this, args);
        }, this));
        return;
      }
      Ext.require(requires, function() {
        return onBeforeClassCreated.apply(this, args);
      });
    };
  }
}, getDependencies:Ext.emptyFn, constructor:function(config) {
  var me = this;
  Ext.route.Router.application = me;
  me.callParent([config]);
  if (Ext.isEmpty(me.getName())) {
    Ext.raise('[Ext.app.Application] Name property is required');
  }
  me.doInit(me);
  Ext.on('appupdate', me.onAppUpdate, me, {single:true});
  Ext.Loader.setConfig({enabled:true});
  this.onProfilesReady();
}, applyId:function(id) {
  return id || this.$className;
}, updateRouter:function(cfg) {
  if (cfg) {
    Ext.route.Router.setConfig(cfg);
  }
}, onAppUpdate:Ext.emptyFn, onProfilesReady:function() {
  var me = this, profiles = me.getProfiles(), length = profiles.length, current, i, instance;
  for (i = 0; i < length; i++) {
    instance = Ext.create(profiles[i], {application:me});
    if (instance.isActive() && !current) {
      current = instance;
      me.setCurrentProfile(current);
    }
  }
  if (current) {
    current.init();
  }
  me.initControllers();
  me.onBeforeLaunch();
  me.finishInitControllers();
}, doInit:function(app) {
  this.initNamespace(app);
  this.callParent([app]);
}, initNamespace:function(me) {
  var appProperty = me.getAppProperty(), ns = Ext.namespace(me.getName());
  if (ns) {
    ns.getApplication = function() {
      return me;
    };
    if (appProperty) {
      if (!ns[appProperty]) {
        ns[appProperty] = me;
      } else {
        if (ns[appProperty] !== me) {
          Ext.log.warn('An existing reference is being overwritten for ' + name + '.' + appProperty + '. See the appProperty config.');
        }
      }
    }
  }
}, initControllers:function() {
  var me = this, controllers = Ext.Array.from(me.controllers), profile = me.getCurrentProfile(), i, ln;
  me.controllers = new Ext.util.MixedCollection;
  for (i = 0, ln = controllers.length; i < ln; i++) {
    me.getController(controllers[i]);
  }
  if (profile) {
    controllers = profile.getControllers();
    for (i = 0, ln = controllers.length; i < ln; i++) {
      me.getController(controllers[i]);
    }
  }
}, finishInitControllers:function() {
  var me = this, controllers, i, l;
  controllers = me.controllers.getRange();
  for (i = 0, l = controllers.length; i < l; i++) {
    controllers[i].finishInit(me);
  }
}, launch:Ext.emptyFn, onBeforeLaunch:function() {
  var me = this, History = Ext.util.History, defaultToken = me.getDefaultToken(), currentProfile = me.getCurrentProfile(), controllers, c, cLen, controller, token;
  me.initMainView();
  if (currentProfile) {
    currentProfile.launch();
  }
  me.launch.call(me.scope || me);
  me.launched = true;
  me.fireEvent('launch', me);
  controllers = me.controllers.items;
  cLen = controllers.length;
  for (c = 0; c < cLen; c++) {
    controller = controllers[c];
    controller.onLaunch(me);
  }
  if (!History.ready) {
    History.init();
  }
  token = History.getToken();
  if (token || token === defaultToken) {
    Ext.route.Router.onStateChange(token);
  } else {
    if (defaultToken) {
      History.replace(defaultToken);
    }
  }
  if (Ext.Microloader && Ext.Microloader.appUpdate && Ext.Microloader.appUpdate.updated) {
    Ext.Microloader.fireAppUpdate();
  }
  if (!me.cnsTimer) {
    me.cnsTimer = Ext.defer(Ext.ClassManager.clearNamespaceCache, 2000, Ext.ClassManager);
  }
}, getModuleClassName:function(name, kind) {
  return Ext.app.Controller.getFullName(name, kind, this.getName()).absoluteName;
}, initMainView:function() {
  var me = this, currentProfile = me.getCurrentProfile(), mainView;
  if (currentProfile) {
    mainView = currentProfile.getMainView();
  }
  if (mainView) {
    me.setMainView(mainView);
  } else {
    me.getMainView();
  }
}, applyMainView:function(value) {
  var view = this.getView(value);
  return view.create({$initParent:this.viewport});
}, createController:function(name) {
  return this.getController(name);
}, destroyController:function(controller) {
  if (typeof controller === 'string') {
    controller = this.getController(controller, true);
  }
  Ext.destroy(controller);
}, getController:function(name, preventCreate) {
  var me = this, controllers = me.controllers, className, controller, len, i, c, all;
  controller = controllers.get(name);
  if (!controller) {
    all = controllers.items;
    for (i = 0, len = all.length; i < len; ++i) {
      c = all[i];
      className = c.getModuleClassName();
      if (className && className === name) {
        controller = c;
        break;
      }
    }
  }
  if (!controller && !preventCreate) {
    className = me.getModuleClassName(name, 'controller');
    controller = Ext.create(className, {application:me, moduleClassName:className});
    controllers.add(controller);
    if (me._initialized) {
      controller.doInit(me);
    }
  }
  return controller;
}, unregister:function(controller) {
  this.controllers.remove(controller);
}, getApplication:function() {
  return this;
}, destroy:function(destroyRefs) {
  var me = this, controllers = me.controllers, ns = Ext.namespace(me.getName()), appProp = me.getAppProperty();
  Ext.undefer(me.cnsTimer);
  Ext.un('appupdate', me.onAppUpdate, me);
  Ext.destroy(me.viewport);
  if (controllers) {
    controllers.each(function(controller) {
      controller.destroy(destroyRefs, true);
    });
  }
  me.controllers = null;
  me.callParent([destroyRefs, true]);
  if (ns && ns[appProp] === me) {
    delete ns[appProp];
  }
  if (Ext.route.Router.application === me) {
    Ext.route.Router.application = null;
  }
  if (Ext.app.Application.instance === me) {
    Ext.app.Application.instance = null;
  }
}, updateGlyphFontFamily:function(fontFamily) {
  Ext.setGlyphFontFamily(fontFamily);
}, applyProfiles:function(profiles) {
  var me = this;
  return Ext.Array.map(profiles, function(profile) {
    return me.getModuleClassName(profile, 'profile');
  });
}}, function() {
  Ext.getApplication = function() {
    return Ext.app.Application.instance;
  };
});
Ext.application = function(config) {
  var createApp = function(App) {
    Ext.onReady(function() {
      var Viewport = Ext.viewport;
      Viewport = Viewport && Viewport['Viewport'];
      if (Viewport && Viewport.setup) {
        Viewport.setup(App.prototype.config.viewport);
      }
      Ext.app.Application.instance = new App;
    });
  };
  if (typeof config === 'string') {
    Ext.require(config, function() {
      createApp(Ext.ClassManager.get(config));
    });
  } else {
    config = Ext.apply({extend:'Ext.app.Application'}, config);
    Ext.app.setupPaths(config.name, config.appFolder, config.paths);
    config['paths processed'] = true;
    Ext.define(config.name + '.$application', config, function() {
      createApp(this);
    });
  }
};
Ext.define('Ext.util.ItemCollection', {extend:Ext.util.MixedCollection, alternateClassName:'Ext.ItemCollection', getKey:function(item) {
  return item.getItemId && item.getItemId();
}, has:function(item) {
  return this.map.hasOwnProperty(item.getId());
}});
Ext.define('Ext.mixin.Queryable', {mixinId:'queryable', isQueryable:true, query:function(selector) {
  selector = selector || '*';
  return Ext.ComponentQuery.query(selector, this.getQueryRoot());
}, queryBy:function(fn, scope) {
  var out = [], items = this.getQueryRoot().getRefItems(true), i = 0, len = items.length, item;
  for (; i < len; ++i) {
    item = items[i];
    if (fn.call(scope || item, item) !== false) {
      out.push(item);
    }
  }
  return out;
}, queryById:function(id) {
  return this.down(Ext.makeIdSelector(id));
}, child:function(selector) {
  var children = this.getQueryRoot().getRefItems();
  if (selector && selector.isComponent) {
    return this.matchById(children, selector.getItemId());
  }
  if (selector) {
    children = Ext.ComponentQuery.query(selector, children);
  }
  if (children.length) {
    return children[0];
  }
  return null;
}, down:function(selector) {
  if (selector && selector.isComponent) {
    return this.matchById(this.getRefItems(true), selector.getItemId());
  }
  selector = selector || '';
  return this.query(selector)[0] || null;
}, visitPreOrder:function(selector, fn, scope, extraArgs) {
  Ext.ComponentQuery._visit(true, selector, this.getQueryRoot(), fn, scope, extraArgs);
}, visitPostOrder:function(selector, fn, scope, extraArgs) {
  Ext.ComponentQuery._visit(false, selector, this.getQueryRoot(), fn, scope, extraArgs);
}, getRefItems:function() {
  return [];
}, getQueryRoot:function() {
  return this;
}, privates:{matchById:function(items, id) {
  var len = items.length, i, item;
  for (i = 0; i < len; ++i) {
    item = items[i];
    if (item.getItemId() === id) {
      return item;
    }
  }
  return null;
}}});
Ext.define('Ext.mixin.Container', {extend:Ext.Mixin, mixinConfig:{id:'container'}, isContainer:true, nameHolder:false, referenceHolder:false, getNamedItems:function() {
  var CM = Ext.ComponentManager;
  if (CM.referencesDirty) {
    CM.fixReferences();
  }
  return this.nameRefs || null;
}, getReferences:function() {
  var CM = Ext.ComponentManager;
  if (CM.referencesDirty) {
    CM.fixReferences();
  }
  return this.refs || null;
}, lookup:function(ref) {
  var refs = this.getReferences();
  return refs && refs[ref] || null;
}, lookupName:function(name) {
  var items = this.getNamedItems();
  return items && items[name] || null;
}, lookupReference:function(ref) {
  return this.lookup(ref);
}, privates:{attachNameRef:function(component) {
  var me = this, key = component.name || component._name, entry, nameRefs;
  if (key && !me.destroying && !me.destroyed) {
    nameRefs = me.nameRefs || (me.nameRefs = {});
    entry = nameRefs[key];
    if (!entry) {
      entry = component.shareableName ? [component] : component;
    } else {
      if (!entry.isInstance) {
        entry.push(component);
      } else {
        Ext.raise('Duplicate name: "' + key + '" on ' + me.id + ' between ' + entry.id + ' and ' + component.id);
      }
    }
    nameRefs[key] = entry;
  }
}, attachReference:function(component) {
  var me = this, key, refs;
  if (!me.destroying && !me.destroyed) {
    refs = me.refs || (me.refs = {});
    key = component.referenceKey;
    if (refs[key] && refs[key] !== component) {
      Ext.log.warn('Duplicate reference: "' + key + '" on ' + me.id);
    }
    refs[key] = component;
  }
}, containerOnAdded:function(component, instanced) {
  if (instanced) {
    Ext.ComponentManager.markReferencesDirty();
  }
}, containerOnRemoved:function(destroying) {
  if (!destroying) {
    Ext.ComponentManager.markReferencesDirty();
  }
}, initContainerInheritedState:function(inheritedState, inheritedStateInner) {
  var me = this, controller = me.getController(), session = me.getSession(), viewModel = me.getConfig('viewModel', true), reference = me.reference, referenceHolder = me.referenceHolder;
  if (me.nameHolder) {
    inheritedState.nameHolder = me;
  }
  if (controller) {
    inheritedState.referenceHolder = controller;
    referenceHolder = true;
  } else {
    if (referenceHolder) {
      inheritedState.referenceHolder = me;
    }
  }
  if (referenceHolder) {
    inheritedState.referencePath = '';
  } else {
    if (reference && me.isParentReference) {
      inheritedState.referencePath = me.referenceKey + '.';
    }
  }
  if (session) {
    inheritedState.session = session;
  }
  if (viewModel) {
    inheritedState.viewModelPath = '';
  } else {
    if (reference && me.isParentReference) {
      inheritedState.viewModelPath = me.viewModelKey + '.';
    }
  }
}, setupReference:function(reference) {
  var len;
  if (reference && reference.charAt(len = reference.length - 1) === '\x3e') {
    this.isParentReference = true;
    reference = reference.substring(0, len);
  }
  if (reference && !Ext.validIdRe.test(reference)) {
    Ext.Error.raise('Invalid reference "' + reference + '" for ' + this.getId() + ' - not a valid identifier');
  }
  return reference;
}}});
Ext.define('Ext.util.KeyMap', {alternateClassName:'Ext.KeyMap', eventName:'keydown', constructor:function(config) {
  var me = this;
  if (arguments.length !== 1 || typeof config === 'string' || config.dom || config.tagName || config === document || config.isComponent) {
    Ext.raise('Legacy multi-argument KeyMap constructor is removed. Use a config object instead.');
  }
  Ext.apply(me, config);
  me.bindings = [];
  if (!me.target.isComponent) {
    me.target = Ext.get(me.target);
  }
  if (me.binding) {
    me.addBinding(me.binding);
  } else {
    if (config.key) {
      me.addBinding(config);
    }
  }
  me.enable();
}, addBinding:function(binding) {
  var me = this, keyCode = binding.key, i, len;
  if (me.processing) {
    me.bindings = me.bindings.slice(0);
  }
  if (Ext.isArray(binding)) {
    for (i = 0, len = binding.length; i < len; i++) {
      me.addBinding(binding[i]);
    }
    return;
  }
  me.bindings.push(Ext.apply({keyCode:me.processKeys(keyCode)}, binding));
}, removeBinding:function(binding) {
  var me = this, bindings = me.bindings, len = bindings.length, i, item, keys;
  if (me.processing) {
    me.bindings = bindings.slice(0);
  }
  keys = me.processKeys(binding.key);
  for (i = 0; i < len; i++) {
    item = bindings[i];
    if ((item.fn || item.handler) === (binding.fn || binding.handler) && item.scope === binding.scope) {
      if (binding.alt === item.alt && binding.ctrl === item.ctrl && binding.shift === item.shift) {
        if (Ext.Array.equals(item.keyCode, keys)) {
          Ext.Array.erase(me.bindings, i, 1);
          return;
        }
      }
    }
  }
}, processKeys:function(keyCode) {
  var processed = false, key, keys, keyString, len, i;
  if (keyCode.test) {
    return keyCode;
  }
  if (Ext.isString(keyCode)) {
    keys = [];
    keyString = keyCode.toUpperCase();
    for (i = 0, len = keyString.length; i < len; i++) {
      keys.push(keyString.charCodeAt(i));
    }
    keyCode = keys;
    processed = true;
  }
  if (!Ext.isArray(keyCode)) {
    keyCode = [keyCode];
  }
  if (!processed) {
    for (i = 0, len = keyCode.length; i < len; i++) {
      key = keyCode[i];
      if (Ext.isString(key)) {
        keyCode[i] = key.toUpperCase().charCodeAt(0);
      }
    }
  }
  return keyCode;
}, handleTargetEvent:function(event) {
  var me = this, bindings, i, len, result;
  if (me.enabled) {
    bindings = me.bindings;
    event = me.processEvent.apply(me.processEventScope || me, arguments);
    if (event) {
      me.lastKeyEvent = event;
      if (me.ignoreInputFields && Ext.fly(event.target).isInputField()) {
        return;
      }
      if (!event.getKey) {
        return event;
      }
      me.processing = true;
      for (i = 0, len = bindings.length; i < len; i++) {
        result = me.processBinding(bindings[i], event);
        if (result === false) {
          me.processing = false;
          return result;
        }
      }
      me.processing = false;
    }
  }
}, processEvent:Ext.identityFn, processBinding:function(binding, event) {
  if (this.checkModifiers(binding, event)) {
    var key = event.getKey(), handler = binding.fn || binding.handler, scope = binding.scope || this, keyCode = binding.keyCode, defaultEventAction = binding.defaultEventAction, i, len, result;
    if (keyCode.test) {
      if (keyCode.test(String.fromCharCode(event.getCharCode()))) {
        result = handler.call(scope, key, event);
        if (result !== true && defaultEventAction) {
          event[defaultEventAction]();
        }
        if (result === false) {
          return result;
        }
      }
    } else {
      if (keyCode.length) {
        for (i = 0, len = keyCode.length; i < len; i++) {
          if (key === keyCode[i]) {
            result = handler.call(scope, key, event);
            if (result !== true && defaultEventAction) {
              event[defaultEventAction]();
            }
            if (result === false) {
              return result;
            }
            break;
          }
        }
      }
    }
  }
}, checkModifiers:function(binding, event) {
  var keys = ['shift', 'ctrl', 'alt'], i, len, val, key;
  for (i = 0, len = keys.length; i < len; i++) {
    key = keys[i];
    val = binding[key];
    if (!(val === undefined || val === event[key + 'Key'])) {
      return false;
    }
  }
  return true;
}, on:function(key, fn, scope) {
  var keyCode, shift, ctrl, alt;
  if (Ext.isObject(key) && !Ext.isArray(key)) {
    keyCode = key.key;
    shift = key.shift;
    ctrl = key.ctrl;
    alt = key.alt;
  } else {
    keyCode = key;
  }
  this.addBinding({key:keyCode, shift:shift, ctrl:ctrl, alt:alt, fn:fn, scope:scope});
}, un:function(key, fn, scope) {
  var keyCode, shift, ctrl, alt;
  if (Ext.isObject(key) && !Ext.isArray(key)) {
    keyCode = key.key;
    shift = key.shift;
    ctrl = key.ctrl;
    alt = key.alt;
  } else {
    keyCode = key;
  }
  this.removeBinding({key:keyCode, shift:shift, ctrl:ctrl, alt:alt, fn:fn, scope:scope});
}, isEnabled:function() {
  return !!this.enabled;
}, enable:function() {
  var me = this;
  if (!me.enabled) {
    me.target.on(me.eventName, me.handleTargetEvent, me, {capture:me.capture, priority:me.priority});
    me.enabled = true;
  }
}, disable:function() {
  var me = this;
  if (me.enabled) {
    if (!me.target.destroyed) {
      me.target.removeListener(me.eventName, me.handleTargetEvent, me);
    }
    me.enabled = false;
  }
}, setDisabled:function(disabled) {
  if (disabled) {
    this.disable();
  } else {
    this.enable();
  }
}, destroy:function(removeTarget) {
  var me = this, target = me.target;
  me.bindings = [];
  me.disable();
  me.target = null;
  if (removeTarget) {
    target.destroy();
    Ext.raise('Using removeTarget argument in KeyMap destructor is not supported.');
  }
  me.callParent();
}});
Ext.define('Ext.util.KeyNav', {alternateClassName:'Ext.KeyNav', disabled:false, defaultEventAction:false, forceKeyDown:false, eventName:'keypress', statics:{keyOptions:{left:37, right:39, up:38, down:40, space:32, pageUp:33, pageDown:34, del:46, backspace:8, home:36, end:35, enter:13, esc:27, tab:9}}, constructor:function(config) {
  var me = this, keymapCfg, map;
  if (arguments.length === 2) {
    Ext.raise('2-argument KeyNav constructor is removed. Use a config object instead.');
  }
  config = config || {};
  keymapCfg = {target:config.target, ignoreInputFields:config.ignoreInputFields, eventName:me.getKeyEvent('forceKeyDown' in config ? config.forceKeyDown : me.forceKeyDown, config.eventName), capture:config.capture};
  if (me.map) {
    me.map.destroy();
  }
  me.initConfig(config);
  if (config.processEvent) {
    keymapCfg.processEvent = config.processEvent;
    keymapCfg.processEventScope = config.processEventScope || me;
  }
  if (config.priority) {
    keymapCfg.priority = config.priority;
  }
  if (config.keyMap) {
    map = me.map = config.keyMap;
  } else {
    map = me.map = new Ext.util.KeyMap(keymapCfg);
    me.destroyKeyMap = true;
  }
  me.addBindings(config);
  map.disable();
  if (!config.disabled) {
    map.enable();
  }
}, addBindings:function(bindings) {
  var me = this, map = me.map, keyCodes = Ext.util.KeyNav.keyOptions, Event = Ext.event.Event, defaultScope = bindings.scope || me, binding, keyName, keyCode;
  for (keyName in bindings) {
    binding = bindings[keyName];
    keyCode = keyName.length === 1 ? keyName.charCodeAt(0) : keyCodes[keyName] || Event[keyName.toUpperCase()];
    if (keyCode != null) {
      keyName = keyCode;
    }
    if (binding && (keyName.length === 1 || !isNaN(keyName = parseInt(keyName, 10)))) {
      if (typeof binding === 'function') {
        binding = {handler:binding, defaultEventAction:bindings.defaultEventAction !== undefined ? bindings.defaultEventAction : me.defaultEventAction};
      }
      map.addBinding({key:keyName, ctrl:binding.ctrl, shift:binding.shift, alt:binding.alt, handler:Ext.Function.bind(me.handleEvent, binding.scope || defaultScope, [binding.handler || binding.fn, me], true), defaultEventAction:binding.defaultEventAction !== undefined ? binding.defaultEventAction : me.defaultEventAction});
    }
  }
}, handleEvent:function(keyCode, event, handler, keyNav) {
  keyNav.lastKeyEvent = event;
  return handler.call(this, event);
}, destroy:function(removeEl) {
  var me = this;
  if (removeEl) {
    Ext.raise('removeEl argument in KeyNav destructor is not supported anymore.');
  }
  if (me.destroyKeyMap) {
    me.map.destroy(removeEl);
  }
  me.map = null;
  me.callParent();
}, enable:function() {
  if (this.map) {
    this.map.enable();
    this.disabled = false;
  }
}, disable:function() {
  if (this.map) {
    this.map.disable();
  }
  this.disabled = true;
}, setDisabled:function(disabled) {
  this.map.setDisabled(disabled);
  this.disabled = disabled;
}, isEnabled:function() {
  return !this.disabled;
}, getKeyEvent:function(forceKeyDown, configuredEventName) {
  if (forceKeyDown || Ext.supports.SpecialKeyDownRepeat && !configuredEventName) {
    return 'keydown';
  } else {
    return configuredEventName || this.eventName;
  }
}});
Ext.define('Ext.mixin.FocusableContainer', {extend:Ext.Mixin, mixinConfig:{id:'focusablecontainer'}, isFocusableContainer:true, focusableContainer:false, resetFocusPosition:false, activeChildTabIndex:0, inactiveChildTabIndex:-1, allowFocusingDisabledChildren:false, focusableContainerEl:'el', privates:{initFocusableContainer:function(clearChildren) {
  var items, i, len;
  if (this.focusableContainer) {
    clearChildren = clearChildren != null ? clearChildren : true;
    this.doInitFocusableContainer(clearChildren);
  } else {
    items = this.getFocusables();
    for (i = 0, len = items.length; i < len; i++) {
      items[i].ownerFocusableContainer = null;
    }
  }
}, doInitFocusableContainer:function(clearChildren) {
  var me = this, el = me.focusableContainerEl, child;
  if (!el.isElement) {
    el = me.focusableContainerEl = me[el];
  }
  if (me.initFocusableContainerKeyNav) {
    me.initFocusableContainerKeyNav(el);
  }
  if (clearChildren) {
    me.clearFocusables();
    if (!me.isDisabled()) {
      child = me.findNextFocusableChild({step:1}) || me.findNextFocusableChild({beforeRender:true});
      if (child) {
        me.activateFocusable(child);
      }
    }
  }
  child = me.findNextFocusableChild({firstTabbable:true});
  me.activateFocusableContainer(!!child && !me.isDisabled());
}, initFocusableContainerKeyNav:function(el) {
  var me = this;
  if (!me.focusableKeyNav) {
    el = el || me.focusableContainerEl;
    me.focusableKeyNav = new Ext.util.KeyNav({target:el, disabled:true, eventName:'keydown', processEvent:me.processFocusableContainerKeyEvent, processEventScope:me, scope:me, tab:me.onFocusableContainerTabKey, enter:{handler:me.onFocusableContainerEnterKey, ctrl:false, shift:false, alt:false}, space:{handler:me.onFocusableContainerSpaceKey, ctrl:false, shift:false, alt:false}, up:{handler:me.onFocusableContainerUpKey, ctrl:false, shift:false, alt:false}, down:{handler:me.onFocusableContainerDownKey, 
    ctrl:false, shift:false, alt:false}, left:{handler:me.onFocusableContainerLeftKey, ctrl:false, shift:false, alt:false}, right:{handler:me.onFocusableContainerRightKey, ctrl:false, shift:false, alt:false}});
  }
}, destroyFocusableContainer:function() {
  this.focusableKeyNav = Ext.destroy(this.focusableKeyNav);
}, activateFocusableContainer:function(enable) {
  var keyNav = this.focusableKeyNav;
  if (keyNav) {
    keyNav.setDisabled(!enable);
  }
}, isFocusableContainerActive:function() {
  var keyNav = this.focusableKeyNav;
  return keyNav ? !keyNav.disabled : false;
}, getFocusables:function() {
  return this.items.items;
}, initDefaultFocusable:function() {
  var me = this, haveFocusable = false, items, item, i, len;
  items = me.getFocusables();
  len = items.length;
  if (!len) {
    return;
  }
  for (i = 0; i < len; i++) {
    item = items[i];
    if (!item.isDisabled() && item.isFocusable()) {
      haveFocusable = true;
      break;
    }
  }
  if (!haveFocusable) {
    return;
  }
  item = me.findNextFocusableChild({items:items, step:true});
  if (item) {
    me.activateFocusable(item);
  }
  return item;
}, clearFocusables:function(skipFocused) {
  var me = this, items = me.getFocusables(), len = items.length, item, i;
  for (i = 0; i < len; i++) {
    item = items[i];
    if (!item.destroyed && item.focusable && item.isTabbable()) {
      me.deactivateFocusable(item);
    }
  }
}, processFocusableContainerKeyEvent:function(e) {
  if (!Ext.fly(e.target).isInputField()) {
    return e;
  }
}, activateFocusable:function(child) {
  child.setTabIndex(this.activeChildTabIndex);
}, deactivateFocusable:function(child) {
  child.setTabIndex(this.inactiveChildTabIndex);
}, onFocusableContainerTabKey:function() {
  return true;
}, onFocusableContainerEnterKey:function() {
  return true;
}, onFocusableContainerSpaceKey:function() {
  return true;
}, onFocusableContainerUpKey:function(e) {
  e.preventDefault();
  return this.moveChildFocus(e, false);
}, onFocusableContainerDownKey:function(e) {
  e.preventDefault();
  return this.moveChildFocus(e, true);
}, onFocusableContainerLeftKey:function(e) {
  e.preventDefault();
  return this.moveChildFocus(e, false);
}, onFocusableContainerRightKey:function(e) {
  e.preventDefault();
  return this.moveChildFocus(e, true);
}, getFocusableFromEvent:function(e) {
  var child = Ext.Component.from(e);
  if (!child) {
    Ext.raise('No focusable child found for keyboard event!');
  }
  return child;
}, moveChildFocus:function(e, forward) {
  var child = this.getFocusableFromEvent(e);
  return this.focusChild(child, forward, e);
}, focusChild:function(child, forward) {
  var nextChild = this.findNextFocusableChild({child:child, step:forward});
  if (nextChild) {
    nextChild.focus();
  }
  return nextChild;
}, findNextFocusableChild:function(options) {
  var beforeRender = options.beforeRender, firstTabbable = options.firstTabbable, items, item, child, step, idx, i, len, allowDisabled;
  items = options.items || this.getFocusables();
  step = options.step != null ? options.step : 1;
  child = options.child;
  allowDisabled = !!this.allowFocusingDisabledChildren;
  idx = Ext.Array.indexOf(items, child);
  step = step === true ? 1 : step === false ? -1 : step;
  len = items.length;
  i = step > 0 ? idx < len ? idx + step : 0 : idx > 0 ? idx + step : len - 1;
  for (;; i += step) {
    if (idx < 0 && (i >= len || i < 0)) {
      return null;
    } else {
      if (i >= len) {
        i = -1;
        continue;
      } else {
        if (i < 0) {
          i = len;
          continue;
        } else {
          if (i === idx) {
            return null;
          }
        }
      }
    }
    item = items[i];
    if (!item || !item.focusable || item.isDisabled() && !allowDisabled) {
      continue;
    }
    if (firstTabbable) {
      if (item.isTabbable && item.isTabbable()) {
        return item;
      }
    } else {
      if (beforeRender || item.isFocusable && item.isFocusable()) {
        return item;
      }
    }
  }
  return null;
}, onFocusEnter:function(e) {
  var me = this, target = e.toComponent, child;
  if (target === me) {
    child = me.initDefaultFocusable();
    if (child) {
      child.focus();
    }
  }
  me.activateFocusableContainer(true);
}, onFocusLeave:function(e) {
  var me = this;
  if (me.resetFocusPosition) {
    me.clearFocusables();
    me.initDefaultFocusable();
  }
}, beforeFocusableChildBlur:Ext.privateFn, afterFocusableChildBlur:Ext.privateFn, beforeFocusableChildFocus:function(child) {
  var me = this;
  if (!me.focusableContainer || me.destroying || me.destroyed) {
    return;
  }
  me.clearFocusables();
  me.activateFocusable(child);
}, afterFocusableChildFocus:function(child) {
  var me = this;
  if (!me.focusableContainer || me.destroying || me.destroyed) {
    return;
  }
  me.lastFocusedChild = child;
}, onFocusableChildAdd:function(child) {
  var me = this;
  if (child.focusable) {
    child.ownerFocusableContainer = me;
  }
}, onFocusableChildRemove:function(child) {
  var me = this, next;
  child.ownerFocusableContainer = null;
  if (child === me.lastFocusedChild) {
    me.lastFocusedChild = null;
    next = me.initDefaultFocusable();
    if (child.hasFocus) {
      next = next || child.findFocusTarget();
      if (next) {
        next.focus();
      }
    }
  }
  child = next || me.findNextFocusableChild({step:1, beforeRender:true});
  if (!child) {
    me.activateFocusableContainer(false);
  }
}, beforeFocusableChildEnable:Ext.privateFn, onFocusableChildEnable:function(child) {
  var me = this, active;
  if (!me.focusableContainer || me.destroying || me.destroyed) {
    return;
  }
  if (me.containsFocus) {
    active = Ext.ComponentManager.getActiveComponent();
    me.clearFocusables();
    me.activateFocusable(active);
  } else {
    if (me.resetFocusPosition || me.lastFocusedChild == null) {
      me.clearFocusables();
      if (child.hasFocus) {
        me.activateFocusable(child);
        active = child;
      }
    } else {
      me.deactivateFocusable(child);
      if (child === me.lastFocusedChild) {
        me.clearFocusables();
        me.activateFocusable(child);
      }
      active = me.findNextFocusableChild({firstTabbable:true});
    }
  }
  if (!active) {
    me.initDefaultFocusable();
  }
  me.activateFocusableContainer(true);
}, beforeFocusableChildDisable:function(child) {
  var me = this, next;
  if (!me.focusableContainer || me.destroying || me.destroyed) {
    return;
  }
  if (child.hasFocus) {
    next = me.findNextFocusableChild({child:child}) || child.findFocusTarget();
    if (next) {
      next.focus();
    }
  }
}, onFocusableChildDisable:function(child) {
  var me = this, next;
  if (!me.focusableContainer || me.destroying || me.destroyed) {
    return;
  }
  next = me.findNextFocusableChild({firstTabbable:true});
  if (!next) {
    next = me.initDefaultFocusable();
  }
  if (!next) {
    me.activateFocusableContainer(false);
  }
}, beforeFocusableChildHide:function(child) {
  return this.beforeFocusableChildDisable(child);
}, onFocusableChildHide:function(child) {
  return this.onFocusableChildDisable(child);
}, beforeFocusableChildShow:function(child) {
  return this.beforeFocusableChildEnable(child);
}, onFocusableChildShow:function(child) {
  return this.onFocusableChildEnable(child);
}, onFocusableChildMasked:Ext.privateFn, onFocusableChildDestroy:Ext.privateFn, onFocusableChildUpdate:Ext.privateFn}, deprecated:{7:{configs:{enableFocusableContainer:'focusableContainer'}}}});
Ext.define('Ext.Container', {extend:Ext.Component, alternateClassName:['Ext.lib.Container', 'Ext.container.Container'], xtype:'container', isContainer:true, mixins:[Ext.mixin.Queryable, Ext.mixin.Container, Ext.mixin.FocusableContainer], eventedConfig:{activeItem:0}, config:{activeItemIndex:null, autoSize:null, layout:'auto', control:null, defaults:null, items:null, autoDestroy:true, defaultType:null, defaultFocus:{$value:null, lazy:true}, innerCls:null, masked:null}, weighted:false, manageBorders:false, 
classCls:Ext.baseCSSPrefix + 'container', managedBordersCls:Ext.baseCSSPrefix + 'managed-borders', template:[{reference:'bodyElement', cls:Ext.baseCSSPrefix + 'body-el', uiCls:'body-el'}], constructor:function(config) {
  var me = this;
  me._items = me.items = new Ext.util.ItemCollection;
  me.innerItems = [];
  me.getReferences = me.getFirstReferences;
  me.onItemAdd = me.onFirstItemAdd;
  me.callParent(arguments);
  delete me.getReferences;
}, initialize:function() {
  var me = this;
  me.reference = me.setupReference(me.reference);
  me.callParent();
  if (me.manageBorders) {
    me.addCls(me.managedBordersCls);
  }
  me.getLayout();
}, applyMasked:function(masked) {
  var isVisible = true, currentMask;
  if (masked === false) {
    masked = true;
    isVisible = false;
  }
  currentMask = Ext.factory(masked, Ext['Mask'], this.getMasked());
  if (currentMask) {
    currentMask.setHidden(!isVisible);
    currentMask.render(this.el);
  }
  return currentMask;
}, mask:function(mask) {
  this.setMasked(mask || true);
}, unmask:function() {
  this.setMasked(false);
}, initInheritedState:function(inheritedState, inheritedStateInner) {
  this.callParent([inheritedState, inheritedStateInner]);
  this.initContainerInheritedState(inheritedState, inheritedStateInner);
}, onAdded:function(parent, instanced) {
  this.callParent([parent, instanced]);
  this.containerOnAdded(parent, instanced);
}, onRemoved:function(destroying) {
  this.containerOnRemoved(destroying);
  this.callParent([destroying]);
}, afterItemShow:function(item) {
  var layout;
  if (item.getDocked()) {
    layout = this.getLayout();
    this.items.generation++;
    layout.handleDockedItemBorders();
  }
}, afterItemHide:function(item) {
  var layout;
  if (item.getDocked()) {
    layout = this.getLayout();
    this.items.generation++;
    layout.handleDockedItemBorders();
  }
}, applyItems:function(items, collection) {
  if (items) {
    var me = this, activeItem;
    me.getDefaultType();
    me.getDefaults();
    if (me.initialized && collection.length > 0) {
      me.removeAll();
    }
    if (me.weighted && !items.isWidget && !items.xtype) {
      items = Ext.convertKeyedItems(items);
    }
    me.add(items);
    if (me.initialized) {
      activeItem = me.initialConfig.activeItem || me.config.activeItem || 0;
      me.setActiveItem(activeItem);
    }
  }
}, applyControl:function(selectors) {
  var selector, key, listener, listeners;
  for (selector in selectors) {
    listeners = selectors[selector];
    for (key in listeners) {
      listener = listeners[key];
      if (Ext.isObject(listener)) {
        listener.delegate = selector;
      }
    }
    listeners.delegate = selector;
    this.addListener(listeners);
  }
  return selectors;
}, updateDisabled:function(disabled) {
  var me = this;
  me.callParent([disabled]);
  if (me.focusableContainer) {
    me.getItems();
    if (disabled) {
      me.element.saveTabbableState();
    } else {
      me.element.restoreTabbableState();
    }
    me.activateFocusableContainer(!disabled);
    if (!disabled) {
      me.initDefaultFocusable();
    }
  }
}, onFirstItemAdd:function(item) {
  var me = this;
  delete me.onItemAdd;
  if (item.isInner && me.innerHtmlElement && !me.getHtml() && !me.getTpl()) {
    me.innerHtmlElement.destroy();
    delete me.innerHtmlElement;
  }
  return me.onItemAdd.apply(me, arguments);
}, applyLayout:function(layout, oldLayout) {
  if (typeof layout === 'string') {
    layout = {type:layout};
  }
  if (oldLayout) {
    if (layout) {
      if (!layout.isLayout) {
        oldLayout.setConfig(layout);
      } else {
        Ext.raise('Cannot change layout instances on ' + this.$className);
      }
    }
    return oldLayout;
  }
  if (!(layout && layout.isLayout)) {
    layout = Ext.Factory.layout(Ext.apply({container:this}, layout), Ext.layout.Auto);
  }
  this.link('layout', layout);
  return layout;
}, updateDefaultType:function(defaultType) {
  this.defaultItemClass = Ext.ClassManager.getByAlias('widget.' + defaultType);
  if (!this.defaultItemClass) {
    Ext.Logger.error("Invalid defaultType of: '" + defaultType + "', must be a valid component xtype");
  }
}, factoryItem:function(item) {
  if (!item) {
    Ext.Logger.error('Invalid item given: ' + item + ', must be either the config object to factory a new item, ' + 'or an existing component instance');
  }
  var me = this;
  item = me.applyItemDefaults(item);
  if (!item.isComponent) {
    if (!me.$hasCachedDefaultItemClass) {
      me.getDefaultType();
      me.$hasCachedDefaultItemClass = true;
    }
    item = Ext.factory(item, me.defaultItemClass);
  }
  return item;
}, add:function(newItems) {
  var me = this, items = me.getItems(), weighted = me.weighted, addingArray = true, addedItems = [], doWeightedInsert, i, ln, item, instanced;
  if (!Ext.isArray(newItems)) {
    newItems = [newItems];
    addingArray = false;
  }
  if (weighted) {
    if (items.length) {
      doWeightedInsert = true;
    } else {
      Ext.Array.sort(newItems, Ext.weightSortFn);
    }
  }
  for (i = 0, ln = newItems.length; i < ln; i++) {
    item = newItems[i];
    if (item) {
      instanced = item.isWidget;
      if (!instanced) {
        item.$initParent = me;
      }
      item = me.factoryItem(item);
      if (doWeightedInsert) {
        me.doInsert(items.findInsertionIndex(item, Ext.weightSortFn), item, instanced);
      } else {
        me.doAdd(item, instanced);
      }
      delete item.$initParent;
      if (me.focusableContainer) {
        me.onFocusableChildAdd(item);
      }
      addedItems.push(item);
    } else {
      if (item !== null) {
        Ext.raise('Invalid item passed to add');
      }
    }
  }
  if ((me.isConfiguring || !me.getActiveItem()) && me.innerItems.length > 0) {
    me.setActiveItem(me.initialConfig.activeItem || 0);
  }
  if (me.rendered && ln && me.focusableContainer) {
    me.initFocusableContainer();
  }
  return addingArray ? addedItems : addedItems[0];
}, onItemWeightChange:function(item) {
  var items = this.getItems(), oldIndex = items.indexOf(item), index;
  items.remove(item);
  index = items.findInsertionIndex(item, Ext.weightSortFn);
  items.insert(index, item);
  this.insertInner(item, index);
  this.onItemMove(item, index, oldIndex);
}, doAdd:function(item, instanced) {
  var me = this, items = me.getItems(), index;
  if (!items.has(item)) {
    index = items.length;
    items.add(item);
    if (item.isInnerItem()) {
      me.insertInner(item, index);
    }
    item.onAdded(me, !!instanced);
    if (me.focusableContainer) {
      me.onFocusableChildAdd(item);
    }
    me.onItemAdd(item, index);
  }
}, remove:function(which, destroy) {
  var me = this, component = me.getComponent(which), activeItem, index, innerItems, item, wasActive;
  if (destroy === undefined) {
    destroy = me.getAutoDestroy();
  }
  if (!component) {
    if (!Ext.isArray(which)) {
      Ext.raise('Invalid first argument to Ext.Container#remove() - ', Ext.typeOf(which));
    }
    activeItem = me.getActiveItem();
    for (index = 0; index < which.length; ++index) {
      item = me.getComponent(which[index]);
      if (item === activeItem) {
        wasActive = true;
      } else {
        if (item) {
          me.remove(item, destroy);
        }
      }
    }
    if (wasActive) {
      me.remove(activeItem, destroy);
    }
    return which;
  }
  index = me.indexOf(component);
  innerItems = me.getInnerItems();
  if (index !== -1) {
    if (!me.removingAll && innerItems.length > 1 && component === me.getActiveItem()) {
      me.on({activeitemchange:'doRemove', scope:me, single:true, order:'after', args:[component, index, destroy]});
      me.doResetActiveItem(innerItems.indexOf(component));
    } else {
      me.doRemove(component, index, destroy);
      if (innerItems.length === 0) {
        me.setActiveItem(null);
      }
    }
  }
  return component;
}, doResetActiveItem:function(innerIndex) {
  if (innerIndex === 0) {
    this.setActiveItem(1);
  } else {
    this.setActiveItem(0);
  }
}, doRemove:function(item, index, destroy) {
  var me = this;
  if (!me.destroying) {
    me.items.remove(item);
    if (item.isInnerItem()) {
      me.removeInner(item);
    }
    me.onItemRemove(item, index, destroy);
  }
  if (!item.destroyed) {
    item.onRemoved(item.destroying || destroy);
  }
  if (me.focusableContainer && !me.destroying && !me.destroyed) {
    me.onFocusableChildRemove(item, destroy);
  }
  if (destroy && !item.destroyed) {
    item.destroy();
  }
}, removeAll:function(destroy, everything) {
  var me = this, destroying = me.destroying, items = me.items, removed = destroying ? null : [], ln = items.length, i, item;
  if (typeof destroy !== 'boolean') {
    destroy = this.getAutoDestroy();
  }
  me.removingAll = true;
  for (i = 0; i < ln; i++) {
    item = items.getAt(i);
    if (item && (everything || item.isInnerItem())) {
      me.doRemove(item, i, destroy);
      if (!destroying) {
        i--;
        ln--;
      }
    }
    if (removed) {
      removed.push(item);
    }
  }
  if (!destroying) {
    me.setActiveItem(null);
  }
  me.removingAll = false;
  return removed;
}, getAt:function(index) {
  return this.items.getAt(index);
}, getInnerAt:function(index) {
  return this.innerItems[index];
}, removeAt:function(index, destroy) {
  var item = this.getAt(index);
  if (item) {
    this.remove(item, destroy);
  }
  return item;
}, removeInnerAt:function(index) {
  var item = this.getInnerItems()[index];
  if (item) {
    this.remove(item);
  }
  return item;
}, has:function(item) {
  return this.getItems().indexOf(item) != -1;
}, hasInnerItem:function(item) {
  return this.innerItems.indexOf(item) != -1;
}, indexOf:function(item) {
  return this.getItems().indexOf(item);
}, innerIndexOf:function(item) {
  return this.innerItems.indexOf(item);
}, insertInner:function(item, index) {
  var items = this.getItems().items, innerItems = this.innerItems, currentInnerIndex = innerItems.indexOf(item), newInnerIndex = -1, nextSibling;
  if (currentInnerIndex !== -1) {
    innerItems.splice(currentInnerIndex, 1);
  }
  if (typeof index == 'number') {
    do {
      nextSibling = items[++index];
    } while (nextSibling && !nextSibling.isInnerItem());
    if (nextSibling) {
      newInnerIndex = innerItems.indexOf(nextSibling);
      innerItems.splice(newInnerIndex, 0, item);
    }
  }
  if (newInnerIndex === -1) {
    innerItems.push(item);
    newInnerIndex = innerItems.length - 1;
  }
  if (currentInnerIndex !== -1) {
    this.onInnerItemMove(item, newInnerIndex, currentInnerIndex);
  }
  return this;
}, onInnerItemMove:Ext.emptyFn, removeInner:function(item) {
  Ext.Array.remove(this.innerItems, item);
  return this;
}, insert:function(index, item) {
  var me = this, instanced, i;
  if (typeof index != 'number') {
    Ext.Logger.error("Invalid index of '" + index + "', must be a valid number");
  }
  if (Ext.isArray(item)) {
    for (i = item.length - 1; i >= 0; i--) {
      me.insert(index, item[i]);
    }
    return me;
  }
  instanced = item.isWidget;
  if (!instanced) {
    item.$initParent = me;
  }
  item = me.factoryItem(item);
  me.doInsert(index, item, instanced);
  delete item.$initParent;
  return item;
}, doInsert:function(index, item, instanced) {
  var me = this, items = me.items, itemsLength = items.length, currentIndex, isInnerItem;
  isInnerItem = item.isInnerItem();
  if (index > itemsLength) {
    index = itemsLength;
  }
  if (items[index - 1] === item) {
    return;
  }
  currentIndex = me.indexOf(item);
  if (currentIndex !== -1) {
    items.removeAt(currentIndex);
  }
  items.insert(index, item);
  if (currentIndex === -1) {
    item.onAdded(me, !!instanced);
  }
  if (isInnerItem) {
    me.insertInner(item, index);
  }
  if (currentIndex !== -1) {
    me.onItemMove(item, index, currentIndex);
  } else {
    me.onItemAdd(item, index);
  }
}, insertFirst:function(item) {
  return this.insert(0, item);
}, insertLast:function(item) {
  return this.insert(this.getItems().length, item);
}, insertBefore:function(item, relativeToItem) {
  var index = this.indexOf(relativeToItem);
  if (index !== -1) {
    this.insert(index, item);
  }
  return this;
}, insertAfter:function(item, relativeToItem) {
  var index = this.indexOf(relativeToItem);
  if (index !== -1) {
    this.insert(index + 1, item);
  }
  return this;
}, onItemAdd:function(item, index) {
  var me = this;
  me.doItemLayoutAdd(item, index);
  if (me.initialized) {
    if (item.hasListeners.added) {
      item.fireEvent('added', item, me, index);
    }
    if (me.hasListeners.add) {
      me.fireEvent('add', me, item, index);
    }
  }
}, doItemLayoutAdd:function(item, index) {
  var layout = this.getLayout();
  if (this.rendered && !item.rendered) {
    item.fireAction('renderedchange', [this, item, true], 'onItemAdd', layout, {args:[item, index]});
  } else {
    layout.onItemAdd(item, index);
  }
}, onItemRemove:function(item, index, destroying) {
  var me = this;
  me.doItemLayoutRemove(item, index, destroying);
  if (item.hasListeners.removed) {
    item.fireEvent('removed', item, me, index);
  }
  if (me.hasListeners.remove) {
    me.fireEvent('remove', me, item, index);
  }
}, doItemLayoutRemove:function(item, index, destroying) {
  var layout = this.getLayout();
  if (item.rendered) {
    item.setRendered(false);
    item.fireAction('renderedchange', [this, item, false], 'onItemRemove', layout, {args:[item, index, destroying]});
  } else {
    layout.onItemRemove(item, index, destroying);
  }
}, onItemMove:function(item, toIndex, fromIndex) {
  var me = this;
  me.doItemLayoutMove(item, toIndex, fromIndex);
  if (item.hasListeners.moved) {
    item.fireEvent('moved', item, me, toIndex, fromIndex);
  }
  if (me.hasListeners.move) {
    me.fireEvent('move', me, item, toIndex, fromIndex);
  }
}, doItemLayoutMove:function(item, toIndex, fromIndex) {
  this.getLayout().onItemMove(item, toIndex, fromIndex);
}, onItemInnerStateChange:function(item, isInner) {
  var layout = this.getLayout();
  if (isInner) {
    this.insertInner(item, this.items.indexOf(item));
  } else {
    this.removeInner(item);
  }
  layout.onItemInnerStateChange.apply(layout, arguments);
}, onItemFloatedChange:function(item, floated) {
  var layout = this.getLayout();
  layout.onItemFloatedChange(item, floated);
}, getInnerItems:function() {
  return this.innerItems;
}, getDockedItems:function() {
  var items = this.getItems().items, dockedItems = [], ln = items.length, item, i;
  for (i = 0; i < ln; i++) {
    item = items[i];
    if (item.isDocked()) {
      dockedItems.push(item);
    }
  }
  return dockedItems;
}, applyActiveItem:function(activeItem, currentActiveItem) {
  var me = this, innerItems = me.getInnerItems(), initialConfig = me.initialConfig, initialActive = initialConfig.activeItem || activeItem;
  me.getItems();
  if (me.isConfiguring && !initialConfig.activeItem) {
    activeItem = initialActive;
  }
  if (!activeItem && innerItems.length === 0) {
    return 0;
  } else {
    if (typeof activeItem == 'number') {
      activeItem = Math.max(0, Math.min(activeItem, innerItems.length - 1));
      activeItem = innerItems[activeItem];
      if (activeItem) {
        return activeItem;
      } else {
        if (currentActiveItem) {
          return null;
        }
      }
    } else {
      if (activeItem) {
        var item;
        if (typeof activeItem == 'string') {
          item = me.child(activeItem);
        } else {
          if (activeItem.isComponent) {
            item = activeItem;
          } else {
            activeItem = Ext.apply({$initParent:me}, activeItem);
            item = me.factoryItem(activeItem);
          }
        }
        if (!item) {
          return null;
        }
        me.pendingActiveItem = item;
        if (!item.isInnerItem()) {
          Ext.Logger.error('Setting activeItem to be a non-inner item');
        }
        if (!me.has(item)) {
          me.add(item);
        }
        delete item.$initParent;
        return item;
      }
    }
  }
}, animateActiveItem:function(activeItem, animation) {
  var layout = this.getLayout(), defaultAnimation;
  if (this.activeItemAnimation) {
    this.activeItemAnimation.destroy();
  }
  this.activeItemAnimation = animation = new Ext.Factory.layoutCardFx(animation);
  if (animation && layout.isCard) {
    animation.setLayout(layout);
    defaultAnimation = layout.getAnimation();
    if (defaultAnimation) {
      defaultAnimation.disable();
    }
    animation.on('animationend', function() {
      if (defaultAnimation) {
        defaultAnimation.enable();
      }
      animation.destroy();
    }, this);
  }
  return this.setActiveItem(activeItem);
}, updateActiveItem:function(newActiveItem, oldActiveItem) {
  delete this.pendingActiveItem;
  if (oldActiveItem && !oldActiveItem.destroyed) {
    oldActiveItem.fireEvent('deactivate', oldActiveItem, this, newActiveItem);
  }
  if (newActiveItem) {
    newActiveItem.fireEvent('activate', newActiveItem, this, oldActiveItem);
  }
  this.setActiveItemIndex(this.innerItems.indexOf(newActiveItem));
}, updateActiveItemIndex:function(index) {
  this.setActiveItem(this.innerItems[index]);
}, getRefItems:function(deep) {
  var items = this.getItems().items, result, ln, i, item;
  if (items) {
    if (deep) {
      result = [];
      for (i = 0, ln = items.length; i < ln; i++) {
        item = items[i];
        result[result.length] = item;
        if (item.getRefItems) {
          result.push.apply(result, item.getRefItems(true));
        }
      }
    } else {
      result = items.slice();
    }
  }
  return result || [];
}, getComponent:function(component) {
  if (typeof component === 'number') {
    return this.getItems().getAt(component);
  }
  if (Ext.isObject(component)) {
    component = component.getItemId();
  }
  return this.getItems().get(component);
}, getDockedComponent:function(component) {
  if (Ext.isObject(component)) {
    component = component.getItemId();
  }
  var dockedItems = this.getDockedItems(), ln = dockedItems.length, item, i;
  if (Ext.isNumber(component)) {
    return dockedItems[component];
  }
  for (i = 0; i < ln; i++) {
    item = dockedItems[i];
    if (item.id == component) {
      return item;
    }
  }
  return false;
}, doDestroy:function() {
  var me = this;
  if (me.focusableContainer) {
    me.destroyFocusableContainer();
  }
  me.removeAll(true, true);
  Ext.destroy(me.items, me.getMasked());
  me.items = null;
  if (me._layout) {
    me._layout = Ext.destroy(me._layout);
  }
  me.callParent();
}, getFocusEl:function() {
  var delegate = this.findDefaultFocus();
  if (delegate) {
    return delegate.isWidget ? delegate.getFocusEl() : delegate;
  } else {
    if (this.focusable) {
      return this.focusEl;
    }
  }
  return undefined;
}, findDefaultFocus:function() {
  var result = this.getDefaultFocus();
  if (result && !result.isWidget) {
    result = this.down(result);
    if (result && !result.canFocus()) {
      return;
    }
  }
  return result;
}, onFocusEnter:function(e) {
  var me = this;
  me.callParent([e]);
  if (me.focusableContainer && !me.destroying && !me.destroyed) {
    me.mixins.focusablecontainer.onFocusEnter.call(me, e);
  }
}, onFocusLeave:function(e) {
  var me = this;
  me.callParent([e]);
  if (me.focusableContainer && !me.destroying && !me.destroyed) {
    me.mixins.focusablecontainer.onFocusLeave.call(me, e);
  }
}, updateInnerCls:function(innerCls, old) {
  var el = this.getRenderTarget();
  el.replaceCls(old, innerCls);
}, updateAutoSize:function(autoSize) {
  var me = this, bodySizerElement = me.bodySizerElement;
  if (autoSize === false) {
    if (!bodySizerElement) {
      me.bodySizerElement = me.bodyElement.wrap({cls:Ext.baseCSSPrefix + 'body-sizer-el'});
    }
  } else {
    if (bodySizerElement) {
      me.bodyElement.unwrap();
      bodySizerElement.destroy();
      me.bodySizerElement = null;
    }
  }
}, updateMaxHeight:function(maxHeight, oldMaxHeight) {
  var me = this, height, stashedHeight, maxHeightElement;
  me.callParent([maxHeight, oldMaxHeight]);
  if (Ext.isIE11 && maxHeight != null && me.getAutoSize() !== false) {
    me.getMaxHeightElement().setMaxHeight(maxHeight);
    me.addCls(Ext.baseCSSPrefix + 'max-height-wrapped');
  }
}, privates:{getFirstReferences:function() {
  var me = this;
  delete me.getReferences;
  me.getItems();
  return me.getReferences.apply(me, arguments);
}, getPositionedItemTarget:function() {
  return this.getRenderTarget();
}, applyItemDefaults:function(item) {
  var defaults = this.getDefaults();
  if (defaults && !item.ignoreDefaults) {
    if (item.isComponent) {
      if (item.isInnerItem() && !this.has(item)) {
        if (Ext.isFunction(defaults)) {
          defaults = defaults(item);
        }
        item.setConfig(defaults, null, {defaults:true});
      }
    } else {
      if (Ext.isFunction(defaults)) {
        defaults = defaults(item);
      }
      item = Ext.merge({}, defaults, item);
    }
  }
  return item;
}, setChildRendered:function(rendered, item) {
  if (item.isInnerItem()) {
    this.getLayout().renderInnerItem(item);
  } else {
    if (!rendered || !item.getFloated()) {
      item.setRendered(rendered);
    }
  }
}, getMaxHeightElement:function() {
  var el = this.el, maxHeightElement = this.maxHeightElement, selector = '.x-dock,.x-panelheader,.x-body-el,.x-body-wrap-el,.x-tab-guard-el', childNodes, node, i, ln;
  if (!maxHeightElement) {
    this.maxHeightElement = maxHeightElement = el.insertFirst({cls:Ext.baseCSSPrefix + 'max-height-el'});
    childNodes = Ext.Array.clone(el.dom.childNodes);
    for (i = 1, ln = childNodes.length; i < ln; i++) {
      node = childNodes[i];
      if (Ext.fly(node).is(selector)) {
        maxHeightElement.appendChild(node);
      }
    }
  }
  return maxHeightElement;
}}}, function() {
  this.prototype.defaultItemClass = this;
});
Ext.define('Ext.mixin.Hookable', {extend:Ext.Mixin, mixinConfig:{id:'hookable'}, bindHook:function(instance, boundMethod, bindingMethod, preventDefault, extraArgs) {
  instance.afterMethod(boundMethod, bindingMethod || boundMethod, this, preventDefault, extraArgs);
  return this;
}, unbindHook:function(instance, boundMethod, bindingMethod) {
  instance.removeMethodListener(boundMethod, bindingMethod || boundMethod, this);
  return this;
}});
Ext.define('Ext.util.Wrapper', {mixins:[Ext.mixin.Hookable], constructor:function(elementConfig, wrappedElement) {
  var element = this.link('element', Ext.Element.create(elementConfig));
  if (wrappedElement) {
    element.insertBefore(wrappedElement);
    this.wrap(wrappedElement);
  }
}, bindSize:function(sizeName) {
  var wrappedElement = this.wrappedElement, boundMethodName;
  this.boundSizeName = sizeName;
  this.boundMethodName = boundMethodName = sizeName === 'width' ? 'setWidth' : 'setHeight';
  this.bindHook(wrappedElement, boundMethodName, 'onBoundSizeChange');
  wrappedElement[boundMethodName].call(wrappedElement, wrappedElement.getStyleValue(sizeName));
}, onBoundSizeChange:function(size, args) {
  var element = this.element;
  if (typeof size === 'string' && size.substr(-1) === '%') {
    args[0] = '100%';
  } else {
    size = '';
  }
  element[this.boundMethodName].call(element, size);
}, wrap:function(wrappedElement) {
  var element = this.element, innerDom;
  this.wrappedElement = wrappedElement;
  innerDom = element.dom;
  while (innerDom.firstElementChild !== null) {
    innerDom = innerDom.firstElementChild;
  }
  innerDom.appendChild(wrappedElement.dom);
}, destroy:function() {
  var me = this, element = me.element, dom = element.dom, wrappedElement = me.wrappedElement, boundMethodName = me.boundMethodName, parentNode = dom.parentNode, size;
  if (boundMethodName) {
    me.unbindHook(wrappedElement, boundMethodName, 'onBoundSizeChange');
    size = element.getStyle(me.boundSizeName);
    if (size) {
      wrappedElement[boundMethodName].call(wrappedElement, size);
    }
  }
  if (parentNode) {
    if (!wrappedElement.destroyed) {
      parentNode.replaceChild(dom.firstElementChild, dom);
    }
    delete me.wrappedElement;
  }
  me.callParent();
}});
Ext.define('Ext.layout.wrapper.BoxDock', {config:{direction:'horizontal', element:{className:Ext.baseCSSPrefix + 'dock'}, innerWrapper:null, container:null, manageBorders:null}, positionMap:{top:'start', left:'start', bottom:'end', right:'end'}, managedBordersCls:Ext.baseCSSPrefix + 'managed-borders', constructor:function(config) {
  this.items = {start:[], end:[]};
  this.itemsCount = 0;
  this.initConfig(config);
}, addItems:function(items) {
  var i, ln, item;
  for (i = 0, ln = items.length; i < ln; i++) {
    item = items[i];
    this.addItem(item);
  }
}, addItem:function(item) {
  var docked = item.getDocked(), position = this.positionMap[docked], wrapper = item.$dockWrapper, container = this.getContainer(), index = container.indexOf(item), element = item.element, items = this.items, sideItems = items[position], i, ln, sibling, referenceElement, siblingIndex;
  if (wrapper) {
    wrapper.removeItem(item);
  }
  item.$dockWrapper = this;
  item.addCls(Ext.baseCSSPrefix + 'dock-item');
  item.addCls(Ext.baseCSSPrefix + 'docked-' + docked);
  for (i = 0, ln = sideItems.length; i < ln; i++) {
    sibling = sideItems[i];
    siblingIndex = container.indexOf(sibling);
    if (siblingIndex > index) {
      referenceElement = sibling.element;
      sideItems.splice(i, 0, item);
      break;
    }
  }
  if (!referenceElement) {
    sideItems.push(item);
    referenceElement = this.getInnerWrapper().getElement();
  }
  this.itemsCount++;
  if (position === 'start') {
    element.insertBefore(referenceElement);
  } else {
    element.insertAfter(referenceElement);
  }
}, removeItem:function(item, oldDocked) {
  var me = this, position = oldDocked || item.getDocked(), items = me.items[me.positionMap[position]];
  Ext.Array.remove(items, item);
  item.element.detach();
  delete item.$dockWrapper;
  item.removeCls(Ext.baseCSSPrefix + 'dock-item');
  item.removeCls(Ext.baseCSSPrefix + 'docked-' + position);
  if (--me.itemsCount === 0) {
    me.destroy();
  }
}, getItemsSlice:function(index) {
  var container = this.getContainer(), items = this.items, slice = [], sideItems, i, ln, item;
  for (sideItems = items.start, i = 0, ln = sideItems.length; i < ln; i++) {
    item = sideItems[i];
    if (container.indexOf(item) > index) {
      slice.push(item);
    }
  }
  for (sideItems = items.end, i = 0, ln = sideItems.length; i < ln; i++) {
    item = sideItems[i];
    if (container.indexOf(item) > index) {
      slice.push(item);
    }
  }
  return slice;
}, applyElement:function(element) {
  return Ext.Element.create(element);
}, updateElement:function(element) {
  element.addCls(Ext.baseCSSPrefix + 'dock-' + this.getDirection());
}, updateInnerWrapper:function(innerWrapper, oldInnerWrapper) {
  if (oldInnerWrapper) {
    innerWrapper.getElement().replace(oldInnerWrapper.getElement(), false);
    oldInnerWrapper.$outerWrapper = null;
  } else {
    this.getElement().append(innerWrapper.getElement());
  }
  innerWrapper.setManageBorders(this.getManageBorders());
  innerWrapper.$outerWrapper = this;
}, updateManageBorders:function(manageBorders) {
  var me = this, innerWrapper = me.getInnerWrapper();
  me.getElement().toggleCls(me.managedBordersCls, manageBorders);
  if (innerWrapper) {
    innerWrapper.setManageBorders(manageBorders);
  }
}, destroy:function() {
  var me = this, innerWrapper = me.getInnerWrapper(), outerWrapper = me.$outerWrapper, innerWrapperElement;
  if (innerWrapper) {
    if (outerWrapper) {
      outerWrapper.setInnerWrapper(innerWrapper);
    } else {
      innerWrapperElement = innerWrapper.getElement();
      if (!innerWrapperElement.destroyed) {
        innerWrapperElement.replace(me.getElement());
      }
      delete innerWrapper.$outerWrapper;
    }
  }
  delete me.$outerWrapper;
  me.unlink(['_element']);
  me.callParent();
}});
Ext.define('Ext.layout.wrapper.Inner', {config:{container:null, manageBorders:null}, constructor:function(config) {
  this.initConfig(config);
}, getElement:function() {
  var container = this.getContainer();
  return container.boxScrollerElement || container.bodySizerElement || container.bodyElement;
}, setInnerWrapper:Ext.emptyFn, getInnerWrapper:Ext.emptyFn});
Ext.define('Ext.layout.Auto', {alias:['layout.default', 'layout.auto'], alternateClassName:'Ext.layout.Default', mixins:[Ext.mixin.Observable, Ext.mixin.Factoryable], factoryConfig:{type:'layout', defaultType:'auto', instanceProp:'isLayout'}, isLayout:true, config:{animation:null, container:null}, centerCls:Ext.baseCSSPrefix + 'center', cls:Ext.baseCSSPrefix + 'layout-auto', itemCls:Ext.baseCSSPrefix + 'layout-auto-item', spaceRe:/\s+/, positionMap:{top:'start', left:'start', middle:'center', bottom:'end', 
right:'end'}, positionDirectionMap:{top:'vertical', bottom:'vertical', left:'horizontal', right:'horizontal'}, constructor:function(config) {
  this.mixins.observable.constructor.call(this, config);
}, updateContainer:function(container, oldContainer) {
  var me = this;
  me.dockedItems = [];
  container.getRenderTarget().addCls(me.cls);
  if (container.initialized) {
    me.onContainerInitialized();
  } else {
    container.onInitialized('onContainerInitialized', me);
  }
}, onContainerInitialized:function() {
  var me = this;
  me.handleDockedItemBorders();
  me.getContainer().on({delegate:'\x3e component', beforecenteredchange:'onItemCenteredChange', positionedchange:'onItemPositionedChange', afterdockedchange:'onAfterItemDockedChange', scope:me});
}, onItemAdd:function(item) {
  var me = this, container = me.getContainer(), floated = item.getFloated();
  if (item.getDocked() != null) {
    me.dockItem(item);
  } else {
    if (item.isCentered()) {
      me.onItemCenteredChange(item, true);
    } else {
      if (item.isPositioned()) {
        me.onItemPositionedChange(item, true);
      } else {
        if (!floated) {
          me.onItemInnerStateChange(item, true);
        }
      }
    }
  }
  if (container.rendered && !floated) {
    if (item.isInnerItem()) {
      me.renderInnerItem(item, true);
    } else {
      item.setRendered(true, true);
    }
  }
}, onItemInnerStateChange:function(item, isInner, destroying) {
  var itemCls = this.itemCls;
  if (isInner) {
    this.insertInnerItem(item, this.getContainer().innerIndexOf(item));
    item.addCls(itemCls);
  } else {
    this.removeInnerItem(item);
    item.removeCls(itemCls);
  }
}, insertInnerItem:function(item, index) {
  var itemDom = item.element.dom, container = this.getContainer(), renderTarget = container.getRenderTarget(item), nextSibling = null;
  if (index !== -1) {
    if (renderTarget === container.getRenderTarget()) {
      nextSibling = container.getInnerAt(index + 1);
      nextSibling = nextSibling ? nextSibling.element.dom : null;
    } else {
      nextSibling = renderTarget.dom.childNodes[index];
    }
  }
  renderTarget.dom.insertBefore(itemDom, nextSibling);
}, insertPositionedItem:function(item) {
  var me = this, renderTarget = me.getContainer().getPositionedItemTarget(item).dom;
  if (item.getZIndex() === null) {
    item.setZIndex((me.getContainer().indexOf(item) + 1) * 2);
  }
  renderTarget.insertBefore(item.element.dom, renderTarget.firstChild);
  return me;
}, removeInnerItem:function(item) {
  item.element.detach();
}, removePositionedItem:function(item) {
  item.setZIndex(null);
  item.element.detach();
}, onItemRemove:function(item, index, destroying) {
  var me = this;
  if (item.getDocked()) {
    me.undockItem(item);
  } else {
    if (item.isCentered()) {
      me.onItemCenteredChange(item, false);
    } else {
      if (item.isPositioned()) {
        me.onItemPositionedChange(item, false);
      } else {
        if (!item.getFloated()) {
          me.onItemInnerStateChange(item, false, destroying);
        }
      }
    }
  }
}, onItemMove:function(item, toIndex, fromIndex) {
  if (item.isCentered() || item.isPositioned()) {
    item.setZIndex((toIndex + 1) * 2);
  } else {
    if (item.isInnerItem()) {
      this.insertInnerItem(item, this.getContainer().innerIndexOf(item));
    } else {
      this.undockItem(item);
      this.dockItem(item);
    }
  }
}, onItemCenteredChange:function(item, centered) {
  var wrapperName = '$centerWrapper';
  if (item.getFloated()) {
    item.center();
  } else {
    if (centered) {
      this.insertPositionedItem(item);
      item.link(wrapperName, new Ext.util.Wrapper({className:this.centerCls}, item.element));
    } else {
      item.unlink([wrapperName]);
      this.removePositionedItem(item);
    }
  }
}, onItemPositionedChange:function(item, positioned) {
  if (positioned) {
    this.insertPositionedItem(item);
  } else {
    this.removePositionedItem(item);
  }
}, onAfterItemDockedChange:function(item, docked, oldDocked) {
  if (item.initialized) {
    if (oldDocked) {
      this.undockItem(item, oldDocked);
    }
    if (docked) {
      this.dockItem(item);
    }
  }
}, dockItem:function(item) {
  var me = this, BoxDock = Ext.layout.wrapper.BoxDock, dockedItems = me.dockedItems, ln = dockedItems.length, container = me.getContainer(), itemIndex = container.indexOf(item), positionDirectionMap = me.positionDirectionMap, direction = positionDirectionMap[item.getDocked()], dockInnerWrapper = me.dockInnerWrapper, needsInnerWrapper = !dockInnerWrapper, referenceDirection, i, dockedItem, index, previousItem, slice, referenceItem, referenceDocked, referenceWrapper, newWrapper, nestedWrapper, oldInnerWrapper;
  if (needsInnerWrapper) {
    dockInnerWrapper = new Ext.layout.wrapper.Inner({container:container});
  }
  if (ln === 0) {
    dockedItems.push(item);
    newWrapper = new BoxDock({container:container, direction:direction, manageBorders:container.manageBorders});
    newWrapper.getElement().replace(dockInnerWrapper.getElement(), false);
    newWrapper.setInnerWrapper(dockInnerWrapper);
    newWrapper.addItem(item);
  } else {
    for (i = 0; i < ln; i++) {
      dockedItem = dockedItems[i];
      index = container.indexOf(dockedItem);
      if (index > itemIndex) {
        referenceItem = previousItem || dockedItems[0];
        dockedItems.splice(i, 0, item);
        break;
      }
      previousItem = dockedItem;
    }
    if (!referenceItem) {
      referenceItem = dockedItems[ln - 1];
      dockedItems.push(item);
    }
    referenceDocked = referenceItem.getDocked();
    referenceWrapper = referenceItem.$dockWrapper;
    referenceDirection = positionDirectionMap[referenceDocked];
    if (direction === referenceDirection) {
      referenceWrapper.addItem(item);
    } else {
      slice = referenceWrapper.getItemsSlice(itemIndex);
      newWrapper = new BoxDock({container:container, direction:direction});
      if (slice.length > 0) {
        if (slice.length === referenceWrapper.itemsCount) {
          nestedWrapper = referenceWrapper;
          newWrapper.getElement().replace(nestedWrapper.getElement(), false);
          newWrapper.setInnerWrapper(nestedWrapper);
        } else {
          nestedWrapper = new BoxDock({container:container, direction:referenceDirection});
          oldInnerWrapper = referenceWrapper.getInnerWrapper();
          newWrapper.setInnerWrapper(nestedWrapper);
          referenceWrapper.setInnerWrapper(newWrapper);
          nestedWrapper.setInnerWrapper(oldInnerWrapper);
          nestedWrapper.addItems(slice);
        }
      } else {
        oldInnerWrapper = referenceWrapper.getInnerWrapper();
        referenceWrapper.setInnerWrapper(newWrapper);
        newWrapper.setInnerWrapper(oldInnerWrapper);
      }
      newWrapper.addItem(item);
    }
  }
  if (newWrapper) {
    me.link('dockOuterWrapper', newWrapper);
  }
  if (needsInnerWrapper) {
    me.link('dockInnerWrapper', dockInnerWrapper);
  }
  if (container.initialized) {
    me.handleDockedItemBorders();
  }
}, getDockWrapper:function() {
  var dockedItems = this.dockedItems;
  if (dockedItems.length > 0) {
    return dockedItems[0].$dockWrapper;
  }
  return null;
}, undockItem:function(item, oldDocked) {
  var me = this, dockedItems = me.dockedItems, lastBorderMask, lastBorderCollapse, dockWrapper = item.$dockWrapper;
  if (dockWrapper) {
    dockWrapper.removeItem(item, oldDocked);
  }
  if (me.getContainer().initialized) {
    lastBorderMask = item.lastBorderMask;
    lastBorderCollapse = item.lastBorderCollapse;
    if (lastBorderMask) {
      item.lastBorderMask = 0;
      item.removeCls(me.noBorderClassTable[lastBorderMask]);
    }
    if (lastBorderCollapse) {
      item.lastBorderCollapse = 0;
      item.removeCls(me.getBorderCollapseTable()[lastBorderCollapse]);
    }
    me.handleDockedItemBorders();
  }
  Ext.Array.remove(dockedItems, item);
}, destroy:function() {
  this.dockedItems = null;
  Ext.destroy(this.getAnimation());
  this.callParent();
}, noBorderClassTable:[0, Ext.baseCSSPrefix + 'noborder-l', Ext.baseCSSPrefix + 'noborder-b', Ext.baseCSSPrefix + 'noborder-bl', Ext.baseCSSPrefix + 'noborder-r', Ext.baseCSSPrefix + 'noborder-rl', Ext.baseCSSPrefix + 'noborder-rb', Ext.baseCSSPrefix + 'noborder-rbl', Ext.baseCSSPrefix + 'noborder-t', Ext.baseCSSPrefix + 'noborder-tl', Ext.baseCSSPrefix + 'noborder-tb', Ext.baseCSSPrefix + 'noborder-tbl', Ext.baseCSSPrefix + 'noborder-tr', Ext.baseCSSPrefix + 'noborder-trl', Ext.baseCSSPrefix + 'noborder-trb', 
Ext.baseCSSPrefix + 'noborder-trbl'], edgeMasks:{top:8, right:4, bottom:2, left:1}, handleDockedItemBorders:function(force) {
  var me = this, edges = 0, maskT = 8, maskR = 4, maskB = 2, maskL = 1, container = me.getContainer(), bodyBorder = container.getBodyBorder && container.getBodyBorder(), containerBorder = container.getBorder(), collapsed = me.collapsed, edgeMasks = me.edgeMasks, noBorderCls = me.noBorderClassTable, dockedItemsGen = container.items.generation, bodyClsEl = container.boxScrollerElement || container.bodyElement, b, borderCls, docked, edgesTouched, i, ln, item, dock, lastValue, mask, addCls, removeCls, 
  header;
  if (!force && me.initializedBorders === dockedItemsGen || !container.manageBorders) {
    return;
  }
  addCls = [];
  removeCls = [];
  borderCls = me.getBorderCollapseTable();
  noBorderCls = me.getBorderClassTable ? me.getBorderClassTable() : noBorderCls;
  me.initializedBorders = dockedItemsGen;
  me.collapsed = false;
  docked = container.getDockedItems();
  me.collapsed = collapsed;
  header = container.getHeader && container.getHeader();
  if (header) {
    docked = [header].concat(docked);
  }
  for (i = 0, ln = docked.length; i < ln; i++) {
    item = docked[i];
    if (item.getHidden()) {
      continue;
    }
    dock = item.isPanelHeader ? item.getPosition() : item.getDocked();
    mask = edgesTouched = 0;
    addCls.length = 0;
    removeCls.length = 0;
    if (dock !== 'bottom') {
      if (edges & maskT) {
        b = item.border;
      } else {
        b = containerBorder;
        if (b !== false) {
          edgesTouched += maskT;
        }
      }
      if (b === false) {
        mask += maskT;
      }
    }
    if (dock !== 'left') {
      if (edges & maskR) {
        b = item.border;
      } else {
        b = containerBorder;
        if (b !== false) {
          edgesTouched += maskR;
        }
      }
      if (b === false) {
        mask += maskR;
      }
    }
    if (dock !== 'top') {
      if (edges & maskB) {
        b = item.border;
      } else {
        b = containerBorder;
        if (b !== false) {
          edgesTouched += maskB;
        }
      }
      if (b === false) {
        mask += maskB;
      }
    }
    if (dock !== 'right') {
      if (edges & maskL) {
        b = item.border;
      } else {
        b = containerBorder;
        if (b !== false) {
          edgesTouched += maskL;
        }
      }
      if (b === false) {
        mask += maskL;
      }
    }
    if ((lastValue = item.lastBorderMask) !== mask) {
      item.lastBorderMask = mask;
      if (lastValue) {
        removeCls[0] = noBorderCls[lastValue];
      }
      if (mask) {
        addCls[0] = noBorderCls[mask];
      }
    }
    if ((lastValue = item.lastBorderCollapse) !== edgesTouched) {
      item.lastBorderCollapse = edgesTouched;
      if (lastValue) {
        removeCls.push.apply(removeCls, borderCls[lastValue]);
      }
      if (edgesTouched) {
        addCls.push.apply(addCls, borderCls[edgesTouched]);
      }
    }
    if (removeCls.length) {
      item.removeCls(removeCls);
    }
    if (addCls.length) {
      item.addCls(addCls);
    }
    edges |= edgeMasks[dock];
  }
  mask = edgesTouched = 0;
  addCls.length = 0;
  removeCls.length = 0;
  if (edges & maskT) {
    b = bodyBorder;
  } else {
    b = containerBorder;
    if (b !== false) {
      edgesTouched += maskT;
    }
  }
  if (b === false) {
    mask += maskT;
  }
  if (edges & maskR) {
    b = bodyBorder;
  } else {
    b = containerBorder;
    if (b !== false) {
      edgesTouched += maskR;
    }
  }
  if (b === false) {
    mask += maskR;
  }
  if (edges & maskB) {
    b = bodyBorder;
  } else {
    b = containerBorder;
    if (b !== false) {
      edgesTouched += maskB;
    }
  }
  if (b === false) {
    mask += maskB;
  }
  if (edges & maskL) {
    b = bodyBorder;
  } else {
    b = containerBorder;
    if (b !== false) {
      edgesTouched += maskL;
    }
  }
  if (b === false) {
    mask += maskL;
  }
  if ((lastValue = me.lastBodyBorderMask) !== mask) {
    me.lastBodyBorderMask = mask;
    if (lastValue) {
      removeCls[0] = noBorderCls[lastValue];
    }
    if (mask) {
      addCls[0] = noBorderCls[mask];
    }
  }
  if ((lastValue = me.lastBodyBorderCollapse) !== edgesTouched) {
    me.lastBodyBorderCollapse = edgesTouched;
    if (lastValue) {
      removeCls.push.apply(removeCls, borderCls[lastValue]);
    }
    if (edgesTouched) {
      addCls.push.apply(addCls, borderCls[edgesTouched]);
    }
  }
  if (removeCls.length) {
    bodyClsEl.removeCls(removeCls);
  }
  if (addCls.length) {
    bodyClsEl.addCls(addCls);
  }
}, borderCollapseMap:{}, getBorderCollapseTable:function() {
  var me = this, map = me.borderCollapseMap, container = me.getContainer(), classCls = container.classCls, ui = container.getUi(), uiKey = ui || 'default', uiList, table, classClsList, baseCls, uiCls, i, ln, j, uiLen;
  map = map[classCls] || (map[classCls] = {});
  table = map[uiKey];
  if (!table) {
    classClsList = container.classClsList;
    map[uiKey] = table = [[], [], [], [], [], [], [], [], [], [], [], [], [], [], [], []];
    uiList = [0];
    if (ui) {
      uiList = uiList.concat(ui.split(me.spaceRe));
    }
    uiLen = uiList.length;
    for (i = 0, ln = classClsList.length; i < ln; i++) {
      classCls = classClsList[i];
      for (j = 0; j < uiLen; j++) {
        ui = uiList[j];
        uiCls = ui ? '-' + ui : '';
        baseCls = classCls + uiCls + '-outer-border-';
        table[1].push(baseCls + 'l');
        table[2].push(baseCls + 'b');
        table[3].push(baseCls + 'bl');
        table[4].push(baseCls + 'r');
        table[5].push(baseCls + 'rl');
        table[6].push(baseCls + 'rb');
        table[7].push(baseCls + 'rbl');
        table[8].push(baseCls + 't');
        table[9].push(baseCls + 'tl');
        table[10].push(baseCls + 'tb');
        table[11].push(baseCls + 'tbl');
        table[12].push(baseCls + 'tr');
        table[13].push(baseCls + 'trl');
        table[14].push(baseCls + 'trb');
        table[15].push(baseCls + 'trbl');
      }
    }
  }
  return table;
}, setConfig:function(name, value, options) {
  var config = name, alias = this.alias, type = config.type;
  if (name) {
    if (typeof name === 'string') {
      config = {};
      config[name] = value;
    } else {
      options = value;
    }
    if (!type || alias && alias.indexOf('layout.' + type) > -1) {
      this.callParent([config, options]);
    } else {
      Ext.raise('Cannot change layout from ' + this.$className + ' to "' + type + '"');
    }
  }
  return this;
}, privates:{renderInnerItem:function(item, asRoot) {
  item.setRendered(true, asRoot);
}}});
Ext.define('Ext.Indicator', {extend:Ext.Component, xtype:'indicator', config:{activeIndex:null, count:null, direction:'horizontal', tapMode:'direction'}, activeCls:Ext.baseCSSPrefix + 'indicator-active', baseCls:Ext.baseCSSPrefix + 'indicator', itemCls:Ext.baseCSSPrefix + 'indicator-item', defaultBindProperty:'activeIndex', twoWayBindable:['activeIndex'], isIndicator:true, constructor:function(config) {
  this.indicators = [];
  this.callParent([config]);
}, initialize:function() {
  this.callParent();
  this.element.on({tap:'onTap', scope:this});
}, doDestroy:function() {
  Ext.destroy(this.indicators);
  this.callParent();
}, applyActiveIndex:function(index) {
  var indicators = this.indicators, max = indicators.length - 1;
  if (index > max) {
    Ext.raise('Cannot set the active index greater than the number of indicators');
  }
  return index;
}, updateActiveIndex:function(index, oldIndex) {
  var activeCls = this.activeCls, baseCls = this.baseCls, indicators = this.indicators, currentActiveItem = indicators[oldIndex], activeItem = indicators[index];
  if (currentActiveItem) {
    currentActiveItem.removeCls(activeCls);
  }
  if (activeItem) {
    activeItem.addCls(activeCls);
  }
}, updateCount:function(count) {
  var indicators = this.indicators;
  while (indicators.length < count) {
    this.doAdd();
  }
  while (indicators.length > count) {
    this.doRemove();
  }
}, applyDirection:function(direction) {
  if (direction !== 'vertical' && direction !== 'horizontal') {
    Ext.raise('Invalid indicator direction provided: ' + direction);
    direction = 'horizontal';
  }
  return direction;
}, updateDirection:function(newDirection, oldDirection) {
  this.element.replaceCls(oldDirection, newDirection, this.baseCls);
}, sync:function(count, activeIndex) {
  if (Ext.isNumber(count)) {
    this.setCount(count);
  }
  if (Ext.isNumber(activeIndex)) {
    this.setActiveIndex(activeIndex);
  }
  return this;
}, add:function() {
  var count = this.getCount();
  return this.setCount(++count);
}, removeAll:function() {
  return this.setCount(0);
}, remove:function() {
  var count = this.getCount();
  return this.setCount(--count);
}, doAdd:function() {
  var indicators = this.indicators;
  indicators.push(this.element.createChild({tag:'span', cls:this.itemCls}));
  return this;
}, doRemove:function() {
  var indicators = this.indicators, indicator = indicators.pop();
  if (indicator) {
    indicator.destroy();
  }
  return this;
}, onTap:function(e) {
  var mode = this.getTapMode();
  if (mode === 'item') {
    this.onTapItem(e);
  } else {
    this.onTapDirection(e);
  }
}, onTapItem:function(e) {
  var me = this, item = e.getTarget('.' + me.itemCls, 1, true), index;
  if (item) {
    index = me.indicators.indexOf(item);
    if (index !== -1) {
      me.fireEvent('indicatortap', me, index, item);
    }
  } else {
    me.onTapDirection(e);
  }
}, onTapDirection:function(e) {
  var me = this, direction = me.getDirection(), touch = e.touch, box = me.element.getBox(), centerX = box.left + box.width / 2, centerY = box.top + box.height / 2, event = direction === 'horizontal' && touch.pageX >= centerX || direction === 'vertical' && touch.pageY >= centerY ? 'next' : 'previous';
  me.fireEvent(event, me);
}});
Ext.define('Ext.layout.card.fx.Abstract', {extend:Ext.Evented, mixins:[Ext.mixin.Factoryable], alias:'layout.card.fx.abstract', isAnimation:true, config:{direction:null, duration:null, reverse:null, layout:null}, updateLayout:function(layout) {
  if (layout) {
    this.enable();
  }
}, enable:function() {
  var layout = this.getLayout();
  if (layout) {
    layout.on('beforeactiveitemchange', 'onActiveItemChange', this);
  }
}, disable:function() {
  var layout = this.getLayout();
  if (this.isAnimating) {
    this.stopAnimation();
  }
  if (layout) {
    layout.un('beforeactiveitemchange', 'onActiveItemChange', this);
  }
}, onActiveItemChange:Ext.emptyFn, destroy:function() {
  var me = this, layout = me.getLayout();
  if (me.isAnimating) {
    me.stopAnimation();
  }
  if (layout) {
    layout.un('beforeactiveitemchange', 'onActiveItemChange', this);
  }
  me.setLayout(null);
  if (me.observableId) {
    me.fireEvent('destroy', this);
  }
  me.callParent();
}});
Ext.define('Ext.layout.card.fx.Style', {extend:Ext.layout.card.fx.Abstract, config:{inAnimation:{before:{visibility:null}, preserveEndState:false, replacePrevious:true}, outAnimation:{preserveEndState:false, replacePrevious:true}}, isAnimating:false, constructor:function(config) {
  var inAnimation, outAnimation;
  this.callParent([config]);
  this.endAnimationCounter = 0;
  inAnimation = this.getInAnimation();
  outAnimation = this.getOutAnimation();
  inAnimation.on('animationend', 'incrementEnd', this);
  outAnimation.on('animationend', 'incrementEnd', this);
}, updateDirection:function(direction) {
  this.getInAnimation().setDirection(direction);
  this.getOutAnimation().setDirection(direction);
}, updateDuration:function(duration) {
  this.getInAnimation().setDuration(duration);
  this.getOutAnimation().setDuration(duration);
}, updateReverse:function(reverse) {
  this.getInAnimation().setReverse(reverse);
  this.getOutAnimation().setReverse(reverse);
}, incrementEnd:function() {
  this.endAnimationCounter++;
  if (this.endAnimationCounter > 1) {
    this.endAnimationCounter = 0;
    this.fireEvent('animationend', this);
  }
}, applyInAnimation:function(animation, inAnimation) {
  return Ext.factory(animation, Ext.fx.Animation, inAnimation);
}, applyOutAnimation:function(animation, outAnimation) {
  return Ext.factory(animation, Ext.fx.Animation, outAnimation);
}, updateInAnimation:function(animation) {
  animation.setScope(this);
}, updateOutAnimation:function(animation) {
  animation.setScope(this);
}, onActiveItemChange:function(cardLayout, newItem, oldItem, controller) {
  var me = this, inElement, outElement, inAnimation, outAnimation;
  if (newItem && oldItem && oldItem.isPainted()) {
    inAnimation = me.getInAnimation();
    outAnimation = me.getOutAnimation();
    inElement = newItem.renderElement;
    outElement = oldItem.renderElement;
    inAnimation.setElement(inElement);
    outAnimation.setElement(outElement);
    outAnimation.setOnEnd(function() {
      me.isAnimating = false;
      controller.resume();
    });
    inElement.dom.style.setProperty('visibility', 'hidden', 'important');
    newItem.show();
    cardLayout.renderInnerItem(newItem, true);
    me.isAnimating = true;
    Ext.Animator.run([outAnimation, inAnimation]);
    controller.pause();
  }
}, destroy:function() {
  Ext.destroy(this.getInAnimation(), this.getOutAnimation());
  this.callParent();
}});
Ext.define('Ext.layout.card.fx.Cover', {extend:Ext.layout.card.fx.Style, alias:'layout.card.fx.cover', config:{reverse:null, inAnimation:{before:{'z-index':100}, after:{'z-index':0}, type:'slide', easing:'ease-out'}, outAnimation:{easing:'ease-out', from:{opacity:0.99}, to:{opacity:1}, out:true}}});
Ext.define('Ext.layout.card.fx.Cube', {extend:Ext.layout.card.fx.Style, alias:'layout.card.fx.cube', config:{reverse:null, inAnimation:{type:'cube'}, outAnimation:{type:'cube', out:true}}});
Ext.define('Ext.layout.card.fx.Serial', {extend:Ext.layout.card.fx.Style, duration:500, updateDuration:function(duration) {
  var halfDuration = duration / 2, inAnimation = this.getInAnimation(), outAnimation = this.getOutAnimation();
  inAnimation.setDelay(halfDuration);
  inAnimation.setDuration(halfDuration);
  outAnimation.setDuration(halfDuration);
}});
Ext.define('Ext.layout.card.fx.Fade', {extend:Ext.layout.card.fx.Serial, alias:'layout.card.fx.fade', config:{reverse:null, inAnimation:{type:'fade', easing:'ease-out'}, outAnimation:{type:'fade', easing:'ease-out', out:true}}});
Ext.define('Ext.layout.card.fx.Flip', {extend:Ext.layout.card.fx.Serial, alias:'layout.card.fx.flip', config:{inAnimation:{type:'flip', half:true, easing:'ease-out', before:{'backface-visibility':'hidden'}, after:{'backface-visibility':null}}, outAnimation:{type:'flip', half:true, easing:'ease-in', before:{'backface-visibility':'hidden'}, after:{'backface-visibility':null}, out:true}}, onActiveItemChange:function(cardLayout, newItem, oldItem, controller) {
  var parent = newItem.element.getParent();
  parent.addCls(Ext.baseCSSPrefix + 'layout-card-perspective');
  this.on('animationend', function() {
    parent.removeCls(Ext.baseCSSPrefix + 'layout-card-perspective');
  }, this, {single:true});
  this.callParent(arguments);
}});
Ext.define('Ext.layout.card.fx.Pop', {extend:Ext.layout.card.fx.Serial, alias:'layout.card.fx.pop', config:{inAnimation:{type:'pop', easing:'ease-out'}, outAnimation:{type:'pop', easing:'ease-in', out:true}}});
Ext.define('Ext.layout.card.fx.Reveal', {extend:Ext.layout.card.fx.Style, alias:'layout.card.fx.reveal', config:{inAnimation:{easing:'ease-out', from:{opacity:0.99}, to:{opacity:1}}, outAnimation:{before:{'z-index':100}, after:{'z-index':0}, type:'slide', easing:'ease-out', out:true}}});
Ext.define('Ext.layout.card.fx.Scroll', {extend:Ext.layout.card.fx.Abstract, alias:'layout.card.fx.scroll', config:{duration:150}, getEasing:function() {
  var easing = this.easing;
  if (!easing) {
    this.easing = easing = new Ext.fx.easing.Linear;
  }
  return easing;
}, updateDuration:function(duration) {
  this.getEasing().setDuration(duration);
}, onActiveItemChange:function(cardLayout, newItem, oldItem, controller) {
  var direction = this.getDirection(), easing = this.getEasing(), containerElement, inElement, outElement, containerWidth, containerHeight, reverse;
  if (newItem && oldItem) {
    if (this.isAnimating) {
      this.stopAnimation();
    }
    newItem.setWidth('100%');
    newItem.setHeight('100%');
    containerElement = this.getLayout().container.bodyElement;
    containerWidth = containerElement.getWidth();
    containerHeight = containerElement.getHeight();
    inElement = newItem.renderElement;
    outElement = oldItem.renderElement;
    this.oldItem = oldItem;
    this.newItem = newItem;
    this.containerElement = containerElement;
    this.currentEventController = controller;
    this.isReverse = reverse = this.getReverse();
    newItem.show();
    if (direction == 'right') {
      direction = 'left';
      this.isReverse = reverse = !reverse;
    } else {
      if (direction == 'down') {
        direction = 'up';
        this.isReverse = reverse = !reverse;
      }
    }
    if (direction == 'left') {
      if (reverse) {
        easing.setConfig({startValue:containerWidth, endValue:0});
        containerElement.dom.scrollLeft = containerWidth;
        outElement.setLeft(containerWidth);
      } else {
        easing.setConfig({startValue:0, endValue:containerWidth});
        inElement.setLeft(containerWidth);
      }
    } else {
      if (reverse) {
        easing.setConfig({startValue:containerHeight, endValue:0});
        containerElement.dom.scrollTop = containerHeight;
        outElement.setTop(containerHeight);
      } else {
        easing.setConfig({startValue:0, endValue:containerHeight});
        inElement.setTop(containerHeight);
      }
    }
    this.startAnimation();
    controller.pause();
  }
}, startAnimation:function() {
  this.isAnimating = true;
  this.getEasing().setStartTime(Date.now());
  Ext.AnimationQueue.start(this.doAnimationFrame, this);
}, doAnimationFrame:function() {
  var easing = this.getEasing(), direction = this.getDirection(), scroll = 'scrollTop', value;
  if (direction == 'left' || direction == 'right') {
    scroll = 'scrollLeft';
  }
  if (easing.isEnded) {
    this.stopAnimation();
  } else {
    value = easing.getValue();
    this.containerElement.dom[scroll] = value;
  }
}, stopAnimation:function() {
  var me = this, direction = me.getDirection(), scroll = 'setTop', oldItem = me.oldItem, newItem = me.newItem;
  if (direction == 'left' || direction == 'right') {
    scroll = 'setLeft';
  }
  me.currentEventController.resume();
  if (me.isReverse && oldItem && oldItem.renderElement && oldItem.renderElement.dom) {
    oldItem.renderElement[scroll](null);
  } else {
    if (newItem && newItem.renderElement && newItem.renderElement.dom) {
      newItem.renderElement[scroll](null);
    }
  }
  Ext.AnimationQueue.stop(this.doAnimationFrame, this);
  me.isAnimating = false;
  me.fireEvent('animationend', me);
}});
Ext.define('Ext.layout.card.fx.ScrollCover', {extend:Ext.layout.card.fx.Scroll, alias:'layout.card.fx.scrollcover', onActiveItemChange:function(cardLayout, inItem, outItem, controller) {
  var containerElement, containerSize, xy, animConfig, inTranslate, outTranslate;
  this.currentEventController = controller;
  this.inItem = inItem;
  if (inItem && outItem) {
    containerElement = this.getLayout().container.bodyElement;
    containerSize = containerElement.getSize();
    xy = this.calculateXY(containerSize);
    animConfig = {easing:this.getEasing(), duration:this.getDuration()};
    inItem.renderElement.dom.style.setProperty('visibility', 'hidden', 'important');
    inTranslate = inItem.setTranslatable(true).getTranslatable();
    outTranslate = outItem.setTranslatable(true).getTranslatable();
    outTranslate.translate({x:0, y:0});
    inTranslate.translate({x:xy.left, y:xy.top});
    inTranslate.getWrapper().dom.style.setProperty('z-index', '100', 'important');
    inItem.show();
    inTranslate.on({animationstart:'onInAnimationStart', animationend:'onInAnimationEnd', scope:this});
    inTranslate.translateAnimated({x:0, y:0}, animConfig);
    controller.pause();
  }
}, onInAnimationStart:function() {
  this.inItem.renderElement.dom.style.removeProperty('visibility');
}, onInAnimationEnd:function() {
  if (!this.destroyed) {
    this.inItem.getTranslatable().getWrapper().dom.style.removeProperty('z-index');
    this.currentEventController.resume();
  }
}});
Ext.define('Ext.layout.card.fx.ScrollReveal', {extend:Ext.layout.card.fx.Scroll, alias:'layout.card.fx.scrollreveal', onActiveItemChange:function(cardLayout, inItem, outItem, controller) {
  var containerElement, containerSize, xy, animConfig, outTranslate, inTranslate;
  this.currentEventController = controller;
  this.outItem = outItem;
  this.inItem = inItem;
  if (inItem && outItem) {
    containerElement = this.getLayout().container.bodyElement;
    containerSize = containerElement.getSize();
    xy = this.calculateXY(containerSize);
    animConfig = {easing:this.getEasing(), duration:this.getDuration()};
    outTranslate = outItem.setTranslatable(true).getTranslatable();
    inTranslate = inItem.setTranslatable(true).getTranslatable();
    outTranslate.getWrapper().dom.style.setProperty('z-index', '100', 'important');
    outTranslate.translate({x:0, y:0});
    inTranslate.translate({x:0, y:0});
    inItem.show();
    outTranslate.on({animationend:'onOutAnimationEnd', scope:this});
    outTranslate.translateAnimated({x:xy.x, y:xy.y}, animConfig);
    controller.pause();
  }
}, onOutAnimationEnd:function() {
  if (!this.destroyed) {
    this.outItem.getTranslatable().getWrapper().dom.style.removeProperty('z-index');
    this.currentEventController.resume();
  }
}});
Ext.define('Ext.layout.card.fx.Slide', {extend:Ext.layout.card.fx.Style, alias:'layout.card.fx.slide', config:{inAnimation:{type:'slide', easing:'ease-out'}, outAnimation:{type:'slide', easing:'ease-out', out:true}}});
Ext.define('Ext.layout.Card', {extend:Ext.layout.Auto, alias:'layout.card', type:'card', isCard:true, config:{indicator:{lazy:true, $value:{xtype:'indicator', flex:1}}}, deferRender:true, cls:Ext.baseCSSPrefix + 'layout-card', itemCls:Ext.baseCSSPrefix + 'layout-card-item', applyAnimation:function(animation) {
  return animation ? new Ext.Factory.layoutCardFx(animation) : null;
}, updateAnimation:function(animation, oldAnimation) {
  var me = this, direction;
  me.autoDirection = null;
  if (animation && animation.isAnimation) {
    animation.setLayout(me);
    direction = animation.getDirection();
    if (!direction || me.autoDirectionMap[direction]) {
      me.autoDirection = direction || 'horizontal';
      animation.setDirection(null);
    }
  }
  if (oldAnimation) {
    oldAnimation.destroy();
  }
}, applyIndicator:function(indicator, currentIndicator) {
  return Ext.updateWidget(currentIndicator, indicator, this, 'createIndicator');
}, createIndicator:function(indicator) {
  return Ext.apply({ownerCmp:this.getContainer()}, indicator);
}, updateIndicator:function(indicator) {
  if (indicator) {
    var container = this.getContainer(), innerItems = container.getInnerItems(), activeItem = container.getActiveItem();
    indicator.sync(innerItems.length, innerItems.indexOf(activeItem)).on({indicatortap:'onIndicatorTap', next:'next', previous:'previous', scope:this});
  }
}, onContainerInitialized:function() {
  var me = this, container = me.getContainer(), firstItem = container.getInnerAt(0), activeItem = container.getActiveItem();
  me.callParent();
  if (activeItem) {
    activeItem.show();
    if (firstItem && firstItem !== activeItem) {
      firstItem.hide();
    }
  }
  container.on('activeitemchange', 'onContainerActiveItemChange', me);
}, onContainerActiveItemChange:function(container, newItem, oldItem) {
  var me = this, innerItems = container.getInnerItems(), newIndex = innerItems.indexOf(newItem), oldIndex = innerItems.indexOf(oldItem), animation = me.getAnimation(), autoDirection = me.autoDirection, horizontal = autoDirection && autoDirection === 'horizontal', direction;
  if (autoDirection && newIndex !== -1 && oldIndex !== -1) {
    if (newIndex < oldIndex) {
      direction = horizontal ? 'right' : 'up';
    } else {
      direction = horizontal ? 'left' : 'down';
    }
    animation.setDirection(direction);
  }
  me.fireEventedAction('activeitemchange', [me, newItem, oldItem], 'doActiveItemChange', me);
}, onItemInnerStateChange:function(item, isInner, destroying) {
  this.callParent([item, isInner, destroying]);
  var container = this.getContainer(), activeItem = container.getActiveItem();
  if (isInner) {
    if (activeItem !== container.innerIndexOf(item) && activeItem !== item && item !== container.pendingActiveItem) {
      item.hide();
    }
  } else {
    if (!destroying && !item.destroyed && item.destroying !== true) {
      item.show();
    }
  }
}, doActiveItemChange:function(me, newActiveItem, oldActiveItem) {
  var indicator = me.getConfig('indicator', null, true), container, innerItems;
  if (oldActiveItem && !oldActiveItem.destroyed) {
    oldActiveItem.hide();
  }
  if (newActiveItem && !newActiveItem.destroyed) {
    me.showItem(newActiveItem);
    if (indicator) {
      container = this.getContainer();
      innerItems = container.getInnerItems();
      indicator.setActiveIndex(innerItems.indexOf(newActiveItem));
    }
  }
}, onItemAdd:function(item, index) {
  var indicator, style;
  this.callParent([item, index]);
  if (item.isInnerItem()) {
    indicator = this.getConfig('indicator', null, true);
    if (indicator) {
      indicator.add();
    }
    style = item.element.dom.style;
    style.width = style.height = '';
  }
}, onItemRemove:function(item, index, destroying) {
  var indicator, w, h;
  this.callParent([item, index, destroying]);
  if (item.isInnerItem()) {
    indicator = this.getConfig('indicator', null, true);
    if (indicator) {
      indicator.remove();
    }
    w = item.getWidth();
    h = item.getHeight();
    item.setWidth(null).setWidth(w);
    item.setHeight(null).setHeight(w);
  }
}, next:function() {
  var container = this.getContainer(), activeItem = container.getActiveItem(), innerItems = container.getInnerItems(), index = innerItems.indexOf(activeItem);
  activeItem = innerItems[index + 1];
  if (activeItem) {
    container.setActiveItem(activeItem);
  }
}, previous:function() {
  var container = this.getContainer(), activeItem = container.getActiveItem(), innerItems = container.getInnerItems(), index = innerItems.indexOf(activeItem);
  activeItem = innerItems[index - 1];
  if (activeItem) {
    container.setActiveItem(activeItem);
  }
}, onIndicatorTap:function(indicator, index) {
  var container = this.getContainer();
  container.setActiveItem(index);
}, destroy:function() {
  Ext.destroy(this.getAnimation(), this.getIndicator());
  this.callParent();
}, privates:{autoDirectionMap:{horizontal:1, vertical:1}, renderInnerItem:function(item, asRoot) {
  if (!this.deferRender || this.getContainer().getActiveItem() === item) {
    this.callParent([item, asRoot]);
  }
}, showItem:function(item) {
  item.show();
  if (this.getContainer().rendered) {
    item.setRendered(true, true);
  }
}}});
Ext.define('Ext.util.InputBlocker', {singleton:true, blockInputs:function() {
  if (Ext.browser.is.ie) {
    Ext.select('.x-field-text .x-input:not(.x-item-disabled) .x-input-el, .x-field-textarea .x-input:not(.x-item-disabled) .x-input-el, .x-field-search .x-input:not(.x-item-disabled) .x-input-el').each(function(item) {
      if (item.dom.offsetWidth > 0) {
        item.dom.setAttribute('disabled', true);
        item.dom.setAttribute('overlayfix', true);
      }
    });
  }
}, unblockInputs:function() {
  if (Ext.browser.is.ie) {
    Ext.select('[overlayfix]').each(function(item) {
      item.dom.removeAttribute('disabled');
      item.dom.removeAttribute('overlayfix');
    });
  }
}});
Ext.define('Ext.viewport.Default', function() {
  var TOP = 1, RIGHT = 2, BOTTOM = 4, LEFT = 8, sideMap = {top:TOP, right:RIGHT, bottom:BOTTOM, left:LEFT}, oppositeSide = {1:BOTTOM, 2:LEFT, 4:TOP, 8:RIGHT}, oppositeSideNames = {left:'right', right:'left', top:'bottom', bottom:'top', up:'bottom', down:'top'};
  return {extend:Ext.Container, xtype:'viewport', PORTRAIT:'portrait', LANDSCAPE:'landscape', nameHolder:true, config:{autoMaximize:false, autoBlurInput:true, preventZooming:false, autoRender:true, layout:'card', width:'100%', height:'100%', menus:{}, orientation:null, swipeThreshold:30}, classCls:Ext.baseCSSPrefix + 'viewport', getTemplate:function() {
    var template = this.callParent();
    if (!Ext.feature.has.MatchMedia) {
      template.unshift({reference:'orientationElement', className:Ext.baseCSSPrefix + 'orientation-inspector', children:[{className:Ext.baseCSSPrefix + 'orientation-inspector-landscape'}]});
    }
    return template;
  }, isReady:false, isViewport:true, isMaximizing:false, id:'ext-viewport', isInputRegex:/^(input|textarea|select|a)$/i, isInteractiveWebComponentRegEx:/^(audio|video)$/i, notScalableRe:/user-scalable=no/, focusable:false, focusEl:null, ariaEl:null, allSidesCls:[Ext.baseCSSPrefix + 'top', Ext.baseCSSPrefix + 'right', Ext.baseCSSPrefix + 'bottom', Ext.baseCSSPrefix + 'left'], sideClsMap:{top:Ext.baseCSSPrefix + 'top', right:Ext.baseCSSPrefix + 'right', bottom:Ext.baseCSSPrefix + 'bottom', left:Ext.baseCSSPrefix + 
  'left'}, hasViewportCls:Ext.baseCSSPrefix + 'has-viewport', fixedCls:Ext.baseCSSPrefix + 'fixed-viewport', fullscreenItemCls:Ext.baseCSSPrefix + 'fullscreen', constructor:function(config) {
    var me = this;
    me.doPreventPanning = me.doPreventPanning.bind(me);
    me.doPreventZooming = me.doPreventZooming.bind(me);
    me.maximizeOnEvents = ['ready', 'orientationchange'];
    window.devicePixelRatio = window.devicePixelRatio || 1;
    me.callParent([config]);
    me.updateSize();
    me.windowOuterHeight = me.getWindowOuterHeight();
    Ext.setViewportScroller(me.getScrollable() || Ext.getViewportScroller().setConfig({x:false, y:false, component:me}));
    Ext.getBody().setStyle('overflow', 'hidden');
    Ext.get(document.documentElement).addCls(me.hasViewportCls);
    me.stretchHeights = me.stretchHeights || {};
    if (Ext.feature.has.OrientationChange) {
      me.addWindowListener('orientationchange', me.onOrientationChange.bind(me));
    }
    if (!Ext.os.is.iOS || !me.isScalable()) {
      Ext.get(document.documentElement).addCls(me.fixedCls);
    }
    Ext.GlobalEvents.on('resize', 'onWindowResize', me, {priority:1000});
    Ext.onDocumentReady(me.onDomReady, me);
    return me;
  }, initialize:function() {
    var me = this;
    me.addMeta('apple-mobile-web-app-capable', 'yes');
    me.addMeta('apple-touch-fullscreen', 'yes');
    me.callParent();
  }, getRefItems:function(deep) {
    var menus = this.getMenus(), result = this.callParent([deep]), side, menu;
    for (side in menus) {
      menu = menus[side];
      if (menu) {
        Ext.Array.include(result, menu);
      }
    }
    return result;
  }, initInheritedState:function(inheritedState, inheritedStateInner) {
    var me = this, root = Ext.rootInheritedState;
    if (inheritedState !== root) {
      me.initInheritedState(me.inheritedState = root, me.inheritedStateInner = Ext.Object.chain(root));
    } else {
      me.callParent([inheritedState, inheritedStateInner]);
    }
  }, onAppLaunch:function() {
    var me = this;
    if (!me.isReady) {
      me.onDomReady();
    }
  }, onDomReady:function() {
    var me = this;
    if (me.isReady) {
      return;
    }
    me.isReady = true;
    me.updateSize();
    me.onReady();
    me.fireEvent('ready', me);
    Ext.GlobalEvents.fireEvent('viewportready', me);
  }, onReady:function() {
    if (this.getAutoRender()) {
      this.render();
    }
  }, render:function() {
    var me = this, body = Ext.getBody();
    if (!me.rendered) {
      me.callParent([body, Ext.floatRoot]);
      me.setOrientation(me.determineOrientation());
      Ext.getBody().addCls(Ext.baseCSSPrefix + me.getOrientation());
    }
  }, applyAutoMaximize:function(autoMaximize) {
    return Ext.browser.is.WebView ? false : autoMaximize;
  }, updateAutoMaximize:function(autoMaximize) {
    var me = this;
    if (autoMaximize) {
      me.on('ready', 'doAutoMaximizeOnReady', me, {single:true});
      me.on('orientationchange', 'doAutoMaximizeOnOrientationChange', me);
    } else {
      me.un('ready', 'doAutoMaximizeOnReady', me);
      me.un('orientationchange', 'doAutoMaximizeOnOrientationChange', me);
    }
  }, updatePreventPanning:function(preventPanning) {
    this.toggleWindowListener(preventPanning, 'touchmove', this.doPreventPanning, false);
  }, updatePreventZooming:function(preventZooming) {
    var touchstart = Ext.feature.has.TouchEvents ? 'touchstart' : 'mousedown';
    this.toggleWindowListener(preventZooming, touchstart, this.doPreventZooming, false);
  }, doAutoMaximizeOnReady:function() {
    var me = this;
    me.isMaximizing = true;
    me.on('maximize', function() {
      me.isMaximizing = false;
      me.updateSize();
      me.fireEvent('ready', me);
    }, me, {single:true});
    me.maximize();
  }, doAutoMaximizeOnOrientationChange:function() {
    var me = this;
    me.isMaximizing = true;
    me.on('maximize', function() {
      me.isMaximizing = false;
      me.updateSize();
    }, me, {single:true});
    me.maximize();
  }, doPreventPanning:function(e) {
    var target = e.target, touch;
    if (this.isInteractiveWebComponentRegEx.test(target.tagName) && e.touches && e.touches.length > 0) {
      touch = e.touches[0];
      if (touch && touch.target && this.isInputRegex.test(touch.target.tagName)) {
        return;
      }
    }
    if (target && target.nodeType === 1 && !this.isInputRegex.test(target.tagName)) {
      e.preventDefault();
    }
  }, doPreventZooming:function(e) {
    if ('button' in e && e.button !== 0) {
      return;
    }
    var target = e.target, inputRe = this.isInputRegex, touch;
    if (this.isInteractiveWebComponentRegEx.test(target.tagName) && e.touches && e.touches.length > 0) {
      touch = e.touches[0];
      if (touch && touch.target && inputRe.test(touch.target.tagName)) {
        return;
      }
    }
    if (target && target.nodeType === 1 && !inputRe.test(target.tagName)) {
      e.preventDefault();
    }
  }, addWindowListener:function(eventName, fn, capturing) {
    window.addEventListener(eventName, fn, Boolean(capturing));
  }, removeWindowListener:function(eventName, fn, capturing) {
    window.removeEventListener(eventName, fn, Boolean(capturing));
  }, supportsOrientation:function() {
    return Ext.feature.has.Orientation;
  }, supportsMatchMedia:function() {
    return Ext.feature.has.MatchMedia;
  }, onOrientationChange:function() {
    this.setOrientation(this.determineOrientation());
  }, determineOrientation:function() {
    var me = this, orientationElement = me.orientationElement, nativeOrientation, visible;
    if (me.supportsOrientation()) {
      nativeOrientation = me.getWindowOrientation();
      if (Math.abs(nativeOrientation) === 90 || nativeOrientation === 270) {
        return me.LANDSCAPE;
      } else {
        return me.PORTRAIT;
      }
    } else {
      if (me.supportsMatchMedia()) {
        return window.matchMedia('(orientation : landscape)').matches ? me.LANDSCAPE : me.PORTRAIT;
      } else {
        if (orientationElement) {
          visible = orientationElement.first().isVisible();
          return visible ? me.LANDSCAPE : me.PORTRAIT;
        }
      }
    }
    return null;
  }, updateOrientation:function(newValue, oldValue) {
    if (oldValue) {
      this.fireOrientationChangeEvent(newValue, oldValue);
    }
  }, fireOrientationChangeEvent:function(newOrientation, oldOrientation) {
    var me = this, newSize = me.updateSize();
    Ext.getBody().replaceCls(Ext.baseCSSPrefix + oldOrientation, Ext.baseCSSPrefix + newOrientation);
    me.fireEvent('orientationchange', me, newOrientation, newSize.width, newSize.height);
  }, onWindowResize:function(width, height) {
    var me = this, oldWidth = me.lastSize.width, oldHeight = me.lastSize.height;
    me.updateSize(width, height);
    me.setOrientation(me.determineOrientation());
    if (width != null) {
      me.fireEvent('resize', this, width, height, oldWidth, oldHeight);
    }
  }, updateSize:function(width, height) {
    var lastSize = this.lastSize;
    lastSize.width = width !== undefined ? width : this.getWindowWidth();
    lastSize.height = height !== undefined ? height : this.getWindowHeight();
    return lastSize;
  }, waitUntil:function(condition, onSatisfied, onTimeout, delay, timeoutDuration) {
    if (!delay) {
      delay = 50;
    }
    if (!timeoutDuration) {
      timeoutDuration = 2000;
    }
    var scope = this, elapse = 0;
    Ext.defer(function repeat() {
      elapse += delay;
      if (condition.call(scope) === true) {
        if (onSatisfied) {
          onSatisfied.call(scope);
        }
      } else {
        if (elapse >= timeoutDuration) {
          if (onTimeout) {
            onTimeout.call(scope);
          }
        } else {
          Ext.defer(repeat, delay);
        }
      }
    }, delay);
  }, maximize:function() {
    this.fireMaximizeEvent();
  }, fireMaximizeEvent:function() {
    this.updateSize();
    this.fireEvent('maximize', this);
  }, updateHeight:function(height, oldHeight) {
    Ext.getBody().setHeight(height);
    this.callParent([height, oldHeight]);
  }, updateWidth:function(width, oldWidth) {
    Ext.getBody().setWidth(width);
    this.callParent([width, oldWidth]);
  }, scrollToTop:function() {
    window.scrollTo(0, -1);
  }, getWindowWidth:function() {
    return window.innerWidth;
  }, getWindowHeight:function() {
    return window.innerHeight;
  }, getWindowOuterHeight:function() {
    return window.outerHeight;
  }, getWindowOrientation:function() {
    return window.orientation;
  }, getSize:function() {
    return this.lastSize;
  }, setItemFullScreen:function(item) {
    item.addCls(this.fullscreenItemCls);
    item.setTop(0);
    item.setRight(0);
    item.setBottom(0);
    item.setLeft(0);
    this.add(item);
  }, setMenu:function(menu, config) {
    config = config || {};
    if (config.reveal && config.cover) {
      Ext.raise('[Ext.Viewport] setMenu(): Only one of reveal or cover allowed in config');
    }
    var me = this, side, menus, oldMenu;
    if (Ext.os.is.iOS && !me.hasiOSOrientationFix) {
      me.hasiOSOrientationFix = true;
      me.on('orientationchange', function() {
        window.scrollTo(0, 0);
      }, me);
    }
    if (!menu) {
      Ext.raise('You must specify a menu configuration.');
    }
    menus = me.getMenus();
    if (!me.addedSwipeListener) {
      me.attachSwipeListeners();
      me.addedSwipeListener = true;
    }
    menu = me.configureMenu(menu, config);
    side = menu.getSide();
    oldMenu = menus[side];
    if (oldMenu && !oldMenu.destroyed && oldMenu !== menu) {
      me.hideMenu(side);
      oldMenu.setSide(null);
    }
    menus[side] = menu;
    me.setMenus(menus);
    return menu;
  }, attachSwipeListeners:function() {
    var me = this;
    me.element.on({tap:me.onTap, swipestart:me.onSwipeStart, edgeswipestart:me.onEdgeSwipeStart, edgeswipe:me.onEdgeSwipe, edgeswipeend:me.onEdgeSwipeEnd, scope:me});
  }, configureMenu:function(menu, config) {
    var isInstanced = menu.isComponent, reveal = isInstanced && !('reveal' in config) ? menu.getReveal() : !!config.reveal, cover = (isInstanced && !('cover' in config) ? menu.getCover() : config.cover) !== false && !reveal, side = isInstanced && !('side' in config) ? menu.getSide() : config.side, wasFloated;
    if (!side) {
      Ext.raise('You must specify a side to dock the menu.');
    }
    if (!sideMap[side]) {
      Ext.raise('You must specify a valid side (left, right, top or bottom) to dock the menu.');
    }
    config = {hideAnimation:null, showAnimation:null, hidden:true, floated:cover, zIndex:cover ? null : 5, reveal:reveal, cover:cover, side:side};
    config[oppositeSideNames[side]] = null;
    if (isInstanced) {
      wasFloated = menu.getFloated();
      if (config.floated !== wasFloated) {
        if (menu.rendered) {
          if (wasFloated) {
            this.remove(menu, false);
          } else {
            menu.el.dom.parentNode.removeChild(menu.el.dom);
            menu.setRendered(false);
          }
        }
        menu.setConfig({top:null, right:null, bottom:null, left:null});
      }
      menu.setConfig(config, null, {strict:false});
    } else {
      config.xtype = 'actionsheet';
      menu = Ext.create(Ext.apply(config, menu));
    }
    config = {left:0, right:0, top:0, bottom:0};
    config[oppositeSideNames[side]] = null;
    menu.setConfig(config);
    menu.toggleCls(menu.floatingCls, !menu.getFloated());
    menu.removeCls(this.getLayout().itemCls);
    menu.toggleCls(Ext.baseCSSPrefix + 'menu-cover', cover);
    menu.toggleCls(Ext.baseCSSPrefix + 'menu-reveal', reveal);
    menu.replaceCls(this.allSidesCls, this.sideClsMap[side]);
    menu.isViewportMenu = true;
    return menu;
  }, removeMenu:function(side, animation) {
    var me = this, menus = me.getMenus() || {}, menu = menus[side];
    if (menu) {
      me.hideMenu(side, animation);
      menu.removeCls(me.sideClsMap[side]);
    }
    delete menus[side];
    me.setMenus(menus);
  }, showMenu:function(side) {
    var me = this, sideValue = sideMap[side], menu = me.getMenus()[side], viewportAfter = {translateX:0, translateY:0}, size;
    if (!menu || !menu.isHidden()) {
      return;
    }
    me.beforeMenuAnimate(menu);
    size = menu.element.measure(sideValue & (LEFT | RIGHT) ? 'w' : 'h');
    if (sideValue === LEFT) {
      viewportAfter.translateX = size;
    } else {
      if (sideValue === RIGHT) {
        viewportAfter.translateX = -size;
      } else {
        if (sideValue === TOP) {
          viewportAfter.translateY = size;
        } else {
          if (sideValue === BOTTOM) {
            viewportAfter.translateY = -size;
          }
        }
      }
    }
    menu.translate(0, 0, {duration:200});
    if (!menu.getFloated()) {
      me.translate(viewportAfter.translateX, viewportAfter.translateY, {duration:200});
    }
  }, hideMenu:function(side, animate) {
    var me = this, sideValue = sideMap[side], menu = me.getMenus()[side], after = {translateX:0, translateY:0}, size;
    animate = animate !== false;
    if (!menu || menu.isHidden()) {
      return;
    }
    size = menu.element.measure(sideValue & (LEFT | RIGHT) ? 'w' : 'h');
    if (sideValue === LEFT) {
      after.translateX = -size;
    } else {
      if (sideValue === RIGHT) {
        after.translateX = size;
      } else {
        if (sideValue === TOP) {
          after.translateY = -size;
        } else {
          if (sideValue === BOTTOM) {
            after.translateY = size;
          }
        }
      }
    }
    if (animate) {
      menu.revertFocus();
      menu.translate(after.translateX, after.translateY, {duration:200, callback:function() {
        if (!menu.destroyed) {
          menu.translate(0, 0);
          menu.setHidden(true);
        }
      }});
    } else {
      menu.getTranslatable().stopAnimation();
      menu.setHidden(true);
    }
    if (!menu.getFloated()) {
      me.translate(0, 0, animate ? {duration:200} : null);
    }
  }, hideAllMenus:function(animation) {
    var menus = this.getMenus(), side;
    for (side in menus) {
      this.hideMenu(side, animation);
    }
  }, hideOtherMenus:function(side, animate) {
    var menus = this.getMenus(), menu;
    for (menu in menus) {
      if (side !== menu) {
        this.hideMenu(menu, animate);
      }
    }
  }, toggleMenu:function(side) {
    var menus = this.getMenus(), menu;
    if (menus[side]) {
      menu = menus[side];
      menu.setDisplayed(menu.isHidden());
    }
  }, applyScrollable:function(scrollable) {
    return this.callParent([scrollable, Ext.getViewportScroller()]);
  }, doDestroy:function() {
    var me = this, docEl = Ext.get(document.documentElement), scroller = me._scrollable;
    docEl.removeCls(me.hasViewportCls);
    docEl.removeCls(me.fixedCls);
    if (scroller) {
      scroller.setConfig({x:true, y:true});
      me._scrollable = null;
    }
    Ext.un('resize', 'onWindowResize', me);
    me.callParent();
    Ext.Viewport = null;
  }, privates:{addMeta:function(name, content) {
    var meta = document.createElement('meta');
    meta.setAttribute('name', name);
    meta.setAttribute('content', content);
    Ext.getHead().append(meta);
  }, beforeMenuAnimate:function(menu) {
    var me = this, side = menu.getSide(), sideValue = sideMap[side], before = {translateX:0, translateY:0}, size, modal;
    me.hideOtherMenus(side);
    if (menu.getFloated()) {
      me.add(menu);
    } else {
      Ext.getBody().insertFirst(menu.element);
      if (!menu.rendered) {
        menu.setRendered(true);
      }
      modal = menu.getModal();
      if (modal) {
        Ext.getBody().insertFirst(modal.element);
        if (!modal.rendered) {
          modal.setRendered(true);
        }
      }
      me.translate(0, 0);
    }
    menu.removeCls(me.getLayout().itemCls);
    menu.show(false, {side:null});
    size = menu.element.measure(sideValue & (LEFT | RIGHT) ? 'w' : 'h');
    if (sideValue === LEFT) {
      before.translateX = -size;
    } else {
      if (sideValue === RIGHT) {
        before.translateX = size;
      } else {
        if (sideValue === TOP) {
          before.translateY = -size;
        } else {
          if (sideValue === BOTTOM) {
            before.translateY = size;
          }
        }
      }
    }
    menu.translate(before.translateX, before.translateY);
  }, doAddListener:function(eventName, fn, scope, options, order, caller, manager) {
    var me = this;
    if (eventName === 'ready' && me.isReady && !me.isMaximizing) {
      fn.call(scope);
      return me;
    }
    me.callParent([eventName, fn, scope, options, order, caller, manager]);
  }, isScalable:function() {
    var me = this, metas = document.querySelectorAll('meta[name\x3d"viewport"]'), meta = metas.length && metas[metas.length - 1], scalable = true, content;
    if (meta) {
      content = meta.getAttribute('content');
      scalable = !(content && me.notScalableRe.test(content));
    }
    return scalable;
  }, onTap:function(e) {
  }, onSwipeStart:function(e) {
    var side = this.sideForSwipeDirection(e.direction), menu = this.getMenus()[side];
    if (menu && !menu.owns(e)) {
      this.hideMenu(side);
    }
  }, onEdgeSwipeStart:function(e) {
    var me = this, menus = me.getMenus(), menu = menus[oppositeSideNames[e.direction]], menuSide, checkMenu;
    if (!menu || !menu.isHidden()) {
      return;
    }
    e.claimGesture();
    for (menuSide in menus) {
      checkMenu = menus[menuSide];
      if (checkMenu.isVisible()) {
        return;
      }
    }
    me.$swiping = true;
    me.beforeMenuAnimate(menu);
  }, onEdgeSwipe:function(e) {
    var me = this, side = me.sideForDirection(e.direction), menu = me.getMenus()[oppositeSideNames[e.direction]], size, after, viewportAfter, movement, viewportMovement;
    if (!menu || !me.$swiping) {
      return;
    }
    e.claimGesture();
    if (e.distance !== me.lastSwipeDistance) {
      me.reverseSwiping = e.distance < me.lastSwipeDistance;
    }
    me.lastSwipeDistance = e.distance;
    size = menu.element.measure(side & (LEFT | RIGHT) ? 'w' : 'h');
    movement = Math.min(e.distance - size, 0);
    viewportMovement = Math.min(e.distance, size);
    after = {translateX:0, translateY:0};
    viewportAfter = {translateX:0, translateY:0};
    if (side === LEFT) {
      after.translateX = movement;
      viewportAfter.translateX = viewportMovement;
    } else {
      if (side === RIGHT) {
        after.translateX = -movement;
        viewportAfter.translateX = -viewportMovement;
      } else {
        if (side === TOP) {
          after.translateY = movement;
          viewportAfter.translateY = viewportMovement;
        } else {
          if (side === BOTTOM) {
            after.translateY = -movement;
            viewportAfter.translateY = -viewportMovement;
          }
        }
      }
    }
    menu.translate(after.translateX, after.translateY);
    if (!menu.getFloated()) {
      me.translate(viewportAfter.translateX, viewportAfter.translateY);
    }
  }, onEdgeSwipeEnd:function(e) {
    var me = this, side = me.sideForDirection(e.direction), menu = me.getMenus()[oppositeSideNames[e.direction]], shouldRevert = me.reverseSwiping || e.distance < me.getSwipeThreshold(), after = {translateX:0, translateY:0}, viewportAfter = {translateX:0, translateY:0}, size, velocity, movement, viewportMovement;
    if (!menu) {
      return;
    }
    size = menu.element.measure(side & (LEFT | RIGHT) ? 'w' : 'h');
    velocity = e.flick ? e.flick.velocity : 0;
    if (side === RIGHT) {
      if (velocity.x > 0) {
        shouldRevert = true;
      }
    } else {
      if (side === LEFT) {
        if (velocity.x < 0) {
          shouldRevert = true;
        }
      } else {
        if (side === TOP) {
          if (velocity.y < 0) {
            shouldRevert = true;
          }
        } else {
          if (side === BOTTOM) {
            if (velocity.y > 0) {
              shouldRevert = true;
            }
          }
        }
      }
    }
    movement = shouldRevert ? size : 0;
    viewportMovement = shouldRevert ? 0 : -size;
    if (side === LEFT) {
      after.translateX = -movement;
      viewportAfter.translateX = -viewportMovement;
    } else {
      if (side === RIGHT) {
        after.translateX = movement;
        viewportAfter.translateX = viewportMovement;
      } else {
        if (side === TOP) {
          after.translateY = -movement;
          viewportAfter.translateY = -viewportMovement;
        } else {
          if (side === BOTTOM) {
            after.translateY = movement;
            viewportAfter.translateY = viewportMovement;
          }
        }
      }
    }
    menu.translate(after.translateX, after.translateY, {duration:200, callback:function() {
      if (shouldRevert) {
        menu.setHidden(true);
      }
    }});
    if (!menu.getFloated()) {
      me.translate(viewportAfter.translateX, viewportAfter.translateY, {duration:200});
    }
    me.$swiping = false;
  }, sideForDirection:function(direction) {
    if (direction === 'up') {
      direction = 'top';
    } else {
      if (direction === 'down') {
        direction = 'bottom';
      }
    }
    return oppositeSide[sideMap[direction]];
  }, sideForSwipeDirection:function(direction) {
    if (direction === 'up') {
      return 'top';
    } else {
      if (direction === 'down') {
        return 'bottom';
      }
    }
    return direction;
  }, toggleWindowListener:function(on, eventName, fn, capturing) {
    if (on) {
      this.addWindowListener(eventName, fn, capturing);
    } else {
      this.removeWindowListener(eventName, fn, capturing);
    }
  }}};
});
Ext.define('Ext.viewport.Ios', {extend:Ext.viewport.Default, isFullscreen:function() {
  return this.isHomeScreen();
}, isHomeScreen:function() {
  return window.navigator.standalone === true;
}, constructor:function() {
  this.callParent(arguments);
  document.documentElement.style.overflow = 'hidden';
}, maximize:function() {
  if (this.isFullscreen()) {
    return this.callParent();
  }
  var stretchHeights = this.stretchHeights, orientation = this.getOrientation(), currentHeight = this.getWindowHeight(), height = stretchHeights[orientation];
  if (window.scrollY > 0) {
    this.scrollToTop();
    if (!height) {
      stretchHeights[orientation] = height = this.getWindowHeight();
    }
    this.setHeight(height);
    this.fireMaximizeEvent();
  } else {
    if (!height) {
      height = this.getScreenHeight();
    }
    this.setHeight(height);
    this.waitUntil(function() {
      this.scrollToTop();
      return currentHeight !== this.getWindowHeight();
    }, function() {
      if (!stretchHeights[orientation]) {
        height = stretchHeights[orientation] = this.getWindowHeight();
        this.setHeight(height);
      }
      this.fireMaximizeEvent();
    }, function() {
      Ext.Logger.error('Timeout waiting for window.innerHeight to change', this);
      height = stretchHeights[orientation] = this.getWindowHeight();
      this.setHeight(height);
      this.fireMaximizeEvent();
    }, 50, 1000);
  }
}, getScreenHeight:function() {
  return window.screen[this.getOrientation() === this.PORTRAIT ? 'height' : 'width'];
}, scrollToTop:function() {
  window.scrollTo(0, 0);
}}, function() {
  if (!Ext.os.is.iOS) {
    return;
  }
  if (Ext.os.version.lt('3.2')) {
    this.override({constructor:function() {
      var stretchHeights = this.stretchHeights = {};
      stretchHeights[this.PORTRAIT] = 416;
      stretchHeights[this.LANDSCAPE] = 268;
      return this.callOverridden(arguments);
    }});
  }
  if (Ext.os.version.lt('5')) {
    this.override({fieldMaskClsTest:'-field-mask', doPreventZooming:function(e) {
      var target = e.target;
      if (target && target.nodeType === 1 && !this.isInputRegex.test(target.tagName) && target.className.indexOf(this.fieldMaskClsTest) == -1) {
        e.preventDefault();
      }
    }});
  }
  if (Ext.os.is.iPad) {
    this.override({isFullscreen:function() {
      return true;
    }});
  }
  if (Ext.os.version.gtEq('7') && Ext.os.version.lt('8')) {
    if (Ext.os.deviceType === 'Tablet' || !Ext.browser.is.Safari || window.navigator.standalone) {
      this.override({constructor:function() {
        var stretchHeights = {}, stretchWidths = {}, orientation = this.determineOrientation(), screenHeight = window.screen.height, screenWidth = window.screen.width, menuHeight = orientation === this.PORTRAIT ? screenHeight - window.innerHeight : screenWidth - window.innerHeight;
        stretchHeights[this.PORTRAIT] = screenHeight - menuHeight;
        stretchHeights[this.LANDSCAPE] = screenWidth - menuHeight;
        stretchWidths[this.PORTRAIT] = screenWidth;
        stretchWidths[this.LANDSCAPE] = screenHeight;
        this.stretchHeights = stretchHeights;
        this.stretchWidths = stretchWidths;
        this.callOverridden(arguments);
        this.on('ready', this.setViewportSizeToAbsolute, this);
        this.on('orientationchange', this.setViewportSizeToAbsolute, this);
      }, getWindowHeight:function() {
        return this.stretchHeights[this.getOrientation()];
      }, getWindowWidth:function() {
        return this.stretchWidths[this.getOrientation()];
      }, setViewportSizeToAbsolute:function() {
        this.setWidth(this.getWindowWidth());
        this.setHeight(this.getWindowHeight());
      }});
    }
    if (Ext.os.deviceType === 'Tablet') {
      this.override({constructor:function() {
        this.callOverridden(arguments);
        window.addEventListener('scroll', function() {
          if (window.scrollX !== 0) {
            window.scrollTo(0, window.scrollY);
          }
        }, false);
      }, setViewportSizeToAbsolute:function() {
        window.scrollTo(0, 0);
        this.callOverridden(arguments);
      }, onElementBlur:function() {
        this.callOverridden(arguments);
        if (window.scrollY !== 0) {
          window.scrollTo(0, 0);
        }
      }});
    }
  }
});
Ext.define('Ext.viewport.Android', {extend:Ext.viewport.Default, config:{translatable:{type:'csstransform'}}, preventPullRefresh:true, constructor:function() {
  var me = this;
  me.callParent(arguments);
  me.on({orientationchange:'hideKeyboardIfNeeded', scope:me, priority:1001});
  if (me.preventPullRefresh) {
    Ext.getBody().setStyle({overflow:'hidden'});
  }
}, getWindowWidth:function() {
  return this.element.getWidth();
}, getWindowHeight:function() {
  return this.element.getHeight();
}, getDummyInput:function() {
  var input = this.dummyInput, focusedElement = this.focusedElement, box = Ext.fly(focusedElement).getBox();
  if (!input) {
    this.dummyInput = input = document.createElement('input');
    input.style.position = 'absolute';
    input.style.opacity = '0';
    input.style.pointerEvents = 'none';
    document.body.appendChild(input);
  }
  input.style.left = box.left + 'px';
  input.style.top = box.top + 'px';
  input.style.display = '';
  return input;
}, doBlurInput:function(e) {
  var target = e.target, focusedElement = this.focusedElement, dummy;
  if (focusedElement && !this.isInputRegex.test(target.tagName)) {
    dummy = this.getDummyInput();
    delete this.focusedElement;
    dummy.focus();
    Ext.defer(function() {
      dummy.style.display = 'none';
    }, 100);
  }
}, hideKeyboardIfNeeded:function() {
  var focusedElement = this.focusedElement;
  if (focusedElement) {
    delete this.focusedElement;
    if (Ext.os.version.lt('4')) {
      focusedElement.style.display = 'none';
    } else {
      focusedElement.blur();
    }
    Ext.defer(function() {
      focusedElement.style.display = '';
    }, 1000);
  }
}, doFireOrientationChangeEvent:function() {
  this.orientationChanging = true;
  this.waitUntil(function() {
    return this.getWindowOuterHeight() !== this.windowOuterHeight;
  }, function() {
    this.windowOuterHeight = this.getWindowOuterHeight();
    this.updateSize();
    this.orientationChanging = false;
  }, function() {
    Ext.Logger.error("Timeout waiting for viewport's outerHeight to change before firing orientationchange", this);
  });
  return this;
}, getActualWindowOuterHeight:function() {
  return Math.round(this.getWindowOuterHeight() / window.devicePixelRatio);
}, maximize:function() {
  var stretchHeights = this.stretchHeights, orientation = this.orientation, height;
  height = stretchHeights[orientation];
  if (!height) {
    stretchHeights[orientation] = height = this.getActualWindowOuterHeight();
  }
  if (!this.addressBarHeight) {
    this.addressBarHeight = height - this.getWindowHeight();
  }
  this.setHeight(height);
  var isHeightMaximized = this.isHeightMaximized.bind(this, height);
  this.scrollToTop();
  this.waitUntil(isHeightMaximized, this.fireMaximizeEvent, this.fireMaximizeEvent);
}, isHeightMaximized:function(height) {
  this.scrollToTop();
  return this.getWindowHeight() === height;
}, doPreventZooming:function(e) {
  if ('button' in e && e.button !== 0) {
    return;
  }
  var target = e.target;
  if (target && target.nodeType === 1 && !this.isInputRegex.test(target.tagName) && !this.focusedElement) {
    e.preventDefault();
  }
}}, function() {
  if (!Ext.os.is.Android) {
    return;
  }
  var version = Ext.os.version, userAgent = Ext.browser.userAgent, isBuggy = /(htc|desire|incredible|ADR6300)/i.test(userAgent) && version.lt('2.3');
  if (isBuggy) {
    this.override({constructor:function(config) {
      if (!config) {
        config = {};
      }
      config.autoMaximize = false;
      this.watchDogTick = this.watchDogTick.bind(this);
      Ext.interval(this.watchDogTick, 1000);
      return this.callParent([config]);
    }, watchDogTick:function() {
      this.watchDogLastTick = Ext.Date.now();
    }, doPreventPanning:function() {
      var now = Ext.Date.now(), lastTick = this.watchDogLastTick, deltaTime = now - lastTick;
      if (deltaTime >= 2000) {
        return;
      }
      return this.callParent(arguments);
    }, doPreventZooming:function() {
      var now = Ext.Date.now(), lastTick = this.watchDogLastTick, deltaTime = now - lastTick;
      if (deltaTime >= 2000) {
        return;
      }
      return this.callParent(arguments);
    }});
  }
  if (version.match('2')) {
    this.override({onReady:function() {
      this.addWindowListener('resize', this.onWindowResize.bind(this));
      this.callParent(arguments);
    }, scrollToTop:function() {
      document.body.scrollTop = 100;
    }, onWindowResize:function() {
      var oldWidth = this.windowWidth, oldHeight = this.windowHeight, width = this.getWindowWidth(), height = this.getWindowHeight();
      if (this.getAutoMaximize() && !this.isMaximizing && !this.orientationChanging && window.scrollY === 0 && oldWidth === width && height < oldHeight && (height >= oldHeight - this.addressBarHeight || !this.focusedElement)) {
        this.scrollToTop();
      }
    }});
  } else {
    if (version.gtEq('3.1')) {
      this.override({isHeightMaximized:function(height) {
        this.scrollToTop();
        return this.getWindowHeight() === height - 1;
      }});
    } else {
      if (version.match('3')) {
        this.override({isHeightMaximized:function() {
          this.scrollToTop();
          return true;
        }});
      }
    }
  }
  if (version.gtEq('4')) {
    this.override({doBlurInput:Ext.emptyFn});
  }
});
Ext.define('Ext.viewport.WindowsPhone', {extend:Ext.viewport.Default, requires:[], alternateClassName:'Ext.viewport.WP', config:{translatable:{type:'csstransform'}}, initialize:function() {
  var preventSelection = function(e) {
    var srcElement = e.srcElement.nodeName.toUpperCase(), selectableElements = ['INPUT', 'TEXTAREA'];
    if (selectableElements.indexOf(srcElement) == -1) {
      return false;
    }
  };
  document.body.addEventListener('onselectstart', preventSelection);
  this.addMeta('msapplication-tap-highlight', 'no');
  this.callParent();
}, supportsOrientation:function() {
  return false;
}, onWindowResize:function(width, height) {
  this.callParent([width, height]);
  this.waitUntil(function() {
    var oldWidth = this.windowWidth, oldHeight = this.windowHeight, width = this.getWindowWidth(), height = this.getWindowHeight(), currentOrientation = this.getOrientation(), newOrientation = this.determineOrientation();
    return oldWidth !== width && oldHeight !== height && currentOrientation !== newOrientation;
  }, function() {
    var currentOrientation = this.getOrientation(), newOrientation = this.determineOrientation();
    this.fireOrientationChangeEvent(newOrientation, currentOrientation);
  }, Ext.emptyFn, 250);
}});
Ext.define('Ext.viewport.Viewport', {singleton:true, setup:function(config) {
  var osName = Ext.os.name, viewportName, viewport;
  switch(osName) {
    case 'Android':
      viewportName = Ext.browser.name === 'ChromeMobile' ? 'Default' : 'Android';
      break;
    case 'iOS':
      viewportName = 'Ios';
      break;
    case 'Windows':
      viewportName = Ext.browser.name === 'IE' ? 'WindowsPhone' : 'Default';
      break;
    case 'WindowsPhone':
      viewportName = 'WindowsPhone';
      break;
    default:
      viewportName = 'Default';
      break;
  }
  return Ext.Viewport = viewport = Ext.create('Ext.viewport.' + viewportName, config);
}});
Ext.define('Ext.overrides.app.Application', {override:'Ext.app.Application', config:{viewport:null}, quickTips:false, destroy:function() {
  this.setQuickTips(false);
  this.callParent();
}, initMainView:function() {
  var me = this, viewport = me.viewport = Ext.Viewport, mainView;
  me.callParent();
  mainView = me.getMainView();
  viewport.onAppLaunch();
  if (mainView) {
    viewport.add(mainView);
  }
}, applyQuickTips:function(quickTips) {
  quickTips = quickTips || null;
  if (quickTips) {
    if (quickTips === true) {
      quickTips = {};
    }
    quickTips = new Ext.tip['Manager'](quickTips);
  }
  return quickTips;
}, updateQuickTips:function(quickTips, oldQuickTips) {
  if (oldQuickTips) {
    oldQuickTips.destroy();
  }
}});
Ext.define('Ext.app.domain.View', {extend:Ext.app.EventDomain, isInstance:true, constructor:function(controller) {
  this.callParent([controller]);
  this.controller = controller;
  this.monitoredClasses = [Ext.Widget];
}, match:function(target, selector, controller) {
  var out = false;
  if (selector === '#') {
    out = controller === target.getController();
  } else {
    out = target.is(selector);
  }
  return out;
}, destroy:function() {
  this.controller = null;
  this.callParent();
}});
Ext.define('Ext.app.ViewController', {extend:Ext.app.BaseController, alias:'controller.controller', mixins:[Ext.mixin.Factoryable], isViewController:true, factoryConfig:{type:'controller'}, config:{bindings:{$value:null, lazy:true}, closeViewAction:'destroy'}, view:null, constructor:function(config) {
  this.compDomain = new Ext.app.domain.View(this);
  this.callParent([config]);
}, beforeInit:Ext.emptyFn, init:Ext.emptyFn, initViewModel:Ext.emptyFn, destroy:function() {
  var me = this, domain = me.compDomain, bind, b, key;
  if (me.$hasBinds) {
    bind = me.getBindings();
    for (key in bind) {
      b = bind[key];
      if (b) {
        b.destroy();
      }
    }
  }
  if (domain) {
    domain.unlisten(me);
    domain.destroy();
  }
  me.compDomain = me.view = null;
  me.callParent();
}, closeView:function() {
  var view = this.getView(), action;
  if (view) {
    action = this.getCloseViewAction();
    view[action]();
  }
}, control:function(selectors, listeners) {
  var obj = selectors;
  if (Ext.isString(selectors)) {
    obj = {};
    obj[selectors] = listeners;
  }
  this.compDomain.listen(obj, this);
}, listen:function(to, controller) {
  var component = to.component;
  if (component) {
    to = Ext.apply({}, to);
    delete to.component;
    this.control(component);
  }
  this.callParent([to, controller]);
}, applyId:function(id) {
  if (!id) {
    id = Ext.id(null, 'controller-');
  }
  return id;
}, getReferences:function() {
  var view = this.view;
  return view && view.getReferences();
}, getView:function() {
  return this.view;
}, lookup:function(key) {
  var view = this.view;
  return view && view.lookup(key);
}, lookupReference:function(key) {
  return this.lookup(key);
}, getSession:function() {
  var view = this.view;
  return view && view.lookupSession();
}, getViewModel:function() {
  var view = this.view;
  return view && view.lookupViewModel();
}, getStore:function(name) {
  var viewModel = this.getViewModel();
  return viewModel ? viewModel.getStore(name) : null;
}, fireViewEvent:function(eventName, args) {
  var view = this.view, result = false, a = arguments;
  if (view) {
    if (view !== args) {
      a = Ext.Array.slice(a);
      a.splice(1, 0, view);
    }
    result = view.fireEvent.apply(view, a);
  }
  return result;
}, applyBindings:function(bindings) {
  if (!bindings) {
    return null;
  }
  var me = this, viewModel = me.getViewModel(), getBindTemplateScope = me.getBindTemplateScope(), b, fn, descriptor;
  me.$hasBinds = true;
  if (!viewModel) {
    Ext.raise('Cannot use bind config without a viewModel');
  }
  for (fn in bindings) {
    descriptor = bindings[fn];
    b = null;
    if (descriptor) {
      b = viewModel.bind(descriptor, fn, me);
      b.getTemplateScope = getBindTemplateScope;
    }
    bindings[fn] = b;
  }
  return bindings;
}, privates:{view:null, attachReference:function(component) {
  var view = this.view;
  if (view) {
    view.attachReference(component);
  }
}, getBindTemplateScope:function() {
  return this.scope;
}, initBindings:function() {
  this.getBindings();
}, setView:function(view) {
  this.view = view;
  if (!this.beforeInit.$nullFn) {
    this.beforeInit(view);
  }
}}});
Ext.define('Ext.util.Bag', {isBag:true, constructor:function() {
  this.items = [];
  this.map = {};
}, generation:0, length:0, beginUpdate:Ext.emptyFn, endUpdate:Ext.emptyFn, add:function(item) {
  var me = this, items = me.items, map = me.map, n = 1, old, i, idx, id, it, ret, was;
  if (Ext.isArray(item)) {
    old = ret = [];
    n = item.length;
  }
  for (i = 0; i < n; i++) {
    id = me.getKey(it = old ? item[i] : item);
    idx = map[id];
    if (idx === undefined) {
      items.push(it);
      map[id] = me.length++;
      if (old) {
        old.push(it);
      } else {
        ret = it;
      }
    } else {
      was = items[idx];
      if (old) {
        old.push(was);
      } else {
        ret = was;
      }
      items[idx] = it;
    }
  }
  ++me.generation;
  return ret;
}, clear:function() {
  var me = this, needsClear = me.generation || me.length, ret = needsClear ? me.items : [];
  if (needsClear) {
    me.items = [];
    me.length = 0;
    me.map = {};
    ++me.generation;
  }
  return ret;
}, clone:function() {
  var me = this, ret = new me.self, len = me.length;
  if (len) {
    Ext.apply(ret.map, me.map);
    ret.items = me.items.slice();
    ret.length = me.length;
  }
  return ret;
}, contains:function(item) {
  var ret = false, map = this.map, key;
  if (item != null) {
    key = this.getKey(item);
    if (key in map) {
      ret = this.items[map[key]] === item;
    }
  }
  return ret;
}, containsKey:function(key) {
  return key in this.map;
}, destroy:function() {
  this.items = this.map = null;
  this.callParent();
}, each:function(fn, scope) {
  var items = this.items, len = items.length, i, ret;
  if (len) {
    scope = scope || this;
    items = items.slice(0);
    for (i = 0; i < len; i++) {
      ret = fn.call(scope, items[i], i, len);
      if (ret === false) {
        break;
      }
    }
  }
  return ret;
}, getAt:function(index) {
  var out = null;
  if (index < this.length) {
    out = this.items[index];
  }
  return out;
}, get:function(key) {
  return this.getByKey(key);
}, getByKey:function(key) {
  var map = this.map, ret = key in map ? this.items[map[key]] : null;
  return ret;
}, indexOfKey:function(key) {
  var map = this.map, ret = key in map ? map[key] : -1;
  return ret;
}, last:function() {
  return this.items[this.length - 1];
}, updateKey:function(item, oldKey) {
  var me = this, map = me.map, newKey;
  if (!item || !oldKey) {
    return;
  }
  if ((newKey = me.getKey(item)) !== oldKey) {
    if (me.getAt(map[oldKey]) === item && !(newKey in map)) {
      me.generation++;
      map[newKey] = map[oldKey];
      delete map[oldKey];
    }
  } else {
    if (newKey in map && me.getAt(map[newKey]) !== item) {
      Ext.raise('Duplicate newKey "' + newKey + '" for item with oldKey "' + oldKey + '"');
    }
    if (oldKey in map && me.getAt(map[oldKey]) !== item) {
      Ext.raise('Incorrect oldKey "' + oldKey + '" for item with newKey "' + newKey + '"');
    }
  }
}, getCount:function() {
  return this.length;
}, getKey:function(item) {
  return item.id || item.getId();
}, getRange:function(begin, end) {
  var items = this.items, length = items.length, range;
  if (!length) {
    range = [];
  } else {
    range = Ext.Number.clipIndices(length, [begin, end]);
    range = items.slice(range[0], range[1]);
  }
  return range;
}, remove:function(item) {
  var me = this, map = me.map, items = me.items, ret = null, n = 1, changed, old, i, idx, id, last, was;
  if (Ext.isArray(item)) {
    n = item.length;
    old = ret = [];
  }
  if (me.length) {
    for (i = 0; i < n; i++) {
      idx = map[id = me.getKey(old ? item[i] : item)];
      if (idx !== undefined) {
        delete map[id];
        was = items[idx];
        if (old) {
          old.push(was);
        } else {
          ret = was;
        }
        last = items.pop();
        if (idx < --me.length) {
          items[idx] = last;
          map[me.getKey(last)] = idx;
        }
        changed = true;
      }
    }
    if (changed) {
      ++me.generation;
    }
  }
  return ret;
}, removeByKey:function(key) {
  var item = this.getByKey(key);
  if (item) {
    this.remove(item);
  }
  return item || null;
}, replace:function(item) {
  this.add(item);
  return item;
}, sort:function(fn) {
  var me = this, items = me.items, n = items.length, item;
  if (n) {
    Ext.Array.sort(items, fn);
    me.map = {};
    while (n-- > 0) {
      item = items[n];
      me.map[me.getKey(item)] = n;
    }
    ++me.generation;
  }
}});
Ext.define('Ext.util.Scheduler', {mixins:[Ext.mixin.Observable], busyCounter:0, lastBusyCounter:0, destroyed:false, firing:null, notifyIndex:-1, nextId:0, orderedItems:null, passes:0, scheduledCount:0, validIdRe:null, config:{cycleLimit:5, preSort:null, tickDelay:5}, suspendOnNotify:true, constructor:function(config) {
  if (Ext.util.Scheduler.instances) {
    Ext.util.Scheduler.instances.push(this);
  } else {
    Ext.util.Scheduler.instances = [this];
  }
  this.id = Ext.util.Scheduler.count = (Ext.util.Scheduler.count || 0) + 1;
  this.mixins.observable.constructor.call(this, config);
  this.items = new Ext.util.Bag;
}, destroy:function() {
  var me = this, timer = me.timer;
  if (timer) {
    window.clearTimeout(timer);
    me.timer = null;
  }
  me.items.destroy();
  me.items = me.orderedItems = null;
  me.callParent();
  Ext.Array.remove(Ext.util.Scheduler.instances, this);
}, add:function(item) {
  var me = this, items = me.items;
  if (items === me.firing) {
    me.items = items = items.clone();
  }
  item.id = item.id || ++me.nextId;
  item.scheduler = me;
  items.add(item);
  if (!me.sortMap) {
    me.orderedItems = null;
  }
}, remove:function(item) {
  var me = this, items = me.items;
  if (me.destroyed) {
    return;
  }
  if (me.sortMap) {
    Ext.raise('Items cannot be removed during sort');
  }
  if (items === me.firing) {
    me.items = items = items.clone();
  }
  if (item.scheduled) {
    me.unscheduleItem(item);
    item.scheduled = false;
  }
  items.remove(item);
  me.orderedItems = null;
}, sort:function() {
  var me = this, items = me.items, sortMap = {}, preSort = me.getPreSort(), i, item;
  me.orderedItems = [];
  me.sortMap = sortMap;
  me.sortStack = [];
  if (preSort) {
    items.sort(preSort);
  }
  items = items.items;
  for (i = 0; i < items.length; ++i) {
    item = items[i];
    if (!sortMap[item.id]) {
      me.sortItem(item);
    }
  }
  me.sortMap = null;
  me.sortStack = null;
}, sortItem:function(item) {
  var me = this, sortMap = me.sortMap, orderedItems = me.orderedItems, itemId;
  if (!item.scheduler) {
    me.add(item);
  }
  itemId = item.id;
  if (item.scheduler !== me) {
    Ext.raise('Item ' + itemId + ' belongs to another Scheduler');
  }
  me.sortStack.push(item);
  if (sortMap[itemId] === 0) {
    for (var cycle = [], i = 0; i < me.sortStack.length; ++i) {
      cycle[i] = me.sortStack[i].getFullName();
    }
    Ext.raise('Dependency cycle detected: ' + cycle.join('\n --\x3e '));
  }
  if (!(itemId in sortMap)) {
    sortMap[itemId] = 0;
    if (!item.sort.$nullFn) {
      item.sort();
    }
    sortMap[itemId] = 1;
    item.order = me.orderedItems.length;
    orderedItems.push(item);
  }
  me.sortStack.pop();
  return me;
}, sortItems:function(items) {
  var me = this, sortItem = me.sortItem;
  if (items) {
    if (items instanceof Array) {
      Ext.each(items, sortItem, me);
    } else {
      Ext.Object.eachValue(items, sortItem, me);
    }
  }
  return me;
}, applyPreSort:function(preSort) {
  if (typeof preSort === 'function') {
    return preSort;
  }
  var parts = preSort.split(','), direction = [], length = parts.length, c, i, s;
  for (i = 0; i < length; ++i) {
    direction[i] = 1;
    s = parts[i];
    if ((c = s.charAt(0)) === '-') {
      direction[i] = -1;
    } else {
      if (c !== '+') {
        c = 0;
      }
    }
    if (c) {
      parts[i] = s.substring(1);
    }
  }
  return function(lhs, rhs) {
    var ret = 0, i, prop, v1, v2;
    for (i = 0; !ret && i < length; ++i) {
      prop = parts[i];
      v1 = lhs[prop];
      v2 = rhs[prop];
      ret = direction[i] * (v1 < v2 ? -1 : v2 < v1 ? 1 : 0);
    }
    return ret;
  };
}, notify:function() {
  var me = this, timer = me.timer, cyclesLeft = me.getCycleLimit(), globalEvents = Ext.GlobalEvents, suspend = me.suspendOnNotify, busyCounter, i, item, len, queue, firedEvent;
  if (timer) {
    window.clearTimeout(timer);
    me.timer = null;
  }
  if (!me.firing && me.scheduledCount) {
    if (suspend) {
      Ext.suspendLayouts();
    }
    while (me.scheduledCount) {
      if (cyclesLeft) {
        --cyclesLeft;
      } else {
        me.firing = null;
        if (me.onCycleLimitExceeded) {
          me.onCycleLimitExceeded();
        }
        break;
      }
      if (!firedEvent) {
        firedEvent = true;
        if (globalEvents.hasListeners.beforebindnotify) {
          globalEvents.fireEvent('beforebindnotify', me);
        }
      }
      ++me.passes;
      if (!(queue = me.orderedItems)) {
        me.sort();
        queue = me.orderedItems;
      }
      len = queue.length;
      if (len) {
        me.firing = me.items;
        for (i = 0; i < len; ++i) {
          item = queue[i];
          if (item.scheduled) {
            item.scheduled = false;
            --me.scheduledCount;
            me.notifyIndex = i;
            item.react();
            if (!me.scheduledCount) {
              break;
            }
          }
        }
      }
    }
    me.firing = null;
    me.notifyIndex = -1;
    if (suspend) {
      Ext.resumeLayouts(true);
    }
  }
  if ((busyCounter = me.busyCounter) !== me.lastBusyCounter) {
    if (!(me.lastBusyCounter = busyCounter)) {
      me.fireEvent('idle', me);
    }
  }
}, onTick:function() {
  this.timer = null;
  this.notify();
}, scheduleItem:function(item) {
  var me = this;
  ++me.scheduledCount;
  if (!me.timer && !me.firing) {
    me.scheduleTick();
  }
}, scheduleTick:function() {
  var me = this;
  if (!me.destroyed && !me.timer) {
    me.timer = Ext.defer(me.onTick, me.getTickDelay(), me);
  }
}, unscheduleItem:function(item) {
  if (this.scheduledCount) {
    --this.scheduledCount;
  }
}, adjustBusy:function(adjustment) {
  var me = this, busyCounter = me.busyCounter + adjustment;
  me.busyCounter = busyCounter;
  if (busyCounter) {
    if (!me.lastBusyCounter) {
      me.lastBusyCounter = busyCounter;
      me.fireEvent('busy', me);
    }
  } else {
    if (me.lastBusyCounter && !me.timer) {
      me.scheduleTick();
    }
  }
}, isBusy:function() {
  return !this.isIdle();
}, isIdle:function() {
  return !(this.busyCounter + this.lastBusyCounter);
}, debugHooks:{$enabled:false, onCycleLimitExceeded:function() {
  Ext.raise('Exceeded cycleLimit ' + this.getCycleLimit());
}, scheduleItem:function(item) {
  if (!item) {
    Ext.raise('scheduleItem: Invalid argument');
  }
  Ext.log('Schedule item: ' + item.getFullName() + ' - ' + (this.scheduledCount + 1));
  if (item.order <= this.notifyIndex) {
    Ext.log.warn('Suboptimal order: ' + item.order + ' \x3c ' + this.notifyIndex);
  }
  this.callParent([item]);
}, unscheduleItem:function(item) {
  if (!this.scheduledCount) {
    Ext.raise('Invalid scheduleCount');
  }
  this.callParent([item]);
  Ext.log('Unschedule item: ' + item.getFullName() + ' - ' + this.scheduledCount);
}}});
Ext.define('Ext.data.Batch', {mixins:{observable:Ext.mixin.Observable}, config:{pauseOnException:false}, current:-1, total:0, running:false, complete:false, exception:false, constructor:function(config) {
  var me = this;
  me.mixins.observable.constructor.call(me, config);
  me.operations = [];
  me.exceptions = [];
}, add:function(operation) {
  var me = this, i, len;
  if (Ext.isArray(operation)) {
    for (i = 0, len = operation.length; i < len; ++i) {
      me.add(operation[i]);
    }
  } else {
    me.total++;
    operation.setBatch(me);
    me.operations.push(operation);
  }
  return me;
}, sort:function() {
  this.operations.sort(this.sortFn);
}, sortFn:function(operation1, operation2) {
  var ret = operation1.order - operation2.order;
  if (ret) {
    return ret;
  }
  var entityType1 = operation1.entityType, entityType2 = operation2.entityType, rank;
  if (!entityType1 || !entityType2) {
    return 0;
  }
  if (!(rank = entityType1.rank)) {
    entityType1.schema.rankEntities();
    rank = entityType1.rank;
  }
  return (rank - entityType2.rank) * operation1.foreignKeyDirection;
}, start:function(index) {
  var me = this;
  if (me.destroyed || !me.operations.length || me.running) {
    return me;
  }
  me.exceptions.length = 0;
  me.exception = false;
  me.running = true;
  return me.runOperation(Ext.isDefined(index) ? index : me.current + 1);
}, abort:function() {
  var me = this, op;
  if (me.running) {
    op = me.getCurrent();
    if (!op.destroyed) {
      op.abort();
    }
  }
  me.running = false;
  me.aborted = true;
  me.current = undefined;
}, retry:function() {
  return this.start(this.current);
}, runNextOperation:function() {
  var me = this;
  if (me.running) {
    me.runOperation(me.current + 1);
  }
  return me;
}, pause:function() {
  this.running = false;
  return this;
}, getOperations:function() {
  return this.operations;
}, getExceptions:function() {
  return this.exceptions;
}, getCurrent:function() {
  var out = null, current = this.current;
  if (!(current === -1 || this.complete)) {
    out = this.operations[current];
  }
  return out;
}, getTotal:function() {
  return this.total;
}, isRunning:function() {
  return this.running;
}, isComplete:function() {
  return this.complete;
}, hasException:function() {
  return this.exception;
}, runOperation:function(index) {
  var me = this, operations = me.operations, operation = operations[index];
  if (operation === undefined) {
    me.running = false;
    me.complete = true;
    me.fireEvent('complete', me, operations[operations.length - 1]);
  } else {
    me.current = index;
    operation.setInternalCallback(me.onOperationComplete);
    operation.setInternalScope(me);
    operation.execute();
  }
  return me;
}, onOperationComplete:function(operation) {
  var me = this, exception = operation.hasException();
  if (exception) {
    me.exception = true;
    me.exceptions.push(operation);
    me.fireEvent('exception', me, operation);
  }
  if (exception && me.getPauseOnException()) {
    me.pause();
  } else {
    me.fireEvent('operationcomplete', me, operation);
    me.runNextOperation();
  }
}, destroy:function() {
  var me = this, operations = me.operations, op, i, len;
  if (me.running) {
    me.abort();
  }
  for (i = 0, len = me.operations.length; i < len; i++) {
    op = operations[i];
    if (op) {
      if (!op.destroyed && !op.$destroyOwner) {
        op.destroy();
      }
      op[i] = null;
    }
  }
  me.operations = me.exceptions = null;
  me.callParent();
}});
Ext.define('Ext.data.matrix.Slice', {constructor:function(side, id) {
  this.id = id;
  this.side = side;
  this.members = {};
}, attach:function(store) {
  var me = this;
  Ext.Assert.falsey(me.store, 'Store is already attached');
  me.store = store;
  store.matrix = me;
  store.on('load', me.onStoreLoad, me, {single:true});
}, commit:function() {
  var members = this.members, id;
  for (id in members) {
    members[id][2] = 0;
  }
}, onStoreLoad:function(store) {
  this.update(store.getData().items, 0);
}, update:function(recordsOrIds, state) {
  if (!(recordsOrIds instanceof Array)) {
    Ext.raise('Only array of records or record ids are supported');
  }
  var me = this, MatrixSlice = Ext.data.matrix.Slice, side = me.side, assocIndex = side.index, length = recordsOrIds.length, id = me.id, members = me.members, otherSide = side.inverse, otherSlices = otherSide.slices, assoc, call, i, item, otherId, otherSlice, record;
  for (i = 0; i < length; ++i) {
    call = record = null;
    item = recordsOrIds[i];
    otherId = item.isEntity ? (record = item).id : item;
    assoc = members[otherId];
    if (state < 0 && assoc && assoc[2] === 1) {
      delete members[otherId];
      otherSlice = otherSlices[otherId];
      if (otherSlice) {
        delete otherSlice.members[id];
      }
      call = 1;
    } else {
      if (!assoc) {
        assoc = [otherId, otherId, state];
        assoc[assocIndex] = id;
        members[otherId] = assoc;
        otherSlice = otherSlices[otherId];
        if (!otherSlice) {
          otherSlices[otherId] = otherSlice = new MatrixSlice(otherSide, otherId);
        }
        otherSlice.members[id] = assoc;
        call = 1;
      } else {
        if (state !== assoc[2] && state !== 0 && !(state === 1 && assoc[2] === 0)) {
          assoc[2] = state;
          otherSlice = otherSlices[otherId];
          call = 1;
        }
      }
    }
    if (call) {
      if (me.notify) {
        me.notify.call(me.scope, me, otherId, state);
      }
      if (otherSlice && otherSlice.notify) {
        otherSlice.notify.call(otherSlice.scope, otherSlice, id, state);
      }
    }
  }
}, updateId:function(newId) {
  var me = this, oldId = me.id, side = me.side, slices = side.slices, slice = slices[oldId], members = slice.members, index = side.index, otherSlices = side.inverse.slices, assoc, otherId, otherMembers;
  me.id = newId;
  slices[newId] = slice;
  delete slices[oldId];
  for (otherId in members) {
    assoc = members[otherId];
    assoc[index] = newId;
    otherMembers = otherSlices[otherId].members;
    otherMembers[newId] = otherMembers[oldId];
    delete otherMembers[oldId];
  }
}, destroy:function() {
  var me = this, store = me.store;
  if (store) {
    store.matrix = null;
    store.un('load', me.onStoreLoad, me);
  }
  me.notify = me.scope = me.store = me.side = me.members = null;
  me.callParent();
}});
Ext.define('Ext.data.matrix.Side', {constructor:function(matrix, index, role) {
  var me = this;
  me.matrix = matrix;
  me.index = index;
  me.role = role;
  me.slices = {};
}, commit:function() {
  var slices = this.slices, id;
  for (id in slices) {
    slices[id].commit();
  }
}, get:function(id1, id2) {
  var me = this, slices = me.slices, slice = slices[id1] || (slices[id1] = new Ext.data.matrix.Slice(me, id1));
  return id2 || id2 === 0 ? slice.members[id2] : slice;
}, update:function(id1, id2, state) {
  var slice = this.get(id1);
  return slice.update(id2, state);
}, updateId:function(oldId, newId) {
  var slice = this.get(oldId);
  if (slice) {
    slice.updateId(newId);
  }
}, destroy:function() {
  var me = this, slices = me.slices, id;
  for (id in slices) {
    slices[id].destroy();
  }
  me.inverse = me.matrix = me.role = me.slices = null;
  me.callParent();
}});
Ext.define('Ext.data.matrix.Matrix', {constructor:function(session, matrix) {
  var me = this, association = matrix.isManyToMany ? matrix : session.getSchema().getAssociation(matrix), Side = Ext.data.matrix.Side, left = new Side(me, 0, association.left), right = new Side(me, 1, association.right);
  Ext.Assert.truthy(association.isManyToMany, 'Association is not many-to-many');
  me.association = association;
  me.session = session;
  me.left = left;
  me.right = right;
  left.inverse = right;
  right.inverse = left;
}, commit:function() {
  this.left.commit();
  this.right.commit();
}, update:function(id1, id2, state) {
  return this.left.update(id1, id2, state);
}, updateId:function(record, oldId, newId) {
  var Type = record.self, left = this.left, right = this.right, matchSide;
  if (Type === left.role.cls) {
    matchSide = left;
  }
  if (Type === right.role.cls) {
    matchSide = right;
  }
  if (matchSide) {
    matchSide.updateId(oldId, newId);
  }
}, destroy:function() {
  var me = this;
  me.left.destroy();
  me.right.destroy();
  me.association = me.session = me.left = me.right = null;
  me.callParent();
}});
Ext.define('Ext.data.session.ChangesVisitor', {constructor:function(session) {
  var me = this, crud;
  me.session = session;
  crud = session.getCrudProperties();
  me.result = null;
  me.writerOptions = {};
  me.createKey = crud.create;
  me.readKey = crud.read;
  me.updateKey = crud.update;
  me.dropKey = crud.drop;
}, onDirtyRecord:function(record) {
  var me = this, crud = me.crud, created = record.phantom, dropped = record.dropped, updated = !created && !dropped, type = record.$className, prop = created || dropped ? 'allDataOptions' : 'partialDataOptions', writerOptions = me.writerOptions, name = record.entityName, options, bucket, entry, result;
  if (created && dropped) {
    return false;
  }
  crud = created ? me.createKey : dropped ? me.dropKey : me.updateKey;
  writerOptions = writerOptions[type] || (writerOptions[type] = {});
  if (dropped) {
    if (!(options = writerOptions.drop)) {
      writerOptions.drop = options = {all:record.getProxy().getWriter().getWriteAllFields()};
    }
    if (!options.all) {
      entry = record.id;
    }
  }
  if (!entry) {
    if (!(options = writerOptions[prop])) {
      options = record.getProxy().getWriter().getConfig(prop);
      writerOptions[prop] = options = Ext.Object.chain(options);
      me.setupOptions(options);
    }
    entry = record.getData(options);
  }
  result = me.result || (me.result = {});
  bucket = result[name] || (result[name] = {});
  bucket = bucket[crud] || (bucket[crud] = []);
  bucket.push(entry);
}, setupOptions:function(options) {
  options.serialize = true;
}, onMatrixChange:function(association, id1, id2, state) {
  var me = this, name = association.left.type, assocName = association.right.role, operation = state < 0 ? me.dropKey : me.createKey, bucket, result;
  result = me.result || (me.result = {});
  bucket = result[name] || (result[name] = {});
  bucket = bucket[assocName] || (bucket[assocName] = {});
  bucket = bucket[operation] || (bucket[operation] = {});
  bucket = bucket[id1] || (bucket[id1] = []);
  bucket.push(id2);
}});
Ext.define('Ext.data.session.ChildChangesVisitor', {extend:Ext.data.session.ChangesVisitor, constructor:function() {
  this.seen = {};
  this.callParent(arguments);
}, setupOptions:function(options) {
  this.callParent([options]);
  options.serialize = false;
}, onDirtyRecord:function(record) {
  if (this.callParent(arguments) !== false) {
    if (!record.$source && (record.dropped || !record.phantom)) {
      this.readEntity(record);
    }
  }
}, readEntity:function(record) {
  var me = this, readKey = me.readKey, name = record.entityName, id = record.id, seen = me.seen, seenKey = name + id, result, bucket;
  if (seen[seenKey]) {
    return;
  }
  seen[seenKey] = true;
  result = me.result || (me.result = {});
  bucket = result[name] || (result[name] = {});
  bucket = bucket[readKey] || (bucket[readKey] = []);
  bucket.push(Ext.apply({}, record.modified, record.data));
}});
Ext.define('Ext.data.session.BatchVisitor', {map:null, constructor:function(batch) {
  this.batch = batch;
}, getBatch:function(sort) {
  var map = this.map, batch = this.batch, bucket, entity, name, operation, operationType, proxy, batchActions, records, len, i;
  if (map) {
    if (!batch) {
      batch = new Ext.data.Batch;
    }
    for (name in map) {
      bucket = map[name];
      entity = bucket.entity;
      proxy = entity.getProxy();
      batchActions = proxy.getBatchActions();
      delete bucket.entity;
      for (operationType in bucket) {
        if (batchActions) {
          operation = proxy.createOperation(operationType, {records:bucket[operationType]});
          operation.entityType = entity;
          batch.add(operation);
        } else {
          records = bucket[operationType];
          for (i = 0, len = records.length; i < len; ++i) {
            operation = proxy.createOperation(operationType, {records:[records[i]]});
            operation.entityType = entity;
            batch.add(operation);
          }
        }
      }
    }
  }
  if (batch && sort !== false) {
    batch.sort();
  }
  return batch;
}, onDirtyRecord:function(record) {
  var me = this, operation = record.phantom ? 'create' : record.dropped ? 'destroy' : 'update', name = record.$className, map = me.map || (me.map = {}), bucket = map[name] || (map[name] = {entity:record.self});
  bucket = bucket[operation] || (bucket[operation] = []);
  bucket.push(record);
}});
Ext.define('Ext.mixin.Dirty', {mixinId:'dirty', config:{dirty:{$value:false, lazy:true}}, dirty:false, _dirtyRecordCount:0, ignoreDirty:false, recordStateIsDirtyState:true, isDirty:function() {
  return this.getDirty();
}, applyDirty:function(dirty) {
  return this.ignoreDirty ? false : dirty;
}, updateDirty:function(dirty) {
  var me = this;
  me.dirty = dirty;
  if (me.fireEvent && !me.isDirtyInitializing) {
    me.fireDirtyChange();
  }
}, clearRecordStates:function() {
  var me = this, counters = me._crudCounters;
  if (counters) {
    counters.C = counters.U = counters.D = 0;
  }
  me._dirtyRecordCount = 0;
  if (me.recordStateIsDirtyState) {
    me.setDirty(false);
  }
}, fireDirtyChange:function() {
  var me = this;
  if (!me.ignoreDirty && me.hasListeners.dirtychange) {
    me.fireEvent('dirtychange', me, me.dirty);
  }
}, trackRecordState:function(record, initial) {
  var me = this, counters = me._crudCounters || (me._crudCounters = {C:0, R:0, U:0, D:0}), dirtyRecordCountWas = me._dirtyRecordCount, state = record.crudState, stateWas = record.crudStateWas, changed, dirtyRecordCount;
  if (initial || state !== stateWas) {
    if (!initial && stateWas) {
      --counters[stateWas];
    }
    if (!(record.phantom && state === 'D')) {
      ++counters[state];
    }
    me.checkCounters();
    me._dirtyRecordCount = dirtyRecordCount = counters.C + counters.U + counters.D;
    changed = !dirtyRecordCount !== !dirtyRecordCountWas;
    if (changed && me.recordStateIsDirtyState) {
      me.setDirty(dirtyRecordCount > 0);
    }
  }
  return changed;
}, untrackRecordState:function(record) {
  var me = this, counters = me._crudCounters, dirtyRecordCountWas = me._dirtyRecordCount, state = record.crudState, changed, dirtyRecordCount;
  if (counters && state !== 'D' && !record.erased) {
    --counters[state];
    me.checkCounters();
    me._dirtyRecordCount = dirtyRecordCount = counters.C + counters.U + counters.D;
    changed = !dirtyRecordCount !== !dirtyRecordCountWas;
    if (changed && me.recordStateIsDirtyState) {
      me.setDirty(dirtyRecordCount > 0);
    }
  }
  return changed;
}, checkCounters:function() {
  var counters = this._crudCounters, key;
  for (key in counters) {
    if (counters[key] < 0) {
      Ext.raise('Invalid state for ' + key);
    }
  }
}});
Ext.define('Ext.data.Session', {mixins:[Ext.mixin.Dirty, Ext.mixin.Observable], isSession:true, config:{schema:'default', parent:null, autoDestroy:true, crudProperties:{create:'C', read:'R', update:'U', drop:'D'}}, crudOperations:[{type:'R', entityMethod:'readEntities'}, {type:'C', entityMethod:'createEntities'}, {type:'U', entityMethod:'updateEntities'}, {type:'D', entityMethod:'dropEntities'}], crudKeys:{C:1, R:1, U:1, D:1}, statics:{nextId:1}, constructor:function(config) {
  var me = this;
  me.data = {};
  me.matrices = {};
  me.id = Ext.data.Session.nextId++;
  me.identifierCache = {};
  me.recordCreator = me.recordCreator.bind(me);
  me.mixins.observable.constructor.call(me, config);
}, destroy:function() {
  var me = this, matrices = me.matrices, data = me.data, entityName, entities, record, id;
  for (id in matrices) {
    matrices[id].destroy();
  }
  for (entityName in data) {
    entities = data[entityName];
    for (id in entities) {
      record = entities[id].record;
      if (record) {
        record.$source = null;
        record.unjoin(me);
      }
    }
  }
  me.identifierCache = me.recordCreator = me.matrices = me.data = null;
  me.setSchema(null);
  me.callParent();
}, adopt:function(record) {
  var me = this, associations = record.associations, roleName;
  me.checkModelType(record.self);
  if (record.session && record.session !== me) {
    Ext.raise('Record already belongs to an existing session');
  }
  if (record.session !== me) {
    me.add(record);
    if (associations) {
      for (roleName in associations) {
        associations[roleName].adoptAssociated(record, me);
      }
    }
  }
}, commit:function() {
  var me = this, data = me.data, matrices = me.matrices, dirtyWas = me.getDirty(), entityName, entities, id, record;
  me.suspendEvent('dirtychange');
  for (entityName in data) {
    entities = data[entityName];
    for (id in entities) {
      record = entities[id].record;
      if (record) {
        record.commit();
      }
    }
  }
  for (id in matrices) {
    matrices[id].commit();
  }
  me.clearRecordStates();
  me.resumeEvent('dirtychange');
  if (me.getDirty() !== dirtyWas) {
    me.fireDirtyChange();
  }
}, createRecord:function(type, data, preventAdd) {
  this.checkModelType(type);
  var Model = type.$isClass ? type : this.getSchema().getEntity(type), parent = this.getParent(), id;
  if (data && parent) {
    id = Model.getIdFromData(data);
    if (parent.peekRecord(Model, id)) {
      Ext.raise('A parent session already contains an entry for ' + Model.entityName + ': ' + id);
    }
  }
  return new Model(data, preventAdd ? null : this);
}, getChanges:function() {
  var visitor = new Ext.data.session.ChangesVisitor(this);
  this.visitData(visitor);
  return visitor.result;
}, getChangesForParent:function() {
  var visitor = new Ext.data.session.ChildChangesVisitor(this);
  this.visitData(visitor);
  return visitor.result;
}, getRecord:function(type, id, autoLoad) {
  var me = this, wasInstance = type.isModel, record, Model, parent, parentRec;
  if (wasInstance) {
    wasInstance = type;
    id = type.id;
    type = type.self;
  }
  record = me.peekRecord(type, id);
  if (!record) {
    Model = type.$isClass ? type : me.getSchema().getEntity(type);
    parent = me.getParent();
    if (parent) {
      parentRec = parent.peekRecord(Model, id);
    }
    if (parentRec) {
      if (parentRec.isLoading()) {
        wasInstance = false;
      } else {
        record = parentRec.copy(undefined, me);
        record.$source = parentRec;
      }
    }
    if (!record) {
      if (wasInstance) {
        record = wasInstance;
        me.adopt(record);
      } else {
        record = Model.createWithId(id, null, me);
        if (autoLoad !== false) {
          record.load(Ext.isObject(autoLoad) ? autoLoad : undefined);
        }
      }
    }
  }
  return record;
}, getSaveBatch:function(sort) {
  var visitor = new Ext.data.session.BatchVisitor;
  this.visitData(visitor);
  return visitor.getBatch(sort);
}, onInvalidAssociationEntity:function(entityType, id) {
  Ext.raise('Unable to read association entity: ' + this.getModelIdentifier(entityType, id));
}, onInvalidEntityCreate:function(entityType, id) {
  Ext.raise('Cannot create, record already not exists: ' + this.getModelIdentifier(entityType, id));
}, onInvalidEntityDrop:function(entityType, id) {
  Ext.raise('Cannot drop, record does not exist: ' + this.getModelIdentifier(entityType, id));
}, onInvalidEntityRead:function(entityType, id) {
  Ext.raise('Cannot read, record already not exists: ' + this.getModelIdentifier(entityType, id));
}, onInvalidEntityUpdate:function(entityType, id, dropped) {
  if (dropped) {
    Ext.raise('Cannot update, record dropped: ' + this.getModelIdentifier(entityType, id));
  } else {
    Ext.raise('Cannot update, record does not exist: ' + this.getModelIdentifier(entityType, id));
  }
}, peekRecord:function(type, id, deep) {
  this.checkModelType(type);
  var entityType = type.$isClass ? type : this.getSchema().getEntity(type), entityName = entityType.entityName, entry = this.data[entityName], ret, parent;
  entry = entry && entry[id];
  ret = entry && entry.record;
  if (!ret && deep) {
    parent = this.getParent();
    ret = parent && parent.peekRecord(type, id, deep);
  }
  return ret || null;
}, save:function() {
  var me = this, parent = me.getParent(), visitor;
  if (parent) {
    visitor = new Ext.data.session.ChildChangesVisitor(me);
    me.visitData(visitor);
    parent.update(visitor.result);
    me.commit();
  } else {
    Ext.raise('Cannot commit session, no parent exists');
  }
}, spawn:function() {
  return new this.self({schema:this.getSchema(), parent:this});
}, update:function(data) {
  var me = this, schema = me.getSchema(), crudOperations = me.crudOperations, len = crudOperations.length, crudKeys = me.crudKeys, dirtyWas = me.getDirty(), entityName, entityType, entityInfo, i, operation, item, associations, key, role, associationData;
  me.suspendEvent('dirtychange');
  me.getSchema().processKeyChecks(true);
  for (entityName in data) {
    entityType = schema.getEntity(entityName);
    if (!entityType) {
      Ext.raise('Invalid entity type: ' + entityName);
    }
    entityInfo = data[entityName];
    for (i = 0; i < len; ++i) {
      operation = crudOperations[i];
      item = entityInfo[operation.type];
      if (item) {
        me[operation.entityMethod](entityType, item);
      }
    }
  }
  for (entityName in data) {
    entityType = schema.getEntity(entityName);
    associations = entityType.associations;
    entityInfo = data[entityName];
    for (key in entityInfo) {
      if (crudKeys[key]) {
        continue;
      }
      role = associations[key];
      if (!role) {
        Ext.raise('Invalid association key for ' + entityName + ', "' + key + '"');
      }
      associationData = entityInfo[role.role];
      role.processUpdate(me, associationData);
    }
  }
  me.resumeEvent('dirtychange');
  if (me.getDirty() !== dirtyWas) {
    me.fireDirtyChange();
  }
}, afterCommit:function(record) {
  this.trackRecordState(record);
}, afterDrop:function(record) {
  this.trackRecordState(record);
}, afterEdit:function(record) {
  this.trackRecordState(record);
}, afterErase:function(record) {
  this.evict(record);
}, afterReject:function(record) {
  this.trackRecordState(record);
}, privates:{add:function(record) {
  var me = this, id = record.id, entry = me.getEntry(record.self, id), associations, roleName;
  if (entry.record) {
    Ext.raise('Duplicate id ' + record.id + ' for ' + record.entityName);
  }
  record.session = me;
  entry.record = record;
  me.trackRecordState(record, true);
  me.registerReferences(record);
  associations = record.associations;
  for (roleName in associations) {
    associations[roleName].checkMembership(me, record);
  }
}, applySchema:function(schema) {
  return Ext.data.schema.Schema.get(schema);
}, checkModelType:function(name) {
  if (name.$isClass) {
    name = name.entityName;
  }
  if (!name) {
    Ext.raise('Unable to use anonymous models in a Session');
  } else {
    if (!this.getSchema().getEntity(name)) {
      Ext.raise('Unknown entity type ' + name);
    }
  }
}, createEntities:function(entityType, items) {
  var me = this, len = items.length, i, data, rec, id;
  for (i = 0; i < len; ++i) {
    data = items[i];
    id = entityType.getIdFromData(data);
    rec = me.peekRecord(entityType, id);
    if (!rec) {
      rec = me.createRecord(entityType, data, true);
      rec.phantom = true;
      rec.crudState = 'C';
      me.add(rec);
      rec.crudStateWas = 'C';
    } else {
      me.onInvalidEntityCreate(entityType, id);
    }
  }
}, dropEntities:function(entityType, ids) {
  var len = ids.length, i, rec, id, extractId;
  if (len) {
    extractId = Ext.isObject(ids[0]);
  }
  for (i = 0; i < len; ++i) {
    id = ids[i];
    if (extractId) {
      id = entityType.getIdFromData(id);
    }
    rec = this.peekRecord(entityType, id);
    if (rec) {
      rec.drop();
    } else {
      this.onInvalidEntityDrop(entityType, id);
    }
  }
}, evict:function(record) {
  var me = this, entityName = record.entityName, entities = me.data[entityName], id = record.id;
  if (entities && entities[id]) {
    me.untrackRecordState(record);
    record.unjoin(me);
    delete entities[id];
  }
}, getEntityList:function(entityType, ids) {
  var len = ids.length, i, id, rec, invalid;
  for (i = 0; i < len; ++i) {
    id = ids[i];
    rec = this.peekRecord(entityType, id);
    if (rec) {
      ids[i] = rec;
    } else {
      invalid = true;
      ids[i] = null;
      this.onInvalidAssociationEntity(entityType, id);
    }
  }
  if (invalid) {
    ids = Ext.Array.clean(ids);
  }
  return ids;
}, getEntry:function(type, id) {
  if (type.isModel) {
    id = type.getId();
    type = type.self;
  }
  var entityType = type.$isClass ? type : this.getSchema().getEntity(type), entityName = entityType.entityName, data = this.data, entry;
  entry = data[entityName] || (data[entityName] = {});
  entry = entry[id] || (entry[id] = {});
  return entry;
}, getRefs:function(record, role, includeParent) {
  var entry = this.getEntry(record), refs = entry && entry.refs && entry.refs[role.role], parent = includeParent && this.getParent(), parentRefs, id, rec;
  if (parent) {
    parentRefs = parent.getRefs(record, role);
    if (parentRefs) {
      for (id in parentRefs) {
        rec = parentRefs[id];
        if (!refs || !refs[id]) {
          this.getRecord(rec.self, rec.id);
        }
      }
      refs = entry && entry.refs && entry.refs[role.role];
    }
  }
  return refs || null;
}, getIdentifier:function(entityType) {
  var parent = this.getParent(), cache, identifier, key, ret;
  if (parent) {
    ret = parent.getIdentifier(entityType);
  } else {
    cache = this.identifierCache;
    identifier = entityType.identifier;
    key = identifier.getId() || entityType.entityName;
    ret = cache[key];
    if (!ret) {
      if (identifier.clone) {
        ret = identifier.clone({id:null});
      } else {
        ret = identifier;
      }
      cache[key] = ret;
    }
  }
  return ret;
}, getMatrix:function(matrix, preventCreate) {
  var name = matrix.isManyToMany ? matrix.name : matrix, matrices = this.matrices, ret;
  ret = matrices[name];
  if (!ret && !preventCreate) {
    ret = matrices[name] = new Ext.data.matrix.Matrix(this, matrix);
  }
  return ret || null;
}, getMatrixSlice:function(role, id) {
  var matrix = this.getMatrix(role.association), side = matrix[role.side];
  return side.get(id);
}, getModelIdentifier:function(entityType, id) {
  return id + '@' + entityType.entityName;
}, onIdChanged:function(record, oldId, newId) {
  var me = this, matrices = me.matrices, entityName = record.entityName, id = record.id, bucket = me.data[entityName], entry = bucket[oldId], associations = record.associations, refs = entry.refs, setNoRefs = me._setNoRefs, association, fieldName, matrix, refId, role, roleName, roleRefs, key;
  if (bucket[newId]) {
    Ext.raise('Cannot change ' + entityName + ' id from ' + oldId + ' to ' + newId + ' id already exists');
  }
  delete bucket[oldId];
  bucket[newId] = entry;
  for (key in matrices) {
    matrices[key].updateId(record, oldId, newId);
  }
  if (refs) {
    for (roleName in refs) {
      roleRefs = refs[roleName];
      role = associations[roleName];
      association = role.association;
      if (!association.isManyToMany) {
        fieldName = association.field.name;
        for (refId in roleRefs) {
          roleRefs[refId].set(fieldName, id, setNoRefs);
        }
      }
    }
  }
  me.registerReferences(record, oldId);
}, processManyBlock:function(entityType, role, items, processor) {
  var me = this, id, record, records, store;
  if (items) {
    for (id in items) {
      record = me.peekRecord(entityType, id);
      if (record) {
        records = me.getEntityList(role.cls, items[id]);
        store = role.getAssociatedItem(record);
        me[processor](role, store, record, records);
      } else {
        me.onInvalidAssociationEntity(entityType, id);
      }
    }
  }
}, processManyCreate:function(role, store, record, records) {
  if (store) {
    store.add(records);
  } else {
    record[role.getterName](null, null, records);
  }
}, processManyDrop:function(role, store, record, records) {
  if (store) {
    store.remove(records);
  }
}, processManyRead:function(role, store, record, records) {
  if (store) {
    store.setRecords(records);
  } else {
    record[role.getterName](null, null, records);
  }
}, readEntities:function(entityType, items) {
  var me = this, len = items.length, i, data, rec, id;
  for (i = 0; i < len; ++i) {
    data = items[i];
    id = entityType.getIdFromData(data);
    rec = me.peekRecord(entityType, id);
    if (!rec) {
      rec = me.createRecord(entityType, data, true);
    } else {
      me.onInvalidEntityRead(entityType, id);
    }
    rec.phantom = false;
    me.add(rec);
  }
}, recordCreator:function(data, Model) {
  var me = this, id = Model.getIdFromData(data), record = me.peekRecord(Model, id, true);
  if (!record) {
    record = new Model(data, me);
  } else {
    record = me.getRecord(Model, id);
    record.mergeData(data);
  }
  return record;
}, registerReferences:function(record, oldId) {
  var entityName = record.entityName, id = record.id, recordData = record.data, remove = oldId || oldId === 0, entry, i, fk, len, reference, references, refs, roleName;
  len = (references = record.references).length;
  for (i = 0; i < len; ++i) {
    reference = references[i];
    fk = recordData[reference.name];
    if (fk || fk === 0) {
      reference = reference.reference;
      entityName = reference.type;
      roleName = reference.inverse.role;
      entry = this.getEntry(reference.cls, fk);
      refs = entry.refs || (entry.refs = {});
      refs = refs[roleName] || (refs[roleName] = {});
      refs[id] = record;
      if (remove) {
        delete refs[oldId];
      }
    }
  }
}, updateEntities:function(entityType, items) {
  var len = items.length, i, data, rec, id, modified;
  if (Ext.isArray(items)) {
    for (i = 0; i < len; ++i) {
      data = items[i];
      id = entityType.getIdFromData(data);
      rec = this.peekRecord(entityType, id);
      if (rec) {
        rec.set(data);
      } else {
        this.onInvalidEntityUpdate(entityType, id);
      }
    }
  } else {
    for (id in items) {
      data = items[id];
      rec = this.peekRecord(entityType, id);
      if (rec && !rec.dropped) {
        modified = rec.set(data);
      } else {
        this.onInvalidEntityUpdate(entityType, id, !!rec);
      }
    }
  }
}, updateReference:function(record, field, newValue, oldValue) {
  var reference = field.reference, entityName = reference.type, roleName = reference.inverse.role, id = record.id, entry, refs;
  if (oldValue || oldValue === 0) {
    refs = this.getEntry(entityName, oldValue).refs[roleName];
    delete refs[id];
  }
  if (newValue || newValue === 0) {
    entry = this.getEntry(entityName, newValue);
    refs = entry.refs || (entry.refs = {});
    refs = refs[roleName] || (refs[roleName] = {});
    refs[id] = record;
  }
}, visitData:function(visitor) {
  var me = this, data = me.data, matrices = me.matrices, all, assoc, id, id2, matrix, members, name, record, slice, slices, state;
  me.getSchema().processKeyChecks(true);
  for (name in data) {
    all = data[name];
    for (id in all) {
      record = all[id].record;
      if (record) {
        if (record.phantom || record.dirty || record.dropped) {
          if (visitor.onDirtyRecord) {
            visitor.onDirtyRecord(record);
          }
        } else {
          if (visitor.onCleanRecord) {
            visitor.onCleanRecord(record);
          }
        }
      }
    }
  }
  if (visitor.onMatrixChange) {
    for (name in matrices) {
      matrix = matrices[name].left;
      slices = matrix.slices;
      assoc = matrix.role.association;
      for (id in slices) {
        slice = slices[id];
        members = slice.members;
        for (id2 in members) {
          state = (record = members[id2])[2];
          if (state) {
            visitor.onMatrixChange(assoc, record[0], record[1], state);
          }
        }
      }
    }
  }
  return visitor;
}, _setNoRefs:{refs:false}}});
Ext.define('Ext.util.Schedulable', {'abstract':true, isSchedulable:true, scheduled:false, constructor:function() {
  this.getScheduler().add(this);
}, destroy:function() {
  var me = this, scheduler = me.getScheduler();
  if (scheduler && !scheduler.destroyed) {
    scheduler.remove(me);
  }
  me.scheduler = null;
  me.schedule = me.react = Ext.emptyFn;
  me.callParent();
}, getFullName:function() {
  return this.name || this.id;
}, privates:{getScheduler:function() {
  return this.scheduler;
}, schedule:function() {
  var me = this, scheduler;
  if (!me.scheduled) {
    scheduler = me.getScheduler();
    if (scheduler) {
      me.scheduled = true;
      if (me.onSchedule) {
        me.onSchedule();
      }
      scheduler.scheduleItem(me);
    }
  }
}, unschedule:function() {
  var me = this, scheduler;
  if (me.scheduled) {
    scheduler = me.getScheduler();
    if (scheduler && !scheduler.destroyed) {
      scheduler.unscheduleItem(me);
    }
    me.scheduled = false;
  }
}, sort:function() {
}}});
Ext.define('Ext.app.bind.BaseBinding', {extend:Ext.util.Schedulable, isBinding:true, calls:0, kind:20, defaultOptions:{}, lastValue:undefined, constructor:function(owner, callback, scope, options) {
  var me = this;
  me.options = options;
  me.owner = owner;
  me.scope = scope;
  me.callback = callback;
  if (!callback) {
    Ext.raise('Callback is required');
  }
  me.lateBound = Ext.isString(callback);
  if (options && options.deep) {
    me.deep = true;
  }
  me.callParent();
}, destroy:function() {
  var me = this, owner = me.owner;
  if (owner) {
    owner.onBindDestroy(me);
  }
  me.callParent();
  me.scope = me.callback = me.owner = null;
}, isReadOnly:function() {
  return true;
}, privates:{getScheduler:function() {
  var owner = this.owner;
  return owner && owner.getScheduler();
}, getSession:function() {
  var owner = this.owner;
  return owner.isSession ? owner : owner.getSession();
}, notify:function(value) {
  var me = this, options = me.options || me.defaultOptions, previous = me.lastValue;
  if (!me.calls || me.deep || me.valueChanged(value, previous)) {
    ++me.calls;
    me.lastValue = value;
    if (me.lateBound) {
      me.scope[me.callback](value, previous, me);
    } else {
      me.callback.call(me.scope, value, previous, me);
    }
    if (options.single) {
      me.destroy();
    }
  }
}, valueChanged:function(value, previous) {
  var ret = true;
  if (previous !== value) {
    if (value && previous && value instanceof Date && previous instanceof Date) {
      ret = value.getTime() !== previous.getTime();
    }
  } else {
    ret = Ext.isArray(value);
  }
  return ret;
}}});
Ext.define('Ext.app.bind.Binding', {extend:Ext.app.bind.BaseBinding, constructor:function(stub, callback, scope, options) {
  var me = this;
  me.callParent([stub.owner, callback, scope, options]);
  me.stub = stub;
  me.depth = stub.depth;
  if (stub.isAvailable() && !stub.scheduled) {
    me.schedule();
  }
}, destroy:function(fromParent) {
  var me = this, stub = me.stub;
  if (stub && !fromParent) {
    stub.unbind(me);
    me.stub = null;
  }
  me.callParent();
}, bindValidation:function(callback, scope) {
  var stub = this.stub;
  return stub && stub.bindValidation(callback, scope);
}, bindValidationField:function(callback, scope) {
  var stub = this.stub;
  return stub && stub.bindValidationField(callback, scope);
}, getFullName:function() {
  return this.fullName || (this.fullName = '@(' + this.stub.getFullName() + ')');
}, getValue:function() {
  var me = this, stub = me.stub;
  return stub && stub.getValue();
}, isAvailable:function() {
  var stub = this.stub;
  return stub && stub.isAvailable();
}, isLoading:function() {
  var stub = this.stub;
  return stub && stub.isLoading();
}, isReadOnly:function() {
  var stub = this.stub, options = this.options, ret = true;
  if (!(options && options.twoWay === false)) {
    if (stub) {
      ret = stub.isReadOnly();
    }
  }
  return ret;
}, refresh:function() {
}, setValue:function(value) {
  if (this.isReadOnly()) {
    Ext.raise('Cannot setValue on a readonly binding');
  }
  this.stub.set(value);
}, privates:{getDataObject:function() {
  var stub = this.stub;
  return stub && stub.getDataObject();
}, getRawValue:function() {
  var me = this, stub = me.stub;
  return stub && stub.getRawValue();
}, isDescendantOf:function(item) {
  var stub = this.stub;
  return stub ? item === stub || stub.isDescendantOf(item) : false;
}, react:function() {
  this.notify(this.getValue());
}, schedule:function() {
  if (!this.stub.scheduled) {
    this.callParent();
  }
}, sort:function() {
  var stub = this.stub;
  stub.scheduler.sortItem(stub);
}}});
Ext.define('Ext.app.bind.AbstractStub', {extend:Ext.util.Schedulable, children:null, depth:0, generation:1, kind:10, parent:null, constructor:function(owner, name) {
  var me = this;
  me.owner = owner;
  me.name = name;
  me.callParent();
}, destroy:function() {
  var me = this, children = me.children, bindings = me.bindings, len, i, key;
  if (bindings) {
    for (i = 0, len = bindings.length; i < len; ++i) {
      bindings[i].destroy(true);
    }
  }
  for (key in children) {
    children[key].destroy();
  }
  if (me.scheduled) {
    me.unschedule();
  }
  me.callParent();
}, add:function(child) {
  var me = this;
  (me.children || (me.children = {}))[child.name] = child;
  child.depth = me.depth + 1;
  child.parent = me;
}, getChild:function(path) {
  var pathArray = Ext.isString(path) ? path.split('.') : path;
  if (pathArray && pathArray.length) {
    return this.descend(pathArray, 0);
  }
  return this;
}, getFullName:function() {
  var me = this, name = me.fullName, parent = me.parent, s;
  if (!name) {
    name = me.name || me.id;
    if (parent && (s = parent.getFullName())) {
      name = (s.charAt(s.length - 1) !== ':' ? s + '.' : s) + name;
    }
    me.fullName = name;
  }
  return name;
}, getSession:function() {
  var owner = this.owner;
  return owner.isSession ? owner : owner.getSession();
}, bind:function(callback, scope, options) {
  var me = this, binding = new Ext.app.bind.Binding(me, callback, scope, options), bindings = me.bindings || (me.bindings = []);
  binding.depth = me.depth;
  bindings.push(binding);
  return binding;
}, getValue:function() {
  return this.isAvailable() ? this.getRawValue() : null;
}, graft:function(replacement) {
  var me = this, bindings = me.bindings, name = me.name, i;
  me.parent = me.bindings = null;
  me.destroy();
  replacement.depth = me.depth;
  replacement.bindings = bindings;
  replacement.generation = me.generation + 1;
  replacement.name = name;
  replacement.id = me.id;
  replacement.path = me.path;
  if (bindings) {
    for (i = bindings.length; i-- > 0;) {
      bindings[i].stub = replacement;
    }
  }
  return replacement;
}, isDescendantOf:function(item) {
  for (var parent = this; parent = parent.parent;) {
    if (parent === item) {
      return true;
    }
  }
  return false;
}, isAvailable:function() {
  return true;
}, isLoading:function() {
  return false;
}, onSchedule:function() {
  for (var i, len, binding, bindings, p = this.parent; p; p = p.parent) {
    bindings = p.bindings;
    if (bindings) {
      for (i = 0, len = bindings.length; i < len; ++i) {
        binding = bindings[i];
        if (binding.deep && !binding.scheduled) {
          binding.schedule();
        }
      }
    }
  }
}, react:function() {
  var bindings = this.bindings, binding, i, len;
  if (bindings) {
    for (i = 0, len = bindings.length; i < len; ++i) {
      binding = bindings[i];
      if (!binding.scheduled) {
        binding.schedule();
      }
    }
  }
}, unbind:function(binding) {
  var bindings = this.bindings;
  if (bindings && bindings.length) {
    Ext.Array.remove(bindings, binding);
  }
}, privates:{collect:function() {
  var children = this.children, bindings = this.bindings, totalCount = 0, count = 0, child, key;
  if (children) {
    for (key in children) {
      child = children[key];
      count = child.collect();
      if (count === 0) {
        child.destroy();
        delete children[key];
      }
      totalCount += count;
    }
  }
  if (bindings) {
    totalCount += bindings.length;
  }
  return totalCount;
}, getScheduler:function() {
  var owner = this.owner;
  return owner && owner.getScheduler();
}, sort:function() {
  var parent = this.parent;
  if (parent) {
    this.scheduler.sortItem(parent);
  }
}}});
Ext.define('Ext.app.bind.Stub', {extend:Ext.app.bind.AbstractStub, isStub:true, dirty:true, formula:null, validationKey:'validation', constructor:function(owner, name, parent) {
  var me = this, path = name;
  me.callParent([owner, name]);
  me.boundValue = null;
  if (parent) {
    parent.add(me);
    if (!parent.isRootStub) {
      path = parent.path + '.' + name;
    }
    me.checkHadValue();
  }
  me.path = path;
}, destroy:function() {
  var me = this, formula = me.formula, storeBinding = me.storeBinding;
  if (formula) {
    formula.destroy();
  }
  if (storeBinding) {
    storeBinding.destroy();
  }
  me.detachBound();
  me.callParent();
}, bindValidation:function(callback, scope) {
  var parent = this.parent;
  return parent && parent.descend([this.validationKey, this.name]).bind(callback, scope);
}, bindValidationField:function(callback, scope) {
  var parent = this.parent, name = this.name, lateBound = typeof callback === 'string', ret;
  if (parent) {
    ret = parent.bind(function(value) {
      var field = null;
      if (value && value.isModel) {
        field = value.getField(name);
      }
      if (lateBound) {
        scope[callback](field, value, this);
      } else {
        callback.call(scope, field, value, this);
      }
    });
  }
  return ret || null;
}, descend:function(path, index) {
  var me = this, children = me.children || (me.children = {}), pos = index || 0, name = path[pos++], ret;
  if (!(ret = children[name])) {
    ret = new Ext.app.bind.Stub(me.owner, name, me);
  }
  if (pos < path.length) {
    ret = ret.descend(path, pos);
  }
  return ret;
}, getChildValue:function(parentData) {
  var me = this, name = me.name, bindMappings = me.bindMappings, storeMappings = bindMappings.store, modelMappings = bindMappings.model, ret;
  if (!parentData && !Ext.isString(parentData)) {
    ret = me.hadValue ? null : undefined;
  } else {
    ret = me.inspectValue(parentData);
    if (!ret) {
      if (parentData.isEntity) {
        if (modelMappings[name]) {
          ret = parentData[modelMappings[name]]();
        } else {
          ret = parentData.data[name];
        }
      } else {
        if (parentData.isStore && storeMappings[name]) {
          ret = parentData[storeMappings[name]]();
        } else {
          ret = parentData[name];
          if (ret === undefined && me.hadValue) {
            ret = null;
          }
        }
      }
    }
  }
  return ret;
}, getDataObject:function() {
  var me = this, parentData = me.parent.getDataObject(), name = me.name, ret = parentData ? parentData[name] : null, storeMappings = me.bindMappings.store, associations;
  if (!ret) {
    if (parentData && parentData.isEntity) {
      associations = parentData.associations;
      if (associations && name in associations) {
        ret = parentData[associations[name].getterName]();
      }
    }
  } else {
    if (parentData.isStore && name in storeMappings) {
      ret = parentData[storeMappings[name]]();
    }
  }
  if (!ret || !(ret.$className || Ext.isObject(ret))) {
    parentData[name] = ret = {};
    me.hadValue = true;
    me.invalidate(true, true);
  }
  return ret;
}, getRawValue:function() {
  return this.getChildValue(this.getParentValue());
}, graft:function(replacement) {
  var me = this, parent = me.parent, children = me.children, name = me.name, i, ret;
  replacement.parent = parent;
  replacement.children = children;
  if (parent) {
    parent.children[name] = replacement;
  }
  if (children) {
    for (i in children) {
      children[i].parent = replacement;
    }
  }
  me.children = null;
  replacement.checkHadValue();
  ret = me.callParent([replacement]);
  ret.invalidate(true, true);
  return ret;
}, isAvailable:function() {
  return this.checkAvailability();
}, isLoading:function() {
  return !this.checkAvailability(true);
}, invalidate:function(deep, dirtyOnly) {
  var me = this, children = me.children, name;
  me.dirty = true;
  me.checkHadValue();
  if (!dirtyOnly && me.isAvailable()) {
    if (!me.scheduled) {
      me.schedule();
    }
  }
  if (deep && children) {
    for (name in children) {
      children[name].invalidate(deep, dirtyOnly);
    }
  }
}, isReadOnly:function() {
  var formula = this.formula;
  return !!(formula && !formula.set);
}, set:function(value, preventClimb) {
  var me = this, parent = me.parent, name = me.name, formula = me.formula, parentData, associations, association, formulaStub, setterName;
  if (formula && !formula.settingValue && formula.set) {
    formula.setValue(value);
    return;
  } else {
    if (me.isLinkStub) {
      formulaStub = me.getLinkFormulaStub();
      formula = formulaStub ? formulaStub.formula : null;
      if (formula) {
        if (formulaStub.isReadOnly()) {
          Ext.raise('Cannot setValue on a readonly formula');
        }
        formula.setValue(value);
        return;
      }
    }
  }
  parentData = parent.getDataObject();
  if (parentData.isEntity) {
    associations = parentData.associations;
    if (associations && name in associations) {
      association = associations[name];
      setterName = association.setterName;
      if (setterName) {
        parentData[setterName](value);
      }
      me.invalidate(true);
    } else {
      parentData.set(name, value);
    }
  } else {
    if (value && value.constructor === Object || !(value === parentData[name] && parentData.hasOwnProperty(name))) {
      if (preventClimb || !me.setByLink(value)) {
        if (value === undefined) {
          delete parentData[name];
        } else {
          parentData[name] = value;
        }
        me.inspectValue(parentData);
        me.invalidate(true);
      }
    }
  }
}, onStoreDataChanged:function() {
  this.invalidate(true);
}, afterLoad:function(record) {
  this.invalidate(true);
}, afterCommit:function(record) {
  this.afterEdit(record, null);
}, afterEdit:function(record, modifiedFieldNames) {
  var children = this.children, len = modifiedFieldNames && modifiedFieldNames.length, associations = record.associations, bindMappings = this.bindMappings.model, key, i, child, name, ref;
  if (children) {
    if (len) {
      for (i = 0; i < len; ++i) {
        name = modifiedFieldNames[i];
        child = children[name];
        if (!child) {
          ref = record.fieldsMap[name];
          ref = ref && ref.reference;
          child = ref && children[ref.role];
        }
        if (child) {
          child.invalidate(true);
        }
      }
    } else {
      for (key in children) {
        if (!(associations && key in associations)) {
          children[key].invalidate(true);
        }
      }
    }
    for (key in bindMappings) {
      child = children[key];
      if (child) {
        child.invalidate();
      }
    }
  }
  this.invalidate();
}, afterReject:function(record) {
  this.afterEdit(record, null);
}, afterAssociatedRecordSet:function(record, associated, role) {
  var children = this.children, key = role.role;
  if (children && key in children) {
    children[key].invalidate(true);
  }
}, setByLink:function(value) {
  var me = this, n = 0, ret = false, i, link, path, stub, root, name;
  for (stub = me; stub; stub = stub.parent) {
    if (stub.isLinkStub) {
      link = stub;
      if (n) {
        for (path = [], i = 0, stub = me; stub !== link; stub = stub.parent) {
          ++i;
          path[n - i] = stub.name;
        }
      }
      break;
    }
    ++n;
  }
  stub = null;
  if (link) {
    root = link.parent;
    name = link.name;
    if (!root.shouldClimb(name)) {
      stub = root.insertChild(name);
    } else {
      stub = link.getTargetStub();
    }
  }
  if (stub) {
    if (path) {
      stub = stub.descend(path);
    }
    stub.set(value);
    ret = true;
  }
  return ret;
}, setFormula:function(formula) {
  var me = this, oldFormula = me.formula;
  if (oldFormula) {
    oldFormula.destroy();
  }
  me.formula = new Ext.app.bind.Formula(me, formula);
}, react:function() {
  var me = this, bound = this.boundValue, children = me.children, generation;
  if (bound) {
    if (bound.isValidation) {
      bound.refresh();
      generation = bound.generation;
      if (me.lastValidationGeneration === generation) {
        return;
      }
      me.lastValidationGeneration = generation;
    } else {
      if (bound.isModel) {
        if (children && children[me.validationKey]) {
          bound.isValid();
        }
      }
    }
  }
  this.callParent();
}, privates:{bindMappings:{store:{count:'getCount', first:'first', last:'last', loading:'hasPendingLoad', totalCount:'getTotalCount'}, model:{dirty:'isDirty', phantom:'isPhantom', valid:'isValid'}}, checkAvailability:function(isLoading) {
  var me = this, parent = me.parent, bindMappings = me.bindMappings, name = me.name, available = !!(parent && parent.checkAvailability(isLoading)), associations, parentValue, value, availableSet, loading;
  if (available) {
    parentValue = me.getParentValue();
    value = me.inspectValue(parentValue);
    if (value) {
      if (isLoading) {
        available = !value.hasPendingLoad();
      } else {
        if (value.isStore) {
          available = true;
        } else {
          available = !value.isLoading() || value.loadCount > 0;
        }
      }
    } else {
      if (parentValue) {
        if (parentValue.isModel) {
          if (bindMappings.model[name]) {
            available = !parent.isLoading();
            availableSet = true;
          } else {
            associations = parentValue.associations;
            if (!(associations && name in associations)) {
              available = true;
              availableSet = true;
            }
          }
        } else {
          if (parentValue.isStore && bindMappings.store[name] && name !== 'loading') {
            available = !parent.isLoading();
            availableSet = true;
          }
        }
      }
      if (!availableSet) {
        available = me.hadValue || me.getRawValue() !== undefined;
      }
    }
  }
  return available;
}, checkHadValue:function() {
  if (!this.hadValue) {
    this.hadValue = this.getRawValue() !== undefined;
  }
}, collect:function() {
  var me = this, result = me.callParent(), storeBinding = me.storeBinding ? 1 : 0, formula = me.formula ? 1 : 0;
  return result + storeBinding + formula;
}, getLinkFormulaStub:function() {
  var stub = this;
  while (stub.isLinkStub) {
    stub = stub.binding.stub;
  }
  return stub.formula ? stub : null;
}, getParentValue:function() {
  var me = this;
  if (me.dirty) {
    me.parentValue = me.parent.getValue();
    me.dirty = false;
  }
  return me.parentValue;
}, setStore:function(storeBinding) {
  this.storeBinding = storeBinding;
}, inspectValue:function(parentData) {
  var me = this, name = me.name, current = me.boundValue, boundValue = null, associations, raw, changed, associatedEntity;
  if (parentData && parentData.isEntity) {
    associations = parentData.associations;
    if (associations && name in associations) {
      boundValue = parentData[associations[name].getterName]();
    } else {
      if (name === me.validationKey) {
        boundValue = parentData.getValidation();
        me.lastValidationGeneration = null;
      }
    }
  } else {
    if (parentData) {
      raw = parentData[name];
      if (raw && (raw.isModel || raw.isStore)) {
        boundValue = raw;
      }
    }
  }
  changed = current !== boundValue;
  if (changed) {
    if (current) {
      me.detachBound();
    }
    if (boundValue) {
      if (boundValue.isModel) {
        boundValue.join(me);
      } else {
        associatedEntity = boundValue.associatedEntity;
        if (associatedEntity && boundValue.autoLoad !== false && !boundValue.complete && !boundValue.hasPendingLoad()) {
          boundValue.load();
        }
        boundValue.on({scope:me, beginload:'onStoreDataChanged', load:'onStoreDataChanged', datachanged:'onStoreDataChanged', destroy:'onDestroyBound'});
      }
    }
    me.boundValue = boundValue;
  }
  return boundValue;
}, detachBound:function() {
  var me = this, current = me.boundValue;
  if (current && !current.destroyed) {
    if (current.isModel) {
      current.unjoin(me);
    } else {
      current.un({scope:me, beginload:'onStoreDataChanged', load:'onStoreDataChanged', datachanged:'onStoreDataChanged', destroy:'onDestroyBound'});
    }
  }
}, onDestroyBound:function() {
  if (!this.owner.destroying) {
    this.set(null);
  }
}, sort:function() {
  var me = this, formula = me.formula, scheduler = me.scheduler, storeBinding = me.storeBinding;
  me.callParent();
  if (storeBinding) {
    scheduler.sortItem(storeBinding);
  }
  if (formula) {
    scheduler.sortItem(formula);
  }
}}});
Ext.define('Ext.app.bind.LinkStub', {extend:Ext.app.bind.Stub, isLinkStub:true, binding:null, destroy:function() {
  var me = this, binding = me.binding, owner = me.owner;
  if (binding) {
    me.binding = null;
    binding.destroy();
    if (owner) {
      delete owner.linkData[me.name];
    }
  }
  me.target = null;
  me.callParent();
}, getFullName:function() {
  var me = this;
  return me.fullName || (me.fullName = '(' + me.callParent() + ' -\x3e ' + me.binding.getFullName() + ')');
}, getDataObject:function() {
  var binding = this.binding, root = this.parent, name = this.name, rootData, ret;
  if (root.isRootStub && !root.shouldClimb(name)) {
    rootData = root.owner.getData();
    if (!rootData.hasOwnProperty(name)) {
      rootData[name] = ret = {};
    }
  } else {
    ret = binding && binding.getDataObject();
  }
  return ret;
}, getRawValue:function() {
  var binding = this.binding;
  return binding && binding.getRawValue();
}, getValue:function() {
  var binding = this.binding;
  return binding && binding.getValue();
}, getTargetStub:function() {
  var binding = this.binding;
  return binding && binding.stub;
}, isAvailable:function() {
  var binding = this.binding;
  return binding ? binding.isAvailable() : false;
}, isLoading:function() {
  var binding = this.binding;
  return binding ? binding.isLoading() : false;
}, link:function(bindDescriptor, target) {
  var me = this, binding = me.binding;
  if (binding) {
    binding.destroy();
  }
  target = me.target = target || me.owner;
  me.linkDescriptor = bindDescriptor;
  me.binding = target.bind(bindDescriptor, me.onChange, me);
  me.binding.deep = true;
}, onChange:function() {
  this.invalidate(true);
}, react:function() {
  var me = this, linkData = me.owner.linkData;
  linkData[me.name] = me.getValue();
  me.callParent();
}, privates:{collect:function() {
  var me = this, result = me.callParent(), binding = me.binding ? 1 : 0;
  return result + binding;
}, sort:function() {
  var binding = this.binding;
  if (binding) {
    this.scheduler.sortItem(binding);
  }
}}});
Ext.define('Ext.app.bind.RootStub', {extend:Ext.app.bind.AbstractStub, isRootStub:true, depth:0, createRootChild:function(name, direct) {
  var me = this, owner = me.owner, ownerData = owner.getData(), children = me.children, previous = children && children[name], parentStub = previous ? null : me, parentVM, stub;
  if (direct || ownerData.hasOwnProperty(name) || !(parentVM = owner.getParent())) {
    stub = new Ext.app.bind.Stub(owner, name, parentStub);
  } else {
    stub = new Ext.app.bind.LinkStub(owner, name, parentStub);
    stub.link('{' + name + '}', parentVM);
  }
  if (previous) {
    previous.graft(stub);
  }
  return stub;
}, createStubChild:function(name) {
  return this.createRootChild(name, true);
}, descend:function(path, index) {
  var me = this, children = me.children, pos = index || 0, name = path[pos++], ret = children && children[name] || me.createRootChild(name);
  if (pos < path.length) {
    ret = ret.descend(path, pos);
  }
  return ret;
}, getFullName:function() {
  return this.fullName || (this.fullName = this.owner.id + ':');
}, getDataObject:function() {
  return this.owner.data;
}, getRawValue:function() {
  return this.owner.data;
}, getValue:function() {
  return this.owner.data;
}, isDescendantOf:function() {
  return false;
}, set:function(value, preventClimb) {
  if (!value || value.constructor !== Object) {
    Ext.raise('Only an object can be set at the root');
  }
  var me = this, children = me.children || (me.children = {}), owner = me.owner, data = owner.data, parentVM = owner.getParent(), stub, v, key, setSelf, created;
  for (key in value) {
    if (key.indexOf('.') >= 0) {
      Ext.raise('Value names cannot contain dots');
    }
    v = value[key];
    if (v !== undefined) {
      stub = children[key];
      setSelf = preventClimb || !me.shouldClimb(key);
      if (!stub) {
        stub = me.createRootChild(key, setSelf);
        created = true;
      } else {
        if (setSelf && stub.isLinkStub && !stub.getLinkFormulaStub()) {
          stub = me.insertChild(key);
        }
      }
      if (!created || !data.hasOwnProperty(value)) {
        owner.invalidateChildLinks(key);
      }
      stub.set(v, setSelf);
    } else {
      if (data.hasOwnProperty(key)) {
        delete data[key];
        stub = children[key];
        if (stub) {
          if (!stub.isLinkStub && parentVM) {
            stub = me.createRootChild(key);
          }
          owner.invalidateChildLinks(key, true);
          stub.invalidate(true);
        }
      }
    }
  }
}, schedule:Ext.emptyFn, unschedule:Ext.emptyFn, privates:{checkAvailability:function() {
  return true;
}, insertChild:function(name) {
  return this.createRootChild(name, true);
}, invalidateChildLink:function(name, clear) {
  var children = this.children, stub = children && children[name];
  if (stub && stub.isLinkStub && !stub.getLinkFormulaStub()) {
    stub = this.createRootChild(name);
    if (clear) {
      stub.invalidate(true);
    }
    this.owner.invalidateChildLinks(name, clear);
  }
}, shouldClimb:function(name) {
  var parent = this.owner.getParent();
  while (parent) {
    if (parent.getData().hasOwnProperty(name)) {
      return true;
    }
    parent = parent.getParent();
  }
  return false;
}}});
Ext.define('Ext.app.bind.Multi', {extend:Ext.app.bind.BaseBinding, isMultiBinding:true, missing:1, deep:true, constructor:function(descriptor, owner, callback, scope, options) {
  var me = this, trackStatics = options && options.trackStatics;
  me.callParent([owner, callback, scope, options]);
  me.bindings = [];
  me.literal = descriptor.$literal;
  if (descriptor.constructor === Object) {
    if (trackStatics) {
      me.staticKeys = [];
    }
    me.addObject(descriptor, me.lastValue = {}, me.staticKeys);
  } else {
    me.addArray(descriptor, me.lastValue = []);
  }
  if (!--me.missing && !me.scheduled) {
    me.schedule();
  }
}, destroy:function() {
  var me = this;
  me.bindings = Ext.destroy(me.bindings);
  me.callParent();
}, add:function(descriptor, data, property) {
  var me = this, owner = me.owner, bindings = me.bindings, method = me.literal ? descriptor.reference ? 'bindEntity' : 'bindExpression' : 'bind', binding, depth;
  ++me.missing;
  binding = owner[method](descriptor, function(value) {
    data[property] = value;
    if (binding.calls === 1) {
      --me.missing;
    }
    if (!me.missing && !me.scheduled) {
      me.schedule();
    }
  }, me, null);
  depth = binding.depth;
  if (!bindings.length || depth < me.depth) {
    me.depth = depth;
  }
  bindings.push(binding);
  return !this.isBindingStatic(binding);
}, addArray:function(multiBindDescr, array) {
  var me = this, n = multiBindDescr.length, hasDynamic = false, dynamic, b, i;
  for (i = 0; i < n; ++i) {
    b = multiBindDescr[i];
    if (b && (b.reference || Ext.isString(b))) {
      dynamic = me.add(b, array, i);
    } else {
      if (Ext.isArray(b)) {
        dynamic = me.addArray(b, array[i] = []);
      } else {
        if (b && b.constructor === Object) {
          dynamic = me.addObject(b, array[i] = {});
        } else {
          array[i] = b;
          dynamic = false;
        }
      }
    }
    hasDynamic = hasDynamic || dynamic;
  }
  return hasDynamic;
}, addObject:function(multiBindDescr, object, staticKeys) {
  var me = this, hasDynamic = false, dynamic, b, name;
  for (name in multiBindDescr) {
    b = multiBindDescr[name];
    if (b && (b.reference || Ext.isString(b))) {
      dynamic = me.add(b, object, name);
    } else {
      if (Ext.isArray(b)) {
        dynamic = me.addArray(b, object[name] = []);
      } else {
        if (b && b.constructor === Object) {
          dynamic = me.addObject(b, object[name] = {});
        } else {
          object[name] = b;
          dynamic = false;
        }
      }
    }
    if (staticKeys && !dynamic) {
      staticKeys.push(name);
    }
    hasDynamic = hasDynamic || dynamic;
  }
  return hasDynamic;
}, getFullName:function() {
  var me = this, fullName = me.fullName, bindings = me.bindings, length = bindings.length, i;
  if (!fullName) {
    fullName = '@[';
    for (i = 0; i < length; ++i) {
      if (i) {
        fullName += ',';
      }
      fullName += bindings[i].getFullName();
    }
    fullName += ']';
    me.fullName = fullName;
  }
  return fullName;
}, getRawValue:function() {
  return this.lastValue;
}, isDescendantOf:function() {
  return false;
}, isLoading:function() {
  for (var bindings = this.bindings, n = bindings.length; n-- > 0;) {
    if (bindings[n].isLoading()) {
      return true;
    }
  }
  return false;
}, isAvailable:function() {
  for (var bindings = this.bindings, n = bindings.length; n-- > 0;) {
    if (bindings[n].isAvailable()) {
      return true;
    }
  }
  return false;
}, isBindingStatic:function(binding) {
  return binding.isTemplateBinding && binding.isStatic;
}, isStatic:function() {
  var bindings = this.bindings, len = bindings.length, i, binding;
  for (i = 0; i < len; ++i) {
    binding = bindings[i];
    if (!this.isBindingStatic(binding)) {
      return false;
    }
  }
  return true;
}, pruneStaticKeys:function() {
  var value = Ext.apply({}, this.lastValue), keys = this.staticKeys, len = keys.length, i;
  for (i = 0; i < len; ++i) {
    delete value[keys[i]];
  }
  return value;
}, react:function() {
  this.notify(this.lastValue);
}, refresh:function() {
}, privates:{sort:function() {
  this.scheduler.sortItems(this.bindings);
}}});
Ext.define('Ext.app.bind.Formula', {extend:Ext.util.Schedulable, statics:{getFormulaParser:function(name) {
  var cache = this.formulaCache, parser, s;
  if (!cache) {
    cache = this.formulaCache = new Ext.util.LruCache({maxSize:20});
  }
  parser = cache.get(name);
  if (!parser) {
    s = '[^\\.a-z0-9_]' + Ext.String.escapeRegex(name) + '\\(\\s*([\'"])(.*?)\\1\\s*\\)';
    parser = new RegExp(s, 'gi');
    cache.add(name, parser);
  }
  return parser;
}}, isFormula:true, calculation:null, explicit:false, set:null, single:false, fnKeywordArgumentNamesRe:/^function\s*[^\(]*\(\s*([^,\)\s]+)/, fnKeywordRe:/^\s*function/, replaceParenRe:/[\(\)]/g, constructor:function(stub, formula) {
  var me = this, owner = stub.owner, bindTo, expressions, getter, options;
  me.owner = owner;
  me.stub = stub;
  me.callParent();
  if (formula instanceof Function) {
    me.get = getter = formula;
  } else {
    me.get = getter = formula.get;
    me.set = formula.set;
    expressions = formula.bind;
    if (formula.single) {
      me.single = formula.single;
    }
    if (expressions) {
      bindTo = expressions.bindTo;
      if (bindTo) {
        options = Ext.apply({}, expressions);
        delete options.bindTo;
        expressions = bindTo;
      }
    }
  }
  if (!getter) {
    Ext.raise('Must specify a getter method for a formula');
  }
  if (expressions) {
    me.explicit = true;
  } else {
    expressions = getter.$expressions || me.parseFormula(getter);
  }
  me.binding = owner.bind(expressions, me.onChange, me, options);
}, destroy:function() {
  var me = this, binding = me.binding, stub = me.stub;
  if (binding) {
    binding.destroy();
    me.binding = null;
  }
  if (stub) {
    stub.formula = null;
  }
  me.callParent();
  me.getterFn = me.owner = null;
}, getFullName:function() {
  return this.fullName || (this.fullName = this.stub.getFullName() + '\x3d' + this.callParent() + ')');
}, getRawValue:function() {
  return this.calculation;
}, onChange:function() {
  if (!this.scheduled) {
    this.schedule();
  }
}, parseFormula:function(formula) {
  var str = Ext.Function.toCode(formula), defaultProp = 'get', expressions = {$literal:true}, match, getterProp, formulaRe, expr;
  if (this.fnKeywordRe.test(str)) {
    match = this.fnKeywordArgumentNamesRe.exec(str);
    if (match) {
      getterProp = match[1];
    }
  } else {
    match = str.split('\x3d\x3e')[0];
    if (match) {
      match = Ext.String.trim(match.replace(this.replaceParenRe, '')).split(',');
      getterProp = match[0];
    }
  }
  getterProp = getterProp || defaultProp;
  formulaRe = Ext.app.bind.Formula.getFormulaParser(getterProp);
  while (match = formulaRe.exec(str)) {
    expr = match[2];
    expressions[expr] = expr;
  }
  expressions.$literal = true;
  formula.$expressions = expressions;
  return expressions;
}, react:function() {
  var me = this, owner = me.owner, data = me.binding.lastValue, getterFn = me.getterFn, arg;
  if (me.explicit) {
    arg = data;
  } else {
    arg = owner.getFormulaFn(data);
  }
  me.settingValue = true;
  me.stub.set(me.calculation = me.get.call(owner, arg));
  me.settingValue = false;
  if (me.single) {
    me.destroy();
  }
}, setValue:function(value) {
  this.set.call(this.stub.owner, value);
}, privates:{getScheduler:function() {
  var owner = this.owner;
  return owner && owner.getScheduler();
}, sort:function() {
  var me = this, binding = me.binding;
  if (!binding.destroyed) {
    me.scheduler.sortItem(binding);
  }
}}});
Ext.define('Ext.util.Fly', {inheritableStatics:{flyPoolSize:2, fly:function() {
  var T = this, flyweights = T.flyweights || (T.flyweights = []), instance = flyweights.length ? flyweights.pop() : new T;
  instance.reset.apply(instance, arguments);
  return instance;
}}, release:function() {
  var me = this, T = me.self, flyweights = T.flyweights || (T.flyweights = []);
  me.reset();
  if (flyweights.length < T.flyPoolSize) {
    flyweights.push(me);
  }
}, reset:Ext.emptyFn});
Ext.define('Ext.parse.Tokenizer', function(Tokenizer) {
  var flyweights = Tokenizer.flyweights = [], BOOLEAN = {literal:true, 'boolean':true}, ERROR = {error:true}, IDENT = {ident:true}, LITERAL = {literal:true}, NULL = {literal:true, nil:true}, NUMBER = {literal:true, number:true}, STRING = {literal:true, string:true};
  return {extend:Ext.util.Fly, isTokenizer:true, statics:{BOOLEAN:BOOLEAN, ERROR:ERROR, IDENT:IDENT, LITERAL:LITERAL, NULL:NULL, NUMBER:NUMBER, STRING:STRING}, config:{keywords:{'null':{type:'literal', is:NULL, value:null}, 'false':{type:'literal', is:BOOLEAN, value:false}, 'true':{type:'literal', is:BOOLEAN, value:true}}, operators:{'+':'plus', '-':'minus', '*':'multiply', '/':'divide', '!':'bang', ',':'comma', ':':'colon', '[':'arrayOpen', ']':'arrayClose', '{':'curlyOpen', '}':'curlyClose', '(':'parenOpen', 
  ')':'parenClose'}}, error:null, index:-1, constructor:function(config) {
    this.operators = {};
    this.initConfig(config);
  }, next:function() {
    var token = this.peek();
    this.head = undefined;
    return token;
  }, peek:function() {
    var me = this, error = me.error, token = me.head;
    if (error) {
      return error;
    }
    if (token === undefined) {
      me.head = token = me.advance();
    }
    return token;
  }, release:function() {
    this.reset();
    if (flyweights.length < Tokenizer.flyPoolSize) {
      flyweights.push(this);
    }
  }, reset:function(text, pos, end) {
    var me = this;
    me.error = null;
    me.head = undefined;
    me.index = -1;
    me.text = text || null;
    me.pos = pos || 0;
    me.end = text && end == null ? text.length : end;
    return me;
  }, privates:{digitRe:/[0-9]/, identFirstRe:/[a-z_$]/i, identRe:/[0-9a-z_$]/i, spaceRe:/[ \t]/, end:0, head:undefined, pos:0, text:null, applyOperators:function(ops) {
    var operators = this.operators, block, c, def, i, len, name, op;
    for (op in ops) {
      block = operators;
      name = ops[op];
      len = op.length;
      for (i = 0; i < len; ++i) {
        c = op.charAt(i);
        block = block[c] || (block[c] = {});
      }
      if (name) {
        block.token = def = {type:'operator', value:op, is:{operator:true}};
        def.is[name] = true;
      } else {
        block.token = null;
      }
    }
  }, advance:function() {
    var me = this, spaceRe = me.spaceRe, text = me.text, length = me.end, c;
    while (me.pos < length) {
      c = text.charAt(me.pos);
      if (spaceRe.test(c)) {
        ++me.pos;
        continue;
      }
      me.index = me.pos;
      return me.parse(c);
    }
    return null;
  }, parse:function(c) {
    var me = this, digitRe = me.digitRe, text = me.text, length = me.end, ret;
    if (c === '.' && me.pos + 1 < length) {
      if (digitRe.test(text.charAt(me.pos + 1))) {
        ret = me.parseNumber();
      }
    }
    if (!ret && me.operators[c]) {
      ret = me.parseOperator(c);
    }
    if (!ret) {
      if (c === '"' || c === "'") {
        ret = me.parseString();
      } else {
        if (digitRe.test(c)) {
          ret = me.parseNumber();
        } else {
          if (me.identFirstRe.test(c)) {
            ret = me.parseIdent();
          } else {
            ret = me.syntaxError('Unexpected character');
          }
        }
      }
    }
    return ret;
  }, parseIdent:function() {
    var me = this, identRe = me.identRe, keywords = me.getKeywords(), includeDots = !me.operators['.'], text = me.text, start = me.pos, end = start, length = me.end, prev = 0, c, value;
    while (end < length) {
      c = text.charAt(end);
      if (includeDots && c === '.') {
        if (prev === '.') {
          return me.syntaxError(end, 'Unexpected dot operator');
        }
        ++end;
      } else {
        if (identRe.test(c)) {
          ++end;
        } else {
          break;
        }
      }
      prev = c;
    }
    if (prev === '.') {
      return me.syntaxError(end - 1, 'Unexpected dot operator');
    }
    value = text.substring(start, me.pos = end);
    return keywords && keywords[value] || {type:'ident', is:IDENT, value:value};
  }, parseNumber:function() {
    var me = this, digitRe = me.digitRe, text = me.text, start = me.pos, length = me.end, c, decimal, exp, token;
    while (me.pos < length) {
      c = text.charAt(me.pos);
      if (c === '-' || c === '+') {
        if (me.pos !== start) {
          return me.syntaxError(start, 'Invalid number');
        }
        ++me.pos;
      } else {
        if (c === '.') {
          if (decimal) {
            break;
          }
          decimal = true;
          ++me.pos;
        } else {
          if (c === 'e' || c === 'E') {
            if (exp) {
              break;
            }
            decimal = exp = true;
            c = text.charAt(++me.pos);
            if (c === '-' || c === '+') {
              ++me.pos;
            }
          } else {
            if (digitRe.test(c)) {
              ++me.pos;
            } else {
              break;
            }
          }
        }
      }
    }
    token = {type:'literal', is:NUMBER, value:+text.substring(start, me.pos)};
    if (!isFinite(token.value)) {
      token = me.syntaxError(start, 'Invalid number');
    }
    return token;
  }, parseOperator:function(c) {
    var me = this, block = me.operators, text = me.text, length = me.end, end = me.pos, match, matchEnd, token;
    while (block[c]) {
      block = block[c];
      token = block.token;
      ++end;
      if (token) {
        match = token;
        matchEnd = end;
      }
      if (end < length) {
        c = text.charAt(end);
      } else {
        break;
      }
    }
    if (match) {
      me.pos = matchEnd;
    }
    return match;
  }, parseString:function() {
    var me = this, text = me.text, pos = me.pos, start = pos, length = me.end, str = '', c, closed, quote;
    quote = text.charAt(pos++);
    while (pos < length) {
      c = text.charAt(pos++);
      if (c === quote) {
        closed = true;
        break;
      }
      if (c === '\\' && pos < length) {
        c = text.charAt(pos++);
      }
      str += c;
    }
    me.pos = pos;
    if (!closed) {
      return me.syntaxError(start, 'Unterminated string');
    }
    return {type:'literal', is:STRING, value:str};
  }, syntaxError:function(at, message) {
    if (typeof at === 'string') {
      message = at;
      at = this.pos;
    }
    var suffix = at == null ? '' : ' (at index ' + at + ')', error = new Error(message + suffix);
    error.type = 'error';
    error.is = ERROR;
    if (suffix) {
      error.at = at;
    }
    return this.error = error;
  }}};
});
Ext.define('Ext.parse.Symbol', {priority:0, constructor:function(id, config) {
  var me = this, defaultProperty = me.defaultProperty;
  if (config && typeof config === 'object') {
    Ext.apply(me, config);
  } else {
    if (config !== undefined && defaultProperty) {
      me[defaultProperty] = config;
    }
  }
  me.id = id;
}, dump:function() {
  var me = this, ret = {at:me.at, arity:me.arity}, i;
  if ('value' in me) {
    ret.value = me.value;
  }
  if (me.lhs) {
    ret.lhs = me.lhs.dump();
    ret.rhs = me.rhs.dump();
  }
  if (me.operand) {
    ret.operand = me.operand.dump();
  }
  if (me.args) {
    ret.args = [];
    for (i = 0; i < me.args.length; ++i) {
      ret.args.push(me.args[i].dump());
    }
  }
  return ret;
}, led:function() {
  this.parser.syntaxError(this.at, 'Missing operator');
}, nud:function() {
  this.parser.syntaxError(this.at, 'Undefined');
}, update:function(config) {
  if (config && typeof config === 'object') {
    var me = this, priority = config.priority, led = config.led, nud = config.nud;
    if (me.priority <= priority) {
      me.priority = priority;
    }
    if (led) {
      me.led = led;
    }
    if (nud) {
      me.nud = nud;
    }
  }
}});
Ext.define('Ext.parse.symbol.Constant', {extend:Ext.parse.Symbol, arity:'literal', isLiteral:true, defaultProperty:'value', constructor:function(id, config) {
  this.callParent([id, config]);
  this._value = this.value;
}, nud:function() {
  var me = this;
  me.value = me._value;
  me.arity = 'literal';
  me.isLiteral = true;
  return me;
}});
Ext.define('Ext.parse.symbol.Infix', {extend:Ext.parse.Symbol, arity:'binary', isBinary:true, defaultProperty:'priority', led:function(left) {
  var me = this;
  me.lhs = left;
  me.rhs = me.parser.parseExpression(me.priority);
  me.arity = 'binary';
  me.isBinary = true;
  return me;
}});
Ext.define('Ext.parse.symbol.InfixRight', {extend:Ext.parse.symbol.Infix, led:function(left) {
  var me = this;
  me.lhs = left;
  me.rhs = me.parser.parseExpression(me.priority - 1);
  me.arity = 'binary';
  me.isBinary = true;
  return me;
}});
Ext.define('Ext.parse.symbol.Paren', {extend:Ext.parse.Symbol, arity:'binary', isBinary:true, priority:80, led:function(left) {
  var me = this, args = [], parser = me.parser, id = left.id, type = left.arity;
  if (id !== '.' && id !== '[') {
    if ((type !== 'unary' || id !== 'function') && type !== 'ident' && id !== '(' && id !== '\x26\x26' && id !== '||' && id !== '?') {
      parser.syntaxError(left.at, 'Expected a variable name.');
    }
  }
  me.arity = 'invoke';
  me.isInvoke = true;
  me.operand = left;
  me.args = args;
  while (parser.token.id !== ')') {
    if (args.length) {
      parser.advance(',');
    }
    args.push(parser.parseExpression());
  }
  parser.advance(')');
  return me;
}, nud:function() {
  var parser = this.parser, ret = parser.parseExpression();
  parser.advance(')');
  return ret;
}});
Ext.define('Ext.parse.symbol.Prefix', {extend:Ext.parse.Symbol, arity:'unary', isUnary:true, priority:70, nud:function() {
  var me = this;
  me.operand = me.parser.parseExpression(me.priority);
  me.arity = 'unary';
  me.isUnary = true;
  return me;
}});
Ext.define('Ext.parse.Parser', function() {
  var ITSELF = function() {
    return this;
  };
  return {extend:Ext.util.Fly, isParser:true, config:{constants:{'null':null, 'false':false, 'true':true}, infix:{'+':50, '-':50, '*':60, '/':60}, infixRight:{'\x26\x26':30, '||':30}, prefix:{'!':0, '-':0, '+':0}, symbols:{':':0, ',':0, ')':0, '[':0, ']':0, '{':0, '}':0, '(end)':0, '(ident)':{arity:'ident', isIdent:true, nud:ITSELF}, '(literal)':{arity:'literal', isLiteral:true, nud:ITSELF}, '(':{xclass:'Ext.parse.symbol.Paren'}}, tokenizer:{keywords:null}}, token:null, constructor:function(config) {
    this.symbols = {};
    this.initConfig(config);
  }, advance:function(expected) {
    var me = this, tokenizer = me.tokenizer, token = tokenizer.peek(), symbols = me.symbols, index = tokenizer.index, is, symbol, value;
    if (me.error) {
      throw me.error;
    }
    if (expected) {
      me.expect(expected);
    }
    if (!token) {
      return me.token = symbols['(end)'];
    }
    tokenizer.next();
    is = token.is;
    value = token.value;
    if (is.ident) {
      symbol = symbols[value] || symbols['(ident)'];
    } else {
      if (is.operator) {
        if (!(symbol = symbols[value])) {
          me.syntaxError(token.at, 'Unknown operator "' + value + '"');
        }
      } else {
        if (is.literal) {
          symbol = symbols['(literal)'];
        } else {
          me.syntaxError(token.at, 'Unexpected token');
        }
      }
    }
    me.token = symbol = Ext.Object.chain(symbol);
    symbol.at = index;
    symbol.value = value;
    if (!symbol.arity) {
      symbol.arity = token.type;
    }
    return symbol;
  }, expect:function(expected) {
    var token = this.token;
    if (expected !== token.id) {
      this.syntaxError(token.at, 'Expected "' + expected + '"');
    }
    return this;
  }, parseExpression:function(rightPriority) {
    var me = this, token = me.token, left;
    rightPriority = rightPriority || 0;
    me.advance();
    left = token.nud();
    while (rightPriority < (token = me.token).priority) {
      me.advance();
      left = token.led(left);
    }
    return left;
  }, reset:function(text, pos, end) {
    var me = this;
    me.error = me.token = null;
    me.tokenizer.reset(text, pos, end);
    me.advance();
    return me;
  }, syntaxError:function(at, message) {
    if (typeof at === 'string') {
      message = at;
      at = this.pos;
    }
    var suffix = at == null ? '' : ' (at index ' + at + ')', error = new Error(message + suffix);
    error.type = 'error';
    if (suffix) {
      error.at = at;
    }
    throw this.error = error;
  }, privates:{error:null, addSymbol:function(id, config, type, update) {
    var symbols = this.symbols, symbol = symbols[id], cfg, length, i;
    if (symbol) {
      if (typeof config === 'object') {
        cfg = config;
      } else {
        if (update && type) {
          update = Ext.Array.from(update);
          length = update.length;
          cfg = {};
          for (i = 0; i < length; i++) {
            cfg[update[i]] = type.prototype[update[i]];
          }
        } else {
          return symbol;
        }
      }
      symbol.update(cfg);
    } else {
      if (config && config.xclass) {
        type = Ext.ClassManager.get(config.xclass);
      } else {
        type = type || Ext.parse.Symbol;
      }
      symbols[id] = symbol = new type(id, config);
      symbol.parser = this;
    }
    return symbol;
  }, addSymbols:function(symbols, type, update) {
    for (var id in symbols) {
      this.addSymbol(id, symbols[id], type, update);
    }
  }, applyConstants:function(constants) {
    this.addSymbols(constants, Ext.parse.symbol.Constant, 'nud');
  }, applyInfix:function(operators) {
    this.addSymbols(operators, Ext.parse.symbol.Infix, 'led');
  }, applyInfixRight:function(operators) {
    this.addSymbols(operators, Ext.parse.symbol.InfixRight, 'led');
  }, applyPrefix:function(operators) {
    this.addSymbols(operators, Ext.parse.symbol.Prefix, 'nud');
  }, applySymbols:function(symbols) {
    this.addSymbols(symbols);
  }, applyTokenizer:function(config) {
    var ret = config;
    if (config && !config.isTokenizer) {
      ret = new Ext.parse.Tokenizer(config);
    }
    this.tokenizer = ret;
  }}};
});
Ext.define('Ext.app.bind.Parser', {extend:Ext.parse.Parser, infix:{':':{priority:70, dump:function() {
  var me = this, ret = {at:me.at, arity:me.arity, value:me.value, operand:me.operand.dump(), fmt:[]}, fmt = me.fmt, i;
  for (i = 0; i < fmt.length; ++i) {
    ret.fmt.push(fmt[i].dump());
  }
  return ret;
}, led:function(left) {
  var me = this;
  me.arity = 'formatter';
  me.operand = left;
  me.fmt = me.parser.parseFmt();
  return me;
}}, '?':{priority:20, led:function(left) {
  var me = this, parser = me.parser, symbol = parser.symbols[':'], temp;
  me.condition = left;
  temp = symbol.priority;
  symbol.priority = 0;
  me.tv = parser.parseExpression(0);
  me.parser.advance(':');
  symbol.priority = temp;
  me.fv = parser.parseExpression(0);
  me.arity = 'ternary';
  return me;
}}, '\x3d\x3d\x3d':40, '!\x3d\x3d':40, '\x3d\x3d':40, '!\x3d':40, '\x3c':40, '\x3c\x3d':40, '\x3e':40, '\x3e\x3d':40}, symbols:{'(':{nud:function() {
  var parser = this.parser, symbol = parser.symbols[':'], ret, temp;
  temp = symbol.priority;
  symbol.priority = 70;
  ret = parser.parseExpression();
  parser.advance(')');
  symbol.priority = temp;
  return ret;
}}}, prefix:{'@':0}, tokenizer:{operators:{'@':'at', '?':'qmark', '\x3d\x3d\x3d':'feq', '!\x3d\x3d':'fneq', '\x3d\x3d':'eq', '!\x3d':'neq', '\x3c':'lt', '\x3c\x3d':'lte', '\x3e':'gt', '\x3e\x3d':'gte', '\x26\x26':'and', '||':'or'}}, compileExpression:function(tokens, tokensMaps) {
  var me = this, debug, fn;
  me.tokens = tokens;
  me.tokensMap = tokensMaps;
  debug = me.token.value === '@' && me.tokenizer.peek();
  if (debug) {
    debug = debug.value === 'debugger';
    if (debug) {
      me.advance();
      me.advance();
    }
  }
  fn = me.parseSlot(me.parseExpression(), debug);
  me.tokens = me.tokensMap = null;
  return fn;
}, compileFormat:function() {
  var fn;
  try {
    fn = this.parseSlot({arity:'formatter', fmt:this.parseFmt(), operand:{arity:'ident', value:'dummy'}});
    this.expect('(end)');
  } catch (e$29) {
    Ext.raise('Invalid format expression: "' + this.tokenizer.text + '"');
  }
  return fn;
}, privates:{useEval:Ext.isGecko, escapeRe:/("|'|\\)/g, parseFmt:function() {
  var me = this, fmt = [], priority = me.symbols[':'].priority, expr;
  do {
    if (fmt.length) {
      me.advance();
    }
    expr = me.parseExpression(priority);
    if (expr.isIdent || expr.isInvoke) {
      fmt.push(expr);
    } else {
      me.syntaxError(expr.at, 'Expected formatter name');
    }
  } while (me.token.id === ':');
  return fmt;
}, parseSlot:function(expr, debug) {
  var me = this, defs = [], body = [], tokens = me.tokens || [], fn, code, i, length, temp;
  me.definitions = defs;
  me.body = body;
  body.push('return ' + me.compile(expr) + ';');
  length = tokens.length;
  code = 'var fm \x3d Ext.util.Format,\nme,';
  temp = 'var a \x3d Ext.Array.from(values);\nme \x3d scope;\n';
  if (tokens.length) {
    for (i = 0; i < length; i++) {
      code += 'v' + i + (i == length - 1 ? ';' : ',');
      temp += 'v' + i + ' \x3d a[' + i + ']; ';
    }
  } else {
    code += 'v0;';
    temp += 'v0 \x3d a[0];';
  }
  defs = Ext.Array.insert(defs, 0, [code]);
  body = Ext.Array.insert(body, 0, [temp]);
  body = body.join('\n');
  if (debug) {
    body = 'debugger;\n' + body;
  }
  defs.push((me.useEval ? '$\x3d' : 'return') + ' function (values, scope) {', body, '}');
  code = defs.join('\n');
  fn = me.useEval ? me.evalFn(code) : (new Function('Ext', code))(Ext);
  me.definitions = me.body = null;
  return fn;
}, compile:function(expr) {
  var me = this, v;
  switch(expr.arity) {
    case 'ident':
      return me.addToken(expr.value);
    case 'literal':
      v = expr.value;
      return typeof v === 'string' ? '"' + String(v).replace(me.escapeRe, '\\$1') + '"' : v;
    case 'unary':
      return me.compileUnary(expr);
    case 'binary':
      return me.compileBinary(expr);
    case 'ternary':
      return me.compileTernary(expr);
    case 'formatter':
      return me.compileFormatter(expr);
  }
  return this.syntaxError(expr.at, 'Compile error! Unknown symbol');
}, compileUnary:function(expr) {
  var v = expr.value, op = expr.operand;
  if (v === '!' || v === '-' || v === '+') {
    return v + '(' + this.compile(op) + ')';
  } else {
    if (v === '@') {
      if (!op.isIdent) {
        return this.syntaxError(expr.at, 'Compile error! Unexpected symbol');
      }
      return op.value;
    }
  }
  return '';
}, compileBinary:function(expr) {
  return '(' + this.compile(expr.lhs) + ' ' + expr.value + ' ' + this.compile(expr.rhs) + ')';
}, compileTernary:function(expr) {
  return '(' + this.compile(expr.condition) + ' ? ' + this.compile(expr.tv) + ' : ' + this.compile(expr.fv) + ')';
}, compileFormatter:function(expr) {
  var me = this, fmt = expr.fmt, length = fmt.length, body = ['var ret;'], i;
  if (fmt.length) {
    body.push('ret \x3d ' + me.compileFormatFn(fmt[0], me.compile(expr.operand)) + ';');
    for (i = 1; i < length; i++) {
      body.push('ret \x3d ' + me.compileFormatFn(fmt[i], 'ret') + ';');
    }
  }
  body.push('return ret;');
  return me.addFn(body.join('\n'));
}, compileFormatFn:function(expr, value) {
  var fmt, args = [], code = '', length, i;
  if (expr.isIdent) {
    fmt = expr.value;
  } else {
    if (expr.isInvoke) {
      fmt = expr.operand.value;
      args = expr.args;
    }
  }
  if (fmt.substring(0, 5) === 'this.') {
    fmt = 'me.' + fmt.substring(5);
  } else {
    if (!(fmt in Ext.util.Format)) {
      return this.syntaxError(expr.at, 'Compile error! Invalid format specified "' + fmt + '"');
    }
    fmt = 'fm.' + fmt;
  }
  code += value;
  length = args.length;
  for (i = 0; i < length; i++) {
    code += ', ' + this.compile(args[i]);
  }
  return fmt + '(' + code + ')';
}, addFn:function(body) {
  var defs = this.definitions, name = 'f' + defs.length;
  defs.push('function ' + name + '() {', body, '}');
  return name + '()';
}, evalFn:function($) {
  eval($);
  return $;
}, addToken:function(token) {
  var tokensMap = this.tokensMap, tokens = this.tokens, pos = 0;
  if (tokensMap && tokens) {
    if (token in tokensMap) {
      pos = tokensMap[token];
    } else {
      tokensMap[token] = pos = tokens.length;
      tokens.push(token);
    }
  }
  return 'v' + pos;
}}});
Ext.define('Ext.app.bind.Template', {escapes:false, buffer:null, slots:null, tokens:null, constructor:function(text) {
  var me = this, initters = me._initters, name;
  me.text = text;
  for (name in initters) {
    me[name] = initters[name];
  }
}, _initters:{apply:function(values, scope) {
  return this.parse().apply(values, scope);
}, getTokens:function() {
  return this.parse().getTokens();
}}, apply:function(values, scope) {
  var me = this, slots = me.slots, buffer = me.buffer, length = slots.length, i, slot;
  for (i = 0; i < length; ++i) {
    slot = slots[i];
    if (slot) {
      buffer[i] = slot(values, scope);
    }
  }
  if (slot && me.single) {
    return buffer[0];
  }
  return buffer.join('');
}, getText:function() {
  return this.buffer.join('');
}, getTokens:function() {
  return this.tokens;
}, isStatic:function() {
  var tokens = this.getTokens(), slots = this.slots;
  return tokens.length === 0 && slots.length === 0;
}, privates:{literalChar:'~', escapeChar:'\\', parse:function() {
  var me = this, text = me.text, parser = Ext.app.bind.Parser.fly(), buffer = me.buffer = [], slots = me.slots = [], length = text.length, pos = 0, escapes = me.escapes, current = '', i = 0, esc = me.escapeChar, lit = me.literalChar, escaped, tokens, tokensMap, lastEscaped, c, prev, key;
  for (key in me._initters) {
    delete me[key];
  }
  me.tokens = tokens = [];
  me.tokensMap = tokensMap = {};
  while (i < length) {
    c = text[i];
    lastEscaped = escaped;
    escaped = escapes && c === esc;
    if (escaped) {
      c = text[i + 1];
      ++i;
    } else {
      if (c === lit && prev === lit && !lastEscaped) {
        current = current.slice(0, -1);
        current += text.substring(i + 1);
        break;
      } else {
        if (c === '{') {
          if (current) {
            buffer[pos++] = current;
            current = '';
          }
          parser.reset(text, i + 1);
          i = me.parseExpression(parser, pos);
          ++pos;
          continue;
        }
      }
    }
    current += c;
    ++i;
    prev = c;
  }
  if (current) {
    buffer[pos] = current;
  }
  parser.release();
  me.single = buffer.length === 0 && slots.length === 1;
  return me;
}, parseExpression:function(parser, pos) {
  var i;
  this.slots[pos] = parser.compileExpression(this.tokens, this.tokensMap);
  i = parser.token.at + 1;
  parser.expect('}');
  return i;
}}});
Ext.define('Ext.app.bind.TemplateBinding', {extend:Ext.app.bind.BaseBinding, isTemplateBinding:true, lastValue:undefined, value:undefined, constructor:function(template, owner, callback, scope, options) {
  var me = this, tpl = new Ext.app.bind.Template(template), tokens = tpl.getTokens();
  me.callParent([owner, callback, scope, options]);
  me.tpl = tpl;
  me.tokens = tokens;
  tokens.$literal = true;
  if (!tpl.isStatic()) {
    me.multiBinding = new Ext.app.bind.Multi(tokens, owner, me.onBindData, me);
  } else {
    me.isStatic = true;
    me.onData(tpl.getText());
  }
}, destroy:function() {
  var me = this;
  Ext.destroy(me.multiBinding);
  me.tpl = me.multiBinding = null;
  me.callParent();
}, getFullName:function() {
  var multi = this.multiBinding;
  return this.fullName || (this.fullName = '$' + (multi ? multi.getFullName() : this.callParent()));
}, getRawValue:function() {
  return this.value;
}, getTemplateScope:function() {
  return null;
}, isAvailable:function() {
  var multi = this.multiBinding;
  return multi ? multi.isAvailable() : false;
}, isDescendantOf:function() {
  return false;
}, isLoading:function() {
  var multi = this.multiBinding;
  return multi ? multi.isLoading() : false;
}, onBindData:function(data) {
  this.onData(this.tpl.apply(data, this.getTemplateScope()));
}, onData:function(value) {
  var me = this, lastValue = me.value;
  if (lastValue !== (me.value = value)) {
    me.lastValue = lastValue;
    me.schedule();
  }
}, react:function() {
  this.notify(this.value);
}, refresh:function() {
  var multi = this.multiBinding;
  if (multi) {
    multi.refresh();
  }
}, privates:{sort:function() {
  var multi = this.multiBinding;
  if (multi) {
    this.scheduler.sortItem(multi);
  }
}}});
Ext.define('Ext.data.ChainedStore', {extend:Ext.data.AbstractStore, alias:'store.chained', isChainedStore:true, config:{source:null, remoteFilter:false, remoteSort:false}, mixins:[Ext.data.LocalStore], updateRemoteFilter:function(remoteFilter, oldRemoteFilter) {
  if (remoteFilter) {
    Ext.raise('Remote filtering cannot be used with chained stores.');
  }
  this.callParent([remoteFilter, oldRemoteFilter]);
}, updateRemoteSort:function(remoteSort, oldRemoteSort) {
  if (remoteSort) {
    Ext.raise('Remote sorting cannot be used with chained stores.');
  }
  this.callParent([remoteSort, oldRemoteSort]);
}, remove:function() {
  var source = this.getSource();
  if (!source) {
    Ext.raise('Cannot remove records with no source.');
  }
  return source.remove.apply(source, arguments);
}, removeAll:function() {
  var source = this.getSource();
  if (!source) {
    Ext.raise('Cannot remove records with no source.');
  }
  return source.removeAll();
}, getData:function() {
  var me = this, data = me.data;
  if (!data) {
    me.data = data = me.constructDataCollection();
  }
  return data;
}, getTotalCount:function() {
  return this.getCount();
}, getSession:function() {
  return this.getSourceValue('getSession', null);
}, applySource:function(source) {
  if (source) {
    var original = source, s;
    source = Ext.data.StoreManager.lookup(source);
    if (!source) {
      s = 'Invalid source {0}specified for Ext.data.ChainedStore';
      s = Ext.String.format(s, typeof original === 'string' ? '"' + original + '" ' : '');
      Ext.raise(s);
    }
  }
  return source;
}, updateSource:function(source, oldSource) {
  var me = this, data;
  if (oldSource && !oldSource.destroyed) {
    oldSource.removeObserver(me);
  }
  if (source) {
    data = me.getData();
    data.setSource(source.getData());
    if (!me.isInitializing) {
      me.fireEvent('refresh', me);
      me.fireEvent('datachanged', me);
    }
    source.addObserver(me);
  }
}, getModel:function() {
  return this.getSourceValue('getModel', null);
}, getProxy:function() {
  return null;
}, onCollectionAdd:function(collection, info) {
  var me = this, records = info.items, lastChunk = !info.next;
  if (me.ignoreCollectionAdd) {
    return;
  }
  if (me.activeRanges) {
    me.syncActiveRanges();
  }
  me.fireEvent('add', me, records, info.at);
  if (lastChunk) {
    me.fireEvent('datachanged', me);
  }
}, onCollectionItemChange:function(collection, info) {
  var me = this, record = info.item, modifiedFieldNames = info.modified || null, type = info.meta;
  me.onUpdate(record, type, modifiedFieldNames, info);
  me.fireEvent('update', me, record, type, modifiedFieldNames, info);
  me.fireEvent('datachanged', me);
}, onCollectionUpdateKey:function(source, details) {
  this.fireEvent('idchanged', this, details.item, details.oldKey, details.newKey);
}, onUpdate:Ext.emptyFn, onCollectionRemove:function(collection, info) {
  var me = this, records = info.items, lastChunk = !info.next;
  if (me.ignoreCollectionRemove) {
    return;
  }
  me.fireEvent('remove', me, records, info.at, false);
  if (lastChunk) {
    me.fireEvent('datachanged', me);
  }
}, onSourceBeforeLoad:function(source, operation) {
  this.fireEvent('beforeload', this, operation);
  this.callObservers('BeforeLoad', [operation]);
}, onSourceAfterLoad:function(source, records, successful, operation) {
  this.fireEvent('load', this, records, successful, operation);
  this.callObservers('AfterLoad', [records, successful, operation]);
}, onFilterEndUpdate:function() {
  this.callParent(arguments);
  this.callObservers('Filter');
}, onSourceBeforePopulate:function() {
  this.ignoreCollectionAdd = true;
  this.callObservers('BeforePopulate');
}, onSourceAfterPopulate:function() {
  var me = this;
  me.ignoreCollectionAdd = false;
  me.fireEvent('datachanged', me);
  me.fireEvent('refresh', me);
  this.callObservers('AfterPopulate');
}, onSourceBeforeClear:function() {
  this.ignoreCollectionRemove = true;
  this.callObservers('BeforeClear');
}, onSourceAfterClear:function() {
  this.ignoreCollectionRemove = false;
  this.callObservers('AfterClear');
}, onSourceBeforeRemoveAll:function() {
  this.ignoreCollectionRemove = true;
  this.callObservers('BeforeRemoveAll');
}, onSourceAfterRemoveAll:function(source, silent) {
  var me = this;
  me.ignoreCollectionRemove = false;
  if (!silent) {
    me.fireEvent('clear', me);
    me.fireEvent('datachanged', me);
  }
  this.callObservers('AfterRemoveAll', [silent]);
}, onSourceFilter:function() {
  var me = this;
  me.fireEvent('refresh', me);
  me.fireEvent('datachanged', me);
}, hasPendingLoad:function() {
  return this.getSourceValue('hasPendingLoad', false);
}, isLoaded:function() {
  return this.getSourceValue('isLoaded', false);
}, isLoading:function() {
  return this.getSourceValue('isLoading', false);
}, doDestroy:function() {
  var me = this;
  me.observers = null;
  me.setSource(null);
  me.getData().destroy(true);
  me.data = null;
  me.callParent();
}, privates:{getSourceValue:function(method, defaultValue) {
  var source = this.getSource(), val = defaultValue;
  if (source && !source.destroyed) {
    val = source[method]();
  }
  return val;
}, isMoving:function() {
  var source = this.getSource();
  return source.isMoving ? source.isMoving.apply(source, arguments) : false;
}, loadsSynchronously:function() {
  return this.getSource().loadsSynchronously();
}}});
Ext.define('Ext.app.ViewModel', {mixins:[Ext.mixin.Factoryable, Ext.mixin.Identifiable], alias:'viewmodel.default', isViewModel:true, factoryConfig:{name:'viewModel'}, collectTimeout:100, expressionRe:/^(?:\{(?:(\d+)|([a-z_][\w\.]*))\})$/i, statics:{escape:function(value) {
  var ret = value, key;
  if (typeof value === 'string') {
    ret = '~~' + value;
  } else {
    if (value && value.constructor === Object) {
      ret = {};
      for (key in value) {
        ret[key] = this.escape(value[key]);
      }
    }
  }
  return ret;
}}, $configStrict:false, config:{data:true, formulas:{$value:null, merge:function(newValue, currentValue, target, mixinClass) {
  return this.mergeNew(newValue, currentValue, target, mixinClass);
}}, links:null, parent:null, root:true, scheduler:null, schema:'default', session:null, stores:null, view:null}, constructor:function(config) {
  this.bindings = {};
  this.initConfig(config);
}, destroy:function() {
  var me = this, scheduler = me._scheduler, stores = me.storeInfo, parent = me.getParent(), task = me.collectTask, children = me.children, bindings = me.bindings, key, store, autoDestroy, storeBinding;
  me.destroying = true;
  if (task) {
    task.cancel();
    me.collectTask = null;
  }
  if (children) {
    for (key in children) {
      children[key].destroy();
    }
  }
  if (stores) {
    for (key in stores) {
      store = stores[key];
      storeBinding = store.$binding;
      autoDestroy = store.autoDestroy;
      if (autoDestroy || !store.$wasInstance && autoDestroy !== false) {
        store.destroy();
      }
      Ext.destroy(storeBinding);
    }
  }
  if (parent) {
    parent.unregisterChild(me);
  }
  me.getRoot().destroy();
  for (key in bindings) {
    bindings[key].destroy();
  }
  if (scheduler && scheduler.$owner === me) {
    scheduler.$owner = null;
    scheduler.destroy();
  }
  me.children = me.storeInfo = me._session = me._view = me._scheduler = me.bindings = me._root = me._parent = me.formulaFn = me.$formulaData = null;
  me.destroying = false;
  me.callParent();
}, bind:function(descriptor, callback, scope, options) {
  var me = this, track = true, binding;
  scope = scope || me;
  if (!options && descriptor.bindTo !== undefined && !Ext.isString(descriptor)) {
    options = descriptor;
    descriptor = options.bindTo;
  }
  if (!Ext.isString(descriptor)) {
    binding = new Ext.app.bind.Multi(descriptor, me, callback, scope, options);
  } else {
    if (me.expressionRe.test(descriptor)) {
      descriptor = descriptor.substring(1, descriptor.length - 1);
      binding = me.bindExpression(descriptor, callback, scope, options);
      track = false;
    } else {
      binding = new Ext.app.bind.TemplateBinding(descriptor, me, callback, scope, options);
    }
  }
  if (track) {
    me.bindings[binding.id] = binding;
  }
  return binding;
}, getSession:function() {
  var me = this, session = me._session, parent;
  if (!session && (parent = me.getParent())) {
    me.setSession(session = parent.getSession());
  }
  return session || null;
}, getStore:function(key) {
  var storeInfo = this.storeInfo, store;
  if (storeInfo) {
    store = storeInfo[key];
  }
  return store || null;
}, linkTo:function(key, reference) {
  var me = this, stub, create, id, modelType, linkStub, rec;
  if (key.indexOf('.') > -1) {
    Ext.raise('Links can only be at the top-level: "' + key + '"');
  }
  if (reference.isModel) {
    reference = {type:reference.entityName, id:reference.id};
  }
  modelType = reference.type || reference.reference;
  create = reference.create;
  if (modelType) {
    id = reference.id;
    if (!reference.create && Ext.isEmpty(id)) {
      Ext.raise('No id specified. To create a phantom model, specify "create: true" as part of the reference.');
    }
    if (create) {
      id = undefined;
    }
    rec = me.getRecord(modelType, id);
    if (Ext.isObject(create)) {
      rec.set(create);
      rec.commit();
      rec.phantom = true;
    }
    stub = me.getRoot().createStubChild(key);
    stub.set(rec);
  } else {
    stub = me.getStub(key);
    if (!stub.isLinkStub) {
      linkStub = new Ext.app.bind.LinkStub(me, stub.name);
      stub.graft(linkStub);
      stub = linkStub;
    }
    stub.link(reference);
  }
}, notify:function() {
  var scheduler = this.getScheduler();
  if (!scheduler.firing) {
    scheduler.notify();
  }
}, get:function(path) {
  return this.getStub(path).getValue();
}, set:function(path, value) {
  var me = this, obj, stub;
  me.getData();
  if (value === undefined && path && path.constructor === Object) {
    stub = me.getRoot();
    value = path;
  } else {
    if (path && path.indexOf('.') < 0) {
      obj = {};
      obj[path] = value;
      value = obj;
      stub = me.getRoot();
    } else {
      stub = me.getStub(path);
    }
  }
  stub.set(value);
}, privates:{registerChild:function(child) {
  var children = this.children;
  if (!children) {
    this.children = children = {};
  }
  children[child.getId()] = child;
}, unregisterChild:function(child) {
  var children = this.children;
  if (!this.destroying && children) {
    delete children[child.getId()];
  }
}, getRecord:function(type, id) {
  var session = this.getSession(), Model = type, hasId = id !== undefined, record;
  if (session) {
    if (hasId) {
      record = session.getRecord(type, id);
    } else {
      record = session.createRecord(type);
    }
  } else {
    if (!Model.$isClass) {
      Model = this.getSchema().getEntity(Model);
      if (!Model) {
        Ext.raise('Invalid model name: ' + type);
      }
    }
    if (hasId) {
      record = Model.createWithId(id);
      record.load();
    } else {
      record = new Model;
    }
  }
  return record;
}, bindExpression:function(descriptor, callback, scope, options) {
  var stub = this.getStub(descriptor);
  return stub.bind(callback, scope, options);
}, applyScheduler:function(scheduler) {
  if (scheduler && !scheduler.isInstance) {
    if (scheduler === true) {
      scheduler = {};
    }
    if (!('preSort' in scheduler)) {
      scheduler = Ext.apply({preSort:'kind,-depth'}, scheduler);
    }
    scheduler = new Ext.util.Scheduler(scheduler);
    scheduler.$owner = this;
  }
  return scheduler;
}, getScheduler:function() {
  var me = this, scheduler = me._scheduler, parent;
  if (!scheduler) {
    if (!(parent = me.getParent())) {
      scheduler = new Ext.util.Scheduler({preSort:'kind,-depth'});
      scheduler.$owner = me;
    } else {
      scheduler = parent.getScheduler();
    }
    me.setScheduler(scheduler);
  }
  return scheduler;
}, getStub:function(bindDescr) {
  var root = this.getRoot();
  return bindDescr ? root.getChild(bindDescr) : root;
}, collect:function() {
  var me = this, parent = me.getParent(), task = me.collectTask;
  if (parent) {
    parent.collect();
    return;
  }
  if (!task) {
    task = me.collectTask = new Ext.util.DelayedTask(me.doCollect, me);
  }
  if (me.collectTimeout === 0) {
    me.doCollect();
  } else {
    task.delay(me.collectTimeout);
  }
}, doCollect:function() {
  var children = this.children, key;
  if (children) {
    for (key in children) {
      children[key].doCollect();
    }
  }
  this.getRoot().collect();
}, invalidateChildLinks:function(name, clear) {
  var children = this.children, key;
  if (children) {
    for (key in children) {
      children[key].getRoot().invalidateChildLink(name, clear);
    }
  }
}, onBindDestroy:function(binding, fromChild) {
  var me = this, parent;
  if (me.destroying) {
    return;
  }
  if (!fromChild) {
    delete me.bindings[binding.id];
  }
  parent = me.getParent();
  if (parent) {
    parent.onBindDestroy(binding, true);
  } else {
    me.collect();
  }
}, applyData:function(newData, data) {
  var me = this, linkData, parent;
  me.getSession();
  if (!data) {
    parent = me.getParent();
    me.linkData = linkData = parent ? Ext.Object.chain(parent.getData()) : {};
    me.data = me._data = Ext.Object.chain(linkData);
  }
  if (newData && newData.constructor === Object) {
    me.getRoot().set(newData, true);
  }
}, applyParent:function(parent) {
  if (parent) {
    parent.registerChild(this);
  }
  return parent;
}, applyStores:function(stores) {
  var me = this, root = me.getRoot(), key, cfg, storeBind, stub, listeners;
  me.storeInfo = {};
  me.listenerScopeFn = function() {
    return me.getView().getInheritedConfig('defaultListenerScope');
  };
  for (key in stores) {
    cfg = stores[key];
    if (cfg.isStore) {
      cfg.$wasInstance = true;
      me.setupStore(cfg, key);
      continue;
    } else {
      if (Ext.isString(cfg)) {
        cfg = {source:cfg};
      } else {
        cfg = Ext.apply({}, cfg);
      }
    }
    listeners = cfg.listeners;
    delete cfg.listeners;
    storeBind = me.bind(cfg, me.onStoreBind, me, {trackStatics:true});
    if (storeBind.isStatic()) {
      storeBind.destroy();
      me.createStore(key, cfg, listeners);
    } else {
      storeBind.$storeKey = key;
      storeBind.$listeners = listeners;
      stub = root.createStubChild(key);
      stub.setStore(storeBind);
    }
  }
}, onStoreBind:function(cfg, oldValue, binding) {
  var info = this.storeInfo, key = binding.$storeKey, store = info[key], proxy;
  if (!store) {
    this.createStore(key, cfg, binding.$listeners, binding);
  } else {
    cfg = Ext.merge({}, binding.pruneStaticKeys());
    proxy = cfg.proxy;
    delete cfg.type;
    delete cfg.model;
    delete cfg.fields;
    delete cfg.proxy;
    delete cfg.listeners;
    if (proxy) {
      delete proxy.reader;
      delete proxy.writer;
      store.getProxy().setConfig(proxy);
    }
    store.setConfig(cfg);
  }
}, createStore:function(key, cfg, listeners, binding) {
  var session = this.getSession(), store;
  cfg = Ext.apply({}, cfg);
  if (cfg.session) {
    cfg.session = session;
  }
  if (cfg.source) {
    cfg.type = cfg.type || 'chained';
  }
  cfg.listeners = listeners;
  cfg.resolveListenerScope = this.listenerScopeFn;
  store = Ext.Factory.store(cfg);
  store.$binding = binding;
  this.setupStore(store, key);
}, setupStore:function(store, key) {
  var me = this, obj = {};
  me.getData();
  store.resolveListenerScope = me.listenerScopeFn;
  me.storeInfo[key] = store;
  obj[key] = store;
  me.setData(obj);
}, applyFormulas:function(formulas) {
  var me = this, root = me.getRoot(), name, stub;
  me.getData();
  for (name in formulas) {
    if (name.indexOf('.') >= 0) {
      Ext.raise('Formula names cannot contain dots: ' + name);
    }
    root.createStubChild(name);
    stub = me.getStub(name);
    stub.setFormula(formulas[name]);
  }
  return formulas;
}, applyLinks:function(links) {
  for (var link in links) {
    this.linkTo(link, links[link]);
  }
}, applySchema:function(schema) {
  return Ext.data.schema.Schema.get(schema);
}, applyRoot:function() {
  var root = new Ext.app.bind.RootStub(this), parent = this.getParent();
  if (parent) {
    root.depth = parent.getRoot().depth - 1000;
  }
  return root;
}, getFormulaFn:function(data) {
  var me = this, fn = me.formulaFn;
  if (!fn) {
    fn = me.formulaFn = function(name) {
      return me.$formulaData[name];
    };
  }
  me.$formulaData = data;
  return fn;
}}});
Ext.define('Ext.app.domain.Controller', {extend:Ext.app.EventDomain, singleton:true, type:'controller', prefix:'controller.', idMatchRe:/^#/, constructor:function() {
  var me = this;
  me.callParent();
  me.monitor(Ext.app.BaseController);
}, match:function(target, selector) {
  var result = false, alias = target.alias;
  if (selector === '*') {
    result = true;
  } else {
    if (selector === '#') {
      result = !!target.isApplication;
    } else {
      if (this.idMatchRe.test(selector)) {
        result = target.getId() === selector.substring(1);
      } else {
        if (alias) {
          result = Ext.Array.indexOf(alias, this.prefix + selector) > -1;
        }
      }
    }
  }
  return result;
}});
Ext.define('Ext.direct.Manager', {singleton:true, mixins:[Ext.mixin.Observable], exceptions:{TRANSPORT:'xhr', PARSE:'parse', DATA:'data', LOGIN:'login', SERVER:'exception'}, providerClasses:{}, remotingMethods:{}, config:{varName:'Ext.REMOTING_API'}, apiNotFoundError:'Ext Direct API was not found at {0}', constructor:function() {
  var me = this;
  me.mixins.observable.constructor.call(me);
  me.transactions = new Ext.util.MixedCollection;
  me.providers = new Ext.util.MixedCollection;
}, addProvider:function(provider) {
  var me = this, args = arguments, relayers = me.relayers || (me.relayers = {}), i, len;
  if (args.length > 1) {
    for (i = 0, len = args.length; i < len; ++i) {
      me.addProvider(args[i]);
    }
    return;
  }
  if (!provider.isProvider) {
    provider = Ext.create('direct.' + provider.type + 'provider', provider);
  }
  me.providers.add(provider);
  provider.on('data', me.onProviderData, me);
  if (provider.relayedEvents) {
    relayers[provider.id] = me.relayEvents(provider, provider.relayedEvents);
  }
  if (!provider.isConnected()) {
    provider.connect();
  }
  return provider;
}, loadProvider:function(config, callback, scope) {
  var me = this, classes = me.providerClasses, type, url, varName, provider, i, len;
  if (Ext.isArray(config)) {
    for (i = 0, len = config.length; i < len; i++) {
      me.loadProvider(config[i], callback, scope);
    }
    return;
  }
  type = config.type;
  url = config.url;
  if (classes[type] && classes[type].checkConfig(config)) {
    provider = me.addProvider(config);
    me.fireEventArgs('providerload', [url, provider]);
    Ext.callback(callback, scope, [url, provider]);
    return;
  }
  varName = config.varName || me.getVarName();
  delete config.varName;
  if (!url) {
    Ext.raise('Need API discovery URL to load a Remoting provider!');
  }
  delete config.url;
  Ext.Loader.loadScript({url:url, scope:me, onLoad:function() {
    this.onApiLoadSuccess({url:url, varName:varName, config:config, callback:callback, scope:scope});
  }, onError:function() {
    this.onApiLoadFailure({url:url, callback:callback, scope:scope});
  }});
}, getProvider:function(id) {
  return id.isProvider ? id : this.providers.get(id);
}, removeProvider:function(provider) {
  var me = this, providers = me.providers, relayers = me.relayers, id;
  provider = provider.isProvider ? provider : providers.get(provider);
  if (provider) {
    provider.un('data', me.onProviderData, me);
    id = provider.id;
    if (relayers[id]) {
      relayers[id].destroy();
      delete relayers[id];
    }
    providers.remove(provider);
    return provider;
  }
  return null;
}, addTransaction:function(transaction) {
  this.transactions.add(transaction);
  return transaction;
}, removeTransaction:function(transaction) {
  var me = this;
  transaction = me.getTransaction(transaction);
  me.transactions.remove(transaction);
  return transaction;
}, getTransaction:function(transaction) {
  return typeof transaction === 'object' ? transaction : this.transactions.get(transaction);
}, onProviderData:function(provider, event) {
  var me = this, i, len;
  if (Ext.isArray(event)) {
    for (i = 0, len = event.length; i < len; ++i) {
      me.onProviderData(provider, event[i]);
    }
    return;
  }
  if (event.name && event.name !== 'event' && event.name !== 'exception') {
    me.fireEvent(event.name, event);
  } else {
    if (event.status === false) {
      me.fireEvent('exception', event);
    }
  }
  me.fireEvent('event', event, provider);
}, parseMethod:function(fn) {
  var current = Ext.global, i = 0, resolved, parts, len;
  if (Ext.isFunction(fn)) {
    resolved = fn;
  } else {
    if (Ext.isString(fn)) {
      resolved = this.remotingMethods[fn];
      if (!resolved) {
        parts = fn.split('.');
        len = parts.length;
        while (current && i < len) {
          current = current[parts[i]];
          ++i;
        }
        resolved = Ext.isFunction(current) ? current : null;
      }
    }
  }
  return resolved || null;
}, resolveApi:function(api, caller) {
  var prefix, action, method, fullName, fn;
  prefix = api && api.prefix;
  if (prefix && prefix.substr(prefix.length - 1) !== '.') {
    prefix += '.';
  }
  for (action in api) {
    method = api[action];
    if (action !== 'prefix' && typeof method !== 'function') {
      fullName = (prefix || '') + method;
      fn = this.parseMethod(fullName);
      if (typeof fn === 'function') {
        api[action] = fn;
      } else {
        Ext.raise("Cannot resolve Direct API method '" + fullName + "' for " + action + ' action in ' + caller.$className + ' instance with id: ' + (caller.id != null ? caller.id : 'unknown'));
      }
    }
  }
  return api;
}, privates:{addProviderClass:function(type, cls) {
  this.providerClasses[type] = cls;
}, onApiLoadSuccess:function(options) {
  var me = this, url = options.url, varName = options.varName, api, provider, error;
  try {
    api = Ext.apply(options.config, eval(varName));
    provider = me.addProvider(api);
  } catch (e$30) {
    error = e$30 + '';
  }
  if (error) {
    me.fireEventArgs('providerloaderror', [url, error]);
    Ext.callback(options.callback, options.scope, [url, error]);
  } else {
    me.fireEventArgs('providerload', [url, provider]);
    Ext.callback(options.callback, options.scope, [url, provider]);
  }
}, onApiLoadFailure:function(options) {
  var url = options.url, error;
  error = Ext.String.format(this.apiNotFoundError, url);
  this.fireEventArgs('providerloaderror', [url, error]);
  Ext.callback(options.callback, options.scope, [url, error]);
}, registerMethod:function(name, method) {
  this.remotingMethods[name] = method;
}, clearAllMethods:function() {
  this.remotingMethods = {};
}}}, function() {
  Ext.Direct = Ext.direct.Manager;
});
Ext.define('Ext.data.Request', {isDataRequest:true, config:{action:undefined, params:undefined, method:'GET', url:null, operation:null, proxy:null, disableCaching:false, headers:{}, callbackKey:null, rawRequest:null, jsonData:undefined, xmlData:undefined, withCredentials:false, username:null, password:null, binary:false, callback:null, scope:null, timeout:30000, records:null, directFn:null, args:null, useDefaultXhrHeader:null, responseType:null}, constructor:function(config) {
  this.initConfig(config);
}, getParam:function(key) {
  var params = this.getParams(), val;
  if (params) {
    return params[key];
  }
  return val;
}, setParam:function(key, value) {
  var params = this.getParams() || {};
  params[key] = value;
  this.setParams(params);
}});
Ext.define('Ext.data.Validation', {extend:Ext.data.Model, isValidation:true, syncGeneration:0, attach:function(record) {
  this.record = record;
  this.isBase = record.self === Ext.data.Model;
  delete this.data.id;
}, getValidation:function() {
  return null;
}, isValid:function() {
  var me = this;
  if (me.syncGeneration !== me.record.generation) {
    me.refresh();
  }
  return !me.dirty;
}, refresh:function(force) {
  if (this.isBase) {
    return;
  }
  var me = this, data = me.data, record = me.record, fields = record.fields, generation = record.generation, recordData = record.data, sep = record.validationSeparator, values = null, defaultMessage, currentValue, error, field, item, i, j, jLen, len, msg, val, name;
  if (force || me.syncGeneration !== generation) {
    me.syncGeneration = generation;
    for (i = 0, len = fields.length; i < len; ++i) {
      field = fields[i];
      name = field.name;
      val = recordData[name];
      defaultMessage = field.defaultInvalidMessage;
      error = 0;
      if (!(name in data)) {
        data[name] = currentValue = true;
      } else {
        currentValue = data[name];
      }
      if (field.validate !== Ext.emptyFn) {
        msg = field.validate(val, sep, null, record);
        if (msg !== true) {
          error = msg || defaultMessage;
        }
      }
      if (!error) {
        error = true;
      }
      if (error !== currentValue) {
        (values || (values = {}))[name] = error;
      }
    }
    if (values) {
      me.set(values);
    }
  }
}});
Ext.define('Ext.dom.Helper', function() {
  var afterbegin = 'afterbegin', afterend = 'afterend', beforebegin = 'beforebegin', beforeend = 'beforeend', bbValues = ['BeforeBegin', 'previousSibling'], aeValues = ['AfterEnd', 'nextSibling'], bb_ae_PositionHash = {beforebegin:bbValues, afterend:aeValues}, fullPositionHash = {beforebegin:bbValues, afterend:aeValues, afterbegin:['AfterBegin', 'firstChild'], beforeend:['BeforeEnd', 'lastChild']};
  return {singleton:true, alternateClassName:['Ext.DomHelper', 'Ext.core.DomHelper'], emptyTags:/^(?:br|frame|hr|img|input|link|meta|range|spacer|wbr|area|param|col)$/i, confRe:/^(?:tag|children|cn|html|tpl|tplData)$/i, endRe:/end/i, attributeTransform:{cls:'class', htmlFor:'for'}, closeTags:{}, detachedDiv:document.createElement('div'), decamelizeName:function() {
    var camelCaseRe = /([a-z])([A-Z])/g, cache = {};
    function decamel(match, p1, p2) {
      return p1 + '-' + p2.toLowerCase();
    }
    return function(s) {
      return cache[s] || (cache[s] = s.replace(camelCaseRe, decamel));
    };
  }(), generateMarkup:function(spec, buffer) {
    var me = this, specType = typeof spec, attr, val, tag, i, closeTags;
    if (specType === 'string' || specType === 'number') {
      buffer.push(spec);
    } else {
      if (Ext.isArray(spec)) {
        for (i = 0; i < spec.length; i++) {
          if (spec[i]) {
            me.generateMarkup(spec[i], buffer);
          }
        }
      } else {
        tag = spec.tag || 'div';
        buffer.push('\x3c', tag);
        for (attr in spec) {
          if (spec.hasOwnProperty(attr)) {
            val = spec[attr];
            if (val !== undefined && !me.confRe.test(attr)) {
              if (val && val.join) {
                val = val.join(' ');
              }
              if (typeof val === 'object') {
                buffer.push(' ', attr, '\x3d"');
                me.generateStyles(val, buffer, true).push('"');
              } else {
                buffer.push(' ', me.attributeTransform[attr] || attr, '\x3d"', val, '"');
              }
            }
          }
        }
        if (me.emptyTags.test(tag)) {
          buffer.push('/\x3e');
        } else {
          buffer.push('\x3e');
          if (val = spec.tpl) {
            val.applyOut(spec.tplData, buffer);
          }
          if (val = spec.html) {
            buffer.push(val);
          }
          if (val = spec.cn || spec.children) {
            me.generateMarkup(val, buffer);
          }
          closeTags = me.closeTags;
          buffer.push(closeTags[tag] || (closeTags[tag] = '\x3c/' + tag + '\x3e'));
        }
      }
    }
    return buffer;
  }, generateStyles:function(styles, buffer, encode) {
    var a = buffer || [], name, val;
    for (name in styles) {
      if (styles.hasOwnProperty(name)) {
        val = styles[name];
        name = this.decamelizeName(name);
        if (encode && Ext.String.hasHtmlCharacters(val)) {
          val = Ext.String.htmlEncode(val);
        }
        a.push(name, ':', val, ';');
      }
    }
    return buffer || a.join('');
  }, markup:function(spec) {
    if (typeof spec === 'string') {
      return spec;
    }
    var buf = this.generateMarkup(spec, []);
    return buf.join('');
  }, applyStyles:function(el, styles) {
    Ext.fly(el).applyStyles(styles);
  }, createContextualFragment:function(html) {
    var div = this.detachedDiv, fragment = document.createDocumentFragment(), length, childNodes;
    div.innerHTML = html;
    childNodes = div.childNodes;
    length = childNodes.length;
    while (length--) {
      fragment.appendChild(childNodes[0]);
    }
    return fragment;
  }, createDom:function(o) {
    var me = this, markup = me.markup(o), div = me.detachedDiv, child;
    div.innerHTML = markup;
    child = div.firstChild;
    return Ext.supports.ChildContentClearedWhenSettingInnerHTML ? child.cloneNode(true) : child;
  }, insertHtml:function(where, el, html) {
    var me = this, hashVal, range, rangeEl, setStart, frag;
    where = where.toLowerCase();
    if (el.insertAdjacentHTML) {
      if (me.ieInsertHtml) {
        frag = me.ieInsertHtml(where, el, html);
        if (frag) {
          return frag;
        }
      }
      hashVal = fullPositionHash[where];
      if (hashVal) {
        el.insertAdjacentHTML(hashVal[0], html);
        return el[hashVal[1]];
      }
    } else {
      if (el.nodeType === 3) {
        where = where === afterbegin ? beforebegin : where;
        where = where === beforeend ? afterend : where;
      }
      range = Ext.supports.CreateContextualFragment ? el.ownerDocument.createRange() : undefined;
      setStart = 'setStart' + (this.endRe.test(where) ? 'After' : 'Before');
      if (bb_ae_PositionHash[where]) {
        if (range) {
          range[setStart](el);
          frag = range.createContextualFragment(html);
        } else {
          frag = this.createContextualFragment(html);
        }
        el.parentNode.insertBefore(frag, where === beforebegin ? el : el.nextSibling);
        return el[(where === beforebegin ? 'previous' : 'next') + 'Sibling'];
      } else {
        rangeEl = (where === afterbegin ? 'first' : 'last') + 'Child';
        if (el.firstChild) {
          if (range) {
            try {
              range[setStart](el[rangeEl]);
              frag = range.createContextualFragment(html);
            } catch (e$31) {
              frag = this.createContextualFragment(html);
            }
          } else {
            frag = this.createContextualFragment(html);
          }
          if (where === afterbegin) {
            el.insertBefore(frag, el.firstChild);
          } else {
            el.appendChild(frag);
          }
        } else {
          el.innerHTML = html;
        }
        return el[rangeEl];
      }
    }
    Ext.raise({sourceClass:'Ext.DomHelper', sourceMethod:'insertHtml', htmlToInsert:html, targetElement:el, msg:'Illegal insertion point reached: "' + where + '"'});
  }, insertBefore:function(el, o, returnElement) {
    return this.doInsert(el, o, returnElement, beforebegin);
  }, insertAfter:function(el, o, returnElement) {
    return this.doInsert(el, o, returnElement, afterend);
  }, insertFirst:function(el, o, returnElement) {
    return this.doInsert(el, o, returnElement, afterbegin);
  }, append:function(el, o, returnElement) {
    return this.doInsert(el, o, returnElement, beforeend);
  }, overwrite:function(el, html, returnElement) {
    var me = this, newNode;
    el = Ext.getDom(el);
    html = me.markup(html);
    if (me.ieOverwrite) {
      newNode = me.ieOverwrite(el, html);
    }
    if (!newNode) {
      el.innerHTML = html;
      newNode = el.firstChild;
    }
    return returnElement ? Ext.get(newNode) : newNode;
  }, doInsert:function(el, o, returnElement, where) {
    var me = this, newNode;
    el = el.dom || Ext.getDom(el);
    if ('innerHTML' in el) {
      newNode = me.insertHtml(where, el, me.markup(o));
    } else {
      newNode = me.createDom(o, null);
      if (el.nodeType === 3) {
        where = where === afterbegin ? beforebegin : where;
        where = where === beforeend ? afterend : where;
      }
      if (bb_ae_PositionHash[where]) {
        el.parentNode.insertBefore(newNode, where === beforebegin ? el : el.nextSibling);
      } else {
        if (el.firstChild && where === afterbegin) {
          el.insertBefore(newNode, el.firstChild);
        } else {
          el.appendChild(newNode);
        }
      }
    }
    return returnElement ? Ext.get(newNode) : newNode;
  }, createTemplate:function(o) {
    var html = this.markup(o);
    return new Ext.Template(html);
  }, createHtml:function(spec) {
    return this.markup(spec);
  }};
});
Ext.define('Ext.data.validator.AbstractDate', {extend:Ext.data.validator.Validator, config:{message:null, format:''}, applyFormat:function(format) {
  if (!format) {
    format = this.getDefaultFormat();
  }
  if (!Ext.isArray(format)) {
    format = [format];
  }
  return format;
}, parse:function(value) {
  if (Ext.isDate(value)) {
    return value;
  }
  var me = this, format = me.getFormat(), len = format.length, ret = null, i;
  for (i = 0; i < len && !ret; ++i) {
    ret = Ext.Date.parse(value, format[i], true);
  }
  return ret;
}, validate:function(value) {
  return this.parse(value) ? true : this.getMessage();
}});
Ext.define('Ext.data.validator.Number', {extend:Ext.data.validator.Validator, alias:'data.validator.number', type:'number', config:{decimalSeparator:undefined, message:'Is not a valid number', thousandSeparator:undefined}, constructor:function(config) {
  this.callParent([config]);
  this.rebuildMatcher();
}, applyDecimalSeparator:function(v) {
  return v === undefined ? Ext.util.Format.decimalSeparator : v;
}, updateDecimalSeparator:function() {
  this.rebuildMatcher();
}, applyThousandSeparator:function(v) {
  return v === undefined ? Ext.util.Format.thousandSeparator : v;
}, updateThousandSeparator:function() {
  this.rebuildMatcher();
}, parse:function(v) {
  var sep = this.getDecimalSeparator(), N = Ext.Number;
  if (typeof v === 'string') {
    if (!this.matcher.test(v)) {
      return null;
    }
    v = this.parseValue(v);
  }
  return sep ? N.parseFloat(v) : N.parseInt(v);
}, validate:function(value) {
  return this.parse(value) === null ? this.getMessage() : true;
}, privates:{getMatcherText:function(preventSign) {
  var t = this.getThousandSeparator(), d = this.getDecimalSeparator(), s = '(?:';
  if (t) {
    t = Ext.String.escapeRegex(t);
    s += '(?:\\d{1,3}(' + t + '\\d{3})*)|';
  }
  s += '\\d*)';
  if (d) {
    d = Ext.String.escapeRegex(d);
    s += '(?:' + d + '\\d*)?';
  }
  if (!preventSign) {
    s = this.getSignPart() + s;
  }
  return s;
}, getSignPart:function() {
  return '(\\+|\\-)?';
}, parseValue:function(v) {
  var thousandMatcher = this.thousandMatcher, decimal;
  if (thousandMatcher) {
    v = v.replace(thousandMatcher, '');
  }
  decimal = this.getDecimalSeparator();
  if (decimal && decimal !== '.') {
    v = v.replace(decimal, '.');
  }
  return v;
}, rebuildMatcher:function() {
  var me = this, sep;
  if (!me.isConfiguring) {
    sep = me.getThousandSeparator();
    me.matcher = new RegExp('^' + me.getMatcherText() + '$');
    if (sep) {
      me.thousandMatcher = sep ? new RegExp(Ext.String.escapeRegex(sep), 'g') : null;
    }
  }
}}});
Ext.define('Ext.data.validator.Date', {extend:Ext.data.validator.AbstractDate, alias:'data.validator.date', type:'date', isDateValidator:true, message:'Is not a valid date', privates:{getDefaultFormat:function() {
  return [Ext.Date.defaultFormat, 'm/d/Y', 'n/j/Y', 'n/j/y', 'm/j/y', 'n/d/y', 'm/j/Y', 'n/d/Y', 'm-d-y', 'n-d-y', 'm-d-Y', 'mdy', 'mdY', 'Y-m-d'];
}}});
Ext.define('Ext.util.TaskRunner', {fireIdleEvent:null, interval:10, timerId:null, constructor:function(interval) {
  var me = this;
  if (typeof interval === 'number') {
    me.interval = interval;
  } else {
    if (interval) {
      Ext.apply(me, interval);
    }
  }
  me.tasks = [];
  me.timerFn = me.onTick.bind(me);
}, newTask:function(config) {
  var task = new Ext.util.TaskRunner.Task(config);
  task.manager = this;
  if (Ext.Timer.track) {
    task.creator = (new Error).stack;
  }
  return task;
}, start:function(task) {
  var me = this, now = Ext.Date.now();
  if (!task.pending) {
    me.tasks.push(task);
    task.pending = true;
  }
  task.stopped = false;
  task.taskStartTime = now;
  task.taskRunTime = task.fireOnStart !== false ? 0 : task.taskStartTime;
  task.taskRunCount = 0;
  if (!me.firing) {
    if (task.fireOnStart !== false) {
      me.startTimer(0, now);
    } else {
      me.startTimer(task.interval, now);
    }
  }
  return task;
}, stop:function(task, andRemove) {
  var me = this, tasks = me.tasks, pendingCount = 0, i;
  if (!task.stopped) {
    task.stopped = true;
    task.pending = false;
    if (task.onStop) {
      task.onStop.call(task.scope || task, task);
    }
  }
  if (andRemove) {
    Ext.Array.remove(tasks, task);
  }
  for (i = 0; !pendingCount && i < tasks.length; i++) {
    if (!tasks[i].stopped) {
      pendingCount++;
    }
  }
  if (!pendingCount) {
    Ext.undefer(me.timerId);
    me.timerId = null;
  }
  return task;
}, stopAll:function(andRemove) {
  var me = this;
  Ext.each(this.tasks, function(task) {
    me.stop(task, andRemove);
  }, null, true);
}, firing:false, nextExpires:1.0E99, onTick:function() {
  var me = this, tasks = me.tasks, fireIdleEvent = me.fireIdleEvent, now = Ext.Date.now(), nextExpires = 1.0E99, len = tasks.length, expires, newTasks, i, task, rt, remove, args;
  var timer = Ext.Timer.get(me.timerId);
  if (timer) {
    timer.tasks = [];
  }
  me.timerId = null;
  me.firing = true;
  for (i = 0; i < len || i < (len = tasks.length); ++i) {
    task = tasks[i];
    if (!(remove = task.stopped)) {
      expires = task.taskRunTime + task.interval;
      if (expires <= now) {
        rt = 1;
        if (fireIdleEvent === null && task.fireIdleEvent !== false) {
          fireIdleEvent = true;
        }
        task.taskRunCount++;
        if (task.args) {
          args = task.addCountToArgs ? task.args.concat([task.taskRunCount]) : task.args;
        } else {
          args = [task.taskRunCount];
        }
        if (timer) {
          timer.tasks.push(task);
        }
        if (me.disableTryCatch) {
          rt = task.run.apply(task.scope || task, args);
        } else {
          try {
            rt = task.run.apply(task.scope || task, args);
          } catch (taskError) {
            try {
              Ext.log({fn:task.run, prefix:'Error while running task', stack:taskError.stack, msg:taskError, level:'error'});
              if (task.onError) {
                rt = task.onError.call(task.scope || task, task, taskError);
              }
            } catch (ignore) {
            }
          }
        }
        task.taskRunTime = now;
        if (rt === false || task.taskRunCount === task.repeat) {
          me.stop(task);
          remove = true;
        } else {
          remove = task.stopped;
          expires = now + task.interval;
        }
      }
      if (!remove && task.duration && task.duration <= now - task.taskStartTime) {
        me.stop(task);
        remove = true;
      }
    }
    if (remove) {
      task.pending = false;
      if (!newTasks) {
        newTasks = tasks.slice(0, i);
      }
    } else {
      if (newTasks) {
        newTasks.push(task);
      }
      if (nextExpires > expires) {
        nextExpires = expires;
      }
    }
  }
  if (newTasks) {
    me.tasks = newTasks;
  }
  me.firing = false;
  if (me.tasks.length) {
    me.startTimer(nextExpires - now, Ext.Date.now());
  }
  if (fireIdleEvent === null) {
    fireIdleEvent = false;
  }
  Ext._suppressIdle = !fireIdleEvent;
}, startTimer:function(timeout, now) {
  var me = this, expires = now + timeout, timerId = me.timerId;
  if (timerId && me.nextExpires - expires > me.interval) {
    timerId = Ext.undefer(timerId);
  }
  if (!timerId) {
    if (timeout < me.interval) {
      timeout = me.interval;
    }
    me.timerId = Ext.defer(me.timerFn, timeout);
    me.nextExpires = expires;
    var timer = Ext.Timer.get(me.timerId);
    if (timer) {
      timer.runner = me;
    }
  }
}}, function() {
  var me = this, proto = me.prototype;
  proto.destroy = proto.stopAll;
  me.Task = new Ext.Class({isTask:true, stopped:true, fireOnStart:false, constructor:function(config) {
    Ext.apply(this, config);
  }, restart:function(interval) {
    if (interval !== undefined) {
      this.interval = interval;
    }
    this.manager.start(this);
  }, start:function(interval) {
    if (this.stopped) {
      this.restart(interval);
    }
  }, stop:function(andRemove) {
    this.manager.stop(this, andRemove);
  }, destroy:function() {
    this.stop(true);
  }});
  proto = me.Task.prototype;
  proto.destroy = proto.stop;
});
Ext.define('Ext.dom.Fly', {extend:Ext.dom.Element, alternateClassName:'Ext.dom.Element.Fly', validNodeTypes:{1:1, 9:1, 11:1}, isFly:true, constructor:function(dom) {
  this.dom = dom;
  this.el = this;
}, attach:function(dom) {
  var me = this, data;
  if (!dom) {
    return me.detach();
  }
  me.dom = Ext.getDom(dom);
  if (!Ext.cache[dom.id]) {
    data = me.peekData();
    if (data) {
      data.isSynchronized = false;
    }
  }
  return me;
}, detach:function() {
  return this.dom = null;
}, addListener:function() {
  Ext.raise('Cannot use addListener() on Ext.dom.Fly instances. ' + 'Please use Ext.get() to retrieve an Ext.dom.Element instance instead.');
} || null, removeListener:function() {
  Ext.raise('Cannot use removeListener() on Ext.dom.Fly instances. ' + 'Please use Ext.get() to retrieve an Ext.dom.Element instance instead.');
} || null}, function(Fly) {
  var flyweights = {}, detachedBodyEl;
  Fly.cache = flyweights;
  Ext.fly = function(dom, named) {
    var fly = null, fn = Ext.fly, nodeType, data;
    named = named || fn.caller && (fn.caller.$name || fn.caller.name) || '_global';
    dom = Ext.getDom(dom);
    if (dom) {
      nodeType = dom.nodeType;
      if (Fly.prototype.validNodeTypes[nodeType] || !nodeType && dom.window == dom) {
        fly = Ext.cache[dom.id];
        if (!fly || fly.dom !== dom) {
          if (named === 'constructor') {
            named = '$constructor';
          }
          fly = flyweights[named] || (flyweights[named] = new Fly);
          fly.dom = dom;
          data = fly.peekData();
          if (data) {
            data.isSynchronized = false;
          }
        }
      }
    }
    return fly;
  };
  Ext.getDetachedBody = function() {
    if (!detachedBodyEl) {
      Ext.detachedBodyEl = detachedBodyEl = new Fly(document.createElement('div'));
      detachedBodyEl.isDetachedBody = true;
    }
    return detachedBodyEl;
  };
});
Ext.define('Ext.dom.CompositeElementLite', {alternateClassName:['Ext.CompositeElementLite'], isComposite:true, isLite:true, statics:{importElementMethods:function() {
  var Element = Ext.dom.Element, prototype = this.prototype;
  Ext.Object.each(Element.prototype, function(name, member) {
    if (typeof member === 'function' && !prototype[name]) {
      prototype[name] = function() {
        return this.invoke(name, arguments);
      };
    }
  });
}}, constructor:function(elements, skipValidation) {
  if (skipValidation) {
    this.elements = elements || [];
  } else {
    this.elements = [];
    this.add(elements);
  }
}, getElement:function(el) {
  var fly = this._fly || (this._fly = new Ext.dom.Fly);
  return fly.attach(el);
}, transformElement:function(el) {
  return Ext.getDom(el);
}, getCount:function() {
  return this.elements.length;
}, add:function(els, root) {
  var elements = this.elements, i, ln;
  if (!els) {
    return this;
  }
  if (typeof els == 'string') {
    els = Ext.fly(root || document).query(els);
  } else {
    if (els.isComposite) {
      els = els.elements;
    } else {
      if (!Ext.isIterable(els)) {
        els = [els];
      }
    }
  }
  for (i = 0, ln = els.length; i < ln; ++i) {
    elements.push(this.transformElement(els[i]));
  }
  return this;
}, invoke:function(fn, args) {
  var me = this, elements = me.elements, ln = elements.length, prototype, element, i;
  if (i !== 0) {
    prototype = (me.isLite ? Ext.dom.Fly : Ext.dom.Element).prototype;
    for (i = 0; i < ln; i++) {
      element = elements[i];
      if (element) {
        prototype[fn].apply(me.getElement(element), args);
      }
    }
  }
  return me;
}, item:function(index) {
  var el = this.elements[index], out = null;
  if (el) {
    out = this.getElement(el);
  }
  return out;
}, slice:function(start, end) {
  return Ext.Array.slice(this.elements, start, end);
}, each:function(fn, scope) {
  var me = this, els = me.elements, len = els.length, i, e;
  for (i = 0; i < len; i++) {
    e = els[i];
    if (e) {
      e = this.getElement(e);
      if (fn.call(scope || e, e, me, i) === false) {
        break;
      }
    }
  }
  return me;
}, fill:function(els) {
  var me = this;
  me.elements = [];
  me.add(els);
  return me;
}, insert:function(index, nodes) {
  Ext.Array.insert(this.elements, index, nodes);
}, filter:function(selector) {
  var me = this, els = me.elements, len = els.length, out = [], i = 0, isFunc = typeof selector == 'function', add, el;
  for (; i < len; i++) {
    el = els[i];
    add = false;
    if (el) {
      el = me.getElement(el);
      if (isFunc) {
        add = selector.call(el, el, me, i) !== false;
      } else {
        add = el.is(selector);
      }
      if (add) {
        out.push(me.transformElement(el));
      }
    }
  }
  me.elements = out;
  return me;
}, indexOf:function(el) {
  return Ext.Array.indexOf(this.elements, this.transformElement(el));
}, replaceElement:function(el, replacement, domReplace) {
  var index = !isNaN(el) ? el : this.indexOf(el), d;
  if (index > -1) {
    replacement = Ext.getDom(replacement);
    if (domReplace) {
      d = this.elements[index];
      d.parentNode.insertBefore(replacement, d);
      Ext.removeNode(d);
    }
    Ext.Array.splice(this.elements, index, 1, replacement);
  }
  return this;
}, clear:function(removeDom) {
  var me = this, els = me.elements, i = els.length - 1;
  if (removeDom) {
    for (; i >= 0; i--) {
      Ext.removeNode(els[i]);
    }
  }
  this.elements = [];
}, addElements:function(els, root) {
  if (!els) {
    return this;
  }
  if (typeof els === 'string') {
    els = Ext.dom.Element.selectorFunction(els, root);
  }
  var yels = this.elements, eLen = els.length, e;
  for (e = 0; e < eLen; e++) {
    yels.push(Ext.get(els[e]));
  }
  return this;
}, first:function() {
  return this.item(0);
}, last:function() {
  return this.item(this.getCount() - 1);
}, contains:function(el) {
  return this.indexOf(el) != -1;
}, removeElement:function(keys, removeDom) {
  keys = [].concat(keys);
  var me = this, elements = me.elements, kLen = keys.length, val, el, k;
  for (k = 0; k < kLen; k++) {
    val = keys[k];
    if (el = elements[val] || elements[val = me.indexOf(val)]) {
      if (removeDom) {
        if (el.dom) {
          el.destroy();
        } else {
          Ext.removeNode(el);
        }
      }
      Ext.Array.erase(elements, val, 1);
    }
  }
  return me;
}, destroy:function() {
  this.invoke('destroy', arguments);
  this.callParent();
}}, function(CompositeElementLite) {
  var prototype = CompositeElementLite.prototype;
  CompositeElementLite.importElementMethods();
  prototype.on = prototype.addListener;
});
Ext.define('Ext.dom.CompositeElement', {alternateClassName:'Ext.CompositeElement', extend:Ext.dom.CompositeElementLite, isLite:false, getElement:function(el) {
  return el;
}, transformElement:function(el) {
  return Ext.get(el);
}});
Ext.define('Ext.dom.GarbageCollector', {singleton:true, interval:30000, constructor:function() {
  var me = this;
  me.lastTime = Ext.now();
  me.onTick = me.onTick.bind(me);
  me.onTick.$skipTimerCheck = true;
  me.resume();
}, collect:function() {
  var me = this, cache = Ext.cache, eid, dom, el, t, isGarbage, tagName;
  var collectedIds = [];
  for (eid in cache) {
    if (!cache.hasOwnProperty(eid)) {
      continue;
    }
    el = cache[eid];
    if (el.skipGarbageCollection) {
      continue;
    }
    dom = el.dom;
    if (!dom) {
      Ext.raise('Missing DOM node in element garbage collection: ' + eid);
    }
    try {
      isGarbage = Ext.isGarbage(dom);
    } catch (e$32) {
      delete cache[eid];
      collectedIds.push('#' + el.id);
      continue;
    }
    if (isGarbage) {
      isGarbage = false;
      if (el && el.dom) {
        tagName = el.dom.tagName;
        el.collect();
        collectedIds.push((tagName ? tagName : '') + '#' + el.id);
      }
    }
  }
  if (Ext.isIE9m) {
    t = {};
    for (eid in cache) {
      if (cache.hasOwnProperty(eid)) {
        t[eid] = cache[eid];
      }
    }
    Ext.cache = Ext.dom.Element.cache = t;
  }
  me.lastTime = Ext.now();
  return collectedIds;
}, onTick:function() {
  this.timerId = null;
  if (Ext.enableGarbageCollector) {
    this.collect();
  }
  this.resume();
}, pause:function() {
  var timerId = this.timerId;
  if (timerId) {
    this.timerId = null;
    Ext.undefer(timerId);
  }
}, resume:function() {
  var me = this, lastTime = me.lastTime;
  if (Ext.enableGarbageCollector && Ext.now() - lastTime > me.interval) {
    me.collect();
  }
  if (!me.timerId) {
    me.timerId = Ext.defer(me.onTick, me.interval);
  }
}});
Ext.define('Ext.dom.TouchAction', {singleton:true, lastTouchStartTime:0, minMoveDistance:8, spaceRe:/\s+/, preventSingle:null, preventMulti:null, disabledOverflowDom:null, panXCls:Ext.baseCSSPrefix + 'touch-action-pan-x', panYCls:Ext.baseCSSPrefix + 'touch-action-pan-y', cssValues:['none', 'pan-x', 'pan-y', 'pan-x pan-y', 'pinch-zoom', 'pan-x pinch-zoom', 'pan-y pinch-zoom', 'pan-x pan-y pinch-zoom', 'double-tap-zoom', 'pan-x double-tap-zoom', 'pan-y double-tap-zoom', 'pan-x pan-y double-tap-zoom', 
'pinch-zoom double-tap-zoom', 'pan-x pinch-zoom double-tap-zoom', 'pan-y pinch-zoom double-tap-zoom', ''], objectValues:[{panX:false, panY:false, pinchZoom:false, doubleTapZoom:false}, {panX:true, panY:false, pinchZoom:false, doubleTapZoom:false}, {panX:false, panY:true, pinchZoom:false, doubleTapZoom:false}, {panX:true, panY:true, pinchZoom:false, doubleTapZoom:false}, {panX:false, panY:false, pinchZoom:true, doubleTapZoom:false}, {panX:true, panY:false, pinchZoom:true, doubleTapZoom:false}, {panX:false, 
panY:true, pinchZoom:true, doubleTapZoom:false}, {panX:true, panY:true, pinchZoom:true, doubleTapZoom:false}, {panX:false, panY:false, pinchZoom:false, doubleTapZoom:true}, {panX:true, panY:false, pinchZoom:false, doubleTapZoom:true}, {panX:false, panY:true, pinchZoom:false, doubleTapZoom:true}, {panX:true, panY:true, pinchZoom:false, doubleTapZoom:true}, {panX:false, panY:false, pinchZoom:true, doubleTapZoom:true}, {panX:true, panY:false, pinchZoom:true, doubleTapZoom:true}, {panX:false, panY:true, 
pinchZoom:true, doubleTapZoom:true}, {panX:true, panY:true, pinchZoom:true, doubleTapZoom:true}], attributeName:'data-extTouchAction', constructor:function() {
  var me = this, supports = Ext.supports;
  if (supports.TouchAction) {
    me.cssProp = 'touch-action';
  } else {
    if (supports.MSPointerEvents) {
      me.cssProp = '-ms-touch-action';
    }
  }
  if (supports.TouchEvents) {
    Ext.getWin().on({touchstart:'onTouchStart', touchmove:'onTouchMove', touchend:'onTouchEnd', scope:me, delegated:false, translate:false, capture:true, priority:5000});
    Ext.on({scroll:'onScroll', scope:me, destroyable:true});
  }
  if (Ext.isFunction(Object.freeze)) {
    var objectValues = me.objectValues;
    for (var i = 0, ln = objectValues.length; i < ln; i++) {
      Object.freeze(objectValues[i]);
    }
  }
}, containsTargets:function(dom, e) {
  var contains = true, event = e.browserEvent, touches = e.type === 'touchend' ? event.changedTouches : event.touches, i, ln;
  for (i = 0, ln = touches.length; i < ln; i++) {
    if (!dom.contains(touches[i].target)) {
      contains = false;
      break;
    }
  }
  return contains;
}, disableOverflow:function(dom, vertical) {
  var me = this, overflowName = vertical ? 'overflow-y' : 'overflow-x', overflowStyle, cls;
  if (!me.disabledOverflowDom && !Ext.isiOS && !Ext.getScrollbarSize().width) {
    me.disabledOverflowDom = dom;
    cls = vertical ? me.panXCls : me.panYCls;
    while (dom) {
      overflowStyle = Ext.fly(dom).getStyle(overflowName);
      if (overflowStyle === 'auto' || overflowStyle === 'scroll') {
        Ext.fly(dom).addCls(cls);
      }
      dom = dom.parentNode;
    }
  }
}, get:function(dom) {
  var flags = dom.getAttribute(this.attributeName), ret = null;
  if (flags != null) {
    ret = this.objectValues[flags];
  }
  return ret;
}, getFlags:function(touchAction) {
  var flags;
  if (typeof touchAction === 'number') {
    flags = touchAction;
  } else {
    flags = 0;
    if (touchAction.panX !== false) {
      flags |= 1;
    }
    if (touchAction.panY !== false) {
      flags |= 2;
    }
    if (touchAction.pinchZoom !== false) {
      flags |= 4;
    }
    if (touchAction.doubleTapZoom !== false) {
      flags |= 8;
    }
  }
  return flags;
}, isScrollable:function(el, vertical, forward) {
  var overflowStyle = Ext.fly(el).getStyle(vertical ? 'overflow-y' : 'overflow-x'), isScrollable = overflowStyle === 'auto' || overflowStyle === 'scroll';
  if (isScrollable) {
    if (vertical) {
      isScrollable = forward ? el.scrollTop + el.clientHeight < el.scrollHeight : el.scrollTop > 0;
    } else {
      isScrollable = forward ? el.scrollLeft + el.clientWidth < el.scrollWidth : el.scrollLeft > 0;
    }
  }
  return isScrollable;
}, lookupFlags:function(dom) {
  return parseInt(dom.getAttribute && dom.getAttribute(this.attributeName) || 15, 10);
}, onScroll:function() {
  this.scrollOccurred = true;
  this.isDoubleTap = false;
}, onTouchEnd:function(e) {
  var me = this, dom = e.target, touchCount, flags, doubleTapZoom;
  touchCount = e.browserEvent.touches.length;
  if (touchCount === 0) {
    if (me.isDoubleTap) {
      while (dom) {
        flags = me.lookupFlags(dom);
        if (flags != null) {
          doubleTapZoom = flags & 8;
          if (!doubleTapZoom) {
            e.preventDefault();
          }
        }
        dom = dom.parentNode;
      }
    }
    me.isDoubleTap = false;
    me.preventSingle = null;
    me.preventMulti = null;
    me.resetOverflow();
  }
}, onTouchMove:function(e) {
  var me = this, prevent = null, dom = e.target, flags, touchCount, panX, panY, point, startPoint, isVertical, scale, distance, deltaX, deltaY, preventSingle, preventMulti;
  preventSingle = me.preventSingle;
  preventMulti = me.preventMulti;
  touchCount = e.browserEvent.touches.length;
  if (touchCount === 1 && preventSingle === false || preventMulti === false) {
    return;
  }
  if (touchCount > 1 && preventMulti === true || touchCount === 1 && preventSingle === true) {
    prevent = true;
  } else {
    if (touchCount === 1) {
      point = e.getPoint();
      startPoint = me.startPoint;
      scale = Ext.Element.getViewportScale();
      distance = point.getDistanceTo(me.startPoint) * scale;
      deltaX = point.x - startPoint.x;
      deltaY = point.y - startPoint.y;
      isVertical = Math.abs(deltaY) >= Math.abs(deltaX);
    }
    while (dom && dom.nodeType === 1) {
      flags = me.lookupFlags(dom);
      if (flags & 0) {
        prevent = true;
      } else {
        if (touchCount === 1) {
          panX = !!(flags & 1);
          panY = !!(flags & 2);
          if (panX && panY) {
            prevent = false;
          } else {
            if (!panX && !panY) {
              prevent = true;
            } else {
              if (distance >= me.minMoveDistance) {
                prevent = !!(panX && isVertical || panY && !isVertical);
              }
            }
          }
          if (!prevent && me.isScrollable(dom, isVertical, (isVertical ? deltaY : deltaX) < 0)) {
            break;
          }
        } else {
          if (me.containsTargets(dom, e)) {
            prevent = !(flags & 4);
          } else {
            prevent = false;
          }
        }
      }
      if (prevent) {
        break;
      }
      dom = dom.parentNode;
    }
  }
  if (touchCount === 1) {
    me.preventSingle = prevent;
  } else {
    if (touchCount > 1) {
      me.preventMulti = prevent;
    }
  }
  if (prevent) {
    e.preventDefault();
  }
}, onTouchStart:function(e) {
  var me = this, time, flags, dom, panX, panY;
  if (e.browserEvent.touches.length === 1) {
    time = e.time;
    if (!me.scrollOccurred && time - me.lastTouchStartTime <= 500) {
      me.isDoubleTap = true;
    }
    me.lastTouchStartTime = time;
    me.scrollOccurred = false;
    me.startPoint = e.getPoint();
    dom = e.target;
    while (dom) {
      flags = me.lookupFlags(dom);
      if (flags != null) {
        panX = !!(flags & 1);
        panY = !!(flags & 2);
        if (panX !== panY) {
          me.disableOverflow(dom, panX);
          break;
        }
      }
      dom = dom.parentNode;
    }
  } else {
    me.isDoubleTap = false;
  }
}, resetOverflow:function() {
  var me = this, dom = me.disabledOverflowDom;
  while (dom) {
    Ext.fly(dom).removeCls([me.panXCls, me.panYCls]);
    dom = dom.parentNode;
  }
  me.disabledOverflowDom = null;
}, set:function(dom, value) {
  var me = this, cssProp = me.cssProp, flags = me.getFlags(value), supportedFlags = flags & Ext.supports.TouchAction, attributeName = me.attributeName;
  if (cssProp) {
    Ext.fly(dom).setStyle(cssProp, me.cssValues[supportedFlags]);
  }
  if (flags === 15) {
    dom.removeAttribute(attributeName);
  } else {
    dom.setAttribute(attributeName, flags);
  }
}});
Ext.define('Ext.drag.Constraint', {alias:'drag.constraint.base', mixins:[Ext.mixin.Factoryable], factoryConfig:{defaultType:'base', type:'drag.constraint'}, config:{element:null, horizontal:null, region:null, snap:null, source:null, vertical:null, x:null, y:null}, constructor:function(config) {
  this.initConfig(config);
}, applyElement:function(element) {
  if (element && typeof element !== 'boolean') {
    element = Ext.get(element);
  }
  return element || null;
}, applySnap:function(snap) {
  if (typeof snap === 'number') {
    snap = {x:snap, y:snap};
  }
  return snap;
}, constrain:function(xy, info) {
  var me = this, x = xy[0], y = xy[1], constrainInfo = me.constrainInfo, initial = constrainInfo.initial, constrainX = constrainInfo.x, constrainY = constrainInfo.y, snap = constrainInfo.snap, min, max;
  if (!constrainInfo.vertical) {
    if (snap && snap.x) {
      if (snap.xFn) {
        x = snap.x.call(me, info, x);
      } else {
        x = me.doSnap(x, initial.x, snap.x);
      }
    }
    if (constrainX) {
      min = constrainX[0];
      max = constrainX[1];
      if (min !== null && x < min) {
        x = min;
      }
      if (max !== null && x > max) {
        x = max;
      }
    }
  } else {
    x = initial.x;
  }
  if (!constrainInfo.horizontal) {
    if (snap && snap.y) {
      if (snap.yFn) {
        y = snap.y.call(me, info, y);
      } else {
        y = me.doSnap(y, initial.y, snap.y);
      }
    }
    if (constrainY) {
      min = constrainY[0];
      max = constrainY[1];
      if (min !== null && y < min) {
        y = min;
      }
      if (max !== null && y > max) {
        y = max;
      }
    }
  } else {
    y = initial.y;
  }
  return [x, y];
}, destroy:function() {
  this.setSource(null);
  this.setElement(null);
  this.callParent();
}, privates:{constrainValue:function(a, b, resolver) {
  var val = null, aNull = a === null, bNull = b === null;
  if (!(aNull && bNull)) {
    if (aNull) {
      val = b;
    } else {
      if (bNull) {
        val = a;
      } else {
        val = resolver(a, b);
      }
    }
  }
  return val;
}, doSnap:function(position, initial, snap) {
  if (!snap) {
    return position;
  }
  var ratio = (position - initial) / snap, floor = Math.floor(ratio);
  if (ratio - floor <= 0.5) {
    ratio = floor;
  } else {
    ratio = floor + 1;
  }
  return initial + snap * ratio;
}, onDragStart:function(info) {
  var me = this, snap = me.getSnap(), vertical = !!me.getVertical(), horizontal = !!me.getHorizontal(), element = me.getElement(), region = me.getRegion(), proxy = info.proxy, proxyEl = proxy.element, x = me.getX(), y = me.getY(), minX = null, maxX = null, minY = null, maxY = null, rminX = null, rmaxX = null, rminY = null, rmaxY = null, pos, size;
  if (element) {
    if (typeof element === 'boolean') {
      element = me.getSource().getElement().parent();
    }
    if (info.local) {
      pos = element.getStyle('position');
      if (pos === 'relative' || pos === 'absolute') {
        size = element.getSize();
        region = new Ext.util.Region(0, size.width, size.height, 0);
      } else {
        region = element.getRegion(true, true);
      }
    } else {
      region = element.getRegion(true);
    }
  }
  if (region) {
    if (!vertical) {
      rminX = region.left;
      rmaxX = region.right - (proxyEl ? proxy.width : 0);
    }
    if (!horizontal) {
      rminY = region.top;
      rmaxY = region.bottom - (proxyEl ? proxy.height : 0);
    }
  }
  if (!vertical && (region || x)) {
    if (x) {
      minX = x[0];
      maxX = x[1];
    }
    if (minX !== null || maxX !== null || rminX !== null || rmaxX !== null) {
      minX = me.constrainValue(minX, rminX, Math.max);
      maxX = me.constrainValue(maxX, rmaxX, Math.min);
      x = [minX, maxX];
    }
  }
  if (!horizontal && (region || y)) {
    if (y) {
      minY = y[0];
      maxY = y[1];
    }
    if (minY !== null || maxY !== null || rminY !== null || rmaxY !== null) {
      minY = me.constrainValue(minY, rminY, Math.max);
      maxY = me.constrainValue(maxY, rmaxY, Math.min);
      y = [minY, maxY];
    }
  }
  if (snap) {
    snap = {x:snap.x, xFn:typeof snap.x === 'function', y:snap.y, yFn:typeof snap.y === 'function'};
  }
  me.constrainInfo = {initial:info.element.initial, vertical:vertical, horizontal:horizontal, x:x, y:y, snap:snap};
}}});
Ext.define('Ext.drag.Info', {constructor:function(source, e) {
  if (!source) {
    return;
  }
  var me = this, local = source.getLocal(), el, proxyEl, proxy, x, xy, y, pageXY, elPageXY;
  me.source = source;
  me.local = local;
  xy = me.getEventXY(e);
  pageXY = e.getXY();
  el = source.getElement();
  elPageXY = el.getXY();
  xy = local ? el.getLocalXY() : elPageXY;
  x = xy[0];
  y = xy[1];
  me.initialEvent = e;
  me.eventTarget = e.target;
  me.cursor = {current:{x:x, y:y}, delta:{x:0, y:0}, initial:{x:pageXY[0], y:pageXY[1]}, offset:{x:pageXY[0] - elPageXY[0], y:pageXY[1] - elPageXY[1]}};
  me.element = {current:{x:x, y:y}, delta:{x:0, y:0}, initial:{x:x, y:y}};
  me.proxy = {instance:source.getProxy(), current:{x:x, y:y}, delta:{x:0, y:0}, initial:{x:x, y:y}, element:el, isUnderCursor:false, isElement:true};
  me.types = [];
  me.data = {};
  source.describe(me);
  proxy = me.proxy;
  proxyEl = proxy.instance.setupElement(me);
  proxy.isElement = proxyEl === source.getElement();
  proxy.element = proxyEl;
  if (proxyEl) {
    proxy.width = proxyEl.getWidth();
    proxy.height = proxyEl.getHeight();
  }
  if (proxy.isElement) {
    el = me.element;
    el.current = proxy.current;
    el.delta = proxy.delta;
  }
  me.needsCursorCheck = proxy.element && source.manager && source.manager.pointerBug;
}, cursor:null, element:null, eventTarget:null, files:null, isNative:false, proxy:null, source:null, target:null, types:null, valid:false, clearData:function(type) {
  Ext.Array.remove(this.types, type);
  delete this.data[type];
}, clone:function() {
  var me = this, ret = new Ext.drag.Info;
  ret.cursor = Ext.merge({}, me.cursor);
  ret.data = Ext.apply({}, me.data);
  ret.element = Ext.merge({}, me.element);
  ret.eventTarget = me.eventTarget;
  ret.proxy = Ext.merge({}, me.proxy);
  ret.source = me.source;
  ret.target = me.target;
  ret.types = Ext.Array.clone(me.types);
  ret.valid = me.valid;
  return ret;
}, getData:function(type) {
  var me = this, data = me.data, dt = me.dataTransfer, ret;
  if (dt) {
    ret = dt.getData(type);
  } else {
    if (!me.finalized) {
      Ext.raise('Unable to call getData until the drop is complete');
    }
    ret = data[type];
    if (typeof ret === 'function') {
      data[type] = ret = ret.call(me.source, me);
    }
    if (!ret && ret !== 0) {
      ret = '';
    }
  }
  return Ext.Promise.resolve(ret);
}, setData:function(type, value) {
  Ext.Array.include(this.types, type);
  this.data[type] = value;
}, destroy:function() {
  var me = this;
  me.eventTarget = me.data = me.proxy = me.targetMap = me.targetMap = me.types = me.elementMap = me.possibleTargets = me.target = null;
  me.callParent();
}, privates:{data:null, dataTransfer:null, elementMap:null, possibleTargets:null, targetMap:null, copyNativeData:function(target, e) {
  var dt = e.browserEvent.dataTransfer;
  this.target = target;
  this.dataTransfer = dt;
  this.files = dt.files;
}, finalize:function() {
  var me = this, target = me.target;
  me.finalized = true;
  if (target) {
    target.info = null;
    target.handleDrop(me);
  }
}, getAlignXY:function(x, y) {
  var me = this, source = me.source, cursorOffset = me.cursor.offset, proxy = source.getProxy(), proxyEl = me.proxy.element, constrain = source.getConstrain(), xy = [x, y];
  if (proxyEl) {
    if (me.proxy.isElement) {
      xy[0] -= cursorOffset.x;
      xy[1] -= cursorOffset.y;
    } else {
      xy = proxy.adjustCursorOffset(me, xy);
    }
    if (constrain) {
      xy = constrain.constrain(xy, me);
    }
  }
  return xy;
}, getEventXY:function(e) {
  var xy = e.getXY(), source = this.source;
  if (this.local) {
    xy = source.convertToLocalXY(xy);
  }
  return xy;
}, onNativeDragEnter:function(target, e) {
  var me = this;
  me.valid = target.accepts(me);
  target.info = me;
  me.copyNativeData(target, e);
}, onNativeDragLeave:function(target, e) {
  var me = this;
  if (me.target === target) {
    target.info = null;
    me.valid = false;
    me.target = me.dataTransfer = me.files = null;
  }
}, onNativeDragMove:function(target, e) {
  this.copyNativeData(target, e);
}, onNativeDrop:function(target, e) {
  this.copyNativeData(target, e);
  target.info = null;
}, setActive:function(target) {
  var me = this, source = me.source, current = me.target, changed = current !== target;
  if (current && changed) {
    current.handleDragLeave(me);
    current.info = null;
  }
  me.target = target;
  if (target) {
    if (changed) {
      me.valid = !!me.possibleTargets[target.getId()] && target.accepts(me) !== false;
      target.handleDragEnter(me);
      target.info = me;
    }
    target.handleDragMove(me);
  } else {
    me.valid = false;
  }
  if (changed) {
    source.getProxy().update(me);
  }
}, update:function(event, beforeStart) {
  var me = this, xy = me.getEventXY(event), x = xy[0], y = xy[1], alignXY = me.getAlignXY(x, y), alignX = alignXY[0], alignY = alignXY[1], proxyData = me.proxy, cursor = me.cursor, current = cursor.current, delta = cursor.delta, initial = cursor.initial, proxy = proxyData.instance;
  current.x = x;
  current.y = y;
  delta.x = x - initial.x;
  delta.y = y - initial.y;
  current = proxyData.current;
  delta = proxyData.delta;
  initial = proxyData.initial;
  current.x = alignX;
  current.y = alignY;
  delta.x = alignX - initial.x;
  delta.y = alignY - initial.y;
  if (me.needsCursorCheck) {
    proxyData.isUnderCursor = !(x < alignX || y < alignY || x > proxyData.width + alignX || y > proxyData.height + alignY);
  }
  if (!beforeStart && proxy) {
    proxy.setXY(me, alignXY);
  }
}}});
Ext.define('Ext.drag.Item', {mixins:[Ext.mixin.Observable, Ext.mixin.Identifiable], config:{autoDestroy:true, component:null, element:null, groups:null}, constructor:function(config) {
  this.mixins.observable.constructor.call(this, config);
}, isDisabled:function() {
  return this.disabled;
}, disable:function() {
  this.disabled = true;
}, enable:function() {
  this.disabled = false;
}, updateComponent:function(comp, was) {
  var el;
  if (comp) {
    el = comp.el;
  } else {
    if (was && was.el === this.getElement()) {
      el = null;
    } else {
      return;
    }
  }
  this.setElement(el);
}, applyElement:function(element) {
  return element ? Ext.get(element) : null;
}, updateElement:function() {
  this.setupListeners();
}, applyGroups:function(group) {
  if (typeof group === 'string') {
    group = [group];
  }
  return group;
}, destroy:function() {
  var me = this, el = me.getElement();
  me.destroying = true;
  me.setElement(null);
  if (el && me.getAutoDestroy()) {
    el.destroy();
  }
  me.callParent();
  me.destroying = false;
}, privates:{disabled:false, convertToLocalXY:function(xy) {
  var c = this.getComponent();
  if (c) {
    xy = c.convertToLocalXY(xy);
  } else {
    xy = this.getElement().translateXY(xy[0], xy[1]);
    xy = [xy.x, xy.y];
  }
  return xy;
}, getElListeners:Ext.privateFn, setupListeners:function(element) {
  var me = this, elListeners = me.elListeners;
  element = element || me.getElement();
  if (elListeners) {
    elListeners.destroy();
    me.elListeners = null;
  }
  if (element) {
    me.elListeners = element.on(Ext.apply({scope:me, destroyable:true}, me.getElListeners()));
  }
}}});
Ext.define('Ext.drag.Source', {extend:Ext.drag.Item, defaultIdPrefix:'source-', config:{activateOnLongPress:false, activeCls:null, constrain:null, handle:null, local:null, proxy:'original', revert:false}, dragging:false, constructor:function(config) {
  var describe = config && config.describe;
  if (describe) {
    this.describe = describe;
    config = Ext.apply({}, config);
    delete config.describe;
  }
  this.callParent([config]);
  this.manager = Ext.drag['Manager'];
}, describe:Ext.emptyFn, isDragging:function() {
  return this.dragging;
}, beforeDragStart:Ext.emptyFn, onDragCancel:Ext.emptyFn, onDragEnd:Ext.emptyFn, onDragMove:Ext.emptyFn, onDragStart:Ext.emptyFn, applyActivateOnLongPress:function(activateOnLongPress) {
  if (typeof activateOnLongPress === 'string') {
    activateOnLongPress = [activateOnLongPress];
  }
  return activateOnLongPress;
}, updateActivateOnLongPress:function(activateOnLongPress) {
  if (!this.isConfiguring) {
    this.setupListeners();
  }
}, updateActiveCls:function(cls, oldCls) {
  if (this.dragging) {
    var el = this.getElement();
    el.replaceCls(oldCls, cls);
  }
}, applyConstrain:function(constrain) {
  if (constrain && !constrain.$isClass) {
    if (constrain.isRegion) {
      constrain = {region:constrain};
    } else {
      if (constrain.isElement || !Ext.isObject(constrain)) {
        constrain = {element:constrain};
      }
    }
    constrain = Ext.apply({source:this}, constrain);
    constrain = Ext.Factory.dragConstraint(constrain);
  }
  return constrain;
}, updateElement:function(element, oldElement) {
  if (oldElement && !oldElement.destroyed) {
    oldElement.un('dragstart', 'stopNativeDrag', this);
  }
  if (element && !this.getHandle()) {
    element.setTouchAction({panX:false, panY:false});
    element.on('dragstart', 'stopNativeDrag', this, {translate:false, delegated:false});
  }
  this.callParent([element, oldElement]);
}, updateHandle:function() {
  if (!this.isConfiguring) {
    this.setupListeners();
  }
}, applyProxy:function(proxy) {
  if (proxy) {
    proxy = Ext.Factory.dragproxy(proxy);
  }
  return proxy;
}, updateProxy:function(proxy, oldProxy) {
  if (oldProxy) {
    oldProxy.destroy();
  }
  if (proxy) {
    proxy.setSource(this);
  }
}, resolveListenerScope:function() {
  var ownerCmp = this.ownerCmp, a = arguments;
  if (ownerCmp) {
    return ownerCmp.resolveListenerScope.apply(ownerCmp, a);
  }
  return this.callParent(a);
}, destroy:function() {
  var me = this;
  me.manager = me.initialEvent = null;
  me.setConstrain(null);
  me.setProxy(null);
  me.callParent();
}, privates:{draggingCls:Ext.baseCSSPrefix + 'drag-dragging', info:null, revertCls:Ext.baseCSSPrefix + 'drag-revert', canActivateOnLongPress:function(e) {
  var activate = this.getActivateOnLongPress();
  return !!(activate && (activate === true || Ext.Array.contains(activate, e.pointerType)));
}, dragCleanup:function(info) {
  var me = this, cls = me.getActiveCls(), proxy = me.getProxy(), el = me.getElement(), proxyEl = info ? info.proxy.element : null;
  if (cls) {
    el.removeCls(cls);
  }
  if (proxyEl) {
    proxyEl.removeCls(me.draggingCls);
  }
  proxy.cleanup(info);
  me.dragging = false;
  me.initialEvent = me.info = null;
}, getElListeners:function() {
  var o = {touchstart:'handleTouchStart', dragstart:'handleDragStart', drag:'handleDragMove', dragend:'handleDragEnd', dragcancel:'handleDragCancel'}, handle = this.getHandle();
  if (handle) {
    o.dragstart = {fn:o.dragstart, delegate:handle};
  }
  if (this.getActivateOnLongPress()) {
    o.longpress = 'handleLongPress';
  }
  return o;
}, handleDragCancel:function(e) {
  var me = this, info = me.info, manager = me.manager;
  if (manager) {
    manager.onDragCancel(info, e);
  }
  me.onDragCancel(info);
  if (me.hasListeners.dragcancel) {
    me.fireEvent('dragcancel', me, info, e);
  }
  Ext.fireEvent('dragcancel', me, info, e);
  me.dragCleanup(info);
}, handleDragEnd:function(e) {
  if (!this.dragging) {
    return;
  }
  var me = this, manager = me.manager, revert = me.getRevert(), info = me.info, proxy = info.proxy;
  info.update(e);
  if (manager) {
    manager.onDragEnd(info, e);
  }
  me.onDragEnd(info);
  if (me.hasListeners.dragend) {
    me.fireEvent('dragend', me, info, e);
  }
  Ext.fireEvent('dragend', me, info, e);
  proxy = proxy.instance;
  if (revert && proxy) {
    proxy.dragRevert(info, me.revertCls, revert, function() {
      me.dragCleanup(info);
    });
  } else {
    me.dragCleanup(info);
  }
}, handleDragMove:function(e) {
  var me = this, info = me.info, manager = me.manager;
  if (!me.dragging) {
    return;
  }
  e.stopPropagation();
  e.claimGesture();
  info.update(e);
  if (manager) {
    manager.onDragMove(info, e);
  }
  me.onDragMove(info);
  if (me.hasListeners.dragmove) {
    me.fireEvent('dragmove', me, info, e);
  }
}, handleDragStart:function(e) {
  var me = this, hasListeners = me.hasListeners, manager = me.manager, constrain = me.getConstrain(), initialEvent = me.initialEvent, el, cls, info, cancel, proxyEl;
  if (me.preventStart(e)) {
    return false;
  }
  if (hasListeners.initdragconstraints) {
    me.fireEvent('initdragconstraints', me, e);
  }
  me.info = info = new Ext.drag.Info(me, initialEvent);
  me.setup(info);
  if (constrain) {
    constrain.onDragStart(info);
  }
  info.update(e, true);
  cancel = me.beforeDragStart(info) === false;
  if (!cancel && hasListeners.beforedragstart) {
    cancel = me.fireEvent('beforedragstart', me, info, e) === false;
  }
  if (cancel) {
    me.dragCleanup();
    return false;
  }
  e.claimGesture();
  me.dragging = true;
  cls = me.getActiveCls();
  el = me.getElement();
  if (cls) {
    el.addCls(cls);
  }
  proxyEl = info.proxy.element;
  if (proxyEl) {
    proxyEl.addCls(me.draggingCls);
  }
  info.update(e);
  if (manager) {
    manager.onDragStart(info, e);
  }
  me.onDragStart(info);
  if (hasListeners.dragstart) {
    me.fireEvent('dragstart', me, info, e);
  }
  Ext.fireEvent('dragstart', me, info, e);
}, handleLongPress:function(e) {
  if (!this.isDisabled() && this.canActivateOnLongPress(e)) {
    this.initialEvent = e;
    e.startDrag();
  }
}, handleTouchStart:function(e) {
  if (!this.isDisabled()) {
    this.initialEvent = e;
  }
}, preventStart:function(e) {
  return this.isDisabled() || !e.longpress && this.canActivateOnLongPress(e);
}, setup:Ext.privateFn, stopNativeDrag:function(e) {
  e.preventDefault();
}}});
Ext.define('Ext.drag.proxy.None', {mixins:[Ext.mixin.Factoryable], alias:'drag.proxy.none', factoryConfig:{aliasPrefix:'drag.proxy.', type:'dragproxy'}, config:{source:null}, constructor:function(config) {
  var getElement = config && config.getElement;
  if (getElement) {
    this.getElement = getElement;
    config = Ext.apply({}, config);
    delete config.getElement;
  }
  this.initConfig(config);
}, cleanup:Ext.emptyFn, dragRevert:function(info, revertCls, options, callback) {
  var positionable = this.getPositionable(info), initial = info.proxy.initial;
  positionable.addCls(revertCls);
  positionable.setXY([initial.x, initial.y], Ext.apply({callback:function() {
    positionable.removeCls(revertCls);
    callback();
  }}, options));
}, getElement:function() {
  return null;
}, getPositionable:function() {
  return this.element;
}, setXY:function(info, xy, animation) {
  var positionable = this.getPositionable(info);
  if (positionable) {
    positionable.setXY(xy, animation);
  }
}, update:Ext.emptyFn, privates:{setupElement:function(info) {
  return this.element = this.getElement(info);
}, adjustCursorOffset:function(info, pos) {
  return pos;
}}});
Ext.define('Ext.drag.proxy.Original', {extend:Ext.drag.proxy.None, alias:'drag.proxy.original', getElement:function(info) {
  return info.source.getElement();
}, getPositionable:function(info) {
  var source = info.source;
  return source.getComponent() || source.getElement();
}});
Ext.define('Ext.event.gesture.Recognizer', {mixins:[Ext.mixin.Identifiable], priority:0, handledEvents:[], isStarted:false, config:{onRecognized:Ext.emptyFn, callbackScope:null}, constructor:function(config) {
  this.initConfig(config);
  Ext.event.publisher.Gesture.instance.registerRecognizer(this);
}, onStart:Ext.emptyFn, onEnd:Ext.emptyFn, onTouchStart:Ext.emptyFn, onTouchMove:Ext.emptyFn, onTouchEnd:function() {
  return this.reset();
}, onTouchCancel:function(e) {
  return this.cancel(e);
}, fire:function(eventName, e, info, isCancel) {
  this.getOnRecognized().call(this.getCallbackScope(), this, eventName, e, info, isCancel);
}, cancel:function(e) {
  if (this.isStarted) {
    this.onCancel(e);
  }
  return this.reset();
}, onCancel:Ext.emptyFn, reset:function() {
  this.isStarted = false;
  return false;
}});
Ext.define('Ext.event.gesture.SingleTouch', {extend:Ext.event.gesture.Recognizer, isSingleTouch:true, onTouchStart:function(e) {
  if (e.touches.length > 1) {
    return this.cancel(e);
  }
}});
Ext.define('Ext.event.gesture.DoubleTap', {extend:Ext.event.gesture.SingleTouch, priority:300, config:{moveDistance:8, tapDistance:24, maxDuration:300}, handledEvents:['singletap', 'doubletap'], singleTapTimer:null, startTime:0, lastTapTime:0, onTouchStart:function(e) {
  var me = this, ret = me.callParent([e]), lastStartPoint;
  if (ret !== false) {
    me.isStarted = true;
    lastStartPoint = me.lastStartPoint = e.changedTouches[0].point;
    me.startPoint = me.startPoint || lastStartPoint;
    me.startTime = e.time;
    Ext.undefer(me.singleTapTimer);
  }
  return ret;
}, onTouchMove:function(e) {
  var me = this, point = e.changedTouches[0].point, scale = Ext.Element.getViewportScale(), distance = Math.round(Math.abs(point.getDistanceTo(me.lastStartPoint) * scale));
  if (distance >= me.getMoveDistance()) {
    return me.cancel(e);
  }
}, onTouchEnd:function(e) {
  var me = this, maxDuration = me.getMaxDuration(), time = e.time, target = e.target, lastTapTime = me.lastTapTime, lastTarget = me.lastTarget, point = e.changedTouches[0].point, duration, scale, distance;
  me.lastTapTime = time;
  me.lastTarget = target;
  if (lastTapTime) {
    duration = time - lastTapTime;
    if (duration <= maxDuration) {
      scale = Ext.Element.getViewportScale();
      distance = Math.round(Math.abs(point.getDistanceTo(me.startPoint) * scale));
      if (distance <= me.getTapDistance()) {
        if (target !== lastTarget) {
          return me.cancel(e);
        }
        me.lastTarget = null;
        me.lastTapTime = 0;
        me.fire('doubletap', e, {touch:e.changedTouches[0], duration:duration});
        return me.callParent([e]);
      }
    }
  }
  if (time - me.startTime > maxDuration) {
    me.fire('singletap', e);
    me.reset();
  } else {
    me.setSingleTapTimer(e);
  }
}, setSingleTapTimer:function(e) {
  var me = this;
  me.singleTapTimer = Ext.defer(function() {
    me.fire('singletap', e);
    me.reset();
  }, me.getMaxDuration());
}, reset:function() {
  var me = this;
  Ext.undefer(me.singleTapTimer);
  me.startTime = me.lastTapTime = 0;
  me.lastStartPoint = me.startPoint = me.singleTapTimer = null;
  return me.callParent();
}}, function(DoubleTap) {
  var gestures = Ext.manifest.gestures;
  DoubleTap.instance = new DoubleTap(gestures && gestures.doubleTap);
});
Ext.define('Ext.event.gesture.Drag', {extend:Ext.event.gesture.SingleTouch, priority:100, startPoint:null, previousPoint:null, lastPoint:null, handledEvents:['dragstart', 'drag', 'dragend', 'dragcancel'], config:{minDistance:8}, constructor:function() {
  this.callParent(arguments);
  this.initInfo();
}, initInfo:function() {
  this.info = {touch:null, previous:{x:0, y:0}, x:0, y:0, delta:{x:0, y:0}, absDelta:{x:0, y:0}, flick:{velocity:{x:0, y:0}}, direction:{x:0, y:0}, time:0, previousTime:{x:0, y:0}, longpress:false};
}, onTouchStart:function(e) {
  var me = this, ret = me.callParent([e]);
  if (ret !== false) {
    me.startTime = e.time;
    me.startPoint = e.changedTouches[0].point;
  }
  return ret;
}, tryDragStart:function(e) {
  var me = this, point = e.changedTouches[0].point, minDistance = me.getMinDistance(), scale = Ext.Element.getViewportScale(), distance = Math.round(Math.abs(point.getDistanceTo(me.startPoint) * scale));
  if (distance >= minDistance) {
    me.doDragStart(e);
  }
}, doDragStart:function(e, isLongPress) {
  var me = this, touch = e.changedTouches[0], point = touch.point, info = me.info, time;
  if (isLongPress) {
    time = Ext.now();
    me.startTime = time;
    me.startPoint = point;
    info.longpress = true;
  } else {
    time = e.time;
  }
  me.isStarted = true;
  me.previousPoint = me.lastPoint = point;
  me.resetInfo('x', e, touch);
  me.resetInfo('y', e, touch);
  info.time = time;
  me.fire('dragstart', e, info);
}, onTouchMove:function(e) {
  var me = this, touch, point;
  if (!me.startPoint) {
    return;
  }
  if (!me.isStarted) {
    me.tryDragStart(e);
  }
  if (!me.isStarted) {
    return;
  }
  touch = e.changedTouches[0];
  point = touch.point;
  if (me.lastPoint) {
    me.previousPoint = me.lastPoint;
  }
  me.lastPoint = point;
  me.lastMoveEvent = e;
  me.updateInfo('x', e, touch);
  me.updateInfo('y', e, touch);
  me.info.time = e.time;
  me.fire('drag', e, me.info);
}, onAxisDragEnd:function(axis, info) {
  var duration = info.time - info.previousTime[axis];
  if (duration > 0) {
    info.flick.velocity[axis] = (info[axis] - info.previous[axis]) / duration;
  }
}, resetInfo:function(axis, e, touch) {
  var me = this, value = me.lastPoint[axis], startValue = me.startPoint[axis], delta = value - startValue, capAxis = axis.toUpperCase(), info = me.info;
  info.touch = touch;
  info.delta[axis] = delta;
  info.absDelta[axis] = Math.abs(delta);
  info.previousTime[axis] = me.startTime;
  info.previous[axis] = startValue;
  info[axis] = value;
  info.direction[axis] = 0;
  info['start' + capAxis] = me.startPoint[axis];
  info['previous' + capAxis] = info.previous[axis];
  info['page' + capAxis] = info[axis];
  info['delta' + capAxis] = info.delta[axis];
  info['absDelta' + capAxis] = info.absDelta[axis];
  info['previousDelta' + capAxis] = 0;
  info.startTime = me.startTime;
}, updateInfo:function(axis, e, touch) {
  var me = this, value = me.lastPoint[axis], previousValue = me.previousPoint[axis], startValue = me.startPoint[axis], delta = value - startValue, info = me.info, direction = info.direction, capAxis = axis.toUpperCase(), previousFlick = info.previous[axis];
  info.touch = touch;
  info.delta[axis] = delta;
  info.absDelta[axis] = Math.abs(delta);
  if (value !== previousFlick && value !== info[axis]) {
    info.previous[axis] = info[axis];
    info.previousTime[axis] = info.time;
  }
  info[axis] = value;
  if (value > previousValue) {
    direction[axis] = 1;
  } else {
    if (value < previousValue) {
      direction[axis] = -1;
    }
  }
  info['start' + capAxis] = startValue;
  info['previous' + capAxis] = info.previous[axis];
  info['page' + capAxis] = info[axis];
  info['delta' + capAxis] = info.delta[axis];
  info['absDelta' + capAxis] = info.absDelta[axis];
  info['previousDelta' + capAxis] = info.previous[axis] - startValue;
  info.startTime = me.startTime;
}, onTouchEnd:function(e) {
  var me = this, touch, point, info;
  if (me.isStarted) {
    touch = e.changedTouches[0];
    point = touch.point;
    info = me.info;
    me.lastPoint = point;
    me.updateInfo('x', e, touch);
    me.updateInfo('y', e, touch);
    info.time = e.time;
    me.onAxisDragEnd('x', info);
    me.onAxisDragEnd('y', info);
    me.fire('dragend', e, info);
  }
  return this.callParent([e]);
}, onCancel:function(e) {
  var me = this, touch = e.changedTouches[0], info = me.info;
  if (!e.touches.length) {
    me.lastPoint = touch.point;
  }
  me.updateInfo('x', e, touch);
  me.updateInfo('y', e, touch);
  info.time = e.time;
  me.fire('dragcancel', e, info, true);
}, reset:function() {
  var me = this;
  me.lastPoint = me.startPoint = me.previousPoint = me.lastPoint = me.lastMoveEvent = null;
  me.initInfo();
  return me.callParent();
}}, function(Drag) {
  var gestures = Ext.manifest.gestures;
  Drag.instance = new Drag(gestures && gestures.drag);
});
Ext.define('Ext.event.gesture.Swipe', {extend:Ext.event.gesture.SingleTouch, priority:600, handledEvents:['swipestart', 'swipe', 'swipecancel'], config:{minDistance:80, maxOffset:35, maxDuration:1000}, onTouchStart:function(e) {
  var me = this, ret = me.callParent([e]), touch;
  if (ret !== false) {
    touch = e.changedTouches[0];
    me.startTime = e.time;
    me.isHorizontal = true;
    me.isVertical = true;
    me.startX = touch.pageX;
    me.startY = touch.pageY;
  }
  return ret;
}, onTouchMove:function(e) {
  var me = this, touch = e.changedTouches[0], x = touch.pageX, y = touch.pageY, deltaX = x - me.startX, deltaY = y - me.startY, absDeltaX = Math.abs(x - me.startX), absDeltaY = Math.abs(y - me.startY), duration = e.time - me.startTime, minDistance, direction, distance;
  if (absDeltaX === 0 && absDeltaY === 0 || duration > me.getMaxDuration()) {
    return me.cancel(e);
  }
  if (me.isHorizontal && absDeltaY > me.getMaxOffset()) {
    me.isHorizontal = false;
  }
  if (me.isVertical && absDeltaX > me.getMaxOffset()) {
    me.isVertical = false;
  }
  if (!me.isVertical || !me.isHorizontal) {
    minDistance = me.getMinDistance();
    if (me.isHorizontal && absDeltaX < minDistance) {
      direction = deltaX < 0 ? 'left' : 'right';
      distance = absDeltaX;
    } else {
      if (me.isVertical && absDeltaY < minDistance) {
        direction = deltaY < 0 ? 'up' : 'down';
        distance = absDeltaY;
      }
    }
  }
  if (!me.isHorizontal && !me.isVertical) {
    return me.cancel(e);
  }
  if (direction && !me.isStarted) {
    me.isStarted = true;
    me.fire('swipestart', e, {touch:touch, direction:direction, distance:distance, duration:duration});
  }
}, onTouchEnd:function(e) {
  var me = this, touch, x, y, deltaX, deltaY, absDeltaX, absDeltaY, minDistance, duration, direction, distance;
  if (me.onTouchMove(e) !== false) {
    touch = e.changedTouches[0];
    x = touch.pageX;
    y = touch.pageY;
    deltaX = x - me.startX;
    deltaY = y - me.startY;
    absDeltaX = Math.abs(deltaX);
    absDeltaY = Math.abs(deltaY);
    minDistance = me.getMinDistance();
    duration = e.time - me.startTime;
    if (me.isVertical && absDeltaY < minDistance) {
      me.isVertical = false;
    }
    if (me.isHorizontal && absDeltaX < minDistance) {
      me.isHorizontal = false;
    }
    if (me.isHorizontal) {
      direction = deltaX < 0 ? 'left' : 'right';
      distance = absDeltaX;
    } else {
      if (me.isVertical) {
        direction = deltaY < 0 ? 'up' : 'down';
        distance = absDeltaY;
      }
    }
    me.fire('swipe', e, {touch:touch, direction:direction, distance:distance, duration:duration});
  }
  return this.callParent([e]);
}, onCancel:function(e) {
  this.fire('swipecancel', e, null, true);
}, reset:function() {
  var me = this;
  me.startTime = me.isHorizontal = me.isVertical = me.startX = me.startY = null;
  return me.callParent();
}}, function(Swipe) {
  var gestures = Ext.manifest.gestures;
  Swipe.instance = new Swipe(gestures && gestures.swipe);
});
Ext.define('Ext.event.gesture.EdgeSwipe', {extend:Ext.event.gesture.Swipe, priority:500, handledEvents:['edgeswipe', 'edgeswipestart', 'edgeswipeend', 'edgeswipecancel'], config:{minDistance:60}, onTouchStart:function(e) {
  var me = this, ret = me.callParent([e]), touch;
  if (ret !== false) {
    touch = e.changedTouches[0];
    me.direction = null;
    me.isHorizontal = true;
    me.isVertical = true;
    me.startX = touch.pageX;
    me.startY = touch.pageY;
  }
  return ret;
}, onTouchMove:function(e) {
  var me = this, touch = e.changedTouches[0], x = touch.pageX, y = touch.pageY, deltaX = x - me.startX, deltaY = y - me.startY, absDeltaY = Math.abs(y - me.startY), absDeltaX = Math.abs(x - me.startX), minDistance = me.getMinDistance(), maxOffset = me.getMaxOffset(), duration = e.time - me.startTime, elementWidth = Ext.Viewport && Ext.Element.getViewportWidth(), elementHeight = Ext.Viewport && Ext.Element.getViewportHeight(), direction, distance;
  if (me.isVertical && absDeltaX > maxOffset) {
    me.isVertical = false;
  }
  if (me.isHorizontal && absDeltaY > maxOffset) {
    me.isHorizontal = false;
  }
  if (me.isVertical && me.isHorizontal) {
    if (absDeltaY > absDeltaX) {
      me.isHorizontal = false;
    } else {
      me.isVertical = false;
    }
  }
  if (me.isHorizontal) {
    direction = deltaX < 0 ? 'left' : 'right';
    distance = deltaX;
  } else {
    if (me.isVertical) {
      direction = deltaY < 0 ? 'up' : 'down';
      distance = deltaY;
    }
  }
  direction = me.direction || (me.direction = direction);
  if (direction === 'up') {
    distance = deltaY * -1;
  } else {
    if (direction === 'left') {
      distance = deltaX * -1;
    }
  }
  me.distance = distance;
  if (!distance) {
    return me.cancel(e);
  }
  if (!me.isStarted) {
    if (direction === 'right' && me.startX > minDistance || direction === 'down' && me.startY > minDistance || direction === 'left' && elementWidth - me.startX > minDistance || direction === 'up' && elementHeight - me.startY > minDistance) {
      return me.cancel(e);
    }
    me.isStarted = true;
    me.startTime = e.time;
    me.fire('edgeswipestart', e, {touch:touch, direction:direction, distance:distance, duration:duration});
  } else {
    me.fire('edgeswipe', e, {touch:touch, direction:direction, distance:distance, duration:duration});
  }
}, onTouchEnd:function(e) {
  var me = this, duration;
  if (me.onTouchMove(e) !== false) {
    duration = e.time - me.startTime;
    me.fire('edgeswipeend', e, {touch:e.changedTouches[0], direction:me.direction, distance:me.distance, duration:duration});
  }
  return this.reset();
}, onCancel:function(e) {
  this.fire('edgeswipecancel', e, {touch:e.changedTouches[0]}, true);
}, reset:function() {
  var me = this;
  me.direction = me.isHorizontal = me.isVertical = me.startX = me.startY = me.startTime = me.distance = null;
  return me.callParent();
}}, function(EdgeSwipe) {
  var gestures = Ext.manifest.gestures;
  EdgeSwipe.instance = new EdgeSwipe(gestures && gestures.edgeSwipe);
});
Ext.define('Ext.event.gesture.LongPress', {extend:Ext.event.gesture.SingleTouch, priority:400, config:{moveDistance:8, minDuration:1000}, handledEvents:['longpress', 'taphold'], onTouchStart:function(e) {
  var me = this, ret = me.callParent([e]);
  if (ret !== false) {
    me.startPoint = e.changedTouches[0].point;
    me.setLongPressTimer(e);
  }
  return ret;
}, setLongPressTimer:function(e) {
  var me = this;
  Ext.undefer(me.timer);
  me.timer = Ext.defer(me.fireLongPress, me.getMinDuration(), me, [e]);
}, onTouchMove:function(e) {
  var me = this, point = e.changedTouches[0].point, scale = Ext.Element.getViewportScale(), distance = Math.round(Math.abs(point.getDistanceTo(me.startPoint) * scale));
  if (distance >= me.getMoveDistance()) {
    return me.cancel(e);
  }
}, reset:function() {
  var me = this;
  me.timer = me.startPoint = Ext.undefer(me.timer);
  return me.callParent();
}, fireLongPress:function(e) {
  var me = this, info = {touch:e.changedTouches[0], duration:me.getMinDuration(), startDrag:me.startDrag};
  this.fire('taphold', e, info);
  this.fire('longpress', e, info);
  this.reset();
}, startDrag:function() {
  var dragRecognizer = Ext.event.gesture.Drag.instance, touchStartEvent = this.parentEvent;
  dragRecognizer.doDragStart(touchStartEvent, true);
  Ext.event.publisher.Gesture.instance.claimRecognizer(dragRecognizer, touchStartEvent);
}}, function(LongPress) {
  var gestures = Ext.manifest.gestures;
  LongPress.instance = new LongPress(gestures && gestures.longPress);
});
Ext.define('Ext.event.gesture.MultiTouch', {extend:Ext.event.gesture.Recognizer, requiredTouchesCount:2, isTracking:false, isMultiTouch:true, onTouchStart:function(e) {
  var me = this, requiredTouchesCount = me.requiredTouchesCount, touches = e.touches, touchesCount = touches.length;
  if (touchesCount === requiredTouchesCount) {
    me.isTracking = true;
  } else {
    if (touchesCount > requiredTouchesCount) {
      return me.cancel(e);
    }
  }
}, reset:function() {
  this.isTracking = false;
  return this.callParent();
}});
Ext.define('Ext.event.gesture.Pinch', {extend:Ext.event.gesture.MultiTouch, priority:700, handledEvents:['pinchstart', 'pinch', 'pinchend', 'pinchcancel'], startDistance:0, lastTouches:null, onTouchMove:function(e) {
  var me = this, touches, firstPoint, secondPoint, distance;
  if (me.isTracking) {
    touches = e.touches;
    firstPoint = touches[0].point;
    secondPoint = touches[1].point;
    distance = firstPoint.getDistanceTo(secondPoint);
    if (distance === 0) {
      return;
    }
    if (!me.isStarted) {
      me.isStarted = true;
      me.startDistance = distance;
      me.fire('pinchstart', e, {touches:touches, distance:distance, scale:1});
    } else {
      me.fire('pinch', e, {touches:touches, distance:distance, scale:distance / me.startDistance});
    }
  }
}, onTouchEnd:function(e) {
  if (this.isStarted) {
    this.fire('pinchend', e);
  }
  return this.callParent([e]);
}, onCancel:function(e) {
  this.fire('pinchcancel', e, null, true);
}, reset:function() {
  this.lastTouches = null;
  this.startDistance = 0;
  return this.callParent();
}}, function(Pinch) {
  var gestures = Ext.manifest.gestures;
  Pinch.instance = new Pinch(gestures && gestures.pinch);
});
Ext.define('Ext.event.gesture.Rotate', {extend:Ext.event.gesture.MultiTouch, priority:800, handledEvents:['rotatestart', 'rotate', 'rotateend', 'rotatecancel'], startAngle:0, lastTouches:null, lastAngle:null, onTouchMove:function(e) {
  var me = this, touches, lastAngle, firstPoint, secondPoint, angle, nextAngle, previousAngle, diff;
  if (me.isTracking) {
    touches = e.touches;
    lastAngle = me.lastAngle;
    firstPoint = touches[0].point;
    secondPoint = touches[1].point;
    angle = firstPoint.getAngleTo(secondPoint);
    if (lastAngle !== null) {
      diff = Math.abs(lastAngle - angle);
      nextAngle = angle + 360;
      previousAngle = angle - 360;
      if (Math.abs(nextAngle - lastAngle) < diff) {
        angle = nextAngle;
      } else {
        if (Math.abs(previousAngle - lastAngle) < diff) {
          angle = previousAngle;
        }
      }
    }
    me.lastAngle = angle;
    if (!me.isStarted) {
      me.isStarted = true;
      me.startAngle = angle;
      me.fire('rotatestart', e, {touches:touches, angle:angle, rotation:0});
    } else {
      me.fire('rotate', e, {touches:touches, angle:angle, rotation:angle - me.startAngle});
    }
    me.lastTouches = Ext.Array.clone(touches);
  }
}, onTouchEnd:function(e) {
  if (this.isStarted) {
    this.fire('rotateend', e);
  }
  return this.callParent([e]);
}, onCancel:function(e) {
  this.fire('rotatecancel', e, null, true);
}, reset:function() {
  var me = this;
  me.lastTouches = me.lastAngle = me.startAngle = null;
  return this.callParent();
}}, function(Rotate) {
  var gestures = Ext.manifest.gestures;
  Rotate.instance = new Rotate(gestures && gestures.rotate);
});
Ext.define('Ext.event.gesture.Tap', {extend:Ext.event.gesture.SingleTouch, priority:200, handledEvents:['tap', 'tapcancel'], config:{moveDistance:8}, onTouchStart:function(e) {
  var me = this, ret = me.callParent([e]);
  if (ret !== false) {
    me.isStarted = true;
    me.startPoint = e.changedTouches[0].point;
  }
  return ret;
}, onTouchMove:function(e) {
  var me = this, point = e.changedTouches[0].point, scale = Ext.Element.getViewportScale(), distance = Math.round(Math.abs(point.getDistanceTo(me.startPoint) * scale));
  if (distance >= me.getMoveDistance()) {
    return me.cancel(e);
  }
}, onTouchEnd:function(e) {
  this.fire('tap', e, {touch:e.changedTouches[0]});
  return this.callParent([e]);
}, onCancel:function(e) {
  this.fire('tapcancel', e, {touch:e.changedTouches[0]}, true);
}, reset:function() {
  this.startPoint = null;
  return this.callParent();
}}, function(Tap) {
  var gestures = Ext.manifest.gestures;
  Tap.instance = new Tap(gestures && gestures.tap);
});
Ext.define('Ext.event.publisher.Focus', {extend:Ext.event.publisher.Dom, type:'focus', handledEvents:['focusenter', 'focusleave', 'focusmove'], handledDomEvents:['focusin', 'focusout'], publishDelegatedDomEvent:function(e) {
  var me = this, relatedTarget = e.relatedTarget;
  if (me.$suppressEvents) {
    return;
  }
  if (e.type === 'focusout') {
    if (relatedTarget == null) {
      me.processFocusIn(e, e.target, document.body);
    }
  } else {
    if (relatedTarget == null || !relatedTarget.tagName) {
      relatedTarget = document.body;
    }
    me.processFocusIn(e, relatedTarget, e.target);
  }
}, processFocusIn:function(e, fromElement, toElement) {
  var me = this, commonAncestor, node, targets = [], focusFly = me.focusFly, backwards, event, focusEnterEvent;
  if (fromElement && focusFly.attach(fromElement).isFocusSuspended() || toElement && focusFly.attach(toElement).isFocusSuspended()) {
    return;
  }
  if (toElement.compareDocumentPosition) {
    backwards = !!(toElement.compareDocumentPosition(fromElement) & 4);
  }
  for (node = fromElement, commonAncestor = Ext.dom.Element.getCommonAncestor(toElement, fromElement, true); node && node !== commonAncestor; node = node.parentNode) {
    targets.push(node);
  }
  if (targets.length) {
    event = me.createSyntheticEvent('focusleave', e, fromElement, toElement, fromElement, toElement, backwards);
    me.publish(event, targets);
    if (event.stopped) {
      return;
    }
  }
  targets.length = 0;
  for (node = toElement; node && node !== commonAncestor; node = node.parentNode) {
    targets.push(node);
  }
  focusEnterEvent = me.createSyntheticEvent('focusenter', e, toElement, fromElement, fromElement, toElement, backwards);
  if (targets.length) {
    me.publish(focusEnterEvent, targets);
    if (focusEnterEvent.stopped) {
      return;
    }
  }
  targets = me.getPropagatingTargets(commonAncestor);
  if (targets.length) {
    event = me.createSyntheticEvent('focusmove', e, toElement, fromElement, fromElement, toElement, backwards);
    me.publish(event, targets);
    if (event.stopped) {
      return;
    }
  }
  if (Ext.GlobalEvents.hasListeners.focus) {
    Ext.GlobalEvents.fireEvent('focus', {event:focusEnterEvent, toElement:toElement, fromElement:fromElement, backwards:backwards});
  }
}, createSyntheticEvent:function(eventName, browserEvent, target, relatedTarget, fromElement, toElement, backwards) {
  var event = new Ext.event.Event(browserEvent);
  event.type = eventName;
  event.relatedTarget = relatedTarget;
  event.target = target;
  event.fromElement = fromElement;
  event.toElement = toElement;
  event.backwards = backwards;
  return event;
}}, function(Focus) {
  var focusTimeout;
  Focus.prototype.focusFly = new Ext.dom.Fly;
  Focus.instance = new Focus;
  if (!Ext.supports.FocusinFocusoutEvents) {
    this.override({handledDomEvents:['focus', 'blur'], publishDelegatedDomEvent:function(e) {
      var me = this, targetIsElement;
      me.callSuper([e]);
      targetIsElement = e.target !== window && e.target !== document;
      if (e.type === 'blur') {
        if (!targetIsElement) {
          if (e.explicitOriginalTarget === Focus.previousActiveElement) {
            if (e.target === window) {
              Ext.undefer(focusTimeout);
              focusTimeout = 0;
              me.processFocusIn(e, Focus.previousActiveElement, document.body);
              Focus.previousActiveElement = null;
            }
          }
        } else {
          focusTimeout = Ext.defer(function() {
            focusTimeout = 0;
            me.processFocusIn(e, e.target, document.body);
            Focus.previousActiveElement = null;
          }, 1);
          if (targetIsElement && Ext.cache[e.target.id]) {
            Ext.cache[e.target.id].focusinTimeout = focusTimeout;
          }
        }
        Focus.previousActiveElement = targetIsElement ? e.target : null;
      } else {
        Ext.undefer(focusTimeout);
        focusTimeout = 0;
        me.processFocusIn(e, Focus.previousActiveElement || document.body, targetIsElement ? e.target : document.body);
      }
    }});
    Ext.define(null, {override:'Ext.dom.Element', destroy:function() {
      if (this.focusinTimeout) {
        Ext.undefer(this.focusinTimeout);
        this.focusinTimeout = null;
      }
      this.callParent();
    }});
  }
});
Ext.define('Ext.fx.runner.Css', {extend:Ext.Evented, prefixedProperties:{'transform':true, 'transform-origin':true, 'perspective':true, 'transform-style':true, 'transition':true, 'transition-property':true, 'transition-duration':true, 'transition-timing-function':true, 'transition-delay':true, 'animation':true, 'animation-name':true, 'animation-duration':true, 'animation-iteration-count':true, 'animation-direction':true, 'animation-timing-function':true, 'animation-delay':true}, lengthProperties:{'top':true, 
'right':true, 'bottom':true, 'left':true, 'width':true, 'height':true, 'max-height':true, 'max-width':true, 'min-height':true, 'min-width':true, 'margin-bottom':true, 'margin-left':true, 'margin-right':true, 'margin-top':true, 'padding-bottom':true, 'padding-left':true, 'padding-right':true, 'padding-top':true, 'border-bottom-width':true, 'border-left-width':true, 'border-right-width':true, 'border-spacing':true, 'border-top-width':true, 'border-width':true, 'outline-width':true, 'letter-spacing':true, 
'line-height':true, 'text-indent':true, 'word-spacing':true, 'font-size':true, 'translate':true, 'translateX':true, 'translateY':true, 'translateZ':true, 'translate3d':true, 'x':true, 'y':true}, durationProperties:{'transition-duration':true, 'transition-delay':true, 'animation-duration':true, 'animation-delay':true}, angleProperties:{rotate:true, rotateX:true, rotateY:true, rotateZ:true, skew:true, skewX:true, skewY:true}, DEFAULT_UNIT_LENGTH:'px', DEFAULT_UNIT_ANGLE:'deg', DEFAULT_UNIT_DURATION:'ms', 
customProperties:{x:true, y:true}, formattedNameCache:{'x':'left', 'y':'top'}, transformMethods3d:['translateX', 'translateY', 'translateZ', 'rotate', 'rotateX', 'rotateY', 'rotateZ', 'skewX', 'skewY', 'scaleX', 'scaleY', 'scaleZ'], transformMethodsNo3d:['translateX', 'translateY', 'rotate', 'skewX', 'skewY', 'scaleX', 'scaleY'], constructor:function() {
  var me = this;
  me.transformMethods = Ext.feature.has.Css3dTransforms ? me.transformMethods3d : me.transformMethodsNo3d;
  me.vendorPrefix = Ext.browser.getStyleDashPrefix();
  me.ruleStylesCache = {};
  me.callParent();
}, getStyleSheet:function() {
  var styleSheet = this.styleSheet, styleElement, styleSheets;
  if (!styleSheet) {
    styleElement = document.createElement('style');
    styleElement.type = 'text/css';
    (document.head || document.getElementsByTagName('head')[0]).appendChild(styleElement);
    styleSheets = document.styleSheets;
    this.styleSheet = styleSheet = styleSheets[styleSheets.length - 1];
  }
  return styleSheet;
}, applyRules:function(selectors) {
  var styleSheet = this.getStyleSheet(), ruleStylesCache = this.ruleStylesCache, rules = styleSheet.cssRules, selector, properties, ruleStyle, ruleStyleCache, rulesLength, name, value;
  for (selector in selectors) {
    properties = selectors[selector];
    ruleStyle = ruleStylesCache[selector];
    if (ruleStyle === undefined) {
      rulesLength = rules.length;
      styleSheet.insertRule(selector + '{}', rulesLength);
      ruleStyle = ruleStylesCache[selector] = rules.item(rulesLength).style;
    }
    ruleStyleCache = ruleStyle.$cache;
    if (!ruleStyleCache) {
      ruleStyleCache = ruleStyle.$cache = {};
    }
    for (name in properties) {
      value = this.formatValue(properties[name], name);
      name = this.formatName(name);
      if (ruleStyleCache[name] !== value) {
        ruleStyleCache[name] = value;
        if (value === null) {
          ruleStyle.removeProperty(name);
        } else {
          ruleStyle.setProperty(name, value);
        }
      }
    }
  }
  return this;
}, applyStyles:function(styles) {
  var id, element, elementStyle, properties, name, value;
  for (id in styles) {
    if (styles.hasOwnProperty(id)) {
      this.activeElement = element = document.getElementById(id);
      if (!element) {
        continue;
      }
      elementStyle = element.style;
      properties = styles[id];
      for (name in properties) {
        if (properties.hasOwnProperty(name)) {
          value = this.formatValue(properties[name], name);
          name = this.formatName(name);
          if (value === null) {
            elementStyle.removeProperty(name);
          } else {
            elementStyle.setProperty(name, value);
          }
        }
      }
    }
  }
  this.activeElement = null;
  return this;
}, formatName:function(name) {
  var cache = this.formattedNameCache, formattedName = cache[name];
  if (!formattedName) {
    if ((Ext.os.is.Tizen || !Ext.feature.has.CssTransformNoPrefix) && this.prefixedProperties[name]) {
      formattedName = this.vendorPrefix + name;
    } else {
      formattedName = name;
    }
    cache[name] = formattedName;
  }
  return formattedName;
}, formatValue:function(value, name) {
  var type = typeof value, defaultLengthUnit = this.DEFAULT_UNIT_LENGTH, isCustom = this.customProperties[name], transformMethods, method, i, ln, transformValues, values;
  if (value === null) {
    return '';
  }
  if (type === 'string') {
    if (this.lengthProperties[name]) {
      if (!Ext.dom.Element.hasUnit(value)) {
        value = value + defaultLengthUnit;
        if (isCustom) {
          value = this.getCustomValue(value, name);
        }
      }
    }
    return value;
  } else {
    if (type === 'number') {
      if (value === 0) {
        return '0';
      }
      if (this.lengthProperties[name]) {
        value = value + defaultLengthUnit;
        if (isCustom) {
          value = this.getCustomValue(value, name);
        }
        return value;
      }
      if (this.angleProperties[name]) {
        return value + this.DEFAULT_UNIT_ANGLE;
      }
      if (this.durationProperties[name]) {
        return value + this.DEFAULT_UNIT_DURATION;
      }
    } else {
      if (name === 'transform') {
        transformMethods = this.transformMethods;
        transformValues = [];
        for (i = 0, ln = transformMethods.length; i < ln; i++) {
          method = transformMethods[i];
          transformValues.push(method + '(' + this.formatValue(value[method], method) + ')');
        }
        return transformValues.join(' ');
      } else {
        if (Ext.isArray(value)) {
          values = [];
          for (i = 0, ln = value.length; i < ln; i++) {
            values.push(this.formatValue(value[i], name));
          }
          return values.length > 0 ? values.join(', ') : 'none';
        }
      }
    }
  }
  return value;
}, getCustomValue:function(value, name) {
  var el = Ext.fly(this.activeElement);
  if (name === 'x') {
    value = el.translateXY(parseInt(value, 10)).x;
  } else {
    if (name === 'y') {
      value = el.translateXY(null, parseInt(value, 10)).y;
    }
  }
  return value + this.DEFAULT_UNIT_LENGTH;
}});
Ext.define('Ext.fx.runner.CssTransition', {extend:Ext.fx.runner.Css, alternateClassName:'Ext.Animator', singleton:true, listenersAttached:false, constructor:function() {
  this.runningAnimationsData = {};
  this.transitionQueue = {toData:{}, transitionData:{}};
  return this.callParent(arguments);
}, attachListeners:function() {
  this.listenersAttached = true;
  Ext.getWin().on('transitionend', 'onTransitionEnd', this);
}, onTransitionEnd:function(e) {
  var target = e.target, id = target.id;
  if (id && this.runningAnimationsData.hasOwnProperty(id)) {
    this.refreshRunningAnimationsData(Ext.get(target), [e.browserEvent.propertyName]);
  }
}, getElementId:function(element) {
  return element.getId ? element.getId() : element.id;
}, onAnimationEnd:function(element, data, animation, isInterrupted, isReplaced) {
  var id = this.getElementId(element), runningData = this.runningAnimationsData[id], endRules = {}, endData = {}, runningNameMap, toPropertyNames, i, ln, name;
  animation.un('stop', 'onAnimationStop', this);
  if (runningData) {
    runningNameMap = runningData.nameMap;
  }
  endRules[id] = endData;
  if (data.onBeforeEnd) {
    data.onBeforeEnd.call(data.scope || this, element, isInterrupted);
  }
  animation.fireEvent('animationbeforeend', animation, element, isInterrupted);
  this.fireEvent('animationbeforeend', this, animation, element, isInterrupted);
  if (isReplaced || !isInterrupted && !data.preserveEndState) {
    toPropertyNames = data.toPropertyNames;
    for (i = 0, ln = toPropertyNames.length; i < ln; i++) {
      name = toPropertyNames[i];
      if (runningNameMap && !runningNameMap.hasOwnProperty(name)) {
        endData[name] = null;
      }
    }
  }
  if (data.after) {
    Ext.merge(endData, data.after);
  }
  this.applyStyles(endRules);
  if (data.onEnd) {
    data.onEnd.call(data.scope || this, element, isInterrupted);
  }
  animation.fireEvent('animationend', animation, element, isInterrupted);
  this.fireEvent('animationend', this, animation, element, isInterrupted);
  Ext.AnimationQueue.stop(Ext.emptyFn, animation);
}, onAllAnimationsEnd:function(element) {
  var id = this.getElementId(element), transitionQueue = this.transitionQueue, endRules = {};
  delete this.runningAnimationsData[id];
  endRules[id] = {'transition-property':null, 'transition-duration':null, 'transition-timing-function':null, 'transition-delay':null};
  delete transitionQueue.toData[id];
  delete transitionQueue.transitionData[id];
  this.applyStyles(endRules);
  this.fireEvent('animationallend', this, element);
}, hasRunningAnimations:function(element) {
  var id = this.getElementId(element), runningAnimationsData = this.runningAnimationsData;
  return runningAnimationsData.hasOwnProperty(id) && runningAnimationsData[id].sessions.length > 0;
}, refreshRunningAnimationsData:function(element, propertyNames, interrupt, replace) {
  var id = this.getElementId(element), runningAnimationsData = this.runningAnimationsData, runningData = runningAnimationsData[id];
  if (!runningData) {
    return;
  }
  var nameMap = runningData.nameMap, nameList = runningData.nameList, sessions = runningData.sessions, ln, j, subLn, name, i, session, map, list, hasCompletedSession = false;
  interrupt = Boolean(interrupt);
  replace = Boolean(replace);
  if (!sessions) {
    return this;
  }
  ln = sessions.length;
  if (ln === 0) {
    return this;
  }
  if (replace) {
    runningData.nameMap = {};
    nameList.length = 0;
    for (i = 0; i < ln; i++) {
      session = sessions[i];
      this.onAnimationEnd(element, session.data, session.animation, interrupt, replace);
    }
    sessions.length = 0;
  } else {
    for (i = 0; i < ln; i++) {
      session = sessions[i];
      map = session.map;
      list = session.list;
      for (j = 0, subLn = propertyNames.length; j < subLn; j++) {
        name = propertyNames[j];
        if (map[name]) {
          delete map[name];
          Ext.Array.remove(list, name);
          session.length--;
          if (--nameMap[name] == 0) {
            delete nameMap[name];
            Ext.Array.remove(nameList, name);
          }
        }
      }
      if (session.length == 0) {
        sessions.splice(i, 1);
        i--;
        ln--;
        hasCompletedSession = true;
        this.onAnimationEnd(element, session.data, session.animation, interrupt);
      }
    }
  }
  if (!replace && !interrupt && sessions.length == 0 && hasCompletedSession) {
    this.onAllAnimationsEnd(element);
  }
}, getRunningData:function(id) {
  var runningAnimationsData = this.runningAnimationsData;
  if (!runningAnimationsData.hasOwnProperty(id)) {
    runningAnimationsData[id] = {nameMap:{}, nameList:[], sessions:[]};
  }
  return runningAnimationsData[id];
}, getTestElement:function() {
  var me = this, testElement = me.testElement, iframe = me.iframe, iframeDocument, iframeStyle;
  if (testElement) {
    if (testElement.ownerDocument.defaultView !== iframe.contentWindow) {
      iframeDocument = iframe.contentDocument;
      iframeDocument.body.appendChild(testElement);
      me.testElementComputedStyle = iframeDocument.defaultView.getComputedStyle(testElement);
    }
  } else {
    iframe = me.iframe = document.createElement('iframe');
    iframe.setAttribute('data-sticky', true);
    iframe.setAttribute('tabIndex', -1);
    iframeStyle = iframe.style;
    iframeStyle.setProperty('visibility', 'hidden', 'important');
    iframeStyle.setProperty('width', '0px', 'important');
    iframeStyle.setProperty('height', '0px', 'important');
    iframeStyle.setProperty('position', 'absolute', 'important');
    iframeStyle.setProperty('border', '0px', 'important');
    iframeStyle.setProperty('zIndex', '-1000', 'important');
    document.body.appendChild(iframe);
    iframeDocument = iframe.contentDocument;
    iframeDocument.open();
    iframeDocument.writeln('\x3c/body\x3e');
    iframeDocument.close();
    me.testElement = testElement = iframeDocument.createElement('div');
    testElement.style.setProperty('position', 'absolute', 'important');
    iframeDocument.body.appendChild(testElement);
    me.testElementComputedStyle = iframeDocument.defaultView.getComputedStyle(testElement);
  }
  return testElement;
}, getCssStyleValue:function(name, value) {
  var testElement = this.getTestElement(), computedStyle = this.testElementComputedStyle, style = testElement.style;
  style.setProperty(name, value);
  if (Ext.browser.is.Firefox) {
    testElement.offsetHeight;
  }
  value = computedStyle.getPropertyValue(name);
  style.removeProperty(name);
  return value;
}, run:function(animations) {
  var me = this, ret = [], isLengthPropertyMap = me.lengthProperties, fromData = {}, toData = me.transitionQueue.toData, data = {}, transitionData = me.transitionQueue.transitionData, element, elementId, from, to, before, fromPropertyNames, toPropertyNames, doApplyTo, message, runningData, elementData, i, j, ln, animation, propertiesLength, sessionNameMap, computedStyle, formattedName, name, toFormattedValue, computedValue, fromFormattedValue, isLengthProperty, runningNameMap, runningNameList, runningSessions, 
  runningSession, messageTimerFn, onBeforeStart;
  if (!me.listenersAttached) {
    me.attachListeners();
  }
  animations = Ext.Array.from(animations);
  for (i = 0, ln = animations.length; i < ln; i++) {
    animation = animations[i];
    animation = Ext.factory(animation, Ext.fx.Animation);
    ret.push(animation);
    me.activeElement = element = animation.getElement();
    Ext.AnimationQueue.start(Ext.emptyFn, animation);
    computedStyle = window.getComputedStyle(element.dom);
    elementId = me.getElementId(element);
    data[elementId] = data = Ext.merge({}, animation.getData());
    onBeforeStart = animation.getOnBeforeStart();
    if (onBeforeStart) {
      onBeforeStart.call(animation.scope || me, element);
    }
    animation.fireEvent('animationstart', animation, data);
    me.fireEvent('animationstart', me, animation, data);
    before = data.before;
    from = data.from;
    to = data.to;
    data.fromPropertyNames = fromPropertyNames = [];
    data.toPropertyNames = toPropertyNames = [];
    for (name in to) {
      if (to.hasOwnProperty(name)) {
        to[name] = toFormattedValue = me.formatValue(to[name], name);
        formattedName = me.formatName(name);
        isLengthProperty = isLengthPropertyMap.hasOwnProperty(name);
        if (!isLengthProperty) {
          toFormattedValue = me.getCssStyleValue(formattedName, toFormattedValue);
        }
        if (from.hasOwnProperty(name)) {
          from[name] = fromFormattedValue = me.formatValue(from[name], name);
          if (!isLengthProperty) {
            fromFormattedValue = me.getCssStyleValue(formattedName, fromFormattedValue);
          }
          if (toFormattedValue !== fromFormattedValue) {
            fromPropertyNames.push(formattedName);
            toPropertyNames.push(formattedName);
          }
        } else {
          computedValue = computedStyle.getPropertyValue(formattedName);
          if (toFormattedValue !== computedValue) {
            toPropertyNames.push(formattedName);
          }
        }
      }
    }
    propertiesLength = toPropertyNames.length;
    if (propertiesLength === 0) {
      me.onAnimationEnd(element, data, animation);
      continue;
    }
    runningData = me.getRunningData(elementId);
    runningSessions = runningData.sessions;
    if (runningSessions.length > 0) {
      me.refreshRunningAnimationsData(element, Ext.Array.merge(fromPropertyNames, toPropertyNames), true, data.replacePrevious);
    }
    runningNameMap = runningData.nameMap;
    runningNameList = runningData.nameList;
    sessionNameMap = {};
    for (j = 0; j < propertiesLength; j++) {
      name = toPropertyNames[j];
      sessionNameMap[name] = true;
      if (!runningNameMap.hasOwnProperty(name)) {
        runningNameMap[name] = 1;
        runningNameList.push(name);
      } else {
        runningNameMap[name]++;
      }
    }
    runningSession = {element:element, map:sessionNameMap, list:toPropertyNames.slice(), length:propertiesLength, data:data, animation:animation};
    runningSessions.push(runningSession);
    animation.on('stop', 'onAnimationStop', me);
    elementData = Ext.apply({}, before);
    Ext.apply(elementData, from);
    if (runningNameList.length > 0) {
      fromPropertyNames = Ext.Array.difference(runningNameList, fromPropertyNames);
      toPropertyNames = Ext.Array.merge(fromPropertyNames, toPropertyNames);
      elementData['transition-property'] = fromPropertyNames;
    }
    fromData[elementId] = elementData;
    toData[elementId] = Ext.apply({}, to);
    transitionData[elementId] = {'transition-property':toPropertyNames, 'transition-duration':data.duration, 'transition-timing-function':data.easing, 'transition-delay':data.delay};
    animation.startTime = Date.now();
  }
  me.activeElement = null;
  message = me.$className;
  me.applyStyles(fromData);
  doApplyTo = function(e) {
    if (e.data === message && e.source === window) {
      window.removeEventListener('message', doApplyTo, false);
      me.applyStyles(me.transitionQueue.toData);
    }
  };
  if (!me.messageTimerId) {
    messageTimerFn = function() {
      var messageFollowupFn;
      me.messageTimerId = null;
      if (Ext.isIE) {
        me.applyStyles(me.transitionQueue.transitionData);
        if (!me.messageFollowupId) {
          messageFollowupFn = function() {
            me.messageFollowupId = null;
            window.addEventListener('message', doApplyTo, false);
            window.postMessage(message, '*');
          };
          messageFollowupFn.$skipTimerCheck = true;
          me.messageFollowupId = Ext.raf(messageFollowupFn);
        }
      } else {
        Ext.merge(me.transitionQueue.toData, me.transitionQueue.transitionData);
        window.addEventListener('message', doApplyTo, false);
        window.postMessage(message, '*');
      }
    };
    messageTimerFn.$skipTimerCheck = true;
    me.messageTimerId = Ext.raf(messageTimerFn);
  }
  return ret;
}, onAnimationStop:function(animation) {
  var me = this, runningAnimationsData = me.runningAnimationsData, activeAnimations = 0, stoppedAnimations = 0, id, runningData, sessions, i, ln, session;
  for (id in runningAnimationsData) {
    if (runningAnimationsData.hasOwnProperty(id)) {
      runningData = runningAnimationsData[id];
      sessions = runningData.sessions;
      activeAnimations++;
      for (i = 0, ln = sessions.length; i < ln; i++) {
        session = sessions[i];
        if (session.animation === animation) {
          me.refreshRunningAnimationsData(session.element, session.list.slice(), false);
          if (animation.destroying) {
            stoppedAnimations++;
          }
        }
      }
    }
  }
  if (activeAnimations === stoppedAnimations) {
    if (me.messageFollowupId) {
      Ext.unraf(me.messageFollowupId);
      me.messageFollowupId = null;
    }
    if (me.messageTimerId) {
      Ext.unraf(me.messageTimerId);
      me.messageTimerId = null;
    }
    Ext.apply(me.transitionQueue, {toData:{}, transitionData:{}});
  }
}});
Ext.define('Ext.mixin.ItemRippler', {mixinId:'itemrippler', config:{itemRipple:null}, shouldRippleItem:function(item, e) {
  var itemRipple, ripple;
  if (e.getTarget(this.noItemRippleSelector, this.element)) {
    return false;
  }
  itemRipple = item && this.getItemRipple();
  if (itemRipple && item.isWidget) {
    ripple = item.shouldRipple(e);
    if (ripple) {
      itemRipple = Ext.apply({}, itemRipple, ripple);
    }
  }
  return itemRipple;
}, rippleItem:function(item, e) {
  if (!item) {
    return;
  }
  var me = this, start = e.type.match(me.rippleStateRe), itemRipple = me.shouldRippleItem(item, e), release = itemRipple && itemRipple.release, isRelease = release === true, el = item.isWidget ? item.el : item, pos, delta, rs, rippledItems;
  if (itemRipple && start && isRelease) {
    me.$rippleStart = e.getXY();
  }
  if (itemRipple && el && (!start && isRelease || start && release !== true)) {
    rippledItems = me.$rippledItems || (me.$rippledItems = []);
    rs = me.$rippleStart;
    if (rs) {
      pos = e.getXY();
      delta = Math.sqrt(Math.pow(pos[0] - rs[0], 2) + Math.pow(pos[1] - rs[1], 2));
      if (delta <= 8) {
        el.ripple(e, itemRipple);
        rippledItems.push(el);
      }
    } else {
      el.ripple(e, itemRipple);
      rippledItems.push(el);
    }
    me.$rippleStart = null;
  }
}, destroyAllRipples:function() {
  for (var items = this.$rippledItems; items && items.length;) {
    items.pop().destroyAllRipples();
  }
}, privates:{noItemRippleSelector:'.' + Ext.baseCSSPrefix + 'item-no-ripple, ' + '.' + Ext.baseCSSPrefix + 'item-no-tap', rippleStateRe:/start|down/}});
Ext.define('Ext.mixin.ConfigProxy', function(ConfigProxy) {
  return {extend:Ext.Mixin, mixinConfig:{id:'configproxy', extended:function(baseClass, derivedClass, classBody) {
    var proxyConfig = classBody.proxyConfig;
    derivedClass.$configProxies = Ext.apply({}, derivedClass.superclass.self.$configProxies);
    if (proxyConfig) {
      delete classBody.proxyConfig;
      ConfigProxy.processClass(derivedClass, proxyConfig);
    }
  }}, onClassMixedIn:function(targetClass) {
    var prototype = targetClass.prototype, proxyConfig = prototype.proxyConfig, initConfig = prototype.initConfig;
    prototype.$proxiedConfigs = null;
    targetClass.$configProxies = {};
    prototype.initConfig = function(config) {
      initConfig.apply(this, arguments);
      this.$proxiedConfigs = null;
      return this;
    };
    if (proxyConfig) {
      delete prototype.proxyConfig;
      ConfigProxy.processClass(targetClass, proxyConfig);
    }
  }, getProxiedConfigs:function(name) {
    var me = this, configs = me.config, configProxies = me.self.$configProxies[name], i = configProxies && configProxies.length, cfg, proxiedConfigs, ret, s, v;
    if (i && me.isConfiguring) {
      proxiedConfigs = me.$proxiedConfigs || (me.$proxiedConfigs = {});
      while (i-- > 0) {
        cfg = configProxies[i];
        proxiedConfigs[s = cfg.name] = cfg;
        if ((v = configs[s]) !== undefined) {
          (ret || (ret = {}))[s] = v;
        }
      }
    }
    return ret;
  }, mergeProxiedConfigs:function(name, itemConfig, alwaysClone) {
    var me = this, ret = itemConfig, proxied = me.getProxiedConfigs(name), configurator;
    if (proxied) {
      if (!itemConfig) {
        ret = proxied;
      } else {
        if (itemConfig.constructor === Object) {
          configurator = me.self.getConfigurator();
          ret = configurator.merge(me, Ext.clone(itemConfig), proxied);
        }
      }
    }
    if (alwaysClone && ret === itemConfig) {
      ret = Ext.clone(ret);
    }
    return ret;
  }, statics:{processClass:function(targetClass, proxyConfig) {
    var ExtConfig = Ext.Config, targetProto = targetClass.prototype, add = {}, proxies = targetClass.$configProxies, cfg, configs, itemGetter, i, item, methods, n, name, proxiedConfigs, s;
    for (item in proxyConfig) {
      itemGetter = ExtConfig.get(item).names.get;
      configs = proxyConfig[item];
      if (Ext.isArray(configs)) {
        methods = null;
      } else {
        methods = configs.methods;
        configs = configs.configs;
      }
      if (!(proxiedConfigs = proxies[item])) {
        proxies[item] = proxiedConfigs = [];
      } else {
        proxies[item] = proxiedConfigs = proxiedConfigs.slice();
      }
      for (i = 0, n = methods && methods.length; i < n; ++i) {
        if (!targetProto[name = methods[i]]) {
          targetProto[name] = ConfigProxy.wrapFn(itemGetter, name);
        } else {
          Ext.raise('Cannot proxy method "' + name + '"');
        }
      }
      for (i = 0, n = configs && configs.length; i < n; ++i) {
        cfg = ExtConfig.get(s = configs[i]);
        if (s in add) {
          Ext.raise('Duplicate proxy config definitions for "' + s + '"');
        }
        if (s in targetProto.config) {
          Ext.raise('Config "' + s + '" already defined for class ' + targetProto.$className);
        }
        add[s] = undefined;
        proxiedConfigs.push(cfg);
        if (!targetProto[name = cfg.names.get]) {
          targetProto[name] = ConfigProxy.wrapGet(itemGetter, name);
        } else {
          Ext.raise('Cannot proxy "' + s + '" config getter');
        }
        if (!targetProto[name = cfg.names.set]) {
          targetProto[name] = ConfigProxy.wrapSet(itemGetter, name, s);
        } else {
          Ext.raise('Cannot proxy "' + s + '" config setter');
        }
      }
    }
    targetClass.addConfig(add);
  }, wrapFn:function(itemGetter, name) {
    return function() {
      var item = this[itemGetter]();
      return item && item[name].apply(item, arguments);
    };
  }, wrapGet:function(itemGetter, configGetter) {
    return function() {
      var item = this[itemGetter]();
      return item && item[configGetter]();
    };
  }, wrapSet:function(itemGetter, configSetter, itemName) {
    return function(value) {
      var me = this, item, proxiedConfigs;
      if (!me.isConfiguring || value !== undefined) {
        item = me[itemGetter]();
        proxiedConfigs = me.$proxiedConfigs;
        if (proxiedConfigs && proxiedConfigs[itemName]) {
          delete proxiedConfigs[itemName];
          item = null;
        }
        if (item) {
          item[configSetter](value);
        }
      }
      return me;
    };
  }}};
});
Ext.define('Ext.mixin.StyleCacher', {extend:Ext.Mixin, mixinConfig:{id:'stylecacher'}, getCachedStyle:function(el, style) {
  var cache = this.$styleCache;
  if (!cache) {
    cache = this.$styleCache = {};
  }
  if (!(style in cache)) {
    cache[style] = Ext.fly(el).getStyle(style);
  }
  return cache[style];
}});
Ext.define('Ext.util.ClickRepeater', {alternateClassName:'Ext.util.TapRepeater', mixins:[Ext.mixin.Observable], config:{el:null, target:null, disabled:null}, interval:20, delay:250, preventDefault:true, stopDefault:false, timer:0, handler:null, scope:null, constructor:function(config) {
  var me = this;
  if (arguments.length === 2) {
    me.setEl(config);
    config = arguments[1];
  }
  me.mixins.observable.constructor.call(this, config);
}, destroy:function() {
  this.setEl(null);
  this.callParent();
}, privates:{fireClick:function(e) {
  var me = this;
  me.fireEvent('click', me, e);
  Ext.callback(me.handler, me.scope, [me, e], 0, me.getTarget());
}, updateDisabled:function(disabled) {
  var me = this;
  if (disabled) {
    me.savedEl = me.getEl();
    me.setEl(null);
  } else {
    if (me.savedEl) {
      me.setEl(me.savedEl);
    }
  }
}, updateTarget:function(target) {
  this.setEl(target.el);
}, updateEl:function(newEl, oldEl) {
  var me = this, elListeners;
  if (oldEl) {
    oldEl.selectable();
    Ext.undefer(me.timer);
    if (me.pressedCls) {
      oldEl.removeCls(me.pressedCls);
    }
    Ext.getDoc().un('mouseup', me.handleMouseUp, me);
    me.elListeners = Ext.destroy(me.elListeners);
  }
  if (newEl) {
    newEl.unselectable();
    elListeners = {mousedown:me.handleMouseDown, scope:me, destroyable:true};
    if (me.preventDefault || me.stopDefault) {
      elListeners.click = me.eventOptions;
    }
    me.elListeners = newEl.on(elListeners);
  }
}, eventOptions:function(e) {
  if (this.preventDefault) {
    e.preventDefault();
  }
  if (this.stopDefault) {
    e.stopEvent();
  }
}, handleMouseDown:function(e) {
  var me = this, el = me.getEl();
  Ext.undefer(me.timer);
  if (me.pressedCls) {
    el.addCls(me.pressedCls);
  }
  me.mousedownTime = Ext.now();
  if (e.pointerType === 'mouse') {
    el.on('mouseout', me.handleMouseOut, me);
  }
  Ext.getDoc().on('mouseup', me.handleMouseUp, me);
  me.fireEvent('mousedown', me, e);
  me.fireClick(e);
  if (me.accelerate) {
    me.delay = 400;
  }
  me.timer = Ext.defer(me.click, me.delay || me.interval, me, [e]);
  if (me.mousedownPreventDefault) {
    e.preventDefault();
  }
  if (me.mousedownStopEvent) {
    e.stopEvent();
  }
}, click:function(e) {
  var me = this;
  me.fireClick(e);
  me.timer = Ext.defer(me.click, me.accelerate ? me.easeOutExpo(Ext.now() - me.mousedownTime, 400, -390, 12000) : me.interval, me, [e]);
}, easeOutExpo:function(t, b, c, d) {
  return t === d ? b + c : c * (-Math.pow(2, -10 * t / d) + 1) + b;
}, handleMouseOut:function() {
  var me = this, el = me.getEl();
  Ext.undefer(me.timer);
  if (me.pressedCls) {
    el.removeCls(me.pressedCls);
  }
  el.on('mouseover', me.handleMouseReturn, me);
}, handleMouseReturn:function(e) {
  var me = this, el = me.getEl();
  el.un('mouseover', me.handleMouseReturn, me);
  if (me.pressedCls) {
    el.addCls(me.pressedCls);
  }
  me.click(e);
}, handleMouseUp:function(e) {
  var me = this, el = me.getEl();
  Ext.undefer(me.timer);
  el.un('mouseover', me.handleMouseReturn, me);
  el.un('mouseout', me.handleMouseOut, me);
  Ext.getDoc().un('mouseup', me.handleMouseUp, me);
  if (me.pressedCls) {
    el.removeCls(me.pressedCls);
  }
  me.fireEvent('mouseup', me, e);
}}});
Ext.define('Ext.util.Spans', {isSpans:true, constructor:function() {
  this.spans = this.spans || [];
}, clear:function() {
  this.spans.length = 0;
  return this;
}, add:function(begin, end) {
  if (end === undefined) {
    if (typeof begin === 'number') {
      end = begin + 1;
    } else {
      end = begin[1];
      begin = begin[0];
    }
  }
  var me = this, spans = me.spans, b, e, first, last, span;
  first = me.bisect(begin);
  if (first) {
    span = spans[first - 1];
    b = span[0];
    e = span[1];
    if (begin <= e) {
      if (end <= e) {
        return false;
      }
      begin = b;
      spans.splice(--first, 1);
    }
  }
  last = me.bisect(end);
  if (last > first) {
    span = spans[last - 1];
    end = Math.max(end, span[1]);
  }
  if (last < spans.length) {
    span = spans[last];
    if (end === span[0]) {
      end = span[1];
      ++last;
    }
  }
  spans.splice(first, last - first, [begin, end]);
  return true;
}, contains:function(begin, end) {
  if (end === undefined) {
    if (typeof begin === 'number') {
      end = begin + 1;
    } else {
      end = begin[1];
      begin = begin[0];
    }
  }
  var spans = this.spans, index = this.bisect(begin), ret = false, e, span;
  if (index && begin < (e = spans[index - 1][1])) {
    ret = end <= e;
  } else {
    if (index < spans.length) {
      span = spans[index];
      ret = span[0] <= begin && end <= span[1];
    }
  }
  return ret;
}, each:function(fn, scope) {
  var spans = this.spans, len = spans.length, i, span, j;
  for (i = 0; i < len; i++) {
    span = spans[i];
    for (j = span[0]; j < span[1]; j++) {
      if (fn.call(scope || this, i) === false) {
        return;
      }
    }
  }
}, intersects:function(begin, end) {
  if (end === undefined) {
    if (typeof begin === 'number') {
      end = begin + 1;
    } else {
      end = begin[1];
      begin = begin[0];
    }
  }
  var spans = this.spans, index = this.bisect(begin), ret = false;
  if (index && begin < spans[index - 1][1]) {
    ret = true;
  } else {
    if (index < spans.length) {
      ret = spans[index][0] < end;
    }
  }
  return ret;
}, remove:function(begin, end) {
  if (end === undefined) {
    if (typeof begin === 'number') {
      end = begin + 1;
    } else {
      end = begin[1];
      begin = begin[0];
    }
  }
  var me = this, spans = me.spans, first = me.bisect(begin), ret = false, last, span, tmp;
  if (first) {
    span = spans[first - 1];
    tmp = span[1];
    if (begin < tmp) {
      span[1] = begin;
      if (end < tmp) {
        spans.splice(first, 0, [end, tmp]);
        return true;
      }
      ret = true;
    }
  }
  last = me.bisect(end);
  if (first < last) {
    ret = true;
    span = spans[last - 1];
    if (end < span[1]) {
      span[0] = end;
      --last;
    }
    last -= first;
    if (last) {
      spans.splice(first, last);
    }
  }
  return ret;
}, stash:function() {
  return this.spans.slice();
}, unstash:function(pickle) {
  this.spans = pickle;
  return this;
}, getCount:function() {
  var spans = this.spans, len = spans.length, result = 0, i, span;
  for (i = 0; i < len; i++) {
    span = spans[i];
    result += span[1] - span[0];
  }
  return result;
}, privates:{bisect:function(value) {
  return Ext.Number.bisectTuples(this.spans, value, 0);
}}});
Ext.define('Ext.util.TaskManager', {extend:Ext.util.TaskRunner, alternateClassName:['Ext.TaskManager'], singleton:true});
Ext.define('Ext.util.TextMetrics', {statics:{shared:null, measure:function(el, text, fixedWidth) {
  var me = this, shared = me.shared || (me.shared = new me(el, fixedWidth));
  shared.bind(el);
  shared.setFixedWidth(fixedWidth || 'auto');
  return shared.getSize(text);
}, destroy:function() {
  this.shared = Ext.destroy(this.shared);
}}, constructor:function(bindTo, fixedWidth) {
  var me = this, measure = me.measure = Ext.getBody().createChild({'data-sticky':true, role:'presentation', cls:Ext.baseCSSPrefix + 'textmetrics', style:{position:'absolute', left:'-1000px', top:'-1000px', visibility:'hidden'}});
  if (bindTo) {
    me.bind(bindTo);
  }
  if (fixedWidth) {
    measure.setWidth(fixedWidth);
  }
}, getSize:function(text) {
  var measure = this.measure, size;
  measure.setHtml(text);
  size = measure.getSize();
  measure.setHtml('');
  return size;
}, bind:function(el) {
  this.measure.setStyle((this.el || (this.self.prototype.el = new Ext.dom.Fly)).attach(el).getStyle(['font-size', 'font-size-adjust', 'font-style', 'font-weight', 'font-family', 'font-kerning', 'font-stretch', 'line-height', 'text-transform', 'text-decoration', 'letter-spacing', 'word-break']));
}, setFixedWidth:function(width) {
  this.measure.setWidth(width);
}, getWidth:function(text) {
  this.measure.dom.style.width = 'auto';
  return this.getSize(text).width;
}, getHeight:function(text) {
  return this.getSize(text).height;
}, destroy:function() {
  var me = this;
  me.el = me.measure = Ext.destroy(me.measure);
  me.callParent();
}}, function() {
  Ext.Element.override({getTextWidth:function(text, min, max) {
    return Ext.Number.constrain(Ext.util.TextMetrics.measure(this.dom, Ext.valueFrom(text, this.dom.innerHTML, true)).width, min || 0, max || 1000000);
  }});
});
Ext.define('Ext.Tool', {extend:Ext.Component, alternateClassName:'Ext.panel.Tool', xtype:['tool', 'paneltool'], isPanelTool:true, isTool:true, focusable:true, tabIndex:0, focusEl:'element', ariaEl:'element', inheritUi:true, classCls:Ext.baseCSSPrefix + 'tool', pressedCls:Ext.baseCSSPrefix + 'pressed', hoveredCls:Ext.baseCSSPrefix + 'hovered', passiveCls:Ext.baseCSSPrefix + 'passive', element:{reference:'element', tabIndex:0, listeners:{click:'onClick', mousedown:'onMouseDown', mouseover:'onMouseOver', 
mouseout:'onMouseOut'}, children:[{reference:'iconElement', cls:Ext.baseCSSPrefix + 'icon-el ' + Ext.baseCSSPrefix + 'font-icon'}]}, handler:null, scope:null, toolOwner:null, config:{iconCls:null, type:null, passive:null}, stopEvent:true, weight:10, updateIconCls:function(iconCls, oldValue) {
  this.iconElement.replaceCls(oldValue, iconCls);
}, updateType:function(type, oldType) {
  var me = this, baseCls = Ext.Tool.prototype.classCls, iconElement = me.iconElement;
  me.type = type;
  iconElement.replaceCls(oldType && baseCls + '-type-' + oldType, type && baseCls + '-type-' + type);
}, updateDisabled:function(disabled, oldDisabled) {
  this.callParent([disabled, oldDisabled]);
  this.el.removeCls([this.hoveredCls, this.pressedCls]);
}, updatePassive:function(passive) {
  var me = this;
  me.setDisabled(passive);
  me.el.toggleCls(me.passiveCls, passive);
  me.el.setTabIndex(passive ? null : me.getTabIndex());
  me.focusable = !passive;
}, shouldRipple:function(e) {
  return !this.getPassive() && this.callParent();
}, privates:{_toolTypes:{close:1, collapse:1, disclosure:1, down:1, expand:1, gear:1, help:1, left:1, maximize:1, minimize:1, minus:1, menu:1, next:1, pin:1, plus:1, prev:1, print:1, refresh:1, restore:1, right:1, save:1, search:1, toggle:1, unpin:1, up:1}, invokeToolHandler:function(me, handler, scope, args, ev) {
  if (handler) {
    Ext.callback(handler, me.scope, args, 0, me);
  }
  me.fireEvent('click', me, ev, me.toolOwner || me.ownerCt);
  return true;
}, onClick:function(ev) {
  var me = this, handler = me.handler || me.callback, toolOwner = me.toolOwner, args, invoker;
  if (me.getDisabled()) {
    return false;
  }
  if (me.stopEvent !== false) {
    ev.stopEvent();
  }
  args = [me.parent, me, ev];
  if (toolOwner) {
    args[0] = toolOwner;
    if (toolOwner.augmentToolHandler) {
      toolOwner.augmentToolHandler(me, args);
    }
  }
  invoker = toolOwner && toolOwner.invokeToolHandler ? toolOwner : me;
  return invoker.invokeToolHandler(me, handler, me.scope, args, ev);
}, onMouseDown:function(e) {
  var me = this;
  if (!me.focusable) {
    e.preventDefault();
  }
  if (me.getDisabled()) {
    return false;
  }
  me.addCls(me.pressedCls);
  Ext.GlobalEvents.setPressedComponent(me, e);
}, onRelease:function() {
  this.removeCls(this.pressedCls);
}, onMouseOver:function() {
  if (this.getDisabled()) {
    return false;
  }
  this.addCls(this.hoveredCls);
}, onMouseOut:function() {
  this.removeCls(this.hoveredCls);
}}});
Ext.define('Ext.theme.material.Tool', {override:'Ext.Tool', config:{ripple:{bound:false, color:'default', centered:true}}});
Ext.define('Ext.mixin.Toolable', {mixinId:'toolable', config:{defaultToolWeights:{cached:true, $value:{toggle:10, gear:20, prev:30, next:40, left:50, right:60, down:70, up:80, refresh:90, disclosure:100, plus:100, minus:110, search:120, save:130, print:140, expand:150, collapse:160, help:170, pin:180, unpin:190, minimize:200, maximize:210, restore:220, close:230}}, toolDefaults:{xtype:'tool', zone:'end'}, tools:null}, toolAnchorName:'bodyElement', afterClassMixedIn:function(targetClass) {
  var proto = targetClass.prototype, already = proto.toolDefaults, getRefItems = proto.getRefItems;
  if (already) {
    delete proto.toolDefaults;
    targetClass.getConfigurator().add({toolDefaults:Ext.apply({xtype:'tool', weight:0, zone:'end'}, already)});
  }
  already = proto.tools;
  if (already) {
    delete proto.tools;
    targetClass.getConfigurator().add({tools:already});
  }
  if (getRefItems) {
    proto.getRefItems = function(deep) {
      return Ext.Array.push(getRefItems.call(this, deep), this.getTools() || Ext.emptyArray);
    };
  } else {
    proto.getRefItems = function() {
      return this.getTools() || Ext.emptyArray;
    };
  }
}, lookupTool:function(id) {
  var tools = this.getTools(), n = tools && tools.length, i, tool;
  for (i = 0; i < n; ++i) {
    tool = tools[i];
    if (tool.type === id || tool.getItemId() === id) {
      return tool;
    }
  }
  return null;
}, applyTools:function(tools) {
  if (tools) {
    var me = this, array = me.createTools(tools), n = array.length, i, tool, zone;
    Ext.Array.sort(array, Ext.weightSortFn);
    for (i = 0; i < n; ++i) {
      tool = array[i];
      tool.ownerCmp = tool.toolOwner = me;
      array[i] = tool = Ext.create(tool);
      tool.doInheritUi();
      zone = tool.zone;
      tool.addCls(me._toolPositionClsMap[zone]);
      me.getToolZone(tool.zone).el.appendChild(tool.el);
    }
    tools = array;
  }
  return tools;
}, updateTools:function(tools, oldTools) {
  Ext.destroy(oldTools);
}, privates:{_toolZoneNames:{end:'_endZone', head:'_headZone', start:'_startZone', tail:'_tailZone'}, _tailedCls:Ext.baseCSSPrefix + 'tailed', _headedCls:Ext.baseCSSPrefix + 'headed', _toolZoneCls:Ext.baseCSSPrefix + 'tool-zone', _toolZoneClsMap:{end:Ext.baseCSSPrefix + 'end', head:Ext.baseCSSPrefix + 'head', tail:Ext.baseCSSPrefix + 'tail', start:Ext.baseCSSPrefix + 'start'}, _toolPositionClsMap:{end:Ext.baseCSSPrefix + 'end', head:Ext.baseCSSPrefix + 'start', tail:Ext.baseCSSPrefix + 'end', start:Ext.baseCSSPrefix + 
'start'}, _toolDockAlignCls:{left:Ext.baseCSSPrefix + 'align-left', center:Ext.baseCSSPrefix + 'align-center', right:Ext.baseCSSPrefix + 'align-right'}, hasToolZones:false, adjustToolDefaults:function(tool, toolDefaults, defaultToolWeights) {
  toolDefaults = toolDefaults || this.getToolDefaults();
  if (defaultToolWeights === undefined) {
    defaultToolWeights = this.getDefaultToolWeights();
  }
  if (toolDefaults) {
    Ext.applyIf(tool, toolDefaults);
    tool.instanceCls = this.toolCls;
  }
  if (!tool.type && !tool.iconCls) {
    tool.type = tool.itemId;
  }
  if (defaultToolWeights && !('weight' in tool)) {
    tool.weight = defaultToolWeights[tool.type];
  }
  return tool;
}, createTools:function(tools, toolOwner) {
  var me = this, array = Ext.convertKeyedItems(tools, 'handler', 'handler'), n = array.length, defaultToolWeights = me.getDefaultToolWeights(), toolDefaults = me.getToolDefaults(), i, tool;
  toolOwner = toolOwner || me;
  if (array === tools) {
    array = [];
    for (i = 0; i < n; ++i) {
      tool = tools[i];
      if (typeof tool === 'string') {
        tool = me.adjustToolDefaults({type:tool}, toolDefaults, null);
      } else {
        tool = Ext.apply(me.adjustToolDefaults({}, toolDefaults, null), tool);
      }
      tool.toolOwner = toolOwner;
      array[i] = tool;
    }
  } else {
    for (i = 0; i < n; ++i) {
      me.adjustToolDefaults(tool = array[i], toolDefaults, defaultToolWeights);
      tool.toolOwner = toolOwner;
    }
  }
  return array;
}, getToolZone:function(zoneName) {
  var me = this, zonePropName = me._toolZoneNames[zoneName], zone = me[zonePropName], dockWrapName = '_toolDockWrap', anchorElement;
  if (!zonePropName) {
    Ext.raise('Invalid zone name: "' + zoneName + '"');
  }
  if (!zone) {
    zone = Ext.Element.create({classList:[me._toolZoneCls, me._toolZoneClsMap[zoneName]]});
    anchorElement = me[me.toolAnchorName];
    if (!anchorElement) {
      Ext.raise('Invalid tool anchor. No element named "' + me.toolAnchorName + '".');
    }
    if (!me[dockWrapName]) {
      me[dockWrapName] = anchorElement.wrap({cls:Ext.baseCSSPrefix + 'tool-dock'});
      anchorElement.addCls(Ext.baseCSSPrefix + 'tool-anchor');
      me.initUiReference(dockWrapName, 'tool-dock');
      me.syncToolableAlign();
    }
    if (zoneName === 'head') {
      zone.insertBefore(anchorElement);
      anchorElement.addCls(me._headedCls);
    } else {
      if (zoneName === 'tail') {
        zone.insertAfter(anchorElement);
        anchorElement.addCls(me._tailedCls);
      } else {
        if (zoneName === 'start') {
          zone.insertBefore(me._headZone || anchorElement);
        } else {
          if (zoneName === 'end') {
            zone.insertAfter(me._tailZone || anchorElement);
          }
        }
      }
    }
    me[zonePropName] = zone;
    me.hasToolZones = true;
  }
  return zone;
}, syncToolableAlign:function() {
  var me = this, dockWrap = me._toolDockWrap, alignCls = me._toolDockAlignCls, align;
  if (dockWrap && typeof me.getAlign === 'function') {
    align = me.getAlign();
    dockWrap.replaceCls(alignCls[me._toolDockAlign], alignCls[align]);
    me._toolDockAlign = align;
  }
}, doDestroy:function() {
  var me = this;
  me.setTools(null);
  Ext.destroy(me._startZone, me._endZone, me._headZone, me._tailZone, me._toolDockWrap);
}}});
Ext.define('Ext.layout.Box', {extend:Ext.layout.Auto, alias:'layout.box', isBox:true, config:{orient:'horizontal', align:'stretch', constrainAlign:false, pack:'start', vertical:false, reverse:false, overflow:null, wrap:null}, cls:Ext.baseCSSPrefix + 'layout-box', baseItemCls:Ext.baseCSSPrefix + 'layout-box-item', constrainAlignCls:Ext.baseCSSPrefix + 'constrain-align', flexedCls:Ext.baseCSSPrefix + 'flexed', wrapClsMap:{'true':Ext.baseCSSPrefix + 'wrap', 'wrap':Ext.baseCSSPrefix + 'wrap', 'wrap-reverse':Ext.baseCSSPrefix + 
'wrap-reverse'}, boxRe:/^(?:box|hbox|vbox)$/, orientMap:{horizontal:{sizeProp:'width', containerCls:[Ext.baseCSSPrefix + 'layout-hbox', Ext.baseCSSPrefix + 'horizontal'], itemCls:Ext.baseCSSPrefix + 'layout-hbox-item'}, vertical:{sizeProp:'height', containerCls:[Ext.baseCSSPrefix + 'layout-vbox', Ext.baseCSSPrefix + 'vertical'], itemCls:Ext.baseCSSPrefix + 'layout-vbox-item'}}, constructor:function(config) {
  var me = this;
  me.callParent([config]);
  me.positionSortFn = me.positionSortFn.bind(me);
}, setConfig:function(name, value, options) {
  var config = name, type;
  if (name) {
    if (typeof name === 'string') {
      config = {};
      config[name] = value;
    } else {
      Ext.apply({}, name);
      options = value;
    }
    type = config.type;
    delete config.type;
    if (type && !this.boxRe.test(type)) {
      Ext.raise('Cannot change layout from ' + this.$className + ' to "' + type + '"');
    }
    if (config.vertical == null) {
      if (type === 'vbox') {
        config.vertical = true;
      } else {
        if (type === 'hbox') {
          config.vertical = false;
        }
      }
    }
    this.callParent([config, options]);
  }
  return this;
}, destroy:function() {
  Ext.destroy(this.getOverflow());
  this.positionSortFn = null;
  this.callParent();
}, updateContainer:function(container, oldContainer) {
  var listener = {flexchange:'onItemFlexChange', scope:this, delegate:'\x3e component'};
  this.callParent([container, oldContainer]);
  if (container) {
    container.on(listener);
  }
  if (oldContainer) {
    oldContainer.un(listener);
  }
}, updateVertical:function(vertical) {
  this.setOrient(vertical ? 'vertical' : 'horizontal');
}, applyOrient:function(orient) {
  if (orient !== 'horizontal' && orient !== 'vertical') {
    Ext.log.error("Invalid box orient of: '" + orient + "', must be either 'horizontal' or 'vertical'");
  }
  return orient;
}, updateOrient:function(orient, oldOrient) {
  var me = this, container = me.getContainer(), overflow = me.getOverflow(), renderTarget = container.getRenderTarget(), innerItems = container.innerItems, len = innerItems.length, map = me.orientMap, newMap = map[orient], oldMap = map[oldOrient], vertical = orient === 'vertical', i, itemCls, item;
  me.sizePropertyName = newMap.sizeProp;
  if (oldOrient) {
    renderTarget.removeCls(oldMap.containerCls);
    for (i = 0; i < len; ++i) {
      innerItems[i].removeCls(oldMap.itemCls);
    }
  }
  renderTarget.addCls(newMap.containerCls);
  me.itemCls = itemCls = [me.baseItemCls, newMap.itemCls];
  for (i = 0; i < len; ++i) {
    item = innerItems[i];
    item.addCls(itemCls);
  }
  me.setVertical(vertical);
  me.positionFn = vertical ? 'getTop' : 'getLeft';
  if (overflow) {
    overflow.setVertical(vertical);
  }
}, updateConstrainAlign:function(constrainAlign) {
  this.getContainer().getRenderTarget().toggleCls(this.constrainAlignCls, constrainAlign);
}, onItemInnerStateChange:function(item, isInner) {
  var me = this, flex;
  me.callParent(arguments);
  if (isInner) {
    flex = item.getFlex();
    if (flex) {
      me.setItemFlex(item, flex);
    }
  } else {
    me.setItemFlex(item, null);
  }
}, onItemFlexChange:function(item, flex) {
  if (item.isInnerItem()) {
    this.setItemFlex(item, flex);
  }
}, setItemFlex:function(item, flex) {
  var el = item.el, type = typeof flex, isNumber = type === 'number', isString = type === 'string', parts, grow;
  if (!flex || isNumber || isString) {
    if (isNumber) {
      grow = flex;
      flex = flex + ' ' + flex;
    } else {
      if (isString) {
        parts = Ext.String.splitWords(flex);
        grow = parts[0];
        if (parts.length === 1) {
          flex = grow + ' ' + grow;
        }
      }
    }
    el.setStyle('flex', flex);
  } else {
    grow = flex.grow;
    el.setStyle({flexGrow:grow, flexShrink:flex.shrink, flexBasis:flex.basis});
  }
  item.toggleCls(this.flexedCls, !!grow);
}, convertPosition:function(position) {
  var positionMap = this.positionMap;
  if (positionMap.hasOwnProperty(position)) {
    return positionMap[position];
  }
  return position;
}, applyAlign:function(align) {
  return this.convertPosition(align);
}, updateAlign:function(align, oldAlign) {
  this.getContainer().getRenderTarget().swapCls(align, oldAlign, true, Ext.baseCSSPrefix + 'align');
}, applyPack:function(pack) {
  return this.convertPosition(pack);
}, updatePack:function(pack, oldPack) {
  this.getContainer().getRenderTarget().swapCls(pack, oldPack, true, Ext.baseCSSPrefix + 'pack');
}, updateReverse:function(reverse) {
  this.getContainer().getRenderTarget().toggleCls(Ext.baseCSSPrefix + 'reverse', reverse);
}, ensureVisible:function(item, options) {
  if (!item.isWidget) {
    options = item;
    item = options.item;
  }
  if (options && !isNaN(options.offset)) {
    item = this.getItemByOffset(options.offset);
  }
  var me = this, container = this.getContainer(), scrollable = container.getScrollable(), scrollerTarget = scrollable.getElement(), vertical = me.getVertical(), targetInfo = me.getItemInfo(scrollerTarget), itemInfo = me.getItemInfo(item), oversized = itemInfo.size > targetInfo.size, scroll = options && options.scroll || 'min', delta, deltaX, deltaY;
  if (me._currentEnsureVisibleItem === item && scrollable.translatable.isAnimating) {
    return;
  }
  if (scroll === 'min') {
    if (!oversized && itemInfo.start < targetInfo.start || oversized && itemInfo.start > targetInfo.start) {
      delta = itemInfo.start - targetInfo.start;
    } else {
      if (!oversized && itemInfo.end > targetInfo.end || oversized && itemInfo.end < targetInfo.end) {
        delta = itemInfo.end - targetInfo.end;
      } else {
        if (oversized && itemInfo.start < targetInfo.start && itemInfo.end > targetInfo.end) {
          delta = itemInfo.start - targetInfo.start;
        }
      }
    }
  } else {
    if (itemInfo.start < targetInfo.start) {
      delta = itemInfo.end - targetInfo.end;
    } else {
      delta = itemInfo.start - targetInfo.start;
    }
  }
  if (delta) {
    deltaX = !vertical ? delta : null;
    deltaY = vertical ? delta : null;
    me._currentEnsureVisibleItem = item;
    scrollable.scrollBy(deltaX, deltaY, options.animation);
  }
}, getItemByOffset:function(indexOffset) {
  var me = this, container = this.getContainer(), scrollerTarget = container.getScrollable().getElement(), targetInfo = me.getItemInfo(scrollerTarget), items = container.getInnerItems(), len = items.length, minFrontDistance = -Infinity, minEndDistance = -Infinity, startIndex = 0, endIndex = len - 1, index, i, itemFrontDistance, itemEndDistance, item, itemInfo;
  if (!indexOffset) {
    return;
  }
  items.sort(me.positionSortFn);
  for (i = 0; i < len; i++) {
    item = items[i];
    itemInfo = me.getItemInfo(item);
    itemFrontDistance = itemInfo.start - targetInfo.start;
    itemEndDistance = targetInfo.end - itemInfo.end;
    if (itemFrontDistance > minFrontDistance && itemFrontDistance < 0 && itemEndDistance > 0) {
      minFrontDistance = itemFrontDistance;
      startIndex = i;
    }
    if (itemEndDistance > minEndDistance && itemEndDistance < 0 && itemFrontDistance > 0) {
      minEndDistance = itemEndDistance;
      endIndex = i;
      break;
    }
  }
  if (indexOffset > 0) {
    indexOffset--;
    index = endIndex += indexOffset;
    if (endIndex >= len) {
      index = len - 1;
    }
  } else {
    indexOffset++;
    index = startIndex += indexOffset;
    if (startIndex < 0) {
      index = 0;
    }
  }
  return items[index];
}, getItemInfo:function(item) {
  var me = this, vertical = me.getVertical(), el = item.el;
  return {start:el[vertical ? 'getTop' : 'getLeft'](), end:el[vertical ? 'getBottom' : 'getRight'](), size:el[vertical ? 'getHeight' : 'getWidth']()};
}, createOverflow:function(config) {
  return Ext.apply({owner:this, vertical:this.getVertical()}, config);
}, applyOverflow:function(config, existing) {
  return Ext.Factory.layoutOverflow.update(existing, config, this, 'createOverflow');
}, updateWrap:function(wrap, oldWrap) {
  var me = this, el = me.getContainer().getRenderTarget(), map = me.wrapClsMap, cls;
  if (oldWrap) {
    cls = map[oldWrap];
    if (cls) {
      el.removeCls(cls);
    }
  }
  if (wrap) {
    cls = map[wrap];
    if (cls) {
      el.addCls(cls);
    }
  }
}, privates:{positionSortFn:function(a, b) {
  var fn = this.positionFn;
  a = a.el[fn]();
  b = b.el[fn]();
  if (a < b) {
    return -1;
  } else {
    if (b < a) {
      return 1;
    }
  }
  return 0;
}}});
Ext.define('Ext.Button', {extend:Ext.Component, xtype:'button', isButton:true, cachedConfig:{buttonType:'button', iconCls:null, textAlign:null, menuAlign:'tl-bl?', destroyMenu:true, stretchMenu:false}, config:{allowDepress:true, badgeText:null, text:null, icon:false, iconAlign:'left', pressedDelay:0, menu:{lazy:true, $value:null}, arrow:null, arrowAlign:'right', handler:null, toggleHandler:null, scope:null, autoEvent:null, ui:null, enableToggle:false, value:null}, eventedConfig:{pressed:false}, preventDefaultAction:true, 
isMenuOwner:true, baseCls:Ext.baseCSSPrefix + 'button', hasMenuCls:Ext.baseCSSPrefix + 'has-menu', hoveredCls:Ext.baseCSSPrefix + 'hovered', pressedCls:Ext.baseCSSPrefix + 'pressed', pressingCls:Ext.baseCSSPrefix + 'pressing', hasBadgeCls:Ext.baseCSSPrefix + 'has-badge', hasIconCls:Ext.baseCSSPrefix + 'has-icon', hasTextCls:Ext.baseCSSPrefix + 'has-text', hasArrowCls:Ext.baseCSSPrefix + 'has-arrow', noArrowCls:Ext.baseCSSPrefix + 'no-arrow', defaultBindProperty:'text', publishes:['pressed'], element:{reference:'element', 
listeners:{click:'onClick'}}, focusable:true, focusEl:'buttonElement', ariaEl:'buttonElement', backgroundColorEl:'innerElement', focusClsEl:'el', initialize:function() {
  var me = this, el = me.el;
  me.callParent();
  if (me.getConfig('menu', true)) {
    me.addCls(me.hasMenuCls);
  }
  el.on({scope:me, touchstart:'onPress'});
  el.addClsOnOver(me.hoveredCls, me.isEnabled, me);
}, getTemplate:function() {
  return [{reference:'innerElement', cls:Ext.baseCSSPrefix + 'inner-el', children:[{reference:'bodyElement', cls:Ext.baseCSSPrefix + 'body-el', children:[{cls:Ext.baseCSSPrefix + 'icon-el ' + Ext.baseCSSPrefix + 'font-icon', reference:'iconElement'}, {reference:'textElement', cls:Ext.baseCSSPrefix + 'text-el'}]}, {reference:'arrowElement', cls:Ext.baseCSSPrefix + 'arrow-el ' + Ext.baseCSSPrefix + 'font-icon'}]}, {reference:'badgeElement', cls:Ext.baseCSSPrefix + 'badge-el'}, this.getButtonTemplate()];
}, getButtonTemplate:function() {
  return {tag:'button', reference:'buttonElement', cls:Ext.baseCSSPrefix + 'button-el', listeners:{focus:'handleFocusEvent', blur:'handleBlurEvent'}};
}, shouldRipple:function(e) {
  var me = this, ui = me.getUi(), ripple = me.getRipple(), isFab = ui ? ui.split(' ').indexOf('fab') >= 0 : false, text, icon;
  if (!isFab && ripple && ripple.bound === undefined) {
    text = me.getText();
    icon = me.getIconCls();
    if ((!text || text.length === 0) && icon) {
      ripple = Ext.clone(ripple);
      ripple.bound = false;
      ripple.measureSelector = 'x-icon-el';
    }
  }
  return ripple;
}, isPressed:function() {
  return Boolean(this.getPressed());
}, toggle:function() {
  this.setPressed(!this.isPressed());
}, updateBadgeText:function(badgeText) {
  var me = this, el = me.el, badgeElement = me.badgeElement, hasBadgeCls = me.hasBadgeCls;
  if (badgeText) {
    badgeElement.setText(badgeText);
    el.addCls(hasBadgeCls);
  } else {
    el.removeCls(hasBadgeCls);
  }
}, updateButtonType:function(buttonType) {
  this.buttonElement.dom.setAttribute('type', buttonType);
}, updateText:function(text) {
  this.textElement.setHtml(text);
  this.toggleCls(this.hasTextCls, !!text);
}, updateHtml:function(html) {
  this.setText(html);
}, applyPressed:function(pressed) {
  return Boolean(pressed);
}, updatePressed:function(pressed) {
  var me = this, toggleHandler = me.getToggleHandler();
  if (toggleHandler && !me.isConfiguring) {
    Ext.callback(toggleHandler, me.getScope(), [me, pressed], 0, me);
  }
  me.element.toggleCls(me.pressedCls, pressed);
}, updateIcon:function(icon) {
  var me = this, element = me.iconElement, hasIconCls = me.hasIconCls;
  if (icon) {
    me.addCls(hasIconCls);
    element.setStyle('background-image', 'url(' + icon + ')');
  } else {
    element.setStyle('background-image', '');
    if (!me.getIconCls()) {
      me.removeCls(hasIconCls);
    }
  }
}, updateIconCls:function(iconCls, oldIconCls) {
  var me = this, element = me.iconElement, hasIconCls = me.hasIconCls;
  if (iconCls) {
    me.addCls(hasIconCls);
    element.replaceCls(oldIconCls, iconCls);
  } else {
    element.removeCls(oldIconCls);
    if (!me.getIcon()) {
      me.removeCls(hasIconCls);
    }
  }
}, updateIconAlign:function(iconAlign, oldIconAlign) {
  var el = this.el, prefix = Ext.baseCSSPrefix + 'icon-align-';
  el.removeCls(prefix + oldIconAlign);
  el.addCls(prefix + iconAlign);
}, _textAlignCls:{left:Ext.baseCSSPrefix + 'text-align-left', right:Ext.baseCSSPrefix + 'text-align-right', center:''}, updateTextAlign:function(textAlign, oldTextAlign) {
  var textAlignClasses = this._textAlignCls, add = textAlignClasses[textAlign || 'center'], remove = textAlignClasses[oldTextAlign || 'center'];
  this.replaceCls(remove, add);
}, updateArrowAlign:function(align, oldAlign) {
  var element = this.element, cls = Ext.baseCSSPrefix + 'arrow-align-';
  if (oldAlign) {
    element.removeCls(cls + oldAlign);
  }
  element.addCls(cls + align);
}, applyMenu:function(menu) {
  if (menu) {
    if (!menu.isMenu) {
      if (Ext.isArray(menu)) {
        menu = {items:menu};
      }
      if (!menu.xtype) {
        menu.xtype = 'menu';
      }
      menu.ownerCmp = this;
      menu = Ext.widget(menu);
    }
    this.menuMinWidth = menu.getMinWidth();
  }
  return menu;
}, updateMenu:function(menu, oldMenu) {
  var listener = {scope:this, hide:'onMenuHide'};
  if (oldMenu && !oldMenu.destroyed) {
    if (this.getDestroyMenu()) {
      oldMenu.destroy();
    } else {
      if (oldMenu.isMenu) {
        oldMenu.un(listener);
      }
    }
  }
  this.toggleCls(this.hasMenuCls, !!menu);
  if (menu && menu.isMenu) {
    menu.on(listener);
  }
}, updateArrow:function(arrow) {
  this.toggleCls(this.noArrowCls, !arrow);
  this.toggleCls(this.hasArrowCls, !!arrow);
}, applyAutoEvent:function(autoEvent) {
  var me = this;
  if (typeof autoEvent == 'string') {
    autoEvent = {name:autoEvent, scope:me.scope || me};
  }
  return autoEvent;
}, updateAutoEvent:function(autoEvent) {
  var name = autoEvent.name, scope = autoEvent.scope;
  this.setHandler(function() {
    scope.fireEvent(name, scope, this);
  });
  this.setScope(scope);
}, applyPressedDelay:function(delay) {
  if (Ext.isNumber(delay)) {
    return delay;
  }
  return delay ? 100 : 0;
}, enableFocusable:function() {
  this.buttonElement.dom.disabled = false;
  this.callParent();
}, disableFocusable:function() {
  this.callParent();
  this.buttonElement.dom.disabled = true;
}, findEventTarget:function(e) {
  return this.element;
}, onPress:function(e) {
  var me = this, element = this.findEventTarget(e), pressedDelay = me.getPressedDelay(), pressingCls = me.pressingCls;
  if (!me.getDisabled() && !e.button) {
    if (pressedDelay > 0) {
      me.pressedTimeout = Ext.defer(function() {
        delete me.pressedTimeout;
        if (element) {
          element.addCls(pressingCls);
        }
      }, pressedDelay);
    } else {
      element.addCls(pressingCls);
    }
    Ext.GlobalEvents.setPressedComponent(me, e);
  }
}, onRelease:function(e) {
  this.fireAction('release', [this, e], 'doRelease');
}, doRelease:function(me, e) {
  var element = me.findEventTarget(e);
  if (!me.getDisabled()) {
    if (me.hasOwnProperty('pressedTimeout')) {
      Ext.undefer(me.pressedTimeout);
      delete me.pressedTimeout;
    } else {
      if (element) {
        element.removeCls(me.pressingCls);
      }
    }
  }
}, onClick:function(e) {
  return this.onTap(e);
}, onTap:function(e) {
  if (this.getDisabled()) {
    return false;
  }
  this.fireAction('tap', [this, e], 'doTap');
}, doTap:function(me, e) {
  var menu = me.getMenu(), handler = me.getHandler();
  if (e && e.preventDefault && me.preventDefaultAction) {
    e.preventDefault();
  }
  if (menu) {
    me.toggleMenu(e, menu);
  } else {
    if ((me.getToggleHandler() || me.getEnableToggle()) && (me.getAllowDepress() || !me.isPressed())) {
      me.toggle();
    }
    if (handler) {
      Ext.callback(handler, me.getScope(), [me, e], 0, me);
    }
  }
}, onEnterKey:function(e) {
  this.onTap(e);
  e.stopEvent();
  return false;
}, onDownKey:function(e) {
  var menu = this.getMenu();
  if (menu && !this.getDisabled()) {
    this.showMenu(e, menu);
    e.stopEvent();
    return false;
  }
}, onEscKey:function(e) {
  var menu = this.getMenu();
  if (menu && !this.getDisabled() && menu.isVisible()) {
    menu.hide();
    e.stopEvent();
    return false;
  }
}, onFocus:function(e) {
  if (!this.keyHandlersAdded) {
    this.setKeyMap({scope:'this', SPACE:'onEnterKey', ENTER:'onEnterKey', DOWN:'onDownKey', ESC:'onEscKey'});
    this.keyHandlersAdded = true;
  }
  this.callParent([e]);
}, onMenuHide:function(menu) {
  if (menu.isMenu && !this.$buttonWasPressed) {
    this.setPressed(false);
  }
}, toggleMenu:function(e, menu) {
  var me = this;
  menu = menu || me.getMenu();
  if (menu) {
    if (menu.isVisible()) {
      me.hideMenu(e, menu);
    } else {
      me.showMenu(e, menu);
    }
  }
}, hideMenu:function(e, menu) {
  menu = menu || this.getMenu();
  if (menu) {
    menu.hide();
  }
}, showMenu:function(e, menu) {
  var me = this, isPointerEvent = !e || e.pointerType, pressed;
  menu = menu || me.getMenu();
  me.setupMenuStretch(menu);
  if (menu) {
    if (menu.isVisible()) {
      if (isPointerEvent) {
        menu.hide();
      } else {
        menu.focus();
      }
    } else {
      menu.autoFocus = !isPointerEvent;
      if (menu.isMenu) {
        me.$buttonWasPressed = pressed = me.getPressed();
        menu.showBy(me.element, me.getMenuAlign());
        if (!pressed) {
          me.setPressed(true);
        }
      } else {
        if (menu.isViewportMenu) {
          menu.setDisplayed(!menu.getDisplayed());
        } else {
          menu.show();
        }
      }
    }
  }
}, doDestroy:function() {
  var me = this;
  if (me.hasOwnProperty('pressedTimeout')) {
    Ext.undefer(me.pressedTimeout);
  }
  me.setMenu(null);
  me.callParent();
}, getFocusClsEl:function() {
  return this.element;
}, privates:{setupMenuStretch:function(menu) {
  var me = this;
  if (!me.menuMinWidth) {
    if (me.getStretchMenu()) {
      menu.setMinWidth(me.el.measure('w'));
    } else {
      menu.setMinWidth(null);
    }
  }
}}});
Ext.define('Ext.theme.material.Button', {override:'Ext.Button', config:{ripple:{delegate:'.' + Ext.baseCSSPrefix + 'inner-el'}}, materialIconRe:/^md-icon[-|_](.*)/, applyIconCls:function(classList) {
  if (classList) {
    classList = Ext.dom.Element.splitCls(classList);
    var len = classList.length, i, cls, materialMatch;
    for (i = 0; i < len; i++) {
      cls = classList[i];
      materialMatch = cls && cls.match(this.materialIconRe);
      if (materialMatch && materialMatch.length > 1) {
        classList.unshift('md-icon');
        break;
      }
    }
    return classList.join(' ');
  }
  return classList;
}});
Ext.define('Ext.Title', {extend:Ext.Component, xtype:'title', config:{title:''}, baseCls:Ext.baseCSSPrefix + 'title', updateTitle:function(newTitle) {
  this.setHtml(newTitle);
}});
Ext.define('Ext.Spacer', {extend:Ext.Component, alias:'widget.spacer', config:{}, constructor:function(config) {
  config = config || {};
  if (!config.width) {
    config.flex = 1;
  }
  this.callParent([config]);
}});
Ext.define('Ext.Toolbar', {extend:Ext.Container, xtype:'toolbar', isToolbar:true, config:{title:null, defaultType:'button', defaultButtonUI:null, minHeight:null, layout:{type:'box', align:'center'}}, statics:{shortcuts:{'-\x3e':true}}, autoSize:null, border:false, classCls:Ext.baseCSSPrefix + 'toolbar', constructor:function(config) {
  config = config || {};
  if (config.docked == 'left' || config.docked == 'right') {
    config.layout = Ext.apply({type:'box', align:'stretch', vertical:true}, config.layout);
  }
  this.callParent([config]);
}, applyTitle:function(title) {
  if (typeof title == 'string') {
    title = {title:title, centered:true};
  }
  return Ext.factory(title, Ext.Title, this.getTitle());
}, updateTitle:function(newTitle, oldTitle) {
  if (newTitle) {
    this.add(newTitle);
  }
  if (oldTitle) {
    oldTitle.destroy();
  }
}, showTitle:function() {
  var title = this.getTitle();
  if (title) {
    title.show();
  }
}, hideTitle:function() {
  var title = this.getTitle();
  if (title) {
    title.hide();
  }
}, onItemAdd:function(item, index) {
  var defaultButtonUI = this.getDefaultButtonUI();
  if (defaultButtonUI) {
    if (item.isSegmentedButton) {
      if (item.getDefaultUI() == null) {
        item.setDefaultUI(defaultButtonUI);
      }
    } else {
      if (item.isButton && item.getUi() == null) {
        item.setUi(defaultButtonUI);
      }
    }
  }
  this.callParent([item, index]);
}, factoryItem:function(config) {
  if (config === '-\x3e') {
    config = {xtype:'component', flex:1};
  }
  return this.callParent([config]);
}});
Ext.define('Ext.Panel', function(Panel) {
  var platformTags = Ext.platformTags, isMacOrAndroid = platformTags.ios || platformTags.mac || platformTags.android;
  return {extend:Ext.Container, xtype:'panel', mixins:[Ext.mixin.Toolable], alternateClassName:'Ext.panel.Panel', defaultBindProperty:'title', isPanel:true, config:{headerPosition:'top', header:null, icon:null, iconCls:null, iconAlign:null, title:null, titleAlign:null, anchor:null, anchorPosition:null, closable:null, buttonAlign:null, buttonDefaults:null, standardButtons:{ok:{text:'OK', weight:isMacOrAndroid ? 120 : 10}, abort:{text:'Abort', weight:isMacOrAndroid ? 110 : 20}, retry:{text:'Retry', 
  weight:isMacOrAndroid ? 100 : 30}, ignore:{text:'Ignore', weight:isMacOrAndroid ? 90 : 40}, yes:{text:'Yes', weight:isMacOrAndroid ? 80 : 50}, no:{text:'No', weight:isMacOrAndroid ? 70 : 60}, cancel:{text:'Cancel', weight:isMacOrAndroid ? 60 : 70}, apply:{text:'Apply', weight:isMacOrAndroid ? 50 : 80}, save:{text:'Save', weight:isMacOrAndroid ? 40 : 90}, submit:{text:'Submit', weight:isMacOrAndroid ? 30 : 100}, help:{text:'Help', weight:isMacOrAndroid ? 10 : 110}, close:{text:'Close', weight:isMacOrAndroid ? 
  20 : 120}}, minButtonWidth:75, buttons:null, bbar:null, lbar:null, rbar:null, tbar:null}, cachedConfig:{border:false, bodyBorder:null, bodyPadding:null, bodyStyle:null, buttonToolbar:{xtype:'toolbar', itemId:'buttonToolbar', docked:'bottom', defaultType:'button', weighted:true, ui:'footer', defaultButtonUI:'action', layout:{type:'box', vertical:false, pack:'center'}}, closeAction:'destroy', closeToolText:'Close panel'}, classCls:Ext.baseCSSPrefix + 'panel', headerCls:null, titleCls:null, toolCls:Ext.baseCSSPrefix + 
  'paneltool', sideCls:{top:Ext.baseCSSPrefix + 'top', right:Ext.baseCSSPrefix + 'right', bottom:Ext.baseCSSPrefix + 'bottom', left:Ext.baseCSSPrefix + 'left'}, manageBorders:true, allowHeader:true, template:[{reference:'bodyWrapElement', cls:Ext.baseCSSPrefix + 'body-wrap-el', uiCls:'body-wrap-el', children:[{reference:'bodyElement', cls:Ext.baseCSSPrefix + 'body-el', uiCls:'body-el'}]}], addBodyCls:function(cls) {
    this.bodyElement.addCls(cls);
    return this;
  }, removeBodyCls:function(cls) {
    this.bodyElement.removeCls(cls);
    return this;
  }, applyBodyPadding:function(bodyPadding) {
    if (bodyPadding === true) {
      bodyPadding = 5;
    }
    if (bodyPadding) {
      bodyPadding = Ext.dom.Element.unitizeBox(bodyPadding);
    }
    return bodyPadding;
  }, applyBodyStyle:function(bodyStyle, oldBodyStyle) {
    if (oldBodyStyle && bodyStyle === oldBodyStyle && Ext.isObject(oldBodyStyle)) {
      bodyStyle = Ext.apply({}, bodyStyle);
    }
    this.bodyElement.applyStyles(bodyStyle);
    return null;
  }, getBodyStyle:function() {
    Ext.Error.raise("'bodyStyle' is a write-only config.  To query element styles use the Ext.dom.Element API.");
  }, addTool:function(tool) {
    var header = this.ensureHeader(), items;
    if (header) {
      items = this.createTools(Ext.Array.from(tool));
      if (items && items.length) {
        items = header.add(items);
      }
    }
    return items;
  }, applyHeader:function(newHeader, oldHeader) {
    var me = this, header = oldHeader, isTrue;
    me.allowHeader = newHeader !== false;
    if (oldHeader && !newHeader) {
      header = Ext.destroy(header);
    }
    if (newHeader && me.allowHeader) {
      isTrue = newHeader === true;
      if (header) {
        if (!isTrue) {
          header.setConfig(newHeader);
        }
      } else {
        if (isTrue) {
          newHeader = {};
        }
        newHeader.$initParent = me;
        header = Ext.factory(me.createHeader(newHeader));
        me.header = header;
        delete header.$initParent;
        delete newHeader.$initParent;
        header.ownerCmp = me;
        (me.maxHeightElement || me.el).insertFirst(header.el);
        header.doInheritUi();
      }
    }
    return header || null;
  }, updateHeader:function(header) {
    if (header) {
      this.positionHeader(header);
    } else {
      this.syncBorders();
    }
  }, applyTools:function(tools) {
    var header = this.ensureHeader(), items;
    if (header) {
      header.clearTools();
      items = this.createTools(tools);
      if (items && items.length) {
        header.add(items);
      }
    }
  }, close:function() {
    var me = this, action = me.getCloseAction(), destroy = action === 'destroy';
    if (me.fireEvent('beforeclose', me) !== false) {
      if (action && !destroy) {
        me[action]();
      }
      me.fireEvent('close', me);
      if (destroy) {
        me.destroy();
      }
    }
  }, createHeader:function(config) {
    var me = this, ret = {xtype:'panelheader', instanceCls:me.headerCls, docked:'top'}, icon, title;
    me._isCreatingHeader = true;
    if (config && config !== true) {
      Ext.merge(ret, config);
    }
    if (me.initialized) {
      title = me.getTitle();
      if (title != null) {
        if (typeof title === 'string') {
          title = {text:title};
        }
        Ext.merge(ret, {title:title});
      }
      icon = me.getIconCls();
      if (icon != null) {
        ret.iconCls = icon;
      } else {
        icon = me.getIcon();
        if (icon != null) {
          ret.icon = icon;
        }
      }
    }
    me._isCreatingHeader = false;
    return ret;
  }, applyAnchor:function(anchor, oldAnchor) {
    var me = this, el = me.el.dom, svgEl, pathEl;
    if (anchor) {
      if (oldAnchor) {
        return;
      } else {
        anchor = me.el.insertFirst({cls:Ext.baseCSSPrefix + 'anchor-el'});
        svgEl = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svgEl.setAttribute('class', Ext.baseCSSPrefix + 'pointer-el');
        pathEl = document.createElementNS('http://www.w3.org/2000/svg', 'path');
        svgEl.appendChild(pathEl);
        anchor.dom.appendChild(svgEl);
      }
      el.style.overflow = 'visible';
    } else {
      if (oldAnchor) {
        me.anchorSize = oldAnchor.destroy();
        el.style.overflow = '';
      }
    }
    return anchor;
  }, initAnchor:function() {
    var me = this, el = me.el, anchor = me.getAnchor(), cls = me.sideCls.top, svgEl = anchor.dom.firstChild, pathEl = svgEl.firstChild, anchorSize;
    anchor.addCls(cls);
    anchor.show();
    anchorSize = anchor.measure();
    me.anchorSize = anchorSize = new Ext.util.Offset(anchorSize.width, anchorSize.height);
    me.anchorMargin = parseFloat(anchor.getStyle('marginLeft')) || 0;
    anchor.dom.style.margin = '0';
    svgEl.setAttribute('height', anchorSize.y);
    svgEl.setAttribute('width', anchorSize.x);
    pathEl.setAttribute('d', 'M0 ' + anchorSize.y + ' L' + anchorSize.x / 2 + ' 0.5 L' + anchorSize.x + ' ' + anchorSize.y);
    anchorSize.y -= parseFloat(Ext.fly(pathEl).getStyle('stroke-width'));
    anchor.removeCls(cls);
    anchor.hide();
  }, updateAnchorPosition:function(anchorPosition, oldAnchorPosition) {
    var me = this, anchorEl = me.getAnchor(), sideCls = me.sideCls, el = me.el;
    if (anchorEl) {
      if (oldAnchorPosition) {
        anchorEl.removeCls(sideCls[oldAnchorPosition.side]);
      }
      if (anchorPosition) {
        anchorEl.addCls(sideCls[anchorPosition.side]);
        anchorEl.translate(anchorPosition.x, anchorPosition.y);
        anchorEl.show();
      } else {
        anchorEl.hide();
      }
    }
  }, updateBorder:function(border, oldBorder) {
    var me = this;
    me.callParent([border, oldBorder]);
    if (me.getBodyBorder() === null) {
      me.setBodyBorderEnabled(border !== false);
    }
    me.syncBorders();
  }, updateBodyPadding:function(newBodyPadding) {
    this.bodyElement.setStyle('padding', newBodyPadding);
  }, updateBodyBorder:function(bodyBorder) {
    var me = this;
    bodyBorder = bodyBorder === null ? me.getBorder() : bodyBorder;
    me.setBodyBorderEnabled(bodyBorder !== false);
    me.syncBorders();
  }, updateClosable:function(closable) {
    var me = this, tools;
    if (closable) {
      tools = me.addTool({type:'close', weight:1000, scope:me, handler:'onCloseTool', tooltip:me.getCloseToolText(), $internal:true});
      if (tools && tools.length) {
        me.closeTool = tools[0];
      }
    } else {
      Ext.destroy(me.closeTool);
    }
  }, updateHeaderPosition:function(headerPosition, oldHeaderPosition) {
    this.moveHeaderPosition(headerPosition, oldHeaderPosition);
  }, updateIcon:function(icon) {
    var header = this.ensureHeader();
    if (header) {
      header.setIcon(icon);
    }
  }, updateIconCls:function(iconCls) {
    var header = this.ensureHeader();
    if (header) {
      header.setIconCls(iconCls);
    }
  }, updateIconAlign:function(iconAlign) {
    var header = this.ensureHeader();
    if (header) {
      header.setIconAlign(iconAlign);
    }
  }, applyBbar:function(toolbar, previous) {
    return this.normalizeDockedBars(toolbar, previous, 'bottom');
  }, updateButtonAlign:function(buttonAlign) {
    var pack;
    if (buttonAlign && this._buttons) {
      pack = this._packButtonAlign[buttonAlign];
      if (pack) {
        this._buttons.getLayout().setPack(pack);
      }
    }
  }, applyButtons:function(buttons, oldButtons) {
    var me = this, array = Ext.convertKeyedItems(buttons, 'xxx', 'xxx'), buttonDefaults = me.getButtonDefaults(), standardButtons = me.getStandardButtons(), toolbar = me.getButtonToolbar(), n = array ? array.length : 0, button, defaults, handler, i;
    if (buttons && typeof buttons === 'object') {
      if (buttons.xtype || buttons.itemId || buttons.items || buttons.reference) {
        return me.normalizeDockedBars(buttons, oldButtons, 'bottom', toolbar);
      }
    }
    if (buttons) {
      if (array === buttons) {
        array = [];
        for (i = 0; i < n; ++i) {
          button = buttons[i];
          if (typeof button === 'string') {
            if (!Ext.Toolbar.shortcuts[button]) {
              button = Ext.applyIf({itemId:button, text:button}, buttonDefaults);
            }
          } else {
            if (buttonDefaults) {
              button = Ext.apply({}, button, buttonDefaults);
            }
          }
          array[i] = button;
        }
      } else {
        for (i = 0; i < n; ++i) {
          button = array[i];
          handler = button.xxx;
          defaults = standardButtons[button.itemId];
          if (defaults) {
            Ext.applyIf(button, defaults);
          } else {
            if (handler) {
              Ext.raise('Button handler short-hand is only valid for standardButtons');
            }
          }
          if (handler) {
            delete button.xxx;
            button.handler = handler;
          }
          if (buttonDefaults) {
            Ext.applyIf(button, buttonDefaults);
          }
        }
      }
    }
    return me.normalizeDockedBars(array, oldButtons, 'bottom', toolbar);
  }, applyLbar:function(toolbar, previous) {
    return this.normalizeDockedBars(toolbar, previous, 'left');
  }, applyRbar:function(toolbar, previous) {
    return this.normalizeDockedBars(toolbar, previous, 'right');
  }, applyTbar:function(toolbar, previous) {
    return this.normalizeDockedBars(toolbar, previous, 'top');
  }, updateTitle:function(title) {
    var header = this.ensureHeader(), tab = this.tab;
    if (header) {
      header.setTitle(title);
    }
    if (tab && tab.isTab && !tab.destroying && !tab.destroyed) {
      tab.setText(title);
    }
  }, updateTitleAlign:function(titleAlign) {
    var header = this.ensureHeader();
    if (header) {
      header.setTitleAlign(titleAlign);
    }
  }, updateUi:function(ui, oldUi) {
    this.callParent([ui, oldUi]);
    if (this.hasResizable) {
      this.onResizableUiChange(ui, oldUi);
    }
    this.anchorSize = null;
  }, alignTo:function(component, alignment, options) {
    var me = this, anchorElement = me.getAnchor(), config = me.initialConfig, positioned = me.isPositioned(), setX = positioned ? me.setLeft : me.setX, setY = positioned ? me.setTop : me.setY, x, y, target, anchorMargin, alignmentInfo, resultRegion, oldHeight, parent;
    if (anchorElement) {
      if (!me.anchorSize) {
        me.initAnchor();
      }
    } else {
      return me.callParent([component, alignment, options]);
    }
    anchorMargin = me.anchorMargin;
    target = component.isRegion ? component : (component.isWidget ? component.el : Ext.fly(component)).getRegion();
    target.adjust(-anchorMargin, anchorMargin, anchorMargin, -anchorMargin);
    alignmentInfo = me.getAlignmentInfo(target, alignment);
    if (alignmentInfo.isAligned) {
      return;
    }
    parent = me.getParent();
    if (!me.getFloated()) {
      if (!parent) {
        me.setFloated(true);
      } else {
        me.positioned = true;
      }
    }
    if ('unconstrainedWidth' in me) {
      me.setWidth(me.unconstrainedWidth);
    }
    if ('unconstrainedHeight' in me) {
      me.setHeight(me.unconstrainedHeight);
    }
    me.alignToArgs = [component, alignment, options];
    resultRegion = me.getAlignRegion(target, alignment, Ext.apply({anchorSize:me.anchorSize, axisLock:me.getAxisLock()}, options));
    if (resultRegion) {
      setX.call(me, resultRegion.x);
      setY.call(me, resultRegion.y);
      if (resultRegion.constrainWidth) {
        me.unconstrainedWidth = config.width || me.self.prototype.width;
        oldHeight = me.el.getHeight();
        me.setWidth(alignmentInfo.stats.width = resultRegion.getWidth());
        if (resultRegion.align.position === 0) {
          setY.call(me, resultRegion.y + (oldHeight - me.el.getHeight()));
        }
      }
      if (resultRegion.constrainHeight) {
        me.unconstrainedHeight = config.height || me.self.prototype.height;
        me.setHeight(alignmentInfo.stats.height = resultRegion.getHeight());
      }
      if (resultRegion.anchor) {
        x = 0;
        y = 0;
        if (resultRegion.anchor.align & 1) {
          y = resultRegion.anchor.y - resultRegion.y;
        } else {
          x = resultRegion.anchor.x - resultRegion.x;
        }
        me.setAnchorPosition({side:resultRegion.anchor.position, x:x, y:y});
      } else {
        me.setAnchorPosition(null);
      }
      me.setCurrentAlignmentInfo(alignmentInfo);
    } else {
      if (anchorElement) {
        anchorElement.show();
      }
    }
    if (!me.viewportResizeListener) {
      me.viewportResizeListener = Ext.on({resize:'onViewportResize', scope:me, destroyable:true});
    }
  }, getRefItems:function(deep) {
    var items = this.callParent([deep]), header = this.getConfig('header', false, true);
    if (header) {
      if (deep && header.getRefItems) {
        items.unshift.apply(items, header.getRefItems(deep));
      }
      items.unshift(header);
    }
    return items;
  }, onCloseTool:function() {
    this.close();
  }, onRender:function() {
    var me = this, header;
    me.callParent();
    header = me.getHeader();
    if (header) {
      header.setRendered(true);
    }
    if (me.hasCollapsible) {
      me.onCollapsibleRendered();
    }
  }, doDestroy:function() {
    Ext.destroy(this.header, this.anchor);
    this.callParent();
  }, privates:{headerPositionMap:{top:{cls:Ext.baseCSSPrefix + 'header-position-top', dom:0, horz:true}, right:{cls:Ext.baseCSSPrefix + 'header-position-right', dom:1, vert:true}, bottom:{cls:Ext.baseCSSPrefix + 'header-position-bottom', dom:1, horz:true}, left:{cls:Ext.baseCSSPrefix + 'header-position-left', dom:0, vert:true}}, ensureHeader:function() {
    var me = this, header;
    if (!me._isCreatingHeader) {
      me.getItems();
      header = me.getHeader();
      if (!header && me.allowHeader) {
        me.setHeader(true);
        header = me.getHeader();
      }
    }
    return header;
  }, moveHeaderPosition:function(headerPosition, oldHeaderPosition) {
    var me = this, el = me.element, map = me.headerPositionMap, oldItem = map[oldHeaderPosition], newItem = map[headerPosition], oldCls = oldItem ? oldItem.cls : '', newCls = newItem.cls, positionedHeader, header;
    if (oldCls !== newCls) {
      if (oldHeaderPosition) {
        el.removeCls(oldCls);
      }
      el.addCls(newCls);
    }
    if (oldHeaderPosition || headerPosition !== 'top') {
      header = me.ensureHeader();
      if (header) {
        if (!me.isConfiguring) {
          me.positionHeader(header, headerPosition);
          positionedHeader = true;
        }
      }
    }
    if (!positionedHeader) {
      me.syncBorders();
    }
    return header;
  }, _packButtonAlign:{left:'start', right:'end', center:'center'}, normalizeDockedBars:function(toolbar, previous, pos, buttonToolbarCfg, disableFocusableContainer) {
    if (!toolbar) {
      if (previous) {
        previous.destroy();
      }
      return toolbar;
    }
    var me = this, isComponent = toolbar.isComponent, buttonAlign, buttonToolbarDefaults, index, layout, minButtonWidth, pack;
    if (Ext.isArray(toolbar)) {
      toolbar = {xtype:'toolbar', items:toolbar};
    } else {
      if (!isComponent) {
        toolbar = Ext.clone(toolbar);
      }
    }
    if (!toolbar.xtype) {
      toolbar.xtype = 'toolbar';
    }
    if (isComponent) {
      toolbar.setDocked(pos);
    } else {
      toolbar.docked = pos;
    }
    if (disableFocusableContainer) {
      if (isComponent) {
        toolbar.setEnableFocusableContainer(false);
      } else {
        toolbar.enableFocusableContainer = false;
      }
    }
    if (buttonToolbarCfg && !isComponent) {
      toolbar = Ext.merge(Ext.clone(buttonToolbarCfg), toolbar);
      toolbar.layout = Ext.merge(layout = {}, toolbar.layout);
      buttonAlign = me.getButtonAlign();
      if (buttonAlign) {
        pack = me._packButtonAlign[buttonAlign];
        if (pack) {
          layout.pack = pack;
        }
      }
      minButtonWidth = this.getMinButtonWidth();
      buttonToolbarDefaults = toolbar.defaults;
      toolbar.defaults = function(config) {
        var defaults = buttonToolbarDefaults || {}, isButton = !config.xtype || config.isButton, cls;
        if (!isButton) {
          cls = Ext.ClassManager.getByAlias('widget.' + config.xtype);
          if (cls) {
            isButton = cls.prototype.isButton;
          }
        }
        if (isButton && minButtonWidth && !('minWidth' in defaults)) {
          defaults = Ext.apply({minWidth:minButtonWidth}, defaults);
        }
        return defaults;
      };
    }
    if (previous) {
      index = me.indexOf(previous);
      previous.destroy();
      toolbar = me.insert(index, toolbar);
    } else {
      toolbar = me.add(toolbar);
    }
    return toolbar;
  }, positionHeader:function(header, position) {
    var me = this, pos = position || me.getHeaderPosition();
    header.setPosition(pos);
    me.syncBorders();
  }, setBodyBorderEnabled:function(enabled) {
    this.bodyElement.setStyle('border-width', enabled ? '' : '0');
  }, syncBorders:function() {
    if (!this.isConfiguring) {
      this.getLayout().handleDockedItemBorders(true);
    }
  }}};
});
Ext.define('Ext.theme.material.Panel', {override:'Ext.Panel', config:{buttonAlign:'right', buttonToolbar:{defaultButtonUI:null}}});
Ext.define('Ext.Mask', {extend:Ext.Component, xtype:'mask', config:{transparent:false, top:0, left:0, right:0, bottom:0}, baseCls:Ext.baseCSSPrefix + 'mask', initialize:function() {
  var me = this;
  me.callParent();
  me.element.on('tap', 'onTap', me);
  me.on('hide', 'onHide', me);
}, onHide:function() {
  Ext.util.InputBlocker.unblockInputs();
  if (Ext.browser.is.AndroidStock4 && Ext.os.version.getMinor() === 0) {
    var firstChild = this.element.getFirstChild();
    if (firstChild) {
      firstChild.redraw();
    }
  }
}, onTap:function(e) {
  this.fireEvent('tap', this, e);
}, updateTransparent:function(transparent) {
  this.toggleCls(this.baseCls + '-transparent', transparent);
}});
Ext.define('Ext.Sheet', {extend:Ext.Panel, xtype:'sheet', isViewportMenu:false, hidden:true, config:{reveal:null, cover:null, side:null, stretchX:null, stretchY:null, enter:'bottom', exit:'bottom'}, translatable:{type:'csstransform'}, showAnimation:{type:'slideIn', duration:250, easing:'ease-out'}, hideAnimation:{type:'slideOut', duration:250, easing:'ease-in'}, modal:true, hideOnMaskTap:true, centered:true, classCls:Ext.baseCSSPrefix + 'sheet', manageBorders:false, autoSize:null, border:true, bodyBorder:false, 
floated:true, isInputRegex:/^(input|textarea|select|a)$/i, destroy:function() {
  var me = this;
  me.setSide(null);
  me.callParent();
}, applyHideAnimation:function(config) {
  var exit = this.getExit(), direction = exit;
  if (exit === null) {
    return null;
  }
  if (config === true) {
    config = {type:'slideOut'};
  }
  var anim = this.callParent([config]);
  if (anim) {
    if (exit === 'bottom') {
      direction = 'down';
    } else {
      if (exit === 'top') {
        direction = 'up';
      }
    }
    anim.setDirection(direction);
  }
  return anim;
}, applyShowAnimation:function(config) {
  var enter = this.getEnter(), direction = enter;
  if (enter === null) {
    return null;
  }
  if (config === true) {
    config = {type:'slideIn'};
  }
  var anim = this.callParent([config]);
  if (anim) {
    if (enter === 'bottom') {
      direction = 'down';
    }
    if (enter === 'top') {
      direction = 'up';
    }
    anim.setBefore({display:null});
    anim.setReverse(true);
    anim.setDirection(direction);
  }
  return anim;
}, hide:function(animation) {
  var side = this.getSide();
  if (side) {
    Ext.Viewport.hideMenu(side, animation);
  } else {
    this.callParent([animation]);
  }
}, show:function(animation, options) {
  var me = this, VP = Ext.Viewport, side = options && 'side' in options ? options.side : me.getSide();
  if (side) {
    VP.setMenu(me);
    VP.showMenu(side);
  } else {
    me.callParent([animation, options]);
  }
}, updateSide:function(newSide, oldSide) {
  var me = this, reShow = !me.isConfiguring && me.isVisible();
  me.isViewportMenu = !!newSide;
  if (oldSide) {
    Ext.Viewport.removeMenu(oldSide);
  }
  if (newSide) {
    Ext.Viewport.setMenu(me, {side:newSide});
    if (reShow) {
      me.show();
    }
  }
}, updateStretchX:function(newStretchX) {
  this.getLeft();
  this.getRight();
  if (newStretchX) {
    this.setLeft(0);
    this.setRight(0);
  }
}, updateStretchY:function(newStretchY) {
  this.getTop();
  this.getBottom();
  if (newStretchY) {
    this.setTop(0);
    this.setBottom(0);
  }
}});
Ext.define('Ext.Dialog', {extend:Ext.Panel, xtype:['dialog', 'window'], alternateClassName:['Ext.Window', 'Ext.window.Window'], isDialog:true, isWindow:true, ariaRole:'dialog', classCls:Ext.baseCSSPrefix + 'dialog', cachedConfig:{dismissAction:['cancel', 'abort', 'no', 'close'], maximizeAnimation:{easing:'ease-in', from:{opacity:0.6}, to:{opacity:1}}, maximizeProxy:{centered:false, draggable:false, modal:false, showAnimation:null, hideAnimation:null}, maximizeTool:{itemId:'maximize', tooltip:'Maximize to fullscreen'}, 
restoreAnimation:{easing:'ease-in', from:{opacity:1}, to:{opacity:0.6}}, restoreTool:{itemId:'restore', tooltip:'Restore to original size'}}, config:{constrainDrag:true, dismissHandler:null, maximizable:null, maximized:null, maskTapHandler:null, restorable:null}, border:true, bodyBorder:false, centered:true, floated:true, focusable:false, tabIndex:-1, draggable:{handle:'.' + Ext.baseCSSPrefix + 'draggable', listeners:{beforedragstart:'onBeforeDragDialog', scope:'this'}}, keyMap:{ESC:'onEscape', scope:'this'}, 
modal:true, shadow:true, headerCls:Ext.baseCSSPrefix + 'dialogheader', titleCls:Ext.baseCSSPrefix + 'dialogtitle', toolCls:[Ext.baseCSSPrefix + 'paneltool', Ext.baseCSSPrefix + 'dialogtool'], hideMode:'offsets', hideAnimation:{type:'popOut', duration:250, easing:'ease-out'}, showAnimation:{type:'popIn', duration:150, easing:'ease-out'}, initialize:function() {
  var me = this;
  me.callParent();
  if (me.tabGuard) {
    me.addPlugin({type:'tabguard', tabGuardBeforeIndex:me.tabGuardBeforeIndex, tabGuardAfterIndex:me.tabGuardAfterIndex});
  }
}, doDestroy:function() {
  Ext.destroy(this.maximizeTool, this.restoreTool);
  this.callParent();
}, close:function(event) {
  var me = this, buttons = me.getButtons(), actions = me.getDismissAction(), handler = me.getDismissHandler(), action, closeAction, closeActionIsDestroy, done, i, n;
  event = event || null;
  if (me.fireEvent('beforeclose', me, event) !== false) {
    if (handler !== true) {
      if (handler) {
        Ext.callback(handler, null, [me, event], 0, me);
        done = true;
      } else {
        if (actions && buttons) {
          if (typeof actions === 'string') {
            actions = [actions];
          }
          for (i = 0, n = actions.length; i < n; ++i) {
            action = buttons.getComponent(actions[i]);
            if (action && action.isButton) {
              action.onTap(event);
              done = true;
              break;
            }
          }
        }
      }
    }
    if (!done) {
      closeAction = me.getCloseAction();
      if (closeAction) {
        if (!(closeActionIsDestroy = closeAction === 'destroy')) {
          me[closeAction]();
        }
      }
    }
    if (!me.destroyed) {
      me.fireEvent('close', me, event);
      if (closeActionIsDestroy) {
        me.destroy();
      }
    }
  }
}, createMaximizeProxy:function(config) {
  var me = this;
  return Ext.apply({title:me.getTitle(), cls:me.getCls(), userCls:me.getUserCls(), iconCls:me.getIconCls(), ui:me.getUi()}, config);
}, maximize:function(animation) {
  var me = this, maximizing = me.maximizing;
  if (!maximizing && !me.getMaximized()) {
    me._maximizeAnim = animation;
    me.setMaximized(true);
    if (!(maximizing = me.maximizing)) {
      return Ext.Promise.resolve(false);
    }
  }
  return maximizing ? maximizing.promise : Ext.Promise.resolve(true);
}, restore:function(animation) {
  var me = this, restoring = me.restoring;
  if (!restoring && me.getMaximized()) {
    me._maximizeAnim = animation;
    me.setMaximized(false);
    if (!(restoring = me.restoring)) {
      return Ext.Promise.resolve(false);
    }
  }
  return restoring ? restoring.promise : Ext.Promise.resolve(true);
}, shouldRecenter:function() {
  return !this.getMaximized() && this.callParent();
}, updateConstrainDrag:function(constrain) {
  var dragger = this.getDraggable();
  if (dragger) {
    if (constrain === true) {
      constrain = Ext.getBody();
    }
    dragger.setConstrain(constrain);
  }
}, updateDraggable:function(draggable, existing) {
  this.callParent([draggable, existing]);
  if (!this.isConfiguring) {
    this.syncHeaderItems();
  }
}, updateHeader:function(header, oldHeader) {
  var me = this, beforeGuard;
  me.callParent([header, oldHeader]);
  if (header) {
    me.syncHeaderItems();
    if (me.tabGuard && me.getTabGuard) {
      beforeGuard = me.getTabGuard('before');
      if (beforeGuard && beforeGuard.dom) {
        beforeGuard.insertBefore(header.el);
      }
    }
  }
}, applyMaximizable:function(maximizable) {
  var me = this;
  me.maximizeTool = Ext.updateWidget(me.maximizeTool, maximizable, me, 'createMaximizeTool', 'maximizeTool');
  me.syncHeaderItems();
  return maximizable;
}, applyMaximized:function(maximized) {
  var me = this, event;
  if (!me.isConfiguring) {
    event = maximized ? 'beforemaximize' : 'beforerestore';
    if (me.fireEvent(event, me) === false) {
      me._maximizeAnim = undefined;
      return;
    }
  }
  return !!maximized;
}, updateMaximized:function(maximized) {
  var me = this, el = me.el, maximizedCls = me.maximizedCls, maximizeTool = me.maximizeTool, pendingName = maximized ? 'restoring' : 'maximizing', pending = me[pendingName], after, anim, before, center;
  if (me.isConfiguring) {
    me.needsCenter = maximized;
  } else {
    anim = me._maximizeAnim;
    center = me.needsCenter && !maximized;
    me.needsCenter = false;
    if (anim === undefined) {
      anim = me[maximized ? 'getMaximizeAnimation' : 'getRestoreAnimation']();
    }
  }
  me._maximizeAnim = undefined;
  if (pending) {
    pending.destroy();
  }
  if (me.getMaximizable()) {
    me.setRestorable(maximized);
  } else {
    me.syncHeaderItems();
  }
  if (maximizeTool) {
    maximizeTool.setHidden(maximized);
  }
  if (!anim) {
    el.toggleCls(maximizedCls, maximized);
    if (center) {
      me.center();
    }
    me.fireEvent(maximized ? 'maximize' : 'restore', me);
  } else {
    if (maximized) {
      pendingName = 'maximizing';
      before = me.captureSize();
      after = me.captureSize(true);
    } else {
      pendingName = 'restoring';
      el.removeCls(maximizedCls);
      if (center) {
        me.center();
      }
      before = me.captureSize(true);
      after = me.captureSize();
    }
    me[pendingName] = me.animateMaximizeRestore(before, after, anim, function() {
      if (maximized) {
        el.addCls(maximizedCls);
      }
      me[pendingName] = null;
      me.fireEvent(maximized ? 'maximize' : 'restore', me);
    });
  }
}, createMaximizeTool:function(config) {
  var tool = this.adjustToolDefaults(Ext.clone(config));
  tool.handler = 'onMaximize';
  tool.scope = this;
  return tool;
}, applyRestorable:function(restorable) {
  var me = this;
  me.restoreTool = Ext.updateWidget(me.restoreTool, restorable, me, 'createRestoreTool', 'restoreTool');
  me.syncHeaderItems();
  return restorable;
}, createRestoreTool:function(config) {
  var tool = this.adjustToolDefaults(Ext.clone(config));
  tool.handler = 'onRestore';
  tool.scope = this;
  return tool;
}, afterShow:function() {
  this.callParent();
  if (this.getModal()) {
    this.focus();
  }
}, onBeforeDragDialog:function(draggable, info, event) {
  var header = this.getHeader();
  if (!header || !header.el.contains(event.target)) {
    return false;
  }
}, onCloseTool:function(dialog, tool, event) {
  this.close(event);
}, onEscape:function(event) {
  this.close(event);
}, onMaximize:function() {
  this.setMaximized(true);
}, onRestore:function() {
  this.setMaximized(false);
}, onModalMaskTap:function(e) {
  var me = this, handler = me.getMaskTapHandler(), ret;
  if (handler) {
    Ext.callback(handler, null, [me, e], 0, me);
  } else {
    ret = me.callParent([e]);
  }
  return ret;
}, privates:{draggableCls:Ext.baseCSSPrefix + 'draggable', needsCenter:false, maximizedCls:Ext.baseCSSPrefix + 'maximized', animateMaximizeRestore:function(before, after, anim, callback) {
  var me = this, pending = new Ext.Deferred, proxy = me.getMaximizeProxy(), a = Ext.merge({from:{width:before.w + 'px', height:before.h + 'px', transform:{translateX:before.x + 'px', translateY:before.y + 'px'}}, to:{width:after.w + 'px', height:after.h + 'px', transform:{translateX:after.x + 'px', translateY:after.y + 'px'}}}, anim);
  proxy = me.createMaximizeProxy(proxy);
  proxy = new me.self(proxy);
  proxy.show();
  a.element = proxy.el;
  a.callback = function() {
    proxy.destroy();
    callback();
    pending.resolve(true);
  };
  a = new Ext.fx.animation.Abstract(a);
  Ext.Animator.run(a);
  pending.destroy = function() {
    pending.destroy = Ext.emptyFn;
    a.destroy();
    pending.destroyed = true;
  };
  return pending;
}, captureSize:function(maximized) {
  if (maximized) {
    return {x:0, y:0, w:Ext.getViewportWidth(), h:Ext.getViewportHeight()};
  }
  var me = this, size = me.el.measure();
  return {x:me.getX(), y:me.getY(), w:size.width, h:size.height};
}, syncHeaderItems:function() {
  var me = this, maximizeTool = me.maximizeTool, restoreTool = me.restoreTool, header = maximizeTool || restoreTool ? me.ensureHeader() : me.getHeader(), draggableCls = me.draggableCls, draggable, title;
  if (header) {
    draggable = me.getDraggable() && !me.getMaximized();
    header.toggleCls(draggableCls, draggable);
    title = header.getTitle();
    if (title) {
      title.toggleCls(draggableCls, draggable);
    }
    if (maximizeTool && maximizeTool.parent !== header) {
      header.add(maximizeTool);
    }
    if (restoreTool && restoreTool.parent !== header) {
      header.add(restoreTool);
    }
  }
}, updateX:function(x, oldX) {
  this.callParent([x, oldX]);
  if (!this._centering && this.getCentered()) {
    this.setCentered(false);
  }
}}});
Ext.define('Ext.field.Field', {extend:Ext.Component, alternateClassName:'Ext.form.Field', xtype:'field', isField:true, isFormField:true, cachedConfig:{bodyAlign:'start', labelAlign:'left', labelCls:null, labelTextAlign:'left', labelWidth:null, labelMinWidth:null, labelWrap:false}, config:{name:null, label:null, required:false, requiredMessage:'This field is required', value:null, validators:null, validationMessage:'Is in the wrong format', validateDisabled:null, autoFitErrors:null, inline:null, error:null, 
errorMessage:null, errorTarget:'qtip', errorTpl:null, errorTip:null, sideError:null, tipError:null, titleError:null, underError:null}, htmlErrorsTpl:['\x3ctpl if\x3d"count \x3d\x3d 1"\x3e', '\x3ctpl for\x3d"errors"\x3e{.:htmlEncode}\x3c/tpl\x3e', '\x3ctpl elseif\x3d"count"\x3e', '\x3cul class\x3d"{listCls}"\x3e', '\x3ctpl for\x3d"errors"\x3e\x3cli\x3e{.:htmlEncode}\x3c/li\x3e\x3c/tpl\x3e', '\x3c/ul\x3e', '\x3c/tpl\x3e'], plainErrorsTpl:['\x3ctpl if\x3d"count"\x3e', '\x3ctpl for\x3d"errors" between\x3d"\\n"\x3e{.}\x3c/tpl\x3e', 
'\x3c/tpl\x3e'], _errorTplMap:{title:'plainErrorsTpl'}, originalValue:null, focusable:true, classCls:Ext.baseCSSPrefix + 'field', requiredCls:Ext.baseCSSPrefix + 'required', noLabelWrapCls:Ext.baseCSSPrefix + 'no-label-wrap', invalidCls:Ext.baseCSSPrefix + 'invalid', noAutoFitErrorsCls:Ext.baseCSSPrefix + 'no-auto-fit-errors', inlineCls:Ext.baseCSSPrefix + 'inline', labelAlignVerticalCls:Ext.baseCSSPrefix + 'label-align-vertical', labelAlignHorizontalCls:Ext.baseCSSPrefix + 'label-align-horizontal', 
labeledCls:Ext.baseCSSPrefix + 'labeled', verticalLabelMap:{top:1, placeholder:1, bottom:1}, horizontalLabelMap:{left:1, right:1}, nameable:true, validateOnInit:'auto', errorElement:null, errorIconElement:null, errorMessageElement:null, element:{reference:'element', classList:[Ext.supports.CSSMinContent ? '' : Ext.baseCSSPrefix + 'no-min-content', Ext.supports.PercentageSizeFlexBug ? Ext.baseCSSPrefix + 'has-percentage-size-flex-bug' : '']}, initialize:function() {
  var me = this;
  me.callParent();
  if (me.getValue() === '' && me.validateOnInit === 'all') {
    me.validate();
  }
}, didValueChange:function(newVal, oldVal) {
  return !this.isEqual(newVal, oldVal);
}, getTemplate:function() {
  return [{reference:'labelElement', cls:Ext.baseCSSPrefix + 'label-el', tag:'label', children:[{reference:'labelTextElement', cls:Ext.baseCSSPrefix + 'label-text-el', tag:'span'}]}, {reference:'bodyWrapElement', cls:Ext.baseCSSPrefix + 'body-wrap-el', children:[{reference:'bodyElement', cls:Ext.baseCSSPrefix + 'body-el', children:this.getBodyTemplate()}, {reference:'errorElement', cls:Ext.baseCSSPrefix + 'error-el', children:[{reference:'errorIconElement', cls:Ext.baseCSSPrefix + 'error-icon-el ' + 
  Ext.baseCSSPrefix + 'font-icon'}, {reference:'errorMessageElement', cls:Ext.baseCSSPrefix + 'error-message-el'}]}]}];
}, getBodyTemplate:Ext.emptyFn, initElement:function() {
  this.callParent();
  this.innerElement = this.innerElement || this.bodyElement;
}, onFocusLeave:function(e) {
  this.callParent([e]);
  this.completeEdit();
}, completeEdit:Ext.emptyFn, updateBodyAlign:function(bodyAlign, oldBodyAlign) {
  var element = this.element;
  if (oldBodyAlign) {
    element.removeCls(Ext.baseCSSPrefix + 'body-align-' + oldBodyAlign);
  }
  if (bodyAlign) {
    element.addCls(Ext.baseCSSPrefix + 'body-align-' + bodyAlign);
  }
}, updateAutoFitErrors:function(autoFitErrors) {
  this.toggleCls(this.noAutoFitErrorsCls, autoFitErrors === false);
}, applyErrorTpl:function(tpl) {
  if (tpl && !tpl.isTemplate) {
    tpl = Ext.XTemplate.get(tpl);
  }
  return tpl;
}, formatErrors:function(errors) {
  var me = this, tpl = me.getErrorTpl();
  if (!tpl) {
    tpl = me.lookupTpl(me._errorTplMap[me.getErrorTarget()] || 'htmlErrorsTpl');
  }
  return tpl.apply({count:errors ? errors.length : 0, label:me.getLabel(), errors:errors});
}, updateError:function(value) {
  var msg = this.formatErrors(Ext.Array.from(value));
  this.setErrorMessage(msg);
}, updateErrorMessage:function(msg) {
  var me = this, errorTarget;
  me.fireEvent('errorchange', me, msg);
  if (me.preventMark) {
    return;
  }
  me.toggleInvalidCls(!!msg);
  errorTarget = me.getErrorTarget();
  switch(errorTarget) {
    case 'side':
      me.setSideError(msg);
      break;
    case 'qtip':
      me.setTipError(msg);
      break;
    case 'title':
      me.setTitleError(msg);
      break;
    case 'under':
      me.setUnderError(msg);
      break;
    case 'parent':
      var owner = me.up('[onFieldErrorChange]');
      if (owner) {
        owner.onFieldErrorChange(me, msg);
      }
      break;
  }
}, updateErrorTarget:function(target, oldTarget) {
  var me = this, error, owner;
  if (oldTarget) {
    me.removeCls(Ext.baseCSSPrefix + 'error-target-' + oldTarget);
    if (oldTarget === 'qtip') {
      me.setTipError(null);
    } else {
      if (oldTarget === 'title') {
        me.setTitleError(null);
      } else {
        if (oldTarget === 'side') {
          me.setSideError(null);
        } else {
          if (oldTarget === 'under') {
            me.setUnderError(null);
          } else {
            if (oldTarget === 'parent') {
              owner = me.up('[onFieldErrorChange]');
              if (owner) {
                owner.onFieldErrorChange(me);
              }
            }
          }
        }
      }
    }
  }
  if (target) {
    me.addCls(Ext.baseCSSPrefix + 'error-target-' + target);
    if (!me.isConfiguring) {
      error = me.getError();
      if (error) {
        if (target === 'qtip') {
          me.setTipError(error);
        } else {
          if (target === 'title') {
            me.setTitleError(error);
          } else {
            if (target === 'side') {
              me.setSideError(error);
            } else {
              if (target === 'under') {
                me.setUnderError(error);
              } else {
                if (target === 'parent') {
                  owner = me.up('[onFieldErrorChange]');
                  if (owner) {
                    owner.onFieldErrorChange(me, error);
                  }
                }
              }
            }
          }
        }
      }
    }
  }
}, updateInline:function(inline) {
  this.toggleCls(this.inlineCls, inline);
}, updateSideError:function(error) {
  if (error) {
    error = Ext.apply({html:error}, this.getErrorTip());
  }
  this.errorElement.getData().qtip = error;
}, updateTipError:function(error) {
  if (error) {
    error = Ext.apply({html:error}, this.getErrorTip());
  }
  this.bodyElement.getData().qtip = error;
}, updateTitleError:function(error) {
  var dom = this.el.dom;
  if (error) {
    dom.setAttribute('title', error);
  } else {
    dom.removeAttribute('title');
  }
}, updateUnderError:function(error) {
  this.errorMessageElement.dom.innerHTML = error || '';
}, updateLabel:function(label) {
  this.labelTextElement.setHtml(label);
  this.el.toggleCls(this.labeledCls, !!label);
}, updateLabelAlign:function(newLabelAlign, oldLabelAlign) {
  var me = this, element = me.element;
  if (oldLabelAlign) {
    element.removeCls(Ext.baseCSSPrefix + 'label-align-' + oldLabelAlign);
  }
  if (newLabelAlign) {
    element.addCls(Ext.baseCSSPrefix + 'label-align-' + newLabelAlign);
  }
  element.toggleCls(me.labelAlignVerticalCls, newLabelAlign in me.verticalLabelMap);
  element.toggleCls(me.labelAlignHorizontalCls, newLabelAlign in me.horizontalLabelMap);
}, updateLabelTextAlign:function(labelTextAlign, oldLabelTextAlign) {
  var element = this.element;
  if (oldLabelTextAlign) {
    element.removeCls(Ext.baseCSSPrefix + 'label-text-align-' + oldLabelTextAlign);
  }
  if (labelTextAlign) {
    element.addCls(Ext.baseCSSPrefix + 'label-text-align-' + labelTextAlign);
  }
}, updateLabelCls:function(newLabelCls, oldLabelCls) {
  var labelElement = this.labelElement;
  if (newLabelCls) {
    labelElement.addCls(newLabelCls);
  }
  if (oldLabelCls) {
    labelElement.removeCls(oldLabelCls);
  }
}, updateLabelWidth:function(labelWidth) {
  this.labelElement.setWidth(labelWidth);
}, updateLabelMinWidth:function(labelMinWidth) {
  this.labelElement.setStyle('min-width', Ext.Element.addUnits(labelMinWidth));
}, updateLabelWrap:function(labelWrap) {
  this.element.toggleCls(this.noLabelWrapCls, !labelWrap);
}, updateName:function(newName) {
  this.name = newName;
}, updateRequired:function(required) {
  var me = this;
  me.element.toggleCls(me.requiredCls, required);
  if (!me.isConfiguring) {
    me.validate();
  }
}, updateRequiredMessage:function() {
  if (!this.isConfiguring) {
    this.validate();
  }
}, updateDisabled:function(disabled, oldDisabled) {
  this.callParent([disabled, oldDisabled]);
  if (!this.isConfiguring) {
    this.validate();
  }
}, updateValidateDisabled:function() {
  if (!this.isConfiguring) {
    this.validate();
  }
}, applyValue:function(value) {
  if (this.isConfiguring) {
    this.originalValue = value;
  }
  return value;
}, updateValue:function(value, oldValue) {
  var me = this;
  if (!(Ext.isEmpty(value) && Ext.isEmpty(oldValue))) {
    me.validate();
  }
  if (!me.isConfiguring && value !== oldValue) {
    me.fireEvent('change', me, value, oldValue);
  }
}, reset:function() {
  this.setValue(this.originalValue);
  return this;
}, resetOriginalValue:function() {
  this.originalValue = this.getValue();
}, isDirty:function() {
  return this.getValue() !== this.originalValue;
}, toggleInvalidCls:function(hasError) {
  this.el[hasError ? 'addCls' : 'removeCls'](this.invalidCls);
}, markInvalid:function(messages) {
  this.setError(messages);
}, clearInvalid:function() {
  this.setError(null);
}, isValid:function() {
  return !this.getError();
}, isEqual:function(value1, value2) {
  return String(value1) === String(value2);
}, applyValidators:function(validators) {
  var me = this, i, len, ret;
  validators = validators && !Ext.isArray(validators) ? [validators] : validators;
  len = validators && validators.length;
  ret = len ? [] : null;
  for (i = 0; i < len; ++i) {
    ret.push(me.decodeValidator(validators[i]));
  }
  return ret;
}, wrapValidatorFn:function(fn, validator) {
  var me = this, scope = validator && validator.scope;
  return new Ext.data.validator['Validator'](function(value) {
    return Ext.callback(fn, scope, [value], 0, me);
  });
}, doValidate:function(value, errors, skipLazy) {
  var validators = this.getValidators(), len = validators && validators.length, i, result, validator;
  for (i = 0; i < len; ++i) {
    validator = validators[i];
    if (!skipLazy || !validator.lazy) {
      result = validator.validate(value);
      if (result !== true) {
        if (!result || typeof result !== 'string') {
          Ext.raise('Validator did not return a valid result.');
        }
        errors.push(result);
      }
    }
  }
}, parseValue:Ext.identityFn, validate:function(skipLazy) {
  var me = this, empty, errors, field, record, validity, value;
  if (me.isConfiguring && me.validateOnInit === 'none') {
    return true;
  }
  if (!me.getDisabled() || me.getValidateDisabled()) {
    errors = [];
    if (me.isInputField && !me.isSelectField) {
      value = me.getInputValue();
      empty = !value;
      validity = empty && me.inputElement.dom.validity;
      if (validity && validity.badInput) {
        errors.push(me.badFormatMessage);
        empty = false;
      }
    } else {
      value = me.getValue();
      empty = value === '' || value == null;
    }
    if (empty && me.getRequired()) {
      errors.push(me.getRequiredMessage());
    } else {
      if (!errors.length) {
        if (!empty) {
          value = me.parseValue(value, errors);
        }
        if (!errors.length) {
          field = me._validationField;
          record = me._validationRecord;
          if (field && record) {
            field.validate(value, null, errors, record);
          }
          if (!empty) {
            me.doValidate(value, errors, skipLazy);
          }
        }
      }
    }
    if (errors.length) {
      me.setError(errors);
      return false;
    }
  }
  me.setError(null);
  return true;
}, getFocusClsEl:function() {
  return this.element;
}, updateHeight:function(height, oldHeight) {
  this.callParent([height, oldHeight]);
  this.syncFormLayoutHeight();
}, onAdded:function(parent, instanced) {
  this.callParent([parent, instanced]);
  this.syncFormLayoutHeight();
  this.validateLayout();
}, onRemoved:function(destroying) {
  this.callParent([destroying]);
  this.syncFormLayoutHeight();
}, privates:{syncFormLayoutHeight:function() {
  var me = this, parent = me.parent, height = me.getHeight();
  if (!(height && parent && parent.getLayout().isFormLayout)) {
    height = null;
  }
  me.bodyElement.setHeight(height);
}, validateLayout:function() {
  var errorTarget = this.getErrorTarget(), parent = this.parent;
  if (this.isInner && parent && parent.getLayout().isFormLayout) {
    this.setLabelAlign('left');
    if (errorTarget === 'under') {
      this.setErrorTarget('side');
    }
  }
}, applyBind:function(bind, currentBindings) {
  var me = this, valueBinding = currentBindings && currentBindings.value, bindings, newValueBind;
  bindings = me.callParent([bind, currentBindings]);
  if (bindings) {
    newValueBind = bindings.value;
    me.hasBindingValue = !!newValueBind;
    if (newValueBind !== valueBinding && me.getInherited().modelValidation) {
      me.updateValueBinding(bindings);
    }
  }
  return bindings;
}, updateValueBinding:function(bindings) {
  var me = this, newBinding = bindings.value, fieldBinding = bindings.$fieldBinding;
  if (fieldBinding) {
    fieldBinding.destroy();
    bindings.$fieldBinding = null;
  }
  if (newBinding && newBinding.bindValidationField) {
    me.fieldBinding = newBinding.bindValidationField('setValidationField', me);
  }
}, setValidationField:function(field, record) {
  this._validationField = field;
  this._validationRecord = record;
}, decodeValidator:function(validator) {
  var type = Ext.typeOf(validator), result = validator.fn;
  if (type === 'function') {
    result = this.wrapValidatorFn(validator);
  } else {
    if (type === 'regexp') {
      result = Ext.Factory.validator({type:'format', matcher:validator});
    } else {
      if (type === 'object' && result && !validator.isValidator) {
        result = this.wrapValidatorFn(result, validator);
      } else {
        result = Ext.Factory.validator(validator);
      }
    }
  }
  return result;
}}});
Ext.define('Ext.theme.material.field.Field', {override:'Ext.field.Field', config:{labelAlign:'top'}});
Ext.define('Ext.field.Input', {extend:Ext.field.Field, xtype:'inputfield', isInputField:true, tag:'input', config:{inputType:{cached:true, $value:'text'}, readOnly:false, inputValue:null}, focusEl:'inputElement', ariaEl:'inputElement', inputTabIndex:0, getBodyTemplate:function() {
  return [this.getInputTemplate()];
}, getInputTemplate:function() {
  return {tag:this.tag, reference:'inputElement', tabindex:this.inputTabIndex, cls:Ext.baseCSSPrefix + 'input-el'};
}, initElement:function() {
  this.callParent();
  this.labelElement.dom.setAttribute('for', this.inputElement.id);
}, updateDisabled:function(disabled, oldDisabled) {
  this.callParent([disabled, oldDisabled]);
  this.inputElement.dom.disabled = !!disabled;
}, updateInputType:function(newInputType) {
  this.setInputAttribute('type', newInputType);
}, updateName:function(name, oldName) {
  this.callParent([name, oldName]);
  this.setInputAttribute('name', name);
}, updateReadOnly:function(readOnly) {
  this.setInputAttribute('readonly', readOnly ? true : null);
}, updateValue:function(value, oldValue) {
  if (this.canSetInputValue()) {
    this.setInputValue(value);
  }
  this.callParent([value, oldValue]);
}, applyInputValue:function(value) {
  return value != null ? value + '' : '';
}, completeEdit:function() {
  var me = this, value = me.getInputValue(), parsedValue = me.parseValue(value);
  if (parsedValue !== null) {
    me.setInputValue(me.getValue());
  }
}, updateInputValue:function(value) {
  var inputElement = this.inputElement.dom;
  if (inputElement.value !== value) {
    inputElement.value = value;
  }
}, reset:function() {
  var me = this, original = me.originalValue;
  if (me.isEqual(original, me.getValue())) {
    me.setInputValue(original);
    if (!me.isValid()) {
      me.validate();
    }
  } else {
    me.setValue(original);
  }
  return me;
}, privates:{canSetInputValue:function() {
  return true;
}, setInputAttribute:function(attribute, newValue) {
  var inputElement = this.inputElement.dom;
  if (!Ext.isEmpty(newValue, true)) {
    inputElement.setAttribute(attribute, newValue);
  } else {
    inputElement.removeAttribute(attribute);
  }
}}, deprecated:{'6.5':{configs:{inputCls:null}}}});
Ext.define('Ext.field.trigger.Base', {extend:Ext.Widget, alias:'trigger.base', mixins:[Ext.mixin.Factoryable], factoryConfig:{defaultType:'trigger', aliasPrefix:'trigger.'}, isTrigger:true, config:{field:null, group:null, side:null, name:null, triggers:null}, classCls:Ext.baseCSSPrefix + 'trigger', groupedCls:Ext.baseCSSPrefix + 'grouped', inheritUi:true, statics:{sort:function(triggers) {
  Ext.Array.sort(triggers, Ext.weightSortFn);
  return triggers;
}}, doDestroy:function() {
  var triggers = this.getTriggers(), i, ln;
  if (triggers) {
    for (i = 0, ln = triggers.length; i < ln; i++) {
      triggers[i].destroy();
    }
  }
  this.setTriggers(null);
  this.callParent();
}, updateField:function(field) {
  this.field = this.ownerCmp = field;
  this.doInheritUi();
}, updateGroup:function(group) {
  if (!this.isConfiguring) {
    this.getField().syncTriggers();
  }
}, updateSide:function() {
  if (!this.isConfiguring) {
    this.getField().syncTriggers();
  }
}, updateTriggers:function(triggers) {
  var me = this, dom = me.element.dom, iconElement = me.iconElement, i, ln;
  me.toggleCls(me.groupedCls, !!(triggers && triggers.length));
  if (triggers) {
    for (i = 0, ln = triggers.length; i < ln; i++) {
      dom.appendChild(triggers[i].element.dom);
    }
  }
}});
Ext.define('Ext.field.trigger.Trigger', {extend:Ext.field.trigger.Base, xtype:'trigger', alias:'trigger.trigger', config:{handler:null, iconCls:null, repeat:null, scope:null, focusOnTap:true}, interactiveCls:Ext.baseCSSPrefix + 'interactive', template:[{reference:'iconElement', classList:[Ext.baseCSSPrefix + 'icon-el', Ext.baseCSSPrefix + 'font-icon']}], constructor:function(config) {
  var me = this, repeat;
  me.callParent([config]);
  repeat = me.getRepeat();
  if (repeat) {
    me.repeater = new Ext.util.ClickRepeater(Ext.apply({target:me, preventDefault:true, listeners:{mousedown:'onClickRepeaterTouchStart', mouseup:'onClickRepeaterTouchEnd', click:'onClickRepeaterClick', scope:me}}, repeat));
  } else {
    me.element.on({click:'onClick', mousedown:'onMouseDown', scope:me});
  }
}, doDestroy:function() {
  Ext.destroyMembers(this, 'repeater');
  this.callParent();
}, onClickRepeaterClick:function(clickRepeater, e) {
  this.onClick(e);
}, onClick:function(e) {
  var me = this, handler = !me.getDisabled() && me.getHandler(), field = me.getField(), focusEl;
  if (field) {
    if (e.pointerType !== 'mouse') {
      e.preventDefault();
      if (me.getFocusOnTap()) {
        focusEl = field.getFocusTrap ? field.getFocusTrap() : field.getFocusEl();
        if (focusEl.dom !== document.activeElement) {
          if (me.isExpandTrigger) {
            field.focusingFromExpandTrigger = true;
          }
          field.focus();
        }
      }
    }
    if (handler) {
      Ext.callback(handler, me.getScope(), [field, me, e], null, field);
    }
  }
}, onMouseDown:function(e) {
  if (e.pointerType === 'mouse') {
    var field = this.getFocusOnTap() && this.getField();
    if (field) {
      field.focus();
    }
    e.preventDefault();
  }
}, onClickRepeaterTouchStart:function(clickRepeater, e) {
  this.onMouseDown(e);
}, onClickRepeaterTouchEnd:function(clickRepeater, e) {
  var me = this, field = me.field;
  Ext.callback(me.endHandler, me.scope, [field, me, e], 0, field);
}, updateHandler:function(handler) {
  this.toggleCls(this.interactiveCls, !!handler);
}, updateIconCls:function(iconCls, oldIconCls) {
  this.iconElement.replaceCls(oldIconCls, iconCls);
}});
Ext.define('Ext.field.trigger.Clear', {extend:Ext.field.trigger.Trigger, xtype:'cleartrigger', alias:'trigger.clear', classCls:Ext.baseCSSPrefix + 'cleartrigger', weight:-1000, hidden:true, handler:'onClearIconTap', scope:'this'});
Ext.define('Ext.field.Text', {extend:Ext.field.Input, xtype:'textfield', alternateClassName:'Ext.form.Text', config:{clearable:true, placeholder:null, maxLength:null, autoComplete:null, autoCapitalize:null, autoCorrect:null, autoHideInputMask:null, inputMask:null, pattern:null, triggers:{clear:{type:'clear'}}, editable:true, bodyAlign:'stretch', labelInPlaceholder:{lazy:true, $value:true}, textAlign:null}, cachedConfig:{animateUnderline:false, parseValidator:null}, bubbleEvents:['action'], badFormatMessage:'Value does not match the required format', 
defaultBindProperty:'value', twoWayBindable:{value:1}, publishes:{value:1}, inputType:'text', classCls:Ext.baseCSSPrefix + 'textfield', focusedCls:Ext.baseCSSPrefix + 'focused', emptyCls:Ext.baseCSSPrefix + 'empty', webkitBorderBoxBugCls:Ext.baseCSSPrefix + 'webkit-border-box-bug', requiredIndicator:'*', getBodyTemplate:function() {
  var template = [{reference:'beforeInputElement', cls:Ext.baseCSSPrefix + 'before-input-el'}];
  template.push(this.getInputTemplate());
  template.push({reference:'afterInputElement', cls:Ext.baseCSSPrefix + 'after-input-el'});
  return [{reference:'inputWrapElement', cls:Ext.baseCSSPrefix + 'input-wrap-el' + (Ext.supports.WebKitInputTableBoxModelBug ? ' ' + this.webkitBorderBoxBugCls : ''), children:template}, {reference:'underlineElement', cls:Ext.baseCSSPrefix + 'underline-el'}];
}, initialize:function() {
  var me = this;
  if (Ext.isRobot) {
    me.focusedInputDelay = 0;
  }
  me.callParent();
  me.inputElement.on({keyup:'onKeyUp', keydown:'onKeyDown', keypress:'onKeyPress', paste:'onPaste', mousedown:'onMouseDown', input:{fn:'onInput', delegated:false}, scope:me});
  me.syncEmptyState();
}, clearValue:function() {
  var me = this, inputMask = me.getInputMask();
  if (inputMask) {
    inputMask.showEmptyMask(me, true);
  } else {
    me.forceInputChange = true;
    me.setValue('');
    me.forceInputChange = false;
  }
  me.syncEmptyState();
}, transformValue:function(value) {
  if (value == null) {
    value = '';
  }
  return value;
}, applyInputMask:function(value, instance) {
  var InputMask = Ext.field['InputMask'];
  if (value) {
    if (!InputMask) {
      Ext.raise('Missing Ext.field.InputMask (required to use inputMask)');
    }
  }
  return value ? InputMask.from(value, instance) : null;
}, updateInputMask:function(inputMask, previous) {
  this.hasMask = false;
  if (previous) {
    previous.release();
  }
  if (inputMask) {
    this.hasMask = true;
    inputMask.syncPattern(this);
  }
}, doValidate:function(value, errors, skipLazy) {
  this.callParent([value, errors, skipLazy]);
  if (!skipLazy) {
    var inputMask = this.getInputMask();
    if (inputMask && !inputMask.isFilled(value) && value !== inputMask._mask) {
      errors.push(this.badFormatMessage);
    }
  }
}, parseValue:function(value, errors) {
  var me = this, parser = me.getParseValidator(), field, i, k, len, v, validators;
  if (parser) {
    field = me._validationField;
    for (k = 2; k-- > 0;) {
      validators = k ? me.getValidators() : field && field.getValidators();
      len = validators && validators.length;
      for (i = 0; i < len; ++i) {
        v = validators[i];
        if (v.parse) {
          v = v.parse(value);
          if (v !== null) {
            return v;
          }
        }
      }
    }
    value = parser.parse(value);
    if (value === null && errors) {
      errors.push(me.badFormatMessage);
    }
  }
  return value;
}, applyValue:function(value, oldValue) {
  if (value && typeof value === 'string') {
    value = this.parseValue(value);
    if (value === null) {
      return;
    }
  }
  return this.transformValue(this.callParent([value, oldValue]));
}, updateInputValue:function(value, oldValue) {
  var me = this, inputMask = me.getInputMask();
  me.callParent([value, oldValue]);
  me.syncEmptyState();
  me.syncLabelPlaceholder(false);
  if (inputMask) {
    inputMask.onChange(this, value, oldValue);
  }
}, updateTextAlign:function(newAlign, oldAlign) {
  var element = this.element;
  if (oldAlign) {
    element.removeCls(Ext.baseCSSPrefix + 'text-align-' + oldAlign);
  }
  if (newAlign) {
    element.addCls(Ext.baseCSSPrefix + 'text-align-' + newAlign);
  }
}, updatePlaceholder:function(value) {
  this.setInputAttribute('placeholder', value);
}, applyMaxLength:function(maxLength) {
  if (maxLength !== null && typeof maxLength != 'number') {
    throw new Error('Ext.field.Text: [applyMaxLength] trying to pass a value which is not a number');
  }
  return maxLength;
}, updateMaxLength:function(newMaxLength) {
  this.setInputAttribute('maxlength', newMaxLength);
}, applyAutoComplete:function(value) {
  return value === true || value === 'on';
}, updateAutoComplete:function(value) {
  this.setInputAttribute('autocomplete', value ? 'on' : 'off');
}, applyAutoCapitalize:function(value) {
  return value === true || value === 'on';
}, updateAutoCapitalize:function(value) {
  this.setInputAttribute('autocapitalize', value ? 'on' : 'off');
}, applyAutoCorrect:function(value) {
  return value === true || value === 'on';
}, updateAutoCorrect:function(value) {
  this.setInputAttribute('autocorrect', value ? 'on' : 'off');
}, updateReadOnly:function(newReadOnly) {
  var me = this, triggers = me.getTriggers(), isEditable = me.getEditable(), triggerName, trigger;
  me.callParent([newReadOnly || !isEditable]);
  for (triggerName in triggers) {
    trigger = triggers[triggerName];
    if (trigger.disableOnReadOnly !== false) {
      trigger.setDisabled(newReadOnly);
    }
  }
  me.syncEmptyState();
}, updateEditable:function(newEditable) {
  var triggers = this.getTriggers(), isReadOnly = this.getReadOnly(), triggerName, trigger;
  this.updateReadOnly(!newEditable);
  for (triggerName in triggers) {
    trigger = triggers[triggerName];
    if (trigger.disableOnReadOnly !== false) {
      triggers[triggerName].setDisabled(isReadOnly);
    }
  }
}, updatePattern:function(pattern) {
  this.setInputAttribute('pattern', pattern);
}, updateDisabled:function(disabled, oldDisabled) {
  this.callParent([disabled, oldDisabled]);
  this.syncEmptyState();
}, updateClearable:function(clearable, oldClearable) {
  var me = this, triggers, clearTrigger;
  if (!me.isConfiguring) {
    triggers = me.getTriggers();
    clearTrigger = triggers && triggers.clear;
    if (clearable) {
      if (!clearTrigger) {
        me.addTrigger('clear', 'clear');
      }
    } else {
      if (clearTrigger) {
        me.removeTrigger('clear');
      }
    }
  }
}, applyTriggers:function(triggers, oldTriggers) {
  var me = this, instances = oldTriggers || {}, clearable = me.getClearable(), name, trigger, oldTrigger;
  for (name in triggers) {
    trigger = triggers[name];
    oldTrigger = instances[name];
    if (oldTrigger) {
      oldTrigger.destroy();
    }
    if (trigger) {
      if (!clearable && name === 'clear') {
        continue;
      }
      instances[name] = me.createTrigger(name, trigger);
    }
  }
  return instances;
}, updateTriggers:function() {
  this.syncTriggers();
}, addTrigger:function(name, trigger) {
  var me = this, triggers = me.getTriggers(), triggerConfig;
  if (triggers && triggers[name]) {
    Ext.raise('Trigger with name "' + name + '" already exists.');
  }
  if (typeof name !== 'string') {
    Ext.raise('Cannot add trigger. Key must be a string.');
  }
  if (typeof trigger !== 'string' && !Ext.isObject(trigger)) {
    Ext.raise('Cannot add trigger "' + name + '". A trigger config or instance is required.');
  }
  trigger = me.createTrigger(name, trigger);
  if (triggers) {
    triggers[name] = trigger;
    me.syncTriggers();
  } else {
    triggerConfig = {};
    triggerConfig[name] = trigger;
    me.setTriggers(triggerConfig);
  }
  return trigger;
}, removeTrigger:function(trigger, destroy) {
  var me = this, triggers = me.getTriggers(), name = trigger, triggerEl;
  if (name.isTrigger) {
    name = trigger.getName();
  } else {
    trigger = triggers[name];
  }
  if (!name) {
    Ext.raise('Trigger not found.');
  } else {
    if (!triggers[name]) {
      Ext.raise('Cannot remove trigger. Trigger with name "' + name + '" not found.');
    }
  }
  delete triggers[name];
  if (destroy !== false) {
    trigger.destroy();
  } else {
    triggerEl = trigger.el.dom;
    triggerEl.parentNode.removeChild(triggerEl);
  }
  this.syncTriggers();
  return trigger;
}, onKeyDown:function(event) {
  var me = this, inputMask = me.getInputMask();
  me.lastKeyTime = Date.now();
  if (inputMask) {
    inputMask.onKeyDown(me, me.getValue(), event);
  }
  me.ignoreInput = true;
  if (Ext.supports.SpecialKeyDownRepeat) {
    me.fireKey(event);
  }
}, onInput:function(e) {
  var me = this, inputEl = me.inputElement.dom, value = inputEl.value, inputMask = me.getInputMask(), parseErrors, oldValue;
  if (inputMask) {
    inputMask.processAutocomplete(this, value);
    value = inputEl.value;
  }
  me._inputValue = value;
  if (value) {
    parseErrors = [];
    value = me.parseValue(value, parseErrors);
  }
  if (parseErrors && parseErrors.length) {
    me.setError(parseErrors);
  } else {
    oldValue = me.getValue();
    me.setValue(value);
    if (me.getValue() === oldValue) {
      me.validate();
    }
  }
  me.syncEmptyState();
  if (me.ignoreInput) {
    me.ignoreInput = false;
    return;
  }
  Ext.defer(function() {
    if (!me.ignoreInput && !me.destroyed) {
      me.fireEvent('keyup', e);
      me.ignoreInput = false;
    }
  }, 10);
}, fireKey:function(e) {
  if (e.isSpecialKey()) {
    this.fireEvent('specialkey', this, e);
  }
}, onKeyPress:function(event) {
  var me = this, inputMask = me.getInputMask();
  if (inputMask) {
    inputMask.onKeyPress(me, me.getValue(), event);
  }
  me.fireEvent('keypress', me, event);
  if (!Ext.supports.SpecialKeyDownRepeat) {
    me.fireKey(event);
  }
}, onKeyUp:function(e) {
  this.fireAction('keyup', [this, e], 'doKeyUp');
}, doKeyUp:function(me, e) {
  me.syncEmptyState();
  if (e.browserEvent.keyCode === 13) {
    me.fireAction('action', [me, e], 'doAction');
  }
}, doAction:function() {
  if (document.documentElement.getBoundingClientRect().top < 0) {
    this.blur();
  }
}, onClearIconTap:function(input, e) {
  this.fireAction('clearicontap', [this, input, e], 'doClearIconTap');
}, doClearIconTap:function() {
  this.clearValue();
}, onFocusEnter:function(event) {
  var me = this, inputMask = me.getInputMask();
  me.callParent([event]);
  me.addCls(me.focusedCls);
  me.syncLabelPlaceholder(true);
  if (inputMask) {
    inputMask.onFocus(me, me.getValue());
  }
}, onFocusLeave:function(event) {
  var me = this, inputMask = me.getInputMask();
  me.callParent([event]);
  me.removeCls(me.focusedCls);
  me.syncLabelPlaceholder(true);
  if (inputMask) {
    inputMask.onBlur(me, me.getValue());
  }
}, onPaste:function(e) {
  this.forceInputChange = true;
  this.handlePaste(e);
  this.forceInputChange = false;
}, getCaretPos:function() {
  return this.inputElement.getCaretPos();
}, setCaretPos:function(pos) {
  this.inputElement.setCaretPos(pos);
}, getTextSelection:function() {
  return this.inputElement.getTextSelection();
}, select:function(start, end, direction) {
  if (this.containsFocus) {
    this.inputElement.selectText(start, end, direction);
  }
  return this;
}, reset:function() {
  this.callParent();
  this.syncEmptyState();
}, onClick:function(e) {
  this.fireEvent('click', e);
}, onMouseDown:function(e) {
  this.fireEvent('mousedown', e);
}, trimValueToMaxLength:function() {
  var me = this, maxLength = me.getMaxLength(), value = me.getValue();
  if (maxLength && value.length > maxLength) {
    me.setValue(value.slice(0, maxLength));
  }
}, doDestroy:function() {
  var me = this, triggers = me.getTriggers(), triggerGroups = me.triggerGroups, name, animation;
  animation = me.labelElement && me.labelElement.getActiveAnimation();
  if (animation) {
    animation.stop();
  }
  if (triggerGroups) {
    for (name in triggerGroups) {
      triggerGroups[name].destroy();
    }
    me.triggerGroups = null;
  }
  for (name in triggers) {
    triggers[name].destroy();
  }
  me.setTriggers(null);
  me.setInputMask(null);
  me.callParent();
}, onRender:function() {
  this.callParent();
  this.syncLabelPlaceholder();
}, getRefItems:function(deep) {
  var me = this, triggers = me.getTriggers(), items = [], triggerName, trigger;
  for (triggerName in triggers) {
    trigger = triggers[triggerName];
    items.push(trigger);
    if (deep && trigger.getRefItems) {
      items.push.apply(items, trigger.getRefItems(deep));
    }
  }
  return items;
}, privates:{focusedInputDelay:300, forceInputChange:false, hasMask:false, lastKeyTime:0, applyParseValidator:function(config) {
  return this.decodeValidator(config);
}, updateLabelInPlaceholder:function(inside) {
  var me = this, placeHolder = me.getPlaceholder() || '', anim = me._animPlaceholderLabel;
  if (me.getLabelAlign() !== 'placeholder' || !me.getLabel()) {
    me.clearWhenVisible('doPositionPlaceholder');
    me.setInputAttribute('placeholder', placeHolder);
    return;
  }
  me.whenVisible('doPositionPlaceholder', [inside, anim]);
  me.el.toggleCls(Ext.baseCSSPrefix + 'label-inside', inside);
}, updateAnimateUnderline:function(value) {
  this.toggleCls(Ext.baseCSSPrefix + 'animate-underline', value);
}, canSetInputValue:function() {
  var me = this;
  return me.hasMask || me.forceInputChange || !me.hasFocus || Date.now() - me.lastKeyTime > me.focusedInputDelay;
}, doPositionPlaceholder:function(inside, doAnimate) {
  var me = this, labelElement = me.labelElement, anim, animation, info, insideInfo, outsideInfo;
  animation = labelElement.getActiveAnimation();
  if (animation) {
    animation.stop();
  }
  info = me.lastPlaceholderAnimInfo;
  if (!info) {
    me.lastPlaceholderAnimInfo = info = me.getPlaceholderAnimInfo();
  }
  insideInfo = info.inside;
  outsideInfo = info.outside;
  anim = {from:inside ? outsideInfo : insideInfo, to:inside ? insideInfo : outsideInfo, preserveEndState:true, duration:250, easing:'ease-out'};
  if (doAnimate) {
    labelElement.animate(anim);
  } else {
    labelElement.setStyle(anim.to);
  }
}, getPlaceholderLabel:function() {
  var me = this, label = me.getLabel();
  if (label && me.getRequired()) {
    label += ' ' + me.requiredIndicator;
  }
  return label;
}, getPlaceholderAnimInfo:function() {
  var me = this, element = me.element, labelElement = me.labelElement, inputElement = me.inputElement, labelOffsets = labelElement.getOffsetsTo(element), inputOffsets = inputElement.getOffsetsTo(element), labelLeftPadding = labelElement.getPadding('l'), inputLeftPadding = inputElement.getPadding('l'), labelTopPadding = labelElement.getPadding('t'), inputTopPadding = inputElement.getPadding('t'), translateX = inputOffsets[0] - labelOffsets[0] + (inputLeftPadding - labelLeftPadding), translateY = inputOffsets[1] - 
  labelOffsets[1] + (inputTopPadding - labelTopPadding);
  return {inside:{transform:{translateX:translateX + 'px', translateY:translateY + 'px'}, 'font-size':inputElement.getStyle('font-size')}, outside:{transform:{translateX:'0px', translateY:'0px'}, 'font-size':labelElement.getStyle('font-size')}};
}, handlePaste:function(e) {
  var me = this, inputMask = me.getInputMask();
  if (inputMask) {
    inputMask.onPaste(me, me.getValue(), e);
  }
  me.fireEvent('paste', me, e);
}, createTrigger:function(name, trigger) {
  if (!trigger.isTrigger) {
    if (trigger === true) {
      trigger = {type:name};
    } else {
      if (typeof trigger === 'string') {
        trigger = {type:trigger};
      }
    }
    trigger = Ext.apply({name:name, field:this}, trigger);
    trigger = trigger.xtype ? Ext.create(trigger) : Ext.Factory.trigger(trigger);
  }
  return trigger;
}, syncLabelPlaceholder:function(animate) {
  var me = this, inputEl = me.inputElement, value = inputEl && inputEl.dom.value, inside;
  me._animPlaceholderLabel = animate;
  if (me.rendered) {
    if (value !== '') {
      inside = false;
    } else {
      inside = !me.hasFocus || me.getDisabled() || me.getReadOnly();
    }
    me.setLabelInPlaceholder(inside);
  }
  me._animPlaceholderLabel = false;
}, syncTriggers:function() {
  var me = this, triggers = me.getTriggers(), beforeInputElement = me.beforeInputElement, afterInputElement = me.afterInputElement, triggerGroups = me.triggerGroups || (me.triggerGroups = {}), beforeTriggers = [], afterTriggers = [], triggersByGroup = {}, TriggerBase = Ext.field.trigger['Base'], name, trigger, groupName, triggerGroup, i, ln;
  for (name in triggers) {
    trigger = triggers[name];
    groupName = trigger.getGroup();
    if (groupName) {
      (triggersByGroup[groupName] || (triggersByGroup[groupName] = [])).push(trigger);
    } else {
      if (trigger.getSide() === 'left') {
        beforeTriggers.push(trigger);
      } else {
        afterTriggers.push(trigger);
      }
    }
  }
  for (groupName in triggersByGroup) {
    triggerGroup = triggerGroups[groupName];
    if (!triggerGroup) {
      triggerGroup = triggers[groupName];
      if (!triggerGroup) {
        triggerGroup = new TriggerBase;
      }
      triggerGroups[groupName] = triggerGroup;
    }
    triggerGroup.setTriggers(TriggerBase.sort(triggersByGroup[groupName]));
    if (triggerGroup.getSide() === 'left') {
      beforeTriggers.push(triggerGroup);
    } else {
      afterTriggers.push(triggerGroup);
    }
  }
  TriggerBase.sort(beforeTriggers);
  TriggerBase.sort(afterTriggers);
  for (i = 0, ln = beforeTriggers.length; i < ln; i++) {
    beforeInputElement.appendChild(beforeTriggers[i].element);
  }
  for (i = 0, ln = afterTriggers.length; i < ln; i++) {
    afterInputElement.appendChild(afterTriggers[i].element);
  }
  for (groupName in triggerGroups) {
    if (!(groupName in triggersByGroup)) {
      triggerGroup = triggerGroups[groupName];
      triggerGroup.setTriggers(null);
      triggerGroup.destroy();
      delete triggerGroups[groupName];
    }
  }
}, syncEmptyState:function() {
  var me = this, triggers = me.getTriggers(), inputMask = me.getInputMask(), clearTrigger = triggers && triggers.clear, value = me.inputElement.dom.value, visible;
  me.toggleCls(me.emptyCls, !value);
  if (clearTrigger) {
    if (me.getClearable()) {
      if (value !== '' && !me.getDisabled() && !me.getReadOnly()) {
        visible = true;
      }
      if (inputMask) {
        if (value === inputMask._mask) {
          visible = false;
        }
      }
    }
    if (visible) {
      clearTrigger.show();
    } else {
      clearTrigger.hide();
    }
  }
}}, deprecated:{'6.5':{configs:{placeHolder:'placeholder', clearIcon:'clearable'}, methods:{getPlaceHolder:'getPlaceholder', setPlaceHolder:'setPlaceholder'}}}}, function() {
  if (Ext.os.is.Android) {
    window.addEventListener('resize', function() {
      var el = document.activeElement, tag = el && el.tagName;
      if (tag === 'INPUT' || tag === 'TEXTAREA') {
        el.scrollIntoView();
      }
    });
  }
});
Ext.define('Ext.theme.material.field.Text', {override:'Ext.field.Text', config:{labelAlign:'placeholder', animateUnderline:true}});
Ext.define('Ext.Img', {extend:Ext.Component, xtype:['image', 'img'], alternateClassName:'Ext.Image', config:{src:null, imageCls:Ext.baseCSSPrefix + 'img-image', backgroundCls:Ext.baseCSSPrefix + 'img-background', mode:'background'}, baseCls:Ext.baseCSSPrefix + 'img', beforeInitialize:function() {
  var me = this;
  me.onLoad = me.onLoad.bind(me);
  me.onError = me.onError.bind(me);
}, initialize:function() {
  var me = this;
  me.callParent();
  me.relayEvents(me.renderElement, '*');
  me.element.on({tap:'onTap', scope:me});
}, hide:function() {
  var me = this;
  me.callParent(arguments);
  me.hiddenSrc = me.hiddenSrc || me.getSrc();
  if (!me.isDestroying) {
    me.setSrc(null);
  }
}, afterShow:function() {
  this.callParent(arguments);
  if (this.hiddenSrc) {
    this.setSrc(this.hiddenSrc);
    delete this.hiddenSrc;
  }
}, updateMode:function(mode) {
  var me = this, imageCls = me.getImageCls(), backgroundCls = me.getBackgroundCls();
  if (mode === 'background') {
    if (me.imageElement) {
      me.imageElement.destroy();
      delete me.imageElement;
      me.updateSrc(me.getSrc());
    }
    me.replaceCls(imageCls, backgroundCls);
  } else {
    me.imageElement = me.element.createChild({tag:'img'});
    me.replaceCls(backgroundCls, imageCls);
  }
}, updateImageCls:function(newCls, oldCls) {
  this.replaceCls(oldCls, newCls);
}, updateBackgroundCls:function(newCls, oldCls) {
  this.replaceCls(oldCls, newCls);
}, onTap:function(e) {
  this.fireEvent('tap', this, e);
}, applySrc:function(src) {
  return src && Ext.resolveResource(src);
}, updateSrc:function(newSrc) {
  var me = this, dom;
  if (me.getMode() === 'background') {
    dom = this.imageObject || new Image;
  } else {
    dom = me.imageElement.dom;
  }
  this.imageObject = dom;
  dom.setAttribute('src', Ext.isString(newSrc) ? newSrc : '');
  dom.addEventListener('load', me.onLoad, false);
  dom.addEventListener('error', me.onError, false);
}, detachListeners:function() {
  var dom = this.imageObject;
  if (dom) {
    dom.removeEventListener('load', this.onLoad, false);
    dom.removeEventListener('error', this.onError, false);
  }
}, onLoad:function(e) {
  this.detachListeners();
  if (this.getMode() === 'background') {
    this.element.dom.style.backgroundImage = 'url("' + this.imageObject.src + '")';
  }
  this.fireEvent('load', this, e);
}, onError:function(e) {
  this.detachListeners();
  if (this.getMode() === 'background') {
    this.element.dom.style.backgroundImage = 'url("' + this.imageObject.src + '")';
  }
  this.fireEvent('error', this, e);
}, updateWidth:function(width) {
  var sizingElement = this.getMode() === 'background' ? this.element : this.imageElement;
  sizingElement.setWidth(width);
  this.callParent(arguments);
}, updateHeight:function(height) {
  var sizingElement = this.getMode() === 'background' ? this.element : this.imageElement;
  sizingElement.setHeight(height);
  this.callParent(arguments);
}, doDestroy:function() {
  var me = this;
  me.detachListeners();
  me.imageObject = me.imageElement = Ext.destroy(me.imageObject, me.imageElement);
  me.callParent();
}});
Ext.define('Ext.LoadMask', {extend:Ext.Mask, xtype:'loadmask', config:{message:'Loading...', cls:Ext.baseCSSPrefix + 'loading-mask', messageCls:Ext.baseCSSPrefix + 'mask-message', indicator:true}, getTemplate:function() {
  var prefix = Ext.baseCSSPrefix;
  return [{reference:'innerElement', cls:prefix + 'mask-inner', children:[{reference:'indicatorElement', cls:prefix + 'loading-spinner-outer', children:[{cls:prefix + 'loading-spinner', children:[{tag:'span', cls:prefix + 'loading-top'}, {tag:'span', cls:prefix + 'loading-right'}, {tag:'span', cls:prefix + 'loading-bottom'}, {tag:'span', cls:prefix + 'loading-left'}]}]}, {reference:'messageElement'}]}];
}, updateMessage:function(newMessage) {
  var cls = Ext.baseCSSPrefix + 'has-message';
  if (newMessage) {
    this.addCls(cls);
  } else {
    this.removeCls(cls);
  }
  this.messageElement.setHtml(newMessage);
}, updateMessageCls:function(newMessageCls, oldMessageCls) {
  this.messageElement.replaceCls(oldMessageCls, newMessageCls);
}, updateIndicator:function(newIndicator) {
  this[newIndicator ? 'removeCls' : 'addCls'](Ext.baseCSSPrefix + 'indicator-hidden');
}});
Ext.define('Ext.field.TextArea', {extend:Ext.field.Text, xtype:'textareafield', alternateClassName:'Ext.form.TextArea', config:{autoCapitalize:false, maxRows:null, clearable:false}, tag:'textarea', classCls:Ext.baseCSSPrefix + 'textareafield', applyMaxRows:function(maxRows) {
  if (maxRows !== null && typeof maxRows !== 'number') {
    throw new Error('Ext.field.TextArea: [applyMaxRows] trying to pass a value which is not a number');
  }
  return maxRows;
}, updateMaxRows:function(newRows) {
  this.setInputAttribute('rows', newRows);
}, doKeyUp:function(me) {
  this.syncEmptyState();
}});
Ext.define('Ext.layout.VBox', {extend:Ext.layout.Box, alias:'layout.vbox', config:{vertical:true}});
Ext.define('Ext.MessageBox', {extend:Ext.Dialog, xtype:'messagebox', config:{iconCls:null, defaultTextHeight:75, buttons:null, message:null, prompt:null, layout:{type:'vbox', pack:'center'}, multiLine:null}, classCls:Ext.baseCSSPrefix + 'messagebox', closeAction:'hide', headerCls:[Ext.baseCSSPrefix + 'dialogheader', Ext.baseCSSPrefix + 'messageboxheader'], titleCls:[Ext.baseCSSPrefix + 'dialogtitle', Ext.baseCSSPrefix + 'messageboxtitle'], toolCls:[Ext.baseCSSPrefix + 'paneltool', Ext.baseCSSPrefix + 
'dialogtool', Ext.baseCSSPrefix + 'messageboxtool'], statics:{INFO:Ext.baseCSSPrefix + 'msgbox-info', WARNING:Ext.baseCSSPrefix + 'msgbox-warning', QUESTION:Ext.baseCSSPrefix + 'msgbox-question', ERROR:Ext.baseCSSPrefix + 'msgbox-error', OK:{ok:'me.onClick'}, YES:{yes:'me.onClick'}, NO:{no:'me.onClick'}, CANCEL:{cancel:'me.onClick'}, OKCANCEL:{ok:'me.onClick', cancel:'me.onClick'}, YESNOCANCEL:{yes:'me.onClick', no:'me.onClick', cancel:'me.onClick'}, YESNO:{yes:'me.onClick', no:'me.onClick'}}, constructor:function(config) {
  config = config || {};
  if (config.hasOwnProperty('multiline') || config.hasOwnProperty('multiLine')) {
    config.prompt = config.prompt || {};
    Ext.applyIf(config.prompt, {multiLine:config.multiline || config.multiLine});
    delete config.multiline;
    delete config.multiLine;
  }
  this.defaultAllowedConfig = {};
  var allowedConfigs = ['ui', 'showAnimation', 'hideAnimation', 'title', 'message', 'prompt', 'iconCls', 'buttons', 'defaultTextHeight'], ln = allowedConfigs.length, i, allowedConfig;
  for (i = 0; i < ln; i++) {
    allowedConfig = allowedConfigs[i];
    this.defaultAllowedConfig[allowedConfig] = this.defaultConfig[allowedConfig];
  }
  this.callParent([config]);
}, applyTitle:function(config) {
  if (typeof config === 'string') {
    return config;
  }
  return config.title;
}, updateTitle:function(newTitle) {
  var header = this.getHeader() || {};
  if (Ext.isSimpleObject(header)) {
    header.title = newTitle;
    this.setHeader(header);
  } else {
    if (Ext.isFunction(header.setTitle)) {
      header.setTitle(newTitle);
    }
  }
}, applyMessage:function(config) {
  config = {html:config, cls:this.baseCls + '-text'};
  return Ext.factory(config, Ext.Component, this._message);
}, updateMessage:function(newMessage) {
  if (newMessage) {
    this.add(newMessage);
  }
}, getMessage:function() {
  if (this._message) {
    return this._message.getHtml();
  }
  return null;
}, applyIconCls:function(config) {
  if (config) {
    config = {xtype:'component', docked:'left', width:40, height:40, hidden:config ? false : true, cls:Ext.baseCSSPrefix + 'icon ' + config};
    return Ext.factory(config, Ext.Component, this._iconCls);
  }
  return config;
}, updateIconCls:function(newIconCls, oldIconCls) {
  this.getTitle();
  this.getButtons();
  if (newIconCls) {
    this.add(newIconCls);
  } else {
    this.remove(oldIconCls);
  }
}, getIconCls:function() {
  var icon = this._iconCls, iconCls;
  if (icon) {
    iconCls = icon.getCls();
    return iconCls ? iconCls[0] : null;
  }
  return null;
}, applyPrompt:function(prompt) {
  if (prompt) {
    var config = {label:false};
    if (Ext.isObject(prompt)) {
      Ext.apply(config, prompt);
    }
    if (config.multiLine) {
      config.height = Ext.isNumber(config.multiLine) ? parseFloat(config.multiLine) : this.getDefaultTextHeight();
      return Ext.factory(config, Ext.field['TextArea'], this.getPrompt());
    } else {
      return Ext.factory(config, Ext.field['Text'], this.getPrompt());
    }
  }
  return prompt;
}, updatePrompt:function(newPrompt, oldPrompt) {
  if (newPrompt) {
    this.add(newPrompt);
  }
  if (oldPrompt && !oldPrompt.destroyed) {
    this.remove(oldPrompt);
  }
}, onClick:function(button) {
  var me = this, msgBoxOptions = me.msgBoxOptions, prompt = me.getPrompt(), fn = msgBoxOptions.fn, which;
  if (button) {
    if (typeof fn == 'function') {
      button.disable();
      prompt = prompt ? prompt.getValue() : null;
      which = button.getItemId() || button.getText();
      me.on({single:true, hiddenchange:function() {
        fn.call(msgBoxOptions.scope || me, which, prompt, msgBoxOptions);
        button.enable();
      }});
    }
  }
  me.hide();
}, show:function(msgBoxOptions, options) {
  var me = this, buttons, config, prompt;
  Ext.util.InputBlocker.blockInputs();
  if (!msgBoxOptions) {
    return me.callParent(arguments);
  }
  config = Ext.apply({buttons:Ext.MessageBox.OK, draggable:false, prompt:null, defaultFocus:null}, msgBoxOptions);
  if (config.multiLine) {
    config.prompt = config.prompt || {};
    config.prompt.multiLine = config.multiLine;
    delete config.multiLine;
  }
  delete config.value;
  delete config.fn;
  delete config.scope;
  config = Ext.merge({}, me.defaultAllowedConfig, config);
  me.setConfig(config);
  me.msgBoxOptions = msgBoxOptions;
  buttons = me.getButtons();
  buttons.items.each(function(btn) {
    if (btn.isButton) {
      var value = btn.getScope();
      if (btn.fn && value) {
        btn.fn = btn.fn.bind(value);
      }
      value = btn.getHandler();
      if (!value || value === 'me.onClick') {
        btn.setHandler('onClick');
        btn.setScope(me);
      }
    }
  });
  prompt = me.getPrompt();
  if (prompt) {
    prompt.setValue(msgBoxOptions.value || '');
  }
  me.callParent([null, options]);
  return me;
}, alert:function(title, message, fn, scope) {
  return this.show({title:title || null, message:message || null, buttons:Ext.MessageBox.OK, defaultFocus:'#ok', prompt:false, fn:function() {
    if (fn) {
      Ext.callback(fn, scope, arguments);
    }
  }, scope:scope});
}, confirm:function(title, message, fn, scope) {
  return this.show({title:title || null, message:message || null, buttons:Ext.MessageBox.YESNO, defaultFocus:'#yes', prompt:false, scope:scope, fn:function() {
    if (fn) {
      Ext.callback(fn, scope, arguments);
    }
  }});
}, prompt:function(title, message, fn, scope, multiLine, value, prompt) {
  return this.show({title:title || null, message:message || null, buttons:Ext.MessageBox.OKCANCEL, scope:scope, prompt:prompt || true, defaultFocus:'textfield', multiLine:multiLine, value:value, fn:function() {
    if (fn) {
      Ext.callback(fn, scope, arguments);
    }
  }});
}}, function(MessageBox) {
  Ext.onInternalReady(function() {
    Ext.Msg = new Ext.MessageBox({id:'ext-messagebox'});
  });
});
Ext.define('Ext.menu.Item', {extend:Ext.Component, alias:'widget.menuitem', alternateClassName:'Ext.menu.TextItem', isMenuItem:true, menuExpandDelay:200, menuHideDelay:200, scope:null, destroyMenu:true, clickHideDelay:0, hideOnClick:true, config:{href:null, target:null, handler:null, text:null, menu:{lazy:true, $value:null}, menuAlign:'tl-tr?', icon:null, iconCls:null, iconAlign:'left', indented:null, separator:null}, inheritUi:true, ariaRole:'menuitem', focusable:true, classCls:Ext.baseCSSPrefix + 
'menuitem', activeCls:Ext.baseCSSPrefix + 'active', hasLeftIconCls:Ext.baseCSSPrefix + 'has-left-icon', hasRightIconCls:Ext.baseCSSPrefix + 'has-right-icon', hasArrowCls:Ext.baseCSSPrefix + 'has-arrow', hasHrefCls:Ext.baseCSSPrefix + 'has-href', isMenuOwner:true, template:[{reference:'bodyElement', tag:'a', href:'#', cls:Ext.baseCSSPrefix + 'body-el ' + Ext.baseCSSPrefix + 'unselectable', children:[{reference:'leftIconWrapElement', cls:Ext.baseCSSPrefix + 'left-icon-wrap-el ' + Ext.baseCSSPrefix + 
'icon-wrap-el', children:[{reference:'leftIconElement', cls:Ext.baseCSSPrefix + 'left-icon-el ' + Ext.baseCSSPrefix + 'icon-el ' + Ext.baseCSSPrefix + 'font-icon'}]}, {html:'', reference:'textElement', cls:Ext.baseCSSPrefix + 'text-el'}, {reference:'rightIconWrapElement', cls:Ext.baseCSSPrefix + 'right-icon-wrap-el ' + Ext.baseCSSPrefix + 'icon-wrap-el', children:[{reference:'rightIconElement', cls:Ext.baseCSSPrefix + 'right-icon-el ' + Ext.baseCSSPrefix + 'icon-el ' + Ext.baseCSSPrefix + 'font-icon'}]}, 
{reference:'arrowElement', cls:Ext.baseCSSPrefix + 'arrow-el ' + Ext.baseCSSPrefix + 'font-icon'}]}], ariaEl:'bodyElement', focusEl:'bodyElement', initialize:function() {
  this.callParent();
  this.syncHasIconCls();
}, getFocusClsEl:function() {
  return this.el;
}, expandMenu:function(event) {
  var me = this, menu = me.getMenu();
  if (!me.getDisabled() && menu) {
    menu.parentMenu = me.parentMenu;
    me.hideOnClick = false;
    if (menu.isVisible()) {
      if (event && event.type === 'keydown') {
        menu.focus();
      }
    } else {
      menu.autoFocus = !event || !event.pointerType;
      menu.showBy(me, me.getMenuAlign(), {axisLock:true});
    }
  }
}, getRefItems:function(deep) {
  var menu = this.getMenu(), items;
  if (menu) {
    items = menu.getRefItems(deep);
    items.unshift(menu);
  }
  return items || [];
}, onFocusEnter:function(e) {
  var me = this;
  me.callParent([e]);
  me.addCls(me.activeCls);
  me.activated = true;
  if (me.hasListeners.activate) {
    me.fireEvent('activate', me);
  }
  if (me.parentMenu) {
    me.parentMenu.setActiveItem(me);
  }
}, onFocusLeave:function(e) {
  var me = this, menu = me.menu;
  me.callParent([e]);
  me.removeCls(me.activeCls);
  if (menu) {
    menu.hide();
  }
  me.activated = false;
  if (me.hasListeners.deactivate) {
    me.fireEvent('deactivate', me);
  }
  if (me.parentMenu) {
    me.parentMenu.setActiveItem(null);
  }
}, onRemoved:function(destroying) {
  this.callParent([destroying]);
  this.parentMenu = null;
}, doDestroy:function() {
  var me = this;
  me.separatorElement = Ext.destroy(me.separatorElement);
  me.setMenu(null);
  me.callParent();
}, updateText:function(text) {
  if (text == null || text === '') {
    text = '';
  }
  this.textElement.dom.firstChild.data = text;
}, applyMenu:function(menu) {
  var me = this, ariaDom = me.ariaEl.dom;
  if (menu) {
    if (menu.isMenu) {
      menu.setConstrainAlign(Ext.getBody());
      menu.ownerCmp = me;
    } else {
      menu = Ext.menu.Menu.create(menu, {ownerCmp:me, $initParent:me, constrainAlign:Ext.getBody()});
    }
    ariaDom.setAttribute('aria-haspopup', true);
    ariaDom.setAttribute('aria-owns', menu.id);
  } else {
    ariaDom.removeAttribute('aria-haspopup');
    ariaDom.removeAttribute('aria-owns');
  }
  me.toggleCls(me.hasArrowCls, !!menu);
  return menu;
}, updateMenu:function(menu, oldMenu) {
  if (oldMenu) {
    if (this.destroyMenu) {
      Ext.destroy(oldMenu);
    } else {
      oldMenu.parentMenu = null;
    }
  }
  this.menu = menu;
}, updateHref:function(href) {
  this.bodyElement.dom.href = href;
  this.toggleCls(this.hasHrefCls, !!href);
}, updateTarget:function(target) {
  this.bodyElement.dom.target = target;
}, updateIcon:function(icon) {
  var me = this, iconElement = me.getIconAlign() === 'left' ? this.leftIconElement : this.rightIconElement;
  if (icon) {
    iconElement.setStyle('background-image', 'url(' + icon + ')');
  } else {
    iconElement.setStyle('background-image', '');
  }
  if (!me.isConfiguring) {
    me.syncHasIconCls();
  }
}, updateIconCls:function(iconCls, oldIconCls) {
  var me = this, iconElement = me.getIconAlign() === 'left' ? this.leftIconElement : this.rightIconElement;
  if (iconCls) {
    iconElement.replaceCls(oldIconCls, iconCls);
  } else {
    iconElement.removeCls(oldIconCls);
  }
  if (!me.isConfiguring) {
    me.syncHasIconCls();
  }
}, updateIconAlign:function(iconAlign) {
  if (!this.isConfiguring) {
    this.syncHasIconCls();
  }
}, updateSeparator:function(separator) {
  var me = this, separatorElement = me.separatorElement;
  if (separator) {
    if (separatorElement) {
      separatorElement.show();
    } else {
      me.separatorElement = separatorElement = Ext.Element.create({cls:Ext.baseCSSPrefix + 'menuseparator'});
      me.el.dom.insertBefore(separatorElement.dom, me.el.dom.firstChild);
    }
  } else {
    if (separatorElement) {
      separatorElement.hide();
    }
  }
}, privates:{onSpace:function(e) {
  return this.onClick(e);
}, onClick:function(e) {
  var me = this, href = me.getHref(), clickHideDelay = me.clickHideDelay, browserEvent = e.browserEvent, handler = me.getHandler(), clickResult;
  if ((!href || me.getDisabled()) && me.bodyElement.dom === e.getTarget('a')) {
    e.stopEvent();
    if (me.getDisabled()) {
      return false;
    }
  }
  if (me.getDisabled() || me.handlingClick) {
    return;
  }
  if (me.hideOnClick && !me.getMenu()) {
    if (!clickHideDelay) {
      me.hideParentMenus();
    } else {
      me.hideParentMenusTimer = Ext.defer(me.hideParentMenus, clickHideDelay, me);
    }
  }
  clickResult = me.fireEvent('click', me, e);
  if (me.destroyed) {
    return;
  }
  if (clickResult !== false && handler) {
    Ext.callback(handler, me.scope, [me, e], 0, me);
  }
  if (me.destroyed) {
    return;
  }
  if (href && e.type !== 'click' && !browserEvent.defaultPrevented) {
    me.handlingClick = true;
    me.bodyElement.dom.click();
    me.handlingClick = false;
  }
  return clickResult;
}, hideParentMenus:function() {
  for (var menu = this.getRefOwner(); menu && (menu.isMenu && menu.getFloated() || menu.isMenuItem); menu = menu.getRefOwner()) {
    if (menu.isMenu) {
      menu.hide();
    }
  }
}, hasIcon:function() {
  return !!(this.getIconCls() || this.getIcon());
}, syncHasIconCls:function() {
  var me = this, rightCls = me.hasRightIconCls, leftCls = me.hasLeftIconCls, iconAlign = me.getIconAlign();
  if (me.hasIcon()) {
    if (iconAlign === 'left') {
      me.replaceCls(rightCls, leftCls);
    } else {
      if (iconAlign === 'right') {
        me.replaceCls(leftCls, rightCls);
      }
    }
  } else {
    me.removeCls([leftCls, rightCls]);
  }
}}});
Ext.define('Ext.theme.material.menu.Item', {override:'Ext.menu.Item', config:{ripple:{delegate:'.' + Ext.baseCSSPrefix + 'body-el'}}, shouldRipple:function() {
  var me = this, rippleDelay = me.el.rippleShowTimeout;
  me.clickHideDelay = me.clickHideDelay > rippleDelay ? me.clickHideDelay : rippleDelay;
  return this.getRipple();
}});
Ext.define('Ext.menu.Manager', {singleton:true, alternateClassName:'Ext.menu.MenuMgr', hideAll:function() {
  var allMenus = this.visible, len = allMenus.length, result = false, i;
  if (len) {
    allMenus = allMenus.slice();
    for (i = 0; i < len; i++) {
      allMenus[i].hide();
      result = true;
    }
  }
  return result;
}, privates:{groups:{}, visible:[], constructor:function() {
  var me = this;
  me.onShow = function() {
    me.registerGlobalListeners();
    return me.onShow.apply(me, arguments);
  };
}, onGlobalScroll:function(scroller) {
  var allMenus = this.visible, len = allMenus.length, i, menu;
  if (len && scroller !== Ext.scroll.Scroller.viewport) {
    allMenus = allMenus.slice();
    for (i = 0; i < len; ++i) {
      menu = allMenus[i];
      if (scroller.contains(menu)) {
        menu.hide();
      }
    }
  }
}, checkActiveMenus:function(e) {
  var allMenus = this.visible, len = allMenus.length, i, menu, mousedownCmp = Ext.Component.from(e);
  if (len) {
    allMenus = allMenus.slice();
    for (i = 0; i < len; ++i) {
      menu = allMenus[i];
      if (!(menu.owns(e) || mousedownCmp && mousedownCmp.isMenuOwner && mousedownCmp.getMenu() === menu)) {
        menu.hide();
      }
    }
  }
}, onShow:function(menu) {
  if (menu.getFloated()) {
    Ext.Array.include(this.visible, menu);
  }
}, onHide:function(menu) {
  if (menu.getFloated()) {
    Ext.Array.remove(this.visible, menu);
  }
}, registerGlobalListeners:function() {
  var me = this;
  delete me.onShow;
  Ext.on({mousedown:me.checkActiveMenus, scrollstart:me.onGlobalScroll, scope:me});
  if (window.jasmine && jasmine.addAllowedListener) {
    jasmine.addAllowedListener('mousedown');
    jasmine.addAllowedListener('scrollstart');
  }
}}});
Ext.define('Ext.menu.Menu', {extend:Ext.Panel, xtype:'menu', isMenu:true, config:{align:'tl-bl?', indented:true, separator:null, autoHide:null, groups:null}, allowOtherMenus:false, ignoreParentClicks:false, mouseLeaveDelay:50, defaultType:'menuitem', autoSize:null, keyMap:{scope:'this', SPACE:'onSpaceKey', ESC:'onEscKey'}, layout:{type:'vbox', align:'stretch'}, classCls:Ext.baseCSSPrefix + 'menu', indentedCls:Ext.baseCSSPrefix + 'indented', hasSeparatorCls:Ext.baseCSSPrefix + 'has-separator', nonMenuItemCls:Ext.baseCSSPrefix + 
'non-menuitem', allowFocusingDisabledChildren:true, border:true, defaultFocus:':focusable', floated:true, focusable:true, focusableContainer:true, nameHolder:true, weighted:true, initialize:function() {
  var me = this, listeners = {click:me.onClick, mouseover:me.onMouseOver, scope:me};
  me.callParent();
  if (Ext.supports.Touch) {
    listeners.pointerdown = me.onMouseOver;
  }
  me.element.on(listeners);
  me.itemOverTask = new Ext.util.DelayedTask(me.handleItemOver, me);
  me.mouseMonitor = me.el.monitorMouseLeave(me.mouseLeaveDelay, me.onMouseLeave, me);
}, doDestroy:function() {
  var me = this;
  me.itemOverTask.cancel();
  Ext.menu.Manager.onHide(me);
  me.parentMenu = me.ownerCmp = null;
  if (me.rendered) {
    me.el.un(me.mouseMonitor);
  }
  me.callParent();
}, showBy:function(component, alignment, options) {
  this.callParent([component, alignment || this.getAlign(), options]);
}, onFocusEnter:function(e) {
  var me = this, hierarchyState;
  me.callParent([e]);
  me.mixins.focusablecontainer.onFocusEnter.call(me, e);
  if (me.getFloated()) {
    hierarchyState = me.getInherited();
    if (!hierarchyState.topmostFocusEvent) {
      hierarchyState.topmostFocusEvent = e;
    }
  }
}, onFocusLeave:function(e) {
  this.callParent([e]);
  if (this.getAutoHide() !== false) {
    this.hide();
  }
}, onItemAdd:function(item, index) {
  this.callParent([item, index]);
  this.syncItemIndentedCls(item);
  if (!item.isMenuItem && !item.isMenuSeparator) {
    item.addCls(this.nonMenuItemCls);
  }
}, onItemRemove:function(item, index, destroying) {
  this.callParent([item, index, destroying]);
  item.removeCls(this.indentedCls, this.nonMenuItemCls);
}, beforeShow:function() {
  var me = this, parent;
  if (me.getFloated()) {
    parent = me.hasFloatMenuParent();
    if (!parent && !me.allowOtherMenus) {
      Ext.menu.Manager.hideAll();
    }
  }
  me.callParent(arguments);
}, afterShow:function() {
  var me = this, ariaDom = me.ariaEl.dom;
  me.callParent(arguments);
  Ext.menu.Manager.onShow(me);
  if (me.getFloated() && ariaDom) {
    ariaDom.setAttribute('aria-expanded', true);
  }
  if (me.getFloated()) {
    me.maxHeight = me.savedMaxHeight;
  }
  if (me.autoFocus) {
    me.focus();
  }
}, afterHide:function() {
  var me = this, ariaDom = me.ariaEl.dom;
  me.callParent();
  me.lastHide = Ext.Date.now();
  Ext.menu.Manager.onHide(me);
  if (me.getFloated() && ariaDom) {
    ariaDom.setAttribute('aria-expanded', false);
  }
  delete me.getInherited().topmostFocusEvent;
}, factoryItem:function(cfg) {
  var result;
  if (typeof cfg === 'string' && cfg[0] !== '@') {
    if (cfg === '-') {
      cfg = {xtype:'menuseparator'};
    } else {
      cfg = {};
    }
  }
  result = this.callParent([cfg]);
  if (result.isMenuItem) {
    result.parentMenu = this;
  }
  return result;
}, updateIndented:function(indented) {
  var me = this;
  if (!me.isConfiguring) {
    me.bodyElement.toggleCls(me.hasSeparatorCls, !!(indented && me.getSeparator()));
    me.items.each(me.syncItemIndentedCls, me);
  }
}, updateSeparator:function(separator) {
  this.bodyElement.toggleCls(this.hasSeparatorCls, !!(separator && this.getIndented()));
}, privates:{applyItemDefaults:function(item) {
  item = this.callParent([item]);
  if (!item.isComponent && !item.xtype && !item.xclass) {
    if (item.group || item.name) {
      item.xtype = 'menuradioitem';
    } else {
      if ('checked' in item) {
        item.xtype = 'menucheckitem';
      }
    }
  }
  return item;
}, applyGroups:function(groups, oldGroups) {
  var me = this, currentGroups = Ext.apply({}, oldGroups), isConfiguring = me.isConfiguring, groupName, members, len, i, item, value, oldValue;
  if (groups) {
    for (groupName in groups) {
      oldValue = currentGroups[groupName];
      currentGroups[groupName] = value = groups[groupName];
      if (!isConfiguring) {
        members = me.lookupName(groupName);
        for (i = 0, len = members.length; i < len; i++) {
          item = members[i];
          item.setChecked(item.getValue() === value);
        }
        me.fireEvent('groupchange', me, groupName, value, oldValue);
      }
    }
    if (!isConfiguring) {
      me.addBindableUpdater('groups');
    }
  }
  return currentGroups;
}, processFocusableContainerKeyEvent:function(e) {
  var keyCode = e.keyCode, item;
  if (keyCode === e.ESC || Ext.fly(e.target).is('input[type\x3dcheckbox]') && (keyCode === e.LEFT || keyCode === e.RIGHT || keyCode === e.UP || keyCode === e.DOWN)) {
    e.preventDefault();
    item = this.getItemFromEvent(e);
    e.target = item && item.focusEl.dom;
  } else {
    if (keyCode === e.TAB && Ext.fly(e.target).is('input[type\x3dtext],textarea')) {
      e.preventDefault();
      item = this.getItemFromEvent(e);
      e.target = item && item.focusEl.dom;
      if (e.shiftKey) {
        e.shiftKey = false;
        e.keyCode = e.UP;
      } else {
        e.keyCode = e.DOWN;
      }
    } else {
      return this.callParent([e]);
    }
  }
  return e;
}, onEscKey:function(e) {
  if (this.getFloated()) {
    this.hide();
  }
}, onSpaceKey:function(e) {
  var clickedItem = this.getItemFromEvent(e);
  if (clickedItem && clickedItem.isMenuItem) {
    clickedItem.onSpace(e);
  }
}, onFocusableContainerLeftKey:function(e) {
  e.preventDefault();
  if (this.parentMenu) {
    this.hide();
  }
}, onFocusableContainerRightKey:function(e) {
  var clickedItem = this.getItemFromEvent(e);
  e.preventDefault();
  if (clickedItem) {
    clickedItem.expandMenu(e);
  }
}, onClick:function(e) {
  var me = this, type = e.type, clickedItem, clickResult, isKeyEvent = type === 'keydown', isTouchEvent = e.pointerType === 'touch';
  if (me.getDisabled()) {
    return e.stopEvent();
  }
  clickedItem = me.getItemFromEvent(e);
  if (clickedItem && clickedItem.isMenuItem) {
    if (!clickedItem.getMenu() || !me.ignoreParentClicks) {
      clickResult = clickedItem.onClick(e);
    } else {
      e.stopEvent();
    }
    if (me.destroyed) {
      return;
    }
    if (clickedItem.getMenu() && clickResult !== false && (isKeyEvent || isTouchEvent)) {
      clickedItem.expandMenu(e);
    }
  }
  if (!clickedItem || clickedItem.getDisabled()) {
    clickedItem = undefined;
  }
  me.fireEvent('click', me, clickedItem, e);
}, onMouseLeave:function(e) {
  var me = this;
  if (me.itemOverTask) {
    me.itemOverTask.cancel();
  }
  if (me.getDisabled()) {
    return;
  }
  me.fireEvent('mouseleave', me, e);
}, onMouseOver:function(e) {
  var me = this, activeItem = me.getActiveItem(), activeItemMenu = activeItem && activeItem.getMenu && activeItem.getMenu(), activeItemExpanded = activeItemMenu && activeItemMenu.isVisible(), isTouch = e.pointerType === 'touch', mouseEnter, overItem, el;
  if (!me.getDisabled()) {
    if (isTouch) {
      mouseEnter = !me.el.contains(document.activeElement);
    } else {
      mouseEnter = !me.el.contains(e.getRelatedTarget());
    }
    overItem = me.getItemFromEvent(e);
    if (overItem) {
      if (isTouch) {
        me.handleItemOver(e, overItem);
      } else {
        el = overItem.isMenuItem ? overItem.bodyElement : overItem.el;
        if (!el.contains(e.getRelatedTarget())) {
          me.itemOverTask.delay(activeItemExpanded ? me.mouseLeaveDelay : 0, null, null, [e, overItem]);
        }
      }
    }
    if (mouseEnter) {
      me.fireEvent('mouseenter', me, e);
    }
    me.fireEvent('mouseover', me, overItem, e);
  }
}, handleItemOver:function(e, item) {
  var isMouseover = e.pointerType === 'mouse';
  if (!item.containsFocus && (isMouseover || item.isMenuItem)) {
    item.focus();
  }
  if (item.expandMenu && isMouseover) {
    item.expandMenu(e);
  }
}, getItemFromEvent:function(e) {
  var bodyDom = this.bodyElement.dom, toEl = e.getTarget(), component;
  while (toEl && toEl.parentNode !== bodyDom) {
    toEl = toEl.parentNode;
  }
  component = toEl && Ext.getCmp(toEl.id);
  if (component && component.isMenuItem && !e.within(component.bodyElement)) {
    component = null;
  }
  return component;
}, hasFloatMenuParent:function() {
  return this.parentMenu || this.up('menu[_floated\x3dtrue]');
}, syncItemIndentedCls:function(item) {
  var indented = item.isMenuItem ? item.getIndented() : item.indented;
  item.toggleCls(this.indentedCls, !!(indented || this.getIndented() && indented !== false));
}}, statics:{create:function(menu, config) {
  if (Ext.isArray(menu)) {
    menu = Ext.apply({xtype:'menu', items:menu}, config);
  } else {
    menu = Ext.apply({xtype:'menu'}, menu, config);
  }
  return Ext.create(menu);
}}, deprecated:{'6.5':{configs:{plain:{message:'To achieve classic toolkit "plain" effect, use "indented".'}, showSeparator:{message:'To achieve classic toolkit "showSeparator" effect, use "separator".'}}}}});
Ext.define('Ext.theme.material.menu.Menu', {override:'Ext.menu.Menu', config:{indented:false}});
Ext.define('Ext.TitleBar', {extend:Ext.Container, xtype:'titlebar', defaultBindProperty:'title', isToolbar:true, classCls:Ext.baseCSSPrefix + 'titlebar', inheritUi:true, config:{cls:Ext.baseCSSPrefix + 'navigation-bar', title:null, titleAlign:'center', defaultType:'button', defaultButtonUI:null, minHeight:null, layout:{type:'hbox', align:'center'}, items:[], maxButtonWidth:'40%'}, autoSize:null, border:false, beforeInitialize:function() {
  this.applyItems = this.applyInitialItems;
}, initialize:function() {
  var me = this;
  me.callParent();
  delete me.applyItems;
  me.add(me.initialItems);
  delete me.initialItems;
  me.on({scope:me, painted:'refreshTitlePosition', single:true});
}, applyInitialItems:function(items) {
  var me = this, titleAlign = me.getTitleAlign(), defaults = me.getDefaults() || {};
  me.initialItems = items;
  me.leftBox = me.add({xtype:'container', style:'position: relative', cls:Ext.baseCSSPrefix + 'titlebar-left', autoSize:null, layout:{type:'hbox', align:'center'}, listeners:{resize:'refreshTitlePosition', scope:me}});
  me.spacer = me.add({xtype:'component', style:'position: relative', cls:Ext.baseCSSPrefix + 'titlebar-center', flex:1, listeners:{resize:'refreshTitlePosition', scope:me}});
  me.rightBox = me.add({xtype:'container', style:'position: relative', cls:Ext.baseCSSPrefix + 'titlebar-right', autoSize:null, layout:{type:'hbox', align:'center'}, listeners:{resize:'refreshTitlePosition', scope:me}});
  switch(titleAlign) {
    case 'left':
      me.titleComponent = me.leftBox.add({xtype:'title', cls:Ext.baseCSSPrefix + 'title-align-left', hidden:defaults.hidden});
      me.refreshTitlePosition = Ext.emptyFn;
      break;
    case 'right':
      me.titleComponent = me.rightBox.add({xtype:'title', cls:Ext.baseCSSPrefix + 'title-align-right', hidden:defaults.hidden});
      me.refreshTitlePosition = Ext.emptyFn;
      break;
    default:
      me.titleComponent = me.add({xtype:'title', hidden:defaults.hidden, centered:true});
      break;
  }
  me.doAdd = me.doBoxAdd;
  me.remove = me.doBoxRemove;
  me.doInsert = me.doBoxInsert;
}, doBoxAdd:function(item) {
  var me = this, titleAlign = me.getTitleAlign();
  me.addDefaultButtonUI(item);
  if (item.config.align == 'right') {
    me.rightBox.add(item);
  } else {
    if (me.titleComponent && titleAlign === 'left') {
      me.leftBox.insertBefore(item, me.titleComponent);
    } else {
      me.leftBox.add(item);
    }
  }
}, doBoxRemove:function(item, destroy) {
  if (item.config.align == 'right') {
    this.rightBox.remove(item, destroy);
  } else {
    this.leftBox.remove(item, destroy);
  }
}, doBoxInsert:function(index, item) {
  var me = this;
  me.addDefaultButtonUI(item);
  if (item.config.align == 'right') {
    me.rightBox.insert(index, item);
  } else {
    me.leftBox.insert(index, item);
  }
}, addDefaultButtonUI:function(item) {
  var defaultButtonUI = this.getDefaultButtonUI();
  if (defaultButtonUI) {
    if (item.isSegmentedButton) {
      if (item.getDefaultUI() == null) {
        item.setDefaultUI(defaultButtonUI);
      }
    } else {
      if (item.isButton && item.getUi() == null) {
        item.setUi(defaultButtonUI);
      }
    }
  }
}, calculateMaxButtonWidth:function() {
  var maxButtonWidth = this.getMaxButtonWidth();
  if (Ext.isString(maxButtonWidth)) {
    maxButtonWidth = parseInt(maxButtonWidth.replace('%', ''), 10);
  }
  maxButtonWidth = Math.round(this.element.getWidth() / 100 * maxButtonWidth);
  return maxButtonWidth;
}, refreshTitlePosition:function() {
  if (this.destroyed) {
    return;
  }
  var titleElement = this.titleComponent.renderElement;
  titleElement.setWidth(null);
  titleElement.setLeft(null);
  var leftBox = this.leftBox, leftButton = leftBox.down('button'), singleButton = leftBox.getItems().getCount() == 1, leftBoxWidth, maxButtonWidth;
  if (leftButton && singleButton) {
    if (leftButton.getWidth() == null) {
      leftButton.renderElement.setWidth('auto');
    }
    leftBoxWidth = leftBox.renderElement.getWidth();
    maxButtonWidth = this.calculateMaxButtonWidth();
    if (leftBoxWidth > maxButtonWidth) {
      leftButton.renderElement.setWidth(maxButtonWidth);
    }
  }
  var spacerBox = this.spacer.renderElement.getBox();
  if (Ext.browser.is.IE) {
    titleElement.setWidth(spacerBox.width);
  }
  var titleBox = titleElement.getBox(), widthDiff = titleBox.width - spacerBox.width, titleLeft = titleBox.left, titleRight = titleBox.right, halfWidthDiff, leftDiff, rightDiff;
  if (widthDiff > 0) {
    halfWidthDiff = widthDiff / 2;
    titleLeft += halfWidthDiff;
    titleRight -= halfWidthDiff;
    titleElement.setWidth(spacerBox.width);
  }
  leftDiff = spacerBox.left - titleLeft;
  rightDiff = titleRight - spacerBox.right;
  if (leftDiff > 0) {
    titleElement.setLeft(leftDiff);
  } else {
    if (rightDiff > 0) {
      titleElement.setLeft(-rightDiff);
    }
  }
  titleElement.repaint();
}, updateTitle:function(newTitle) {
  this.getItems();
  this.titleComponent.setTitle(newTitle);
  if (this.isPainted()) {
    this.refreshTitlePosition();
  }
}});
Ext.define('Ext.theme.neptune.Titlebar', {override:'Ext.TitleBar', config:{defaultButtonUI:'alt'}});
Ext.define('Ext.theme.material.TitleBar', {override:'Ext.TitleBar', config:{titleAlign:'left', defaultButtonUI:'alt'}});
Ext.define('Ext.Toast', {extend:Ext.Sheet, config:{centered:false, showAnimation:{type:'popIn', duration:250, easing:'ease-out'}, hideAnimation:{type:'popOut', duration:250, easing:'ease-out'}, zIndex:999, message:'', timeout:1000, maxQueue:3, messageAnimation:true, hideOnMaskTap:true, modal:false, layout:{type:'vbox', pack:'center'}}, classCls:Ext.baseCSSPrefix + 'toast', applyMessage:function(value) {
  var config = {html:value, cls:this.baseCls + '-text'};
  return Ext.factory(config, Ext.Component, this._message);
}, updateMessage:function(newMessage) {
  if (newMessage) {
    this.add(newMessage);
  }
}, startTimer:function() {
  var timeout = this.getTimeout();
  if (this._timeoutID) {
    Ext.undefer(this._timeoutID);
  }
  if (!Ext.isEmpty(timeout)) {
    this._timeoutID = Ext.defer(this.onTimeout.bind(this), timeout);
  } else {
    this.onTimeout();
  }
}, stopTimer:function() {
  Ext.undefer(this._timeoutID);
  this._timeoutID = null;
}, next:Ext.emptyFn, getIsAnimating:function() {
  var messageContainer = this.getMessage();
  return messageContainer && Ext.Animator.hasRunningAnimations(messageContainer) || Ext.Animator.hasRunningAnimations(this);
}, showToast:function(config) {
  var me = this, message = config.message, timeout = config.timeout, messageContainer = me.getMessage(), msgAnimation = me.getMessageAnimation();
  if (me.isRendered() && me.isHidden() === false) {
    messageContainer.onAfter({hiddenchange:function() {
      me.setMessage(message);
      me.setTimeout(timeout);
      messageContainer.onAfter({scope:me, hiddenchange:function() {
        me.startTimer();
      }, single:true});
      messageContainer.show(msgAnimation);
    }, scope:me, single:true});
    messageContainer.hide(msgAnimation);
  } else {
    Ext.util.InputBlocker.blockInputs();
    if (!me.getParent() && Ext.Viewport) {
      Ext.Viewport.add(me);
    }
    me.setMessage(message);
    me.setTimeout(timeout);
    me.startTimer();
    me.show({animation:null, alignment:{component:document.body, alignment:'t-t', options:{offset:[0, 20]}}});
  }
}, beforeHide:function(animation) {
  this.callParent(arguments);
  if (this.getIsAnimating()) {
    return false;
  }
  this.stopTimer();
  if (!this.next()) {
    return false;
  }
}, onTimeout:function() {
  if (this._timeoutID !== null) {
    this.hide();
  }
}, doDestroy:function() {
  this.stopTimer();
  this.callParent();
}}, function(Toast) {
  var _queue = [];
  function getInstance() {
    if (!Ext.Toast._instance) {
      Ext.Toast._instance = Ext.create('Ext.Toast');
    }
    return Ext.Toast._instance;
  }
  Toast.prototype.getQueueCount = function() {
    return _queue.length;
  };
  Toast.prototype.next = function() {
    var config = _queue.shift();
    if (config) {
      this.showToast(config);
    }
    return !config;
  };
  Ext.Toast.destroy = function() {
    if (Ext.Toast._instance) {
      Ext.Toast._instance.destroy();
      Ext.Toast._instance = null;
    }
  };
  Ext.toast = function(message, timeout) {
    var toast = getInstance(), maxQueue = Ext.Toast.prototype.config.maxQueue, config = message;
    if (Ext.isString(message)) {
      config = {message:message, timeout:timeout};
    }
    if (!config) {
      throw new Error('Toast requires a message');
    }
    if (config.timeout === undefined) {
      config.timeout = Ext.Toast.prototype.config.timeout;
    }
    _queue.push(config);
    if (_queue.length > maxQueue) {
      _queue.shift();
    }
    if (!toast.isRendered() || toast.isHidden()) {
      toast.next();
    }
    return toast;
  };
});
Ext.define('Ext.dataview.Location', {isDataViewLocation:true, child:null, event:null, item:null, record:null, recordIndex:-1, sourceElement:null, view:null, viewIndex:-1, constructor:function(view, source) {
  this.view = view;
  if (source != null) {
    this.attach(source);
  }
}, attach:function(source) {
  var me = this, view = me.view, store = view.store, record, child, sourceElement;
  if (me.source) {
    Ext.raise('DataView Locations cannot be modified');
  }
  if (source.isEvent) {
    me.event = source;
    sourceElement = source.target;
  }
  if (source.isElement || source.nodeType === 1) {
    sourceElement = source;
  }
  me.source = source;
  if (source.isWidget) {
    sourceElement = source.getFocusEl();
    source = source.element;
  }
  if (typeof source === 'number') {
    child = view.itemFromRecord(source);
    me.recordIndex = source;
    record = store && store.getAt(source);
  } else {
    if (source.isModel) {
      record = source;
    } else {
      record = view.mapToRecord(source);
    }
    child = view.mapToItem(source);
    me.recordIndex = store ? store.indexOf(record) : -1;
  }
  if (child && !sourceElement) {
    sourceElement = child.isWidget ? child.getFocusEl() : child;
  }
  me.child = child;
  me.record = record;
  if (record && child) {
    me.item = child;
  }
  if (child) {
    me.viewIndex = view.mapToViewIndex(child);
  }
  me.sourceElement = Ext.getDom(sourceElement);
}, clone:function() {
  var me = this, ret = new this.self(me.view);
  ret.event = me.event;
  ret.sourceElement = me.sourceElement;
  ret.item = me.item;
  ret.record = me.record;
  ret.recordIndex = me.recordIndex;
  ret.viewIndex = me.viewIndex;
  return ret;
}, equals:function(other) {
  return other && other.view === this.view && other.isDataViewLocation && other.sourceElement === this.sourceElement;
}, getFocusEl:function(as) {
  var item = this.get(), ret = null;
  if (item && item.isWidget) {
    item = item.element;
  }
  if (item) {
    ret = as === 'dom' || as === true ? Ext.getDom(item) : Ext.get(item);
  }
  return ret;
}, get:function() {
  return this.child;
}, isFirstDataItem:function() {
  return this.recordIndex === 0;
}, isFirstViewItem:function() {
  var view = this.view;
  if (view.infinite) {
    return view.previous(this.child == null);
  }
  return this.viewIndex === 0;
}, isLastDataItem:function() {
  return this.recordIndex === this.view.store.getCount() - 1;
}, isLastViewItem:function() {
  var view = this.view;
  if (view.infinite) {
    return view.next(this.child == null);
  }
  return this.viewIndex === view.innerItems.length - 1;
}, refresh:function() {
  var me = this, view = me.view, item = me.child, newSource = view.mapToItem(me.record) || (view.items.contains(item) ? item : view.mapToItem(Math.min(me.viewIndex, view.dataItems.length - 1)));
  return new this.self(view, newSource);
}, isFirst:function() {
  return this.view.isFirstItem(this.child);
}, isLast:function() {
  return this.view.isLastItem(this.child);
}, next:function(options) {
  var me = this, candidate = me.nextItem(options), item = candidate && candidate.get();
  while (candidate && (!item || !item.el.isFocusable())) {
    if (candidate.equals(me)) {
      return me;
    }
    candidate = candidate.nextItem(options);
    item = candidate && candidate.get();
  }
  return candidate || me;
}, previous:function(options) {
  var me = this, candidate = me.previousItem(options), item = candidate && candidate.get();
  while (candidate && (!item || !item.el.isFocusable())) {
    if (candidate.equals(me)) {
      return me;
    }
    candidate = candidate.previousItem(options);
    item = candidate && candidate.get();
  }
  return candidate || me;
}, nextItem:function(options) {
  var view = this.view, item = this.child, wrap = typeof options === 'boolean' ? options : !!(options && options.wrap), nextItem;
  if (view.isLastItem(item)) {
    if (wrap) {
      nextItem = view.getFirstItem();
    } else {
      return null;
    }
  } else {
    nextItem = view.nextItem(item);
  }
  return new this.self(view, nextItem);
}, previousItem:function(options) {
  var view = this.view, item = this.child, wrap = typeof options === 'boolean' ? options : !!(options && options.wrap), prevItem;
  if (view.isFirstItem(item)) {
    if (wrap) {
      prevItem = view.getLastItem();
    } else {
      return null;
    }
  } else {
    prevItem = view.previousItem(item);
  }
  return new this.self(view, prevItem);
}});
Ext.define('Ext.dataview.NavigationModel', {extend:Ext.Evented, alias:'navmodel.dataview', mixins:[Ext.mixin.Factoryable, Ext.mixin.Bufferable], factoryConfig:{type:'navmodel', defaultType:'dataview', instanceProp:'isNavigationModel'}, isNavigationModel:true, config:{view:null, disabled:false}, bufferableMethods:{handleChildTrigger:1}, locationClass:'Ext.dataview.Location', setLocation:function(location, options) {
  var me = this, view = me.getView(), oldLocation = me.location, animation = options && options.animation, scroller, child, record, itemContainer, childFloatStyle;
  if (location == null) {
    return me.clearLocation();
  }
  if (!location.isDataViewLocation) {
    location = this.createLocation(location);
  }
  if (!location.equals(oldLocation)) {
    record = location.record;
    child = location.child;
    if (record && !child) {
      return view.ensureVisible(record, {animation:animation}).then(function() {
        if (!me.destroyed) {
          me.setLocation({record:record, column:location.column}, options);
        }
      });
    }
    if (child && me.floatingItems == null) {
      child = child.isComponent ? child.el : Ext.fly(child);
      itemContainer = child.up();
      childFloatStyle = child.getStyleValue('float');
      me.floatingItems = view.getInline && view.getInline() || child.isStyle('display', 'inline-block') || childFloatStyle === 'left' || childFloatStyle === 'right' || itemContainer.isStyle('display', 'flex') && itemContainer.isStyle('flex-direction', 'row');
    }
    scroller = view.getScrollable();
    if (scroller) {
      scroller.ensureVisible(location.sourceElement, {animation:options && options.animation});
    }
    me.handleLocationChange(location, options);
    if (!me.destroyed) {
      me.doFocus();
    }
  }
}, clearLocation:function() {
  var me = this, targetElement;
  if (me.location) {
    me.previousLocation = me.location;
    targetElement = me.location.getFocusEl();
    if (targetElement && !targetElement.destroyed) {
      Ext.fly(targetElement).removeCls(me.focusedCls);
    }
    me.location = null;
  }
}, getLocation:function() {
  return this.location;
}, getPreviousLocation:function() {
  var result = this.previousLocation;
  if (result && (!result.sourceElement || !result.sourceElement.destroyed)) {
    result.refresh();
  }
  return result;
}, disable:function() {
  this.setDisabled(true);
}, enable:function() {
  this.setDisabled(false);
}, privates:{createLocation:function(source, options) {
  return Ext.create(this.locationClass, this.getView(), source, options);
}, getKeyNavCfg:function(view) {
  var me = this;
  return {target:view.getFocusEl(), processEvent:me.processViewEvent, processEventScope:me, eventName:'keydown', defaultEventAction:'stopEvent', esc:me.onKeyEsc, f2:me.onKeyF2, up:me.onKeyUp, down:me.onKeyDown, right:me.onKeyRight, left:me.onKeyLeft, pageDown:me.onKeyPageDown, pageUp:me.onKeyPageUp, home:me.onKeyHome, end:me.onKeyEnd, space:me.onKeySpace, enter:me.onKeyEnter, tab:me.onKeyTab, A:{ctrl:true, handler:me.onSelectAllKeyPress}, scope:me};
}, updateView:function(view) {
  var me = this, keyNavCfg = me.getKeyNavCfg(view);
  me.focusedCls = view.focusedCls;
  if (keyNavCfg) {
    me.keyNav = new Ext.util.KeyNav(keyNavCfg);
  }
  me.viewListeners = view.on(me.getViewListeners(view));
}, getViewListeners:function(view) {
  var result = {scope:this};
  result[view.getTriggerEvent()] = 'onChildTrigger';
  return result;
}, processViewEvent:function(e) {
  var location = this.getLocation(), component;
  if (location && e.keyCode) {
    component = Ext.fly(e.target).component;
    e.navigationMode = component && component.parent === this.getView();
    e.setCurrentTarget(location.sourceElement);
    if (!Ext.fly(e.target).isInputField()) {
      return e;
    }
  }
}, doFocus:function(location) {
  location = location || this.location;
  if (location && location.getFocusEl()) {
    location.getFocusEl().focus();
  }
}, onFocusMove:function(e) {
  var location = this.createLocation(e);
  if (!location.equals(this.location)) {
    this.handleLocationChange(location, {event:e, navigate:false});
  }
}, handleLocationChange:function(location, options) {
  var me = this, oldLocation = me.location, view = me.getView(), target, item;
  me.previousLocation = oldLocation;
  if (oldLocation) {
    me.lastLocation = oldLocation;
    target = oldLocation.getFocusEl();
    if (target && !target.destroyed) {
      Ext.fly(target).removeCls(me.focusedCls);
    }
  }
  me.location = location;
  target = location && location.getFocusEl('dom');
  if (target) {
    item = location.get();
    if (item) {
      if (item.isWidget) {
        item = item.el;
      } else {
        item = Ext.get(item);
      }
      if (item && target === item.dom) {
        item.addCls(me.focusedCls);
      }
      if (options && (options.event || options.select) && options.navigate !== false) {
        me.onNavigate(options.event);
      }
    }
  }
  if (!view.destroyed) {
    view.fireEvent('navigate', view, location, oldLocation);
  }
}, onKeyUp:function(e) {
  e.preventDefault();
  if (this.location) {
    if (this.floatingItems) {
      this.moveUp(e);
    } else {
      this.movePrevious({event:e});
    }
  } else {
    this.setLocation(0);
  }
}, onKeyDown:function(e) {
  e.preventDefault();
  if (this.location) {
    if (this.floatingItems) {
      this.moveDown(e);
    } else {
      this.moveNext({event:e});
    }
  } else {
    this.setLocation(0);
  }
}, onKeyLeft:function(e) {
  e.preventDefault();
  this.movePrevious({event:e});
}, onKeyRight:function(e) {
  e.preventDefault();
  this.moveNext({event:e});
}, onKeyF2:function(e) {
  return false;
}, onKeyEsc:function(e) {
  return false;
}, onKeyTab:function(e) {
  return !this.location.actionable;
}, onKeyPageDown:function(e) {
  e.preventDefault();
  if (!this.location.actionable && !this.floatingItems) {
    var me = this, view = me.getView(), y = (view.infinite ? view.getItemTop(me.location.child) : me.location.child.el.dom.offsetTop) + view.el.getClientRegion().height, candidate = me.createLocation(view.getItemFromPoint(0, y));
    if (!(candidate.child && candidate.child.el.isFocusable())) {
      candidate = candidate.previous();
    }
    me.setLocation(candidate, {event:e});
  }
}, onKeyPageUp:function(e) {
  e.preventDefault();
  if (!this.location.actionable && !this.floatingItems) {
    var me = this, view = me.getView(), y = (view.infinite ? view.getItemTop(me.location.child) : me.location.child.el.dom.offsetTop) - view.el.getClientRegion().height, candidate = me.createLocation(view.getItemFromPoint(0, y));
    if (!(candidate.child && candidate.child.el.isFocusable())) {
      candidate = candidate.next();
    }
    me.setLocation(candidate, {event:e});
  }
}, onKeyHome:function(e) {
  this.setLocation(0, {event:e});
}, onKeyEnd:function(e) {
  this.setLocation(this.getView().getStore().last(), {event:e});
}, onKeySpace:function(e) {
  this.onNavigate(e);
}, onKeyEnter:function(e) {
  e.stopEvent();
  this.getView()._onChildTap(e);
}, onSelectAllKeyPress:function(e) {
  var view = this.getView(), selModel = view.getSelectable();
  if (selModel && view.getStore().getCount()) {
    selModel[selModel.allSelected ? 'deselectAll' : 'selectAll']();
    e.preventDefault();
    return false;
  }
}, moveUp:function(e) {
  var view = this.getView(), location = this.location, el = this.location.sourceElement, topCentre = Ext.fly(el).getAnchorXY('t'), item;
  topCentre[1] -= Ext.fly(el).getMargin('tb') + 10;
  item = this.getView().getItemFromPagePoint(topCentre[0], topCentre[1], true);
  if (!item || !item.isFocusable()) {
    item = location.isFirst() ? view.getLastItem() : view.getFirstItem();
  }
  if (item) {
    this.setLocation(item, {event:e});
  }
}, moveDown:function(e) {
  var view = this.getView(), location = this.location, el = location.sourceElement, bottomCentre = Ext.fly(el).getAnchorXY('b'), item;
  bottomCentre[1] += Ext.fly(el).getMargin('tb') + 10;
  item = view.getItemFromPagePoint(bottomCentre[0], bottomCentre[1]);
  if (!item || !item.isFocusable()) {
    item = location.isLast() ? view.getFirstItem() : view.getLastItem();
  }
  if (item) {
    this.setLocation(item, {event:e});
  }
}, moveNext:function(options) {
  var location = this.getLocation();
  if (location) {
    location = location.next(options);
    if (location) {
      this.setLocation(location, options);
    }
  }
}, movePrevious:function(options) {
  var location = this.getLocation();
  if (location) {
    location = location.previous(options);
    if (location) {
      this.setLocation(location, options);
    }
  }
}, onChildTrigger:function(view, location) {
  var e = location.event, isFocusingEvent = e.pointerType === 'touch' ? e.type === 'tap' : e.type === 'touchstart';
  if (isFocusingEvent) {
    this.handleChildTrigger(view, location);
  } else {
    this.doHandleChildTrigger(view, location);
  }
}, doHandleChildTrigger:function(view, location) {
  var myLocation = this.location, event = location.event, compareMethod = location.isGridLocation ? 'equalCell' : 'equals';
  if (myLocation && myLocation[compareMethod](location)) {
    this.onNavigate(event);
  } else {
    this.setLocation(location, {event:event});
  }
}, onNavigate:function(event) {
  var me = this, location = me.location;
  if (!event) {
    event = new Ext.event.Event({target:location.sourceElement});
  }
  Ext.apply(event, {navigationModel:me, from:me.previousLocation, to:location});
  me.getView().onNavigate(event);
}, updateDisabled:function(disabled) {
  if (this.keyNav) {
    if (disabled) {
      this.keyNav.disable();
    } else {
      this.keyNav.enable();
    }
  }
}}});
Ext.define('Ext.dataview.selection.Selection', {mixins:[Ext.mixin.Factoryable], factoryConfig:{type:'selection', defaultType:'records', instanceProp:'isSelection'}, isSelection:true, config:{selectionModel:null}, constructor:function(config) {
  if (config.isDataView) {
    config = {selectionModel:config.getSelectionModel()};
  }
  this.initConfig(config);
  if (!this.getSelectionModel()) {
    Ext.raise('Selection must be configured with a SelectionModel');
  }
}, destroy:function() {
  this.clear();
  this.callParent();
}, privates:{applySelectionModel:function(selectionModel) {
  var view;
  this.view = view = selectionModel.getView();
  if (view.isGrid) {
    this.view = view.ownerGrid;
  }
  return selectionModel;
}}});
Ext.define('Ext.dataview.selection.Rows', {extend:Ext.dataview.selection.Selection, alias:'selection.rows', isRows:true, config:{selected:true}, clone:function() {
  return new this.self({selectionModel:this.getSelectionModel(), selected:(new Ext.util.Spans).unstash(this.getSelected().stash())});
}, add:function(range, keepExisting, suppressEvent) {
  var me = this, view = me.view, rowIdx;
  if (range.length === 1) {
    range = range[0];
  }
  if (range.isEntity) {
    range = view.mapToRecordIndex(range);
  }
  if (typeof range === 'number') {
    range = [range, range + 1];
  }
  if (range.length !== 2 || typeof range[0] !== 'number' || typeof range[1] !== 'number') {
    Ext.raise('add must be called with a [start, end] row index *EXCLUSIVE* range');
  }
  if (range[0] > range[1]) {
    var tmp = range[1];
    range[1] = range[0];
    range[0] = tmp;
  }
  me.lastSelected = range[1];
  if (!keepExisting) {
    me.clear();
  }
  me.getSelected().add(range);
  for (rowIdx = range[0]; rowIdx < range[1]; rowIdx++) {
    view.onItemSelect(rowIdx);
  }
  if (!suppressEvent) {
    me.getSelectionModel().fireSelectionChange();
  }
}, remove:function(range, suppressEvent) {
  var me = this, selModel = me.getSelectionModel(), view = me.view, rowIdx;
  if (!selModel.getDeselectable() && me.getCount() === 1) {
    return;
  }
  if (range.length === 1) {
    range = range[0];
  }
  if (range.isEntity) {
    range = view.mapToRecordIndex(range);
  }
  if (typeof range === 'number') {
    range = [range, range + 1];
  }
  if (!range.length === 2 && typeof range[0] === 'number' && typeof range[1] === 'number') {
    Ext.raise('remove must be called with a [start, end] record *EXCLUSIVE* range');
  }
  if (range[0] > range[1]) {
    Ext.raise('A range MUST have the start index first, and the exclusive end index second');
  }
  me.getSelected().remove(range);
  for (rowIdx = range[0]; rowIdx < range[1]; rowIdx++) {
    view.onItemDeselect(rowIdx);
  }
  if (!suppressEvent) {
    selModel.fireSelectionChange();
  }
}, isSelected:function(record) {
  var me = this, ranges = me.getSelected().spans, len = ranges.length, recIndex, range, i;
  recIndex = record.isEntity ? me.view.getStore().indexOf(record) : record;
  for (i = 0; i < len; i++) {
    range = ranges[i];
    if (recIndex >= range[0] && recIndex < range[1]) {
      return true;
    }
  }
  return false;
}, getCount:function() {
  return this.getSelected().getCount();
}, selectAll:function() {
  var view = this.view, items = view.dataItems, len = items.length, i;
  for (i = 0; i < len; i++) {
    view.onItemSelect(i);
  }
  this.getSelected().add(0, view.store.getTotalCount() || view.store.getCount());
  this.getSelectionModel().fireSelectionChange();
}, getFirstRowIndex:function() {
  var ranges = this.getSelected().spans;
  return ranges.length ? this.getSelected().spans[0][0] : 0;
}, getLastRowIndex:function() {
  var ranges = this.getSelected().spans;
  return ranges.length ? ranges[ranges.length - 1][1] - 1 : 0;
}, eachRow:function(fn, scope) {
  var me = this, ranges = me.getSelected().spans, len = ranges && ranges.length, result, range, i, j;
  for (i = 0; i < len; i++) {
    range = ranges[i];
    for (j = range[0]; result !== false && j < range[1]; j++) {
      result = fn.call(this || scope, j);
    }
  }
}, eachColumn:function(fn, scope) {
  var columns = this.view.getHeaderContainer().getVisibleColumns(), len = columns.length, i;
  if (this.getCount()) {
    for (i = 0; i < len; i++) {
      if (fn.call(this || scope, columns[i], i) === false) {
        return;
      }
    }
  }
}, eachCell:function(fn, scope) {
  var me = this, selection = me.getSelected(), view = me.view, columns = view.ownerGrid.getVisibleColumnManager().getColumns(), range = me.dragRange, colCount, i, j, location, recCount, abort = false;
  if (columns) {
    colCount = columns.length;
    location = new Ext.grid.Location(view);
    if (selection) {
      me.eachRow(function(recordIndex) {
        location.setItem(recordIndex);
        for (i = 0; i < colCount; i++) {
          location.setColumn(columns[i]);
          if (fn.call(scope || me, location, location.columnIndex, location.recordIndex) === false) {
            abort = true;
            return false;
          }
        }
      });
    }
    if (!abort && range != null) {
      me.view.getStore().getRange(range[0], range[1], {forRender:false, callback:function(records) {
        recCount = records.length;
        for (i = 0; !abort && i < recCount; i++) {
          location.setItem(records[i]);
          for (j = 0; !abort && j < colCount; j++) {
            location.setColumn(columns[j]);
            if (fn.call(scope || me, location, location.columnIndex, location.recordIndex) === false) {
              abort = true;
            }
          }
        }
      }});
    }
  }
}, privates:{applySelected:function(spans) {
  if (!spans.isSpans) {
    spans = new Ext.util.Spans;
  }
  return spans;
}, compareRanges:function(lhs, rhs) {
  return lhs[0] - rhs[0];
}, clear:function(suppressEvent) {
  var me = this, selModel = me.getSelectionModel(), view = me.view, items = view.dataItems, len = items.length, i;
  for (i = 0; i < len; i++) {
    view.onItemDeselect(i);
  }
  me.getSelected().clear();
  if (!selModel.getDeselectable() && me.lastSelected) {
    me.add(me.lastSelected, true, true);
  }
  if (!suppressEvent) {
    selModel.fireSelectionChange();
  }
}, addRecordRange:function(start, end) {
  return this.add([start, end + 1], true);
}, removeRecordRange:function(start, end) {
  return this.remove([start, end + 1]);
}, isAllSelected:function() {
  return this.getCount() === (this.view.getStore().getTotalCount() || this.view.store.getCount());
}, setRangeStart:function(start) {
  if (start == null) {
    this.dragRange = null;
  } else {
    this.dragRange = [start, start];
    this.view.onItemSelect(start, true);
  }
}, setRangeEnd:function(end) {
  var me = this, dragRange = me.dragRange || (me.dragRange = [0, end]), oldEnd = dragRange[1], start = dragRange[0], view = me.view, renderInfo = view.renderInfo, tmp = dragRange[1] = end, removeRange = [], addRange = false, rowIdx, limit;
  if (start > end) {
    end = start;
    start = tmp;
  }
  rowIdx = Math.max(Math.min(dragRange[0], start, oldEnd, end), renderInfo.indexTop);
  limit = Math.min(Math.max(dragRange[1], start, oldEnd, end), renderInfo.indexBottom - 1);
  for (; rowIdx <= limit; rowIdx++) {
    if (rowIdx < start || rowIdx > end) {
      view.onItemDeselect(rowIdx);
      removeRange[removeRange.length ? 1 : 0] = rowIdx;
    } else {
      view.onItemSelect(rowIdx, true);
      addRange = true;
    }
  }
  if (addRange) {
    me.addRange(true);
  }
  if (removeRange.length) {
    me.removeRecordRange(removeRange[0], removeRange[1]);
  }
  me.lastSelectedIndex = end;
}, addRange:function(keep) {
  var range = this.dragRange;
  if (range) {
    this.addRecordRange(range[0], range[1]);
    if (!keep) {
      this.dragRange = null;
    }
  }
}, extendRange:function(extensionVector) {
  this.addRecordRange(extensionVector.start, extensionVector.end);
}, reduceRange:function(extensionVector) {
  this.removeRecordRange(extensionVector.start, extensionVector.end);
}, getRange:function() {
  var range = this.dragRange;
  if (range == null) {
    return [0, -1];
  }
  if (range[0] <= range[1]) {
    return range;
  }
  return [range[1], range[0]];
}, getRangeSize:function() {
  var range = this.getRange();
  return range[1] - range[0] + 1;
}, onSelectionFinish:function() {
  var me = this, range = me.getContiguousSelection();
  if (range) {
    me.getSelectionModel().onSelectionFinish(me, new Ext.grid.Location(me.view, {record:range[0], column:0}), new Ext.grid.Location(me.view, {record:range[1], column:me.view.getHeaderContainer().getVisibleColumns().length - 1}));
  } else {
    me.getSelectionModel().onSelectionFinish(me);
  }
}, getContiguousSelection:function() {
  var selected = this.getSelected(), store = this.view.store, spans = selected.spans;
  if (spans === 1 && store.getAt(spans[0][0]) && store.getAt(spans[0][1])) {
    return selected.spans[0];
  }
}}});
Ext.define('Ext.dataview.selection.Records', {extend:Ext.dataview.selection.Rows, alias:'selection.records', isRecords:true, config:{selected:null}, constructor:function(config) {
  this.callParent([config]);
  var selected = this.getSelected();
  if (!(selected && selected.isCollection)) {
    Ext.raise('An Ext.dataview.selection.Records object MUST be configured with a "selected" Collection');
  }
}, clone:function() {
  return new this.self({selectionModel:this.getSelectionModel(), selected:this.getSelected()});
}, addRowRange:function(start, end, keepExisting, suppressEvent) {
  if (typeof start !== 'number' || typeof end !== 'number') {
    Ext.raise('addRange must be called with a [start, end] row index *EXCLUSIVE* range');
  }
  if (start > end) {
    var tmp = end;
    end = start;
    start = tmp;
  }
  this.add(this.getSelectionModel().getStore().getRange(start, end - 1), keepExisting, suppressEvent);
}, removeRowRange:function(start, end, suppressEvent) {
  if (typeof start !== 'number' || typeof end !== 'number') {
    Ext.raise('addRange must be called with a [start, end] row index *EXCLUSIVE* range');
  }
  if (start > end) {
    var tmp = end;
    end = start;
    start = tmp;
  }
  this.remove(this.getSelectionModel().getStore().getRange(start, end - 1), suppressEvent);
}, add:function(records, keepExisting, suppressEvent) {
  records = Ext.Array.from(records);
  for (var i = 0, ln = records.length; i < ln; i++) {
    if (!records[i].isEntity) {
      Ext.raise('add must be called with records or an array of records');
    }
  }
  var me = this, selected = me.getSelected(), selectionCount = selected.getCount(), args = [keepExisting ? selectionCount : 0, keepExisting ? 0 : selectionCount, records];
  selected.suppressEvent = suppressEvent;
  selected.splice.apply(selected, args);
  selected.suppressEvent = false;
}, remove:function(records, suppressEvent) {
  records = Ext.Array.from(records);
  for (var i = 0, ln = records.length; i < ln; i++) {
    if (!records[i].isEntity) {
      Ext.raise('add must be called with records or an array of records');
    }
  }
  var selected = this.getSelected();
  if (!this.getSelectionModel().getDeselectable() && selected.getCount() === 1) {
    Ext.Array.remove(records, selected.first());
  }
  if (records.length) {
    selected.suppressEvent = suppressEvent;
    selected.remove(records);
    selected.suppressEvent = false;
  }
}, isSelected:function(record) {
  if (!record || !record.isModel) {
    return false;
  }
  return !!this.getSelected().byInternalId.get(record.internalId);
}, getRecords:function() {
  return this.getSelected().getRange();
}, selectAll:function(suppressEvent) {
  var selected = this.getSelected();
  selected.suppressEvent = suppressEvent;
  selected.add(this.getSelectionModel().getStore().getRange());
  selected.suppressEvent = false;
}, getFirstRowIndex:function() {
  return this.getCount() ? this.view.getStore().indexOf(this.getSelected().first()) : 0;
}, getLastRowIndex:function() {
  return this.getCount() ? this.view.getStore().indexOf(this.getSelected().last()) : -1;
}, eachRow:function(fn, scope) {
  var selectedRecords = this.getSelected();
  if (selectedRecords) {
    selectedRecords.each(fn, scope || this);
  }
}, eachColumn:function(fn, scope) {
  var columns = this.view.getHeaderContainer().getVisibleColumns(), len = columns.length, i;
  if (this.getSelected().getCount()) {
    for (i = 0; i < len; i++) {
      if (fn.call(this || scope, columns[i], i) === false) {
        return;
      }
    }
  }
}, eachCell:function(fn, scope) {
  var me = this, selection = me.getSelected(), view = me.view, columns = view.getHeaderContainer().getVisibleColumns(), colCount, i, baseLocation, location;
  if (columns) {
    colCount = columns.length;
    baseLocation = new Ext.grid.Location(view);
    if (selection) {
      selection.each(function(record) {
        location = baseLocation.clone({record:record});
        for (i = 0; i < colCount; i++) {
          location = location.cloneForColumn(columns[i]);
          if (fn.call(scope || me, location, location.columnIndex, location.recordIndex) === false) {
            return false;
          }
        }
      });
    }
  }
}, beginUpdate:function() {
  this.getSelected().beginUpdate();
}, endUpdate:function() {
  this.getSelected().endUpdate();
}, privates:{clear:function(suppressEvent) {
  var selected = this.getSelected(), spliceArgs;
  if (selected) {
    spliceArgs = [0, selected.getCount()];
    if (!this.getSelectionModel().getDeselectable()) {
      spliceArgs[2] = selected.last();
    }
    selected.suppressEvent = suppressEvent;
    selected.splice.apply(selected, spliceArgs);
    selected.suppressEvent = false;
  }
}, addRecordRange:function(start, end) {
  var me = this, view = me.view, store = view.getStore(), tmp = end, range;
  if (start && start.isGridLocation) {
    start = start.recordIndex;
  }
  if (end && end.isGridLocation) {
    end = tmp = end.recordIndex;
  }
  if (start > end) {
    end = start;
    start = tmp;
  }
  range = store.getRange(start, end || start);
  me.getSelected().add(range);
}, removeRecordRange:function(start, end) {
  var me = this, view = me.view, store = view.getStore(), tmp = end, range;
  if (start && start.isGridLocation) {
    start = start.recordIndex;
  }
  if (end && end.isGridLocation) {
    end = tmp = end.recordIndex;
    tmp = end;
  }
  if (start > end) {
    end = start;
    start = tmp;
  }
  range = store.getRange(start, end || start);
  this.getSelected().remove(range);
}, onSelectionFinish:function() {
  var me = this, range = me.getContiguousSelection();
  if (range) {
    me.getSelectionModel().onSelectionFinish(me, new Ext.grid.Location(me.view, {record:range[0], column:0}), new Ext.grid.Location(me.view, {record:range[1], column:me.view.getHeaderContainer().getVisibleColumns().length - 1}));
  } else {
    me.getSelectionModel().onSelectionFinish(me);
  }
}, getContiguousSelection:function() {
  var store = this.view.getStore(), selection, len, i;
  selection = Ext.Array.sort(this.getSelected().getRange(), function(r1, r2) {
    return store.indexOf(r1) - store.indexOf(r2);
  });
  len = selection.length;
  if (len) {
    if (len === 1 && store.indexOf(selection[0]) === -1) {
      return false;
    }
    for (i = 1; i < len; i++) {
      if (store.indexOf(selection[i]) !== store.indexOf(selection[i - 1]) + 1) {
        return false;
      }
    }
    return [store.indexOf(selection[0]), store.indexOf(selection[len - 1])];
  }
}, applySelected:function(selected) {
  if (!selected) {
    Ext.raise("The selection model's own selected Collection must always be passed into a Records Selection");
  }
  return selected;
}, refresh:function() {
  var me = this, view = me.view, selModel = me.getSelectionModel(), storeCollection = view.getStore().getData(), filterFn = storeCollection.getFilters().getFilterFn(), ignoredFilter = selModel.ignoredFilter, selected = me.getSelected(), lastSelected = selModel.getLastSelected(), newLastSelected, selections, toDeselect = [], toReselect = [], selectionLength, i, rec, matchingSelection;
  if (ignoredFilter) {
    if (ignoredFilter.getDisabled()) {
      ignoredFilter = null;
    } else {
      ignoredFilter.setDisabled(true);
      storeCollection = storeCollection.getSource() || storeCollection;
    }
  }
  if (lastSelected) {
    newLastSelected = storeCollection.get(storeCollection.getKey(lastSelected));
    if (newLastSelected && ignoredFilter && !filterFn(newLastSelected)) {
      newLastSelected = null;
    }
  }
  if (me.getCount()) {
    selections = selected.getRange();
    selectionLength = selections.length;
    for (i = 0; i < selectionLength; i++) {
      rec = selections[i];
      matchingSelection = storeCollection.get(storeCollection.getKey(rec));
      if (matchingSelection && ignoredFilter && !filterFn(matchingSelection)) {
        matchingSelection = null;
      }
      if (matchingSelection) {
        if (matchingSelection !== rec) {
          toDeselect.push(rec);
          toReselect.push(matchingSelection);
        }
      } else {
        toDeselect.push(rec);
      }
    }
    if (view.beforeSelectionRefresh) {
      view.beforeSelectionRefresh(toDeselect, toReselect);
    }
    selected.suppressEvent = true;
    selected.splice(selected.getCount(), toDeselect, toReselect);
    selected.suppressEvent = false;
  }
  if (ignoredFilter) {
    ignoredFilter.setDisabled(false);
  }
  selModel.setLastSelected(newLastSelected || toReselect[toReselect.length - 1] || null);
}}});
Ext.define('Ext.dataview.selection.Model', {extend:Ext.Evented, alias:'selmodel.dataview', mixins:[Ext.mixin.Factoryable], factoryConfig:{type:'selmodel', defaultType:'dataview', aliasPrefix:'selmodel.'}, isSelectionModel:true, config:{view:null, store:null, disabled:null, mode:'single', deselectable:true, lastSelected:null, selected:true, selectedRecord:undefined, selection:{type:'records'}}, modes:{single:true, simple:true, multi:true}, onNavigate:function(e) {
  if (!this.getDisabled()) {
    this.selectWithEvent(e.to.record, e);
  }
}, getSelectedRecords:function() {
  var selection = this.getSelection();
  return selection && selection.isRecords ? selection.getRecords() : Ext.emptyArray;
}, getStoreListeners:function() {
  return {add:'onSelectionStoreAdd', remove:'onSelectionStoreRemove', update:'onSelectionStoreUpdate', clear:{fn:'onSelectionStoreClear', priority:1000}, load:'onSelectionStoreLoad', refresh:'refreshSelection', idchanged:'onIdChanged'};
}, applySelected:function(selected, oldSelected) {
  var me = this, store = me.getStore(), collectionConfig = {rootProperty:'data', extraKeys:{byInternalId:{rootProperty:false, property:'internalId'}}, sorters:[function(r1, r2) {
    return store.indexOf(r1) - store.indexOf(r2);
  }], autoSort:false};
  if (oldSelected) {
    oldSelected.removeObserver(me);
    if (me.destroySelected) {
      oldSelected.destroy();
      me.destroySelected = false;
    }
  }
  if (selected && selected.isCollection) {
    me.destroySelected = false;
    selected.setConfig(collectionConfig);
  } else {
    me.destroySelected = true;
    selected = new Ext.util.Collection(Ext.apply(collectionConfig, selected));
  }
  me.observerPriority = 1000;
  selected.addObserver(me);
  return selected;
}, updateSelected:function(selected) {
  this.setSelectedRecord(selected.last() || null);
}, applyMode:function(mode) {
  var view = this.getView(), el = view.getRenderTarget();
  mode = mode ? mode.toLowerCase() : 'single';
  el.toggleCls(view.multiSelectCls, mode === 'multi');
  return this.modes[mode] ? mode : 'single';
}, updateView:function(view) {
  this.setStore(view ? view.getStore() : null);
}, applyStore:function(store) {
  return store ? Ext.data.StoreManager.lookup(store) : null;
}, updateStore:function(newStore, oldStore) {
  var me = this, bindEvents = Ext.apply({scope:me}, me.getStoreListeners());
  if (oldStore && Ext.isObject(oldStore) && oldStore.isStore) {
    oldStore.un(bindEvents);
  }
  if (newStore) {
    newStore.on(bindEvents);
    if (oldStore) {
      me.refreshSelection();
    }
  }
}, selectByLocation:function(location) {
  if (!location.isDataViewLocation) {
    Ext.raise('selectByLocation MUST be passed an Ext.dataview.Location');
  }
  this.select(location.record);
}, selectAll:function(suppressEvent) {
  this.select(this.getStore().getRange(), true, suppressEvent);
}, deselectAll:function(suppressEvent) {
  var selected = this.getSelected();
  selected.suppressEvent = suppressEvent;
  selected.removeAll();
  selected.suppressEvent = false;
}, applySelectedRecord:function(selectedRecord) {
  if (selectedRecord === false) {
    selectedRecord = null;
  }
  return selectedRecord;
}, updateSelectedRecord:function(selectedRecord) {
  var me = this, selected = me.getSelected(), selectionCount = selected.getCount();
  if (selectedRecord) {
    if (selected.last() !== selectedRecord) {
      if (me.getMode() === 'single') {
        selected.splice(0, selectionCount, selectedRecord);
      } else {
        selected.add(selectedRecord);
      }
    }
    me.setLastSelected(selectedRecord);
  } else {
    if (!me.isConfiguring && selectionCount) {
      me.deselectAll();
    }
  }
  me.getView().publishState('selection', selectedRecord);
}, selectWithEvent:function(record, e) {
  var me = this, mode = me.getMode(), isSelected = me.isSelected(record);
  if (mode === 'multi') {
    me.selectWithEventMulti(record, e, isSelected);
  } else {
    if (isSelected) {
      me.deselect(record, mode === 'simple' && e.ctrlKey);
    } else {
      me.select(record, false);
    }
  }
  if (!e.shiftKey && me.isSelected(record)) {
    me.selectionStart = record;
  }
}, selectWithEventMulti:function(record, e, isSelected) {
  var me = this, shift = e.shiftKey, ctrl = e.ctrlKey, start = shift ? me.selectionStart : null;
  if (shift && start) {
    me.selectRange(start, record, ctrl);
  } else {
    me[isSelected ? 'deselect' : 'select'](record, true);
  }
}, selectRange:function(startRecord, endRecord, keepExisting) {
  var store = this.getStore();
  startRecord = typeof startRecord === 'number' ? startRecord : store.indexOf(startRecord);
  endRecord = typeof endRecord === 'number' ? endRecord : store.indexOf(endRecord);
  if (startRecord > endRecord) {
    var tmp = startRecord;
    startRecord = endRecord;
    endRecord = tmp;
  }
  this.getSelection().addRowRange(startRecord, endRecord + 1, keepExisting);
}, select:function(records, keepExisting, suppressEvent) {
  var me = this, record;
  if (me.getDisabled()) {
    return;
  }
  if (typeof records === 'number') {
    records = [me.getStore().getAt(records)];
  }
  if (!records) {
    return;
  }
  if (me.getMode() == 'single' && records) {
    record = records.length ? records[0] : records;
    me.doSingleSelect(record, suppressEvent);
  } else {
    me.doMultiSelect(records, keepExisting, suppressEvent);
  }
}, doSingleSelect:function(record, suppressEvent) {
  this.doMultiSelect([record], false, suppressEvent);
}, doMultiSelect:function(records, keepExisting, suppressEvent) {
  if (records === null || this.getDisabled()) {
    return;
  }
  this.getSelection().add(records, keepExisting, suppressEvent);
}, deselect:function(records, suppressEvent) {
  var me = this;
  if (me.getDisabled()) {
    return;
  }
  records = Ext.isArray(records) ? records : [records];
  var selection = me.getSelection(), store = me.getStore(), len = records.length, i, record;
  for (i = 0; i < len; i++) {
    record = records[i];
    if (typeof record === 'number') {
      records[i] = store.getAt(record);
    }
  }
  selection.remove(records, suppressEvent);
}, onCollectionRemove:function(selectedCollection, chunk) {
  var me = this, view = me.getView(), records = chunk.items;
  me.getSelection().allSelected = this.allSelected = false;
  if (!chunk.next && !chunk.replacement) {
    me.setSelectedRecord(selectedCollection.last() || null);
  }
  view.onItemDeselect(records, selectedCollection.suppressEvent);
  if (!selectedCollection.suppressEvent) {
    me.fireSelectionChange(records, false);
  }
}, onCollectionAdd:function(selectedCollection, adds) {
  var me = this, view = me.getView(), selection = me.getSelection(), records = adds.items;
  if (view.destroyed) {
    return;
  }
  selection.allSelected = this.allSelected = selection.getCount() === view.getStore().getCount();
  me.setSelectedRecord(selectedCollection.last() || null);
  view.onItemSelect(me.getMode() === 'single' ? records[0] : records, selectedCollection.suppressEvent);
  if (!selectedCollection.suppressEvent) {
    me.fireSelectionChange(records, true);
  }
}, fireSelectionChange:function(records, selected) {
  this.fireEvent('selectionchange', this.getView(), records, selected);
}, getSelections:function() {
  if (this.getSelection().isRecords) {
    return this.getSelected().getRange();
  }
}, isRowSelected:function(record) {
  var me = this, sel = me.getSelection();
  if (sel && (sel.isRows || sel.isRecords)) {
    record = Ext.isNumber(record) ? me.getStore().getAt(record) : record;
    return sel.isSelected(record);
  } else {
    return false;
  }
}, isSelected:function(record) {
  return this.getSelection().isSelected(record);
}, hasSelection:function() {
  return this.getSelection().getCount() > 0;
}, refreshSelection:function() {
  if (this.getSelection().isRecords) {
    this.getSelection().refresh();
  }
}, onSelectionStoreRemove:function(store, records) {
  var selection = this.getSelection();
  if (selection.isRecords) {
    selection.remove(records);
  }
}, onSelectionStoreClear:function(store) {
  this.getSelection().clear();
}, getSelectionCount:function() {
  return this.getSelection().getCount();
}, destroy:function() {
  var me = this;
  me.setView(null);
  Ext.destroy(me.selection, me.destroySelected ? me.selected : null);
}, onIdChanged:function(store, rec, oldId, newId) {
  var selected = this.getSelected();
  if (selected) {
    selected.updateKey(rec, oldId);
  }
}, onSelectionStoreAdd:Ext.emptyFn, onSelectionStoreLoad:Ext.emptyFn, onSelectionStoreUpdate:Ext.emptyFn, onItemSelect:Ext.emptyFn, onItemDeselect:Ext.emptyFn, onEditorKey:Ext.emptyFn, privates:{onSelectionFinish:Ext.privateFn, applySelection:function(selection, oldSelection) {
  if (oldSelection) {
    if (oldSelection.type === selection.type) {
      oldSelection.setConfig(selection);
      return oldSelection;
    }
    Ext.destroy(oldSelection);
  }
  if (selection) {
    var store = this.getStore();
    selection = Ext.Factory.selection(Ext.apply({selectionModel:this, type:store && store.isVirtualStore ? 'rows' : 'records', selected:this.getSelected()}, selection));
  }
  return selection;
}}});
Ext.define('Ext.dataview.EmptyText', {extend:Ext.Component, xtype:'emptytext', classCls:Ext.baseCSSPrefix + 'emptytext', inheritUi:true, html:'No data to display', top:0, right:0, bottom:0, left:0});
Ext.define('Ext.dataview.Abstract', {extend:Ext.Container, mixins:[Ext.mixin.ConfigProxy, Ext.mixin.ItemRippler], isDataView:true, cachedConfig:{associatedData:null, deferEmptyText:true, deselectOnContainerClick:true, disableSelection:false, emptyTextDefaults:{xtype:'emptytext'}, emptyItemText:'', itemsFocusable:true, itemTpl:'\x3cdiv\x3e{text:htmlEncode}\x3c/div\x3e', loadingText:'Loading...', pressedDelay:100, scrollToTopOnRefresh:true, storeEventListeners:{add:'onStoreAdd', beforeload:'onStoreBeforeLoad', 
clear:'onStoreClear', load:'onStoreLoad', refresh:'onStoreRefresh', remove:'onStoreRemove', update:'onStoreUpdate'}, triggerEvent:'childtap', triggerCtEvent:'tap'}, config:{itemButtonMode:false, data:null, emptyState:null, emptyText:null, enableTextSelection:null, inline:null, itemCls:null, loadingHeight:null, markDirty:null, navigationModel:{type:'dataview'}, selectable:true}, autoSize:null, publishes:{selection:1}, twoWayBindable:{selection:1}, eventedConfig:{store:undefined}, proxyConfig:{selectable:{configs:['mode', 
'deselectable', 'lastSelected', 'selected'], methods:['isSelected', 'select', 'selectAll', 'deselectAll', 'getSelections', 'hasSelection', 'getSelectionCount']}}, emptyTextProperty:'html', restoreFocus:true, refreshCounter:0, selectionModel:'dataview', defaultBindProperty:'store', focusable:true, scrollable:true, tabIndex:0, classCls:Ext.baseCSSPrefix + 'dataview', focusedCls:Ext.baseCSSPrefix + 'focused', hoveredCls:Ext.baseCSSPrefix + 'hovered', inlineCls:Ext.baseCSSPrefix + 'inline', noWrapCls:Ext.baseCSSPrefix + 
'nowrap', pressedCls:Ext.baseCSSPrefix + 'pressed', scrollDockCls:Ext.baseCSSPrefix + 'scrolldock', selectedCls:Ext.baseCSSPrefix + 'selected', hasLoadedStore:false, scrollDockedItems:null, beforeInitialize:function(config) {
  this.dataItems = [];
  this.callParent([config]);
}, initialize:function() {
  var me = this;
  me.generateSelectorFunctions();
  me.callParent();
  me.bodyElement.on({touchstart:'_onChildTouchStart', touchend:'_onChildTouchEnd', touchcancel:'_onChildTouchCancel', tap:'_onChildTap', tapcancel:'_onChildTapCancel', longpress:'_onChildLongPress', taphold:'_onChildTapHold', singletap:'_onChildSingleTap', doubletap:'_onChildDoubleTap', swipe:'_onChildSwipe', mouseover:'_onChildMouseOver', mouseout:'_onChildMouseOut', contextmenu:'_onChildContextMenu', delegate:me.eventDelegate, scope:me});
  if (Ext.getScrollbarSize().width) {
    me.bodyElement.on('touchstart', '_onContainerTouchStart', me);
  }
  me.on(me.getTriggerCtEvent(), 'onContainerTrigger', me);
}, onRender:function() {
  var me = this;
  me.callParent();
  if (me.forceRefreshOnRender) {
    me.runRefresh();
  } else {
    me.refresh();
  }
}, doDestroy:function() {
  var me = this;
  me.destroyAllRipples();
  me.clearPressedTimer();
  me.setStore(null);
  me.setNavigationModel(null);
  me.setSelectable(null);
  me.lastPressedLocation = null;
  me.callParent();
}, createEmptyText:function(emptyText) {
  var ret = Ext.apply({}, this.getEmptyTextDefaults());
  if (typeof emptyText === 'string') {
    ret[this.emptyTextProperty] = emptyText;
  } else {
    if (emptyText) {
      Ext.apply(ret, emptyText);
    }
  }
  ret.isEmptyText = ret.hidden = true;
  ret.showInEmptyState = null;
  return ret;
}, ensureVisible:function(record, options) {
  var me = this, plan = me.ensureVisiblePlan(record, options), step;
  for (;;) {
    if (!(step = plan.steps.pop())) {
      break;
    }
    me[step](plan);
  }
  return plan.promise;
}, gatherData:function(record, recordIndex) {
  var me = this, data = record && record.getData(me.associatedData);
  if (data) {
    if (recordIndex === undefined) {
      recordIndex = me.store.indexOf(record);
    }
    data = me.prepareData(data, recordIndex, record);
  }
  return data || null;
}, getFirstDataItem:function() {
  return this.dataItems[0] || null;
}, getFirstItem:function() {
  return this.getFastItems()[0] || null;
}, getItemAt:function(index) {
  var items = this.getFastItems();
  if (index < 0) {
    index += items.length;
  }
  return items[index] || null;
}, getItemIndex:function(item) {
  return this.mapToRecordIndex(item);
}, getItem:function(record) {
  var ret = null, idx;
  if (record) {
    idx = record.isEntity ? this.store.indexOf(record) : record;
    if (idx > -1) {
      ret = this.getItemAt(idx);
    }
  }
  return ret;
}, getLastDataItem:function() {
  var dataItems = this.dataItems;
  return dataItems[dataItems.length - 1] || null;
}, getLastItem:function() {
  var items = this.getFastItems();
  return items[items.length - 1];
}, getScrollDockedItems:function(which) {
  var scrollDock = this.scrollDockedItems;
  if (scrollDock) {
    if (which) {
      which = this.scrollDockAliases[which] || which;
      scrollDock = scrollDock[which].slice();
    } else {
      scrollDock = scrollDock.start.items.concat(scrollDock.end.items);
    }
  }
  return scrollDock || [];
}, isItemSelected:function(item) {
  var record = this.mapToRecord(item);
  return record ? this.isSelected(record) : false;
}, isFirstItem:function(item) {
  return Ext.getDom(item) === this.getFirstItem();
}, isFirstDataItem:function(item) {
  return Ext.getDom(item) === this.getFirstDataItem();
}, isLastItem:function(item) {
  return Ext.getDom(item) === this.getLastItem();
}, isLastDataItem:function(item) {
  return Ext.getDom(item) === this.getLastDataItem();
}, mapToItem:function(value, as) {
  var me = this, el = me.element, item, items;
  if (value && value.isEvent) {
    item = value.getTarget(me.itemSelector, el);
  } else {
    if (value && (value.isElement || value.nodeType === 1)) {
      item = Ext.fly(value).findParent(me.itemSelector, el);
    } else {
      if (value && value.isEntity) {
        item = me.itemFromRecord(value);
      } else {
        if (value && value.isComponent && me.items.contains(value)) {
          item = value;
        } else {
          items = me.getFastItems();
          if (value < 0) {
            value += items.length;
          }
          item = items[value || 0];
        }
      }
    }
  }
  if (item) {
    item = me.itemAs(item, as || (me.isElementDataView ? 'el' : 'cmp'));
  }
  return item || null;
}, mapToRecord:function(value) {
  var me = this, item = value, el = me.element, dom, rec;
  if (item && item.isEvent) {
    item = item.getTarget(me.itemSelector, el);
  } else {
    if (item && (item.isElement || item.nodeType === 1)) {
      item = Ext.fly(item).findParent(me.itemSelector, el);
    } else {
      if (typeof item === 'number') {
        item = me.mapToItem(item);
      }
    }
  }
  if (item) {
    dom = item.isWidget ? item.el : item;
    dom = dom.dom || dom;
    if (this.itemSelector(dom)) {
      rec = dom.getAttribute('data-recordid');
      rec = rec && me.store.getByInternalId(+rec);
    }
  }
  return rec || null;
}, mapToRecordIndex:function(value) {
  var me = this, item = value, index = -1, el = me.element, dom;
  if (item && item.isEntity) {
    index = me.store.indexOf(item);
  } else {
    if (item && item.isEvent) {
      item = item.getTarget(me.itemSelector, el);
    } else {
      if (item && (item.isElement || item.nodeType === 1)) {
        item = Ext.fly(item).findParent(me.itemSelector, el);
      } else {
        if (typeof item === 'number') {
          item = me.mapToItem(item);
        }
      }
    }
    if (item) {
      dom = item.isWidget ? item.el : item;
      dom = dom.dom || dom;
      if (me.itemSelector(dom)) {
        index = dom.getAttribute('data-recordindex');
        index = index ? +index : -1;
      }
    }
  }
  return index;
}, mapToViewIndex:function(value, indexOffset) {
  var me = this, index = -1, item = value, el = me.element, items = me.getFastItems(), dom;
  if (typeof item === 'number') {
    indexOffset = indexOffset || 0;
    for (; item < items.length; ++item) {
      dom = items[item];
      if (dom.isWidget) {
        dom = dom.el.dom;
      }
      if (+dom.getAttribute('data-recordindex') === item + indexOffset) {
        index = item;
        break;
      }
    }
  } else {
    if (item) {
      if (item.isEntity) {
        item = me.itemFromRecord(item);
      } else {
        if (item.isEvent) {
          item = item.getTarget(me.itemSelector, el);
        } else {
          if (item.isElement || item.nodeType === 1) {
            item = Ext.fly(item).findParent(me.itemSelector, el);
          }
        }
      }
      if (item && items.length) {
        if (items[0].isWidget) {
          if (!item.isWidget) {
            item = Ext.Component.from(item);
          }
        } else {
          item = item.nodeType ? item : item.el.dom;
        }
        index = Array.prototype.indexOf.call(items, item);
      }
    }
  }
  return index;
}, nextItem:function(item, as) {
  var next = this.traverseItem(item, 1);
  return as ? this.itemAs(next, as) : next;
}, previousItem:function(item, as) {
  var prev = this.traverseItem(item, -1);
  return as ? this.itemAs(prev, as) : prev;
}, prepareData:function(data, index, record) {
  return data;
}, refresh:function() {
  this.whenVisible('runRefresh');
}, onFocusEnter:function(e) {
  var me = this;
  me.callParent([e]);
  if (!(e.within(me.getRenderTarget()) || e.target === me.getFocusEl().dom)) {
    return;
  }
  return me.onInnerFocusEnter(e);
}, onInnerFocusEnter:function(e) {
  var me = this, navigationModel = me.getNavigationModel(), focusPosition, itemCount;
  if (navigationModel.lastLocation === 'scrollbar') {
    if (e.relatedTarget) {
      e.relatedTarget.focus();
    }
    return;
  }
  if (e.target === me.getFocusEl().dom) {
    focusPosition = me.restoreFocus && navigationModel.getPreviousLocation();
    if (focusPosition) {
      focusPosition = focusPosition.refresh();
    } else {
      if (e.backwards) {
        focusPosition = me.getLastDataItem();
      } else {
        focusPosition = me.getFirstDataItem();
      }
    }
  } else {
    focusPosition = e;
  }
  me.toggleChildrenTabbability(false);
  itemCount = me.getFastItems().length;
  if (itemCount) {
    if (focusPosition.isWidget) {
      focusPosition = focusPosition.getFocusEl() || focusPosition.el;
    }
    navigationModel.setLocation(focusPosition, {event:e, navigate:false});
  }
  if (navigationModel.getLocation()) {
    me.el.dom.setAttribute('tabIndex', -1);
  }
}, onFocusLeave:function(e) {
  var me = this, navModel = me.getNavigationModel();
  if (navModel.getLocation()) {
    navModel.setLocation(null, {event:e});
    me.el.dom.setAttribute('tabIndex', 0);
  }
  me.callParent([e]);
}, onInnerFocusLeave:function(e) {
  this.getNavigationModel().setLocation(null, {event:e});
}, onFocusMove:function(e) {
  var me = this, el = me.el, renderTarget = me.getRenderTarget(), toComponent = e.event.toComponent, fromComponent = e.event.fromComponent;
  if (!el.contains(e.toElement)) {
    return me.callParent([e]);
  }
  if (el.contains(e.toElement) && !renderTarget.contains(e.toElement) && renderTarget.contains(e.fromElement)) {
    return me.onInnerFocusLeave(e.event);
  }
  if (el.contains(e.fromElement) && !renderTarget.contains(e.fromElement) && renderTarget.contains(e.toElement)) {
    return me.onInnerFocusEnter(e.event);
  }
  if (!renderTarget.contains(e.fromElement) && !renderTarget.contains(e.toElement)) {
    return me.callParent([e]);
  }
  if ((toComponent === me || toComponent.up('dataview,componentdataview') === me) && (fromComponent === me || fromComponent.up('dataview,componentdataview') === me)) {
    me.getNavigationModel().onFocusMove(e.event);
  }
  return me.callParent([e]);
}, onItemAdd:function(item, index) {
  var me = this, scrollDock = item.scrollDock, scrollDockCls = me.scrollDockCls, scrollDockedItems;
  if (!item.$dataItem && item.isInner) {
    if (scrollDock !== null) {
      scrollDock = scrollDock || 'end';
    }
    if (scrollDock) {
      if (!(scrollDockedItems = me.scrollDockedItems)) {
        me.scrollDockedItems = scrollDockedItems = {start:{items:[], height:0, filter:me.filterScrollDockStart, name:scrollDock}, end:{items:[], height:0, filter:me.filterScrollDockEnd, name:scrollDock}};
      }
      scrollDock = me.scrollDockAliases[scrollDock] || scrollDock;
      if (!scrollDockedItems[scrollDock]) {
        Ext.raise('Invalid value for scrollDock: ' + item.scrollDock);
      }
      item.scrollDock = scrollDock;
      scrollDock = scrollDockedItems[scrollDock];
      scrollDock.items = me.innerItems.filter(scrollDock.filter);
      if (item.showInEmptyState === undefined) {
        item.showInEmptyState = false;
      }
      item.addCls(scrollDockCls + ' ' + scrollDockCls + '-' + scrollDock.name);
      if (me.getItemsFocusable()) {
        item.el.set({tabIndex:-1});
      }
      if (me.addScrollDockedItem) {
        me.addScrollDockedItem(item);
      }
    }
  }
  me.callParent([item, index]);
}, onItemDeselect:function(records, suppressEvent) {
  var me = this;
  if (!me.isConfiguring && !me.destroyed) {
    if (suppressEvent) {
      me.setItemSelection(records, false);
    } else {
      me.fireEventedAction('deselect', [me, records], 'setItemSelection', me, [records, false]);
    }
  }
}, onItemSelect:function(records, suppressEvent) {
  var me = this;
  if (suppressEvent) {
    me.setItemSelection(records, true);
  } else {
    me.fireEventedAction('select', [me, records], 'setItemSelection', me, [records, true]);
  }
}, onChildTouchStart:function(location) {
  var me = this, child = location.item, e = location.event, hasListeners = me.hasListeners, curLocation = me.getNavigationModel().getLocation(), actionable = curLocation && curLocation.actionable, name, skip;
  if (!location.actionable && !(location.equalCell || location.equals)(curLocation)) {
    me.rippleItem(child, e);
  }
  name = 'beforechildtouchstart';
  skip = hasListeners[name] && me.fireEvent(name, me, location) === false;
  if (!skip) {
    name = 'beforeitemtouchstart';
    skip = hasListeners[name] && me.fireEvent(name, me, location.viewIndex, child, location.record, e) === false;
  }
  if (!skip) {
    if (!actionable) {
      me.doChildTouchStart(location);
    }
    me.fireChildEvent('touchstart', location);
  }
}, onChildTouchEnd:function(location) {
  var me = this, child = location.item, curLocation = me.getNavigationModel().getLocation(), e = location.event;
  if (!(curLocation && curLocation.actionable)) {
    me.rippleItem(child, e);
  }
  this.clearPressedCls('touchend', location);
}, onChildTouchCancel:function(location) {
  this.clearPressedCls('touchcancel', location);
}, onChildTouchMove:function(location) {
  this.fireChildEvent('touchmove', location);
}, onChildTap:function(location) {
  this.fireChildEvent('tap', location);
}, onChildTapCancel:function(location) {
  var me = this, itemButtonMode = me.getItemButtonMode();
  if (!itemButtonMode) {
    this.clearPressedCls('tapcancel', location);
  }
}, onChildContextMenu:function(location) {
  this.fireChildEvent('contextmenu', location);
}, onChildLongPress:function(location) {
  this.fireChildEvent('longpress', location);
}, onChildTapHold:function(location) {
  this.fireChildEvent('taphold', location);
}, onChildSingleTap:function(location) {
  this.fireChildEvent('singletap', location);
}, onChildDoubleTap:function(location) {
  this.fireChildEvent('doubletap', location);
}, onChildSwipe:function(location) {
  this.fireChildEvent('swipe', location);
}, onChildMouseOver:function(location) {
  var me = this, child = location.item;
  if (me.mouseOverItem !== child) {
    me.mouseOverItem = child;
    if (me.doHover) {
      me.toggleHoverCls(true);
    }
    me.fireChildEvent('mouseenter', location);
  }
}, onChildMouseOut:function(location) {
  var me = this, itemButtonMode = me.getItemButtonMode(), child = location.item, relatedTarget = location.event.getRelatedTarget(me.itemSelector);
  if (child && child.dom !== relatedTarget) {
    if (me.doHover) {
      me.toggleHoverCls(false);
    }
    if (!itemButtonMode) {
      this.clearPressedCls('mouseleave', location);
    } else {
      me.fireChildEvent('mouseleave', location);
    }
    me.mouseOverItem = null;
  }
}, onNavigate:function(e) {
  var me = this, selectable = !me.destroyed && me.getSelectable();
  if (selectable && me.shouldSelectItem(e)) {
    selectable.onNavigate(e);
  }
}, shouldSelectItem:function(e) {
  var me = this, selectable = me.getSelectable(), no = e.stopSelection || !selectable || selectable.getDisabled(), target = !no && e.getTarget('.' + Ext.baseCSSPrefix + 'item-no-select,.' + Ext.baseCSSPrefix + 'item-no-tap', this.element);
  if (target) {
    no = me.el.contains(target);
  }
  return !no;
}, onStoreAdd:function() {
  this.syncEmptyState();
}, onStoreBeforeLoad:function() {
  this.handleBeforeLoad();
}, onStoreClear:function() {
  this.doClear();
}, onStoreLoad:function() {
  this.hasLoadedStore = true;
  this.clearMask();
  this.syncEmptyState();
}, onStoreRefresh:function() {
  this.refresh();
}, onStoreRemove:function() {
  this.syncEmptyState();
}, onStoreUpdate:function(store, record, type, modifiedFieldNames, info) {
  var me = this, item;
  if (!info || !(info.indexChanged || info.filtered)) {
    item = me.itemFromRecord(record);
    if (item) {
      me.syncItemRecord({item:item, modified:me.indexModifiedFields(modifiedFieldNames), record:record});
    }
  }
  if (me.isSelected(record)) {
    me.setItemSelection(record, true);
  }
}, updateAssociatedData:function(assocData) {
  this.associatedData = {associated:assocData};
}, updateData:function(data) {
  var store = this.store;
  if (!store) {
    this.settingStoreFromData = true;
    this.setStore({data:data, autoDestroy:true});
    this.settingStoreFromData = false;
  } else {
    store.loadData(data);
  }
}, updateDisableSelection:function(value) {
  var el = this.getRenderTarget();
  el.toggleCls(this.showSelectionCls, !value);
}, updateEmptyText:function(emptyText) {
  var me = this, config = emptyText, emptyTextCmp = me.emptyTextCmp;
  if (emptyTextCmp) {
    if (!emptyText || typeof emptyText === 'string') {
      config = {};
      config[me.emptyTextProperty] = emptyText || '';
    }
    emptyTextCmp.setConfig(config);
  }
  if (!me.isConfiguring) {
    me.syncEmptyState();
  }
}, updateEnableTextSelection:function(enableTextSelection) {
  this.setUserSelectable({bodyElement:!!enableTextSelection});
}, updateInline:function(inline) {
  var me = this;
  me.toggleCls(me.inlineCls, !!inline);
  me.toggleCls(me.noWrapCls, inline && inline.wrap === false);
}, updateItemCls:function(newCls, oldCls) {
  if (!this.isConfiguring) {
    var items = this.dataItems, len = items.length, i, item;
    for (i = 0; i < len; i++) {
      item = items[i];
      item = item.isWidget ? item.el : Ext.fly(item);
      item.replaceCls(oldCls, newCls);
    }
  }
}, applyItemTpl:function(config) {
  return Ext.XTemplate.get(config);
}, updateItemTpl:function() {
  if (!this.isConfiguring) {
    this.refresh();
  }
}, updateMarkDirty:function(markDirty) {
  var dataItems = this.dataItems, i, ln, dataItem;
  markDirty = !!markDirty;
  for (i = 0, ln = dataItems.length; i < ln; i++) {
    dataItem = dataItems[i];
    (dataItem.el || Ext.fly(dataItem)).toggleCls(this.markDirtyCls, markDirty);
  }
}, updateMasked:function(masked) {
  var me = this, loadingHeight = me.getLoadingHeight();
  if (masked) {
    if (loadingHeight && loadingHeight > me.el.getHeight()) {
      me.hasLoadingHeight = true;
      me.oldMinHeight = me.getMinHeight();
      me.setMinHeight(loadingHeight);
    }
  } else {
    if (!me.destroying && me.hasLoadingHeight) {
      me.setMinHeight(me.oldMinHeight);
      delete me.hasLoadingHeight;
    }
  }
}, applySelectable:function(selectable, oldSelectable) {
  var me = this, record = me.selection;
  if (selectable === false) {
    selectable = {disabled:true};
  }
  if (selectable) {
    if (typeof selectable === 'string') {
      selectable = {type:me.selectionModel, mode:selectable.toLowerCase(), view:me};
    } else {
      selectable = Ext.apply({type:me.selectionModel, view:me}, selectable);
    }
    if (oldSelectable) {
      if (selectable.isSelectionModel || selectable.type !== oldSelectable.type) {
        Ext.raise('Switching out selectables dynamically is not supported');
      }
      selectable = oldSelectable.setConfig(selectable);
    } else {
      selectable = Ext.Factory.selmodel(me.mergeProxiedConfigs('selectable', selectable));
    }
    if (record) {
      delete me.selection;
      if (!record.isEntity) {
        Ext.raise('DataView selection config must be single record');
      }
      if (selectable.getRecords && !selectable.getRecords()) {
        Ext.raise('DataView configured with selection when selectable not configured to accept records');
      }
      selectable.select(record);
    }
  }
  return selectable;
}, applyStore:function(store) {
  return store ? Ext.data.StoreManager.lookup(store) : null;
}, updateStore:function(newStore, oldStore) {
  var me = this, storeEvents = Ext.apply({scope:me}, me.getStoreEventListeners()), mask = me.autoMask, newLoad;
  if (oldStore) {
    if (!oldStore.destroyed) {
      if (oldStore.getAutoDestroy()) {
        oldStore.destroy();
      } else {
        oldStore.un(storeEvents);
      }
    }
    me.dataRange = me.store = Ext.destroy(me.dataRange);
    if (!me.destroying && !me.destroyed && !newStore) {
      me.doClear();
    }
  }
  if (newStore) {
    me.store = newStore;
    if (me.destroying) {
      return;
    }
    newStore.on(storeEvents);
    if (newStore.isLoaded()) {
      me.hasLoadedStore = true;
    }
    newLoad = !newStore.isTreeStore && newStore.hasPendingLoad();
    me.bindStore(newStore);
    if (me.initialized) {
      me.refresh();
    }
  }
  if (!me.isConfiguring || me.settingStoreFromData) {
    me.getSelectable().setStore(newStore);
  }
  if (mask && !newLoad) {
    me.setMasked(false);
    me.autoMask = false;
  } else {
    if (!mask && newLoad) {
      me.handleBeforeLoad();
    }
  }
}, updateHidden:function(hidden, oldHidden) {
  this.callParent([hidden, oldHidden]);
  this.destroyAllRipples();
}, privates:{associatedData:true, doHover:true, showSelectionCls:Ext.baseCSSPrefix + 'show-selection', multiSelectCls:Ext.baseCSSPrefix + 'multi-select', markDirtyCls:Ext.baseCSSPrefix + 'mark-dirty', scrollDockAliases:{top:'start', bottom:'end'}, getSelection:function() {
  return this.getSelectable().getSelectedRecord();
}, setSelection:function(record) {
  return this.getSelectable().setSelectedRecord(record);
}, generateSelectorFunctions:function() {
  var renderTarget = this.getRenderTarget(), bodyElement = this.bodyElement;
  this.eventDelegate = this.itemSelector = function(candidate) {
    return candidate && (candidate.parentNode === bodyElement.dom || candidate.parentNode === renderTarget.dom);
  };
}, bindStore:function(store) {
  this.dataRange = store.createActiveRange();
}, clearMask:function() {
  this.setMasked(false);
  this.autoMask = false;
}, clearPressedCls:function(type, location) {
  var me = this, record = location.record, child = location.child, el;
  me.clearPressedTimer();
  if (record && child) {
    el = child.isWidget ? child.element : Ext.fly(child);
    el.removeCls(me.pressedCls);
  }
  me.fireChildEvent(type, location);
}, clearPressedTimer:function() {
  var timeout = this.pressedTimeout;
  if (timeout) {
    Ext.undefer(timeout);
    delete this.pressedTimeout;
  }
}, doAddPressedCls:function(record) {
  var me = this, item = me.itemFromRecord(record);
  if (item) {
    item = item.isWidget ? item.element : Ext.fly(item);
    item.addCls(me.pressedCls);
  }
}, doClear:function() {
  this.syncEmptyState();
}, doChildTouchStart:function(location) {
  var me = this, record = location.record, itemButtonMode = me.getItemButtonMode(), pressedDelay = me.getPressedDelay();
  me.clearPressedTimer();
  if (record) {
    if (pressedDelay > 0) {
      me.pressedTimeout = Ext.defer(me.doAddPressedCls, pressedDelay, me, [record]);
    } else {
      me.doAddPressedCls(record);
    }
    if (itemButtonMode) {
      me.lastPressedLocation = location;
      Ext.GlobalEvents.setPressedComponent(me, location);
    }
  }
}, onRelease:function() {
  var me = this;
  if (me.lastPressedLocation) {
    me.clearPressedCls('release', me.lastPressedLocation);
  }
  me.lastPressedLocation = null;
}, ensureVisiblePlan:function(record, plan) {
  var store = this.store, recIndex;
  if (record.record) {
    plan = Ext.apply({}, record);
    record = plan.record;
    delete plan.record;
  } else {
    plan = Ext.apply({}, plan);
  }
  if (record.isEntity) {
    recIndex = store.indexOf(record);
  } else {
    if (typeof record === 'number') {
      recIndex = record;
      record = store.getAt(record);
    } else {
      Ext.raise('ensureVisible first parameter must be record or recordIndex ' + 'or an options object with a record property');
    }
  }
  plan.record = record;
  plan.recordIndex = recIndex;
  plan.animation = plan.animation || plan.animate;
  plan.async = !!plan.animation;
  plan.steps = [];
  if (recIndex < 0 || recIndex >= store.getCount()) {
    Ext.raise('Invalid record passed to List#ensureVisible');
    plan.promise = Ext.Deferred.getCachedRejected();
  } else {
    plan.steps.push('ensureVisibleFocus', 'ensureVisibleSelect', 'ensureVisiblePrep');
  }
  return plan;
}, ensureVisibleFocus:function(plan) {
  if (plan.focus) {
    var item = plan.item;
    if (plan.async) {
      plan.promise = plan.promise.then(function(o) {
        item = o.item;
        if (item) {
          item.focus();
        }
        return o;
      });
    } else {
      if (item) {
        item.focus();
      }
    }
  }
}, ensureVisiblePrep:function(plan) {
  var me = this, dataRange = me.dataRange, cleanup = function() {
    delete dataRange['goto'];
    if (args) {
      dataRange['goto'](args[0], args[1]);
    }
  }, args, promise;
  if (plan.async) {
    dataRange['goto'] = function(begin, end) {
      if (args) {
        args[0] = begin;
        args[1] = end;
      } else {
        args = [begin, end];
      }
    };
    promise = me.ensureVisibleScroll(plan);
    promise = promise.then(function(v) {
      cleanup();
      return v;
    }, function(ex) {
      cleanup();
      throw ex;
    });
  } else {
    promise = me.ensureVisibleScroll(plan);
  }
  plan.promise = promise;
}, ensureVisibleScroll:function(plan) {
  var item = plan.item || (plan.item = this.itemFromRecord(plan.recIndex));
  return this.getScrollable().ensureVisbile(item.el, {animation:plan.animation});
}, ensureVisibleSelect:function(plan) {
  if (plan.select) {
    var me = this;
    if (plan.async) {
      plan.promise = plan.promise.then(function(o) {
        return o;
      });
    } else {
    }
  }
}, filterScrollDockStart:function(item) {
  var scrollDock = item.scrollDock;
  return scrollDock === 'start' || scrollDock === 'top';
}, filterScrollDockEnd:function(item) {
  var scrollDock = item.scrollDock;
  return scrollDock === 'end' || scrollDock === 'bottom';
}, findTailItem:function(rawElements) {
  var me = this, items = rawElements ? me.innerItems : me.items.items, at = -1, tail = null, i, item, scrollDock;
  for (i = items.length; i-- > 0;) {
    item = items[i];
    scrollDock = item.scrollDock;
    if (scrollDock === 'end') {
      tail = items[at = i];
    } else {
      break;
    }
  }
  return rawElements ? tail : at;
}, fireChildEvent:function(type, location) {
  var me = this, deprecatedName = 'item' + type, name = 'child' + type, hasListeners = me.hasListeners;
  if (hasListeners[name]) {
    me.fireEvent(name, me, location);
  }
  if (hasListeners[deprecatedName] && location.record) {
    me.fireEvent(deprecatedName, me, location.viewIndex, location.item, location.record, location.event);
  }
}, getEmptyTextCmp:function() {
  var me = this, cmp = me.emptyTextCmp;
  if (!cmp) {
    me.emptyTextCmp = cmp = me.add(me.createEmptyText(me.getEmptyText()));
  }
  return cmp;
}, getRecordIndexFromPoint:function(x, y) {
  var item = this.getItemFromPoint(x, y);
  return item ? this.mapToRecordIndex(item) : -1;
}, getItemFromPoint:function(x, y) {
  var me = this, scroller = me.getScrollable(), scrollPosition = scroller.getPosition(), scrollSize = scroller.getSize(), offset = me.getScrollerTarget().getXY();
  return me.getItemFromPagePoint(Math.max(Math.min(x, scrollSize.x), 0) + offset[0] - scrollPosition.x, Math.max(Math.min(y, scrollSize.y), 0) + offset[1] - scrollPosition.y);
}, getItemFromPagePoint:function(x, y) {
  var items = this.getFastItems(), len = items.length, point = new Ext.util.Point(x, y), ret = null, i, item, el;
  for (i = 0; i < len; i++) {
    item = items[i];
    el = item.isWidget ? item.element : Ext.fly(item);
    if (el.getRegion().contains(point)) {
      ret = item;
      break;
    }
  }
  return ret;
}, handleBeforeLoad:function() {
  var me = this, loadingText = me.getLoadingText();
  if (loadingText) {
    me.autoMask = true;
    me.setMasked({xtype:'loadmask', message:loadingText});
  }
  me.hideEmptyText();
}, hideEmptyText:function() {
  var cmp = this.emptyTextCmp;
  if (cmp) {
    cmp.hide();
  }
}, indexModifiedFields:function(modified) {
  return modified;
}, itemAs:function(item, as) {
  var ret = item;
  if (as !== 'cmp' && as !== 'dom' && as !== 'el') {
    Ext.raise('Invalid "as" value "' + as + '" to mapToItem()');
  }
  if (typeof ret === 'number') {
    ret = null;
  } else {
    if (ret) {
      if (as === 'cmp') {
        if (!ret.isWidget) {
          ret = Ext.getCmp(ret.id);
        }
      } else {
        if (ret.isWidget) {
          ret = ret.el;
        }
        if (ret) {
          if (ret.isElement) {
            if (as === 'dom') {
              ret = ret.dom;
            }
          } else {
            if (as === 'el') {
              ret = Ext.fly(ret);
            }
          }
        }
      }
    }
  }
  return ret;
}, itemFromRecord:function(rec) {
  var index = rec.isEntity ? this.store.indexOf(rec) : rec;
  return index > -1 && this.dataItems[index] || null;
}, onContainerTrigger:function(e) {
  var me = this;
  if (e.target === me.element.dom) {
    if (me.getDeselectOnContainerClick() && me.store) {
      me.getSelectable().deselectAll();
    }
  }
}, runRefresh:function() {
  var me = this, store = me.store;
  me.syncEmptyState();
  if (store && !me.isConfiguring && (store.isTreeStore || !store.hasPendingLoad())) {
    me.fireEventedAction('refresh', [me], 'doRefresh', me, [me.getScrollToTopOnRefresh()]);
  }
}, saveFocusState:function() {
  var me = this, navModel = me.getNavigationModel(), location = navModel.location, lastFocusedViewIndex, lastFocusedRecord, itemCount, focusItem;
  if (location) {
    lastFocusedRecord = location.record;
    lastFocusedViewIndex = location.viewIndex;
    return function() {
      itemCount = me.getFastItems().length;
      if (itemCount) {
        if (lastFocusedRecord) {
          focusItem = me.mapToItem(lastFocusedRecord);
        }
        if (!focusItem) {
          focusItem = me.mapToItem(Math.min(lastFocusedViewIndex || 0, itemCount - 1));
        }
        navModel.setLocation(null);
        navModel.setLocation(focusItem);
      }
    };
  }
  return Ext.emptyFn;
}, setItemHidden:function(item, hide) {
  if (hide) {
    if (!item.$hidden) {
      item.hide();
      item.$hidden = true;
    }
  } else {
    if (item.$hidden) {
      item.$hidden = false;
      item.show();
    }
  }
}, setItemSelection:function(records, selected) {
  records = Ext.Array.from(records);
  var me = this, len = records.length, pressedCls = me.pressedCls, selectedCls = me.selectedCls, toRemove = pressedCls, i, record, item, toAdd;
  if (!selected) {
    toRemove = [pressedCls, selectedCls];
  } else {
    toAdd = selectedCls;
  }
  if (!me.isConfiguring && !me.destroyed) {
    for (i = 0; i < len; i++) {
      record = records[i];
      item = me.itemFromRecord(record);
      if (item) {
        item = item.isWidget ? item.element : Ext.fly(item);
        item.removeCls(toRemove);
        if (toAdd) {
          item.addCls(toAdd);
        }
      }
    }
  }
}, shouldRippleItem:function(item, e) {
  var disableSelection = this.getDisableSelection();
  if (!disableSelection && this.isItemSelected(item)) {
    return false;
  }
  return this.mixins.itemrippler.shouldRippleItem.call(this, item, e);
}, syncEmptyState:function() {
  var me = this, store = me.store, empty = !store || !store.getCount() && me.getEmptyText(), emptyTextCmp = me.emptyTextCmp;
  if (!empty) {
    if (emptyTextCmp) {
      emptyTextCmp.hide();
    }
  } else {
    if ((me.hasLoadedStore || !me.getDeferEmptyText()) && !(store && store.hasPendingLoad())) {
      emptyTextCmp = emptyTextCmp || me.getEmptyTextCmp();
      emptyTextCmp.show();
    }
  }
  me.setEmptyState(empty);
  return empty;
}, toggleChildrenTabbability:function(enableTabbing) {
  var focusEl = this.getRenderTarget();
  if (enableTabbing) {
    focusEl.restoreTabbableState({skipSelf:true});
  } else {
    focusEl.saveTabbableState({skipSelf:true, includeSaved:false});
  }
}, toggleHoverCls:function(on) {
  var target = this.mouseOverItem, el;
  if (target) {
    el = target.isWidget ? target.element : Ext.fly(target);
    el.toggleCls(this.hoveredCls, on);
  }
}, _onChildEvent:function(fn, e) {
  var me = this, last = me.lastPressedLocation, location = me.getNavigationModel().createLocation(e);
  if (location.child) {
    location.pressing = !!(last && last.child === location.child);
    me[fn](location);
  }
  return location;
}, _onChildTouchStart:function(e) {
  var child = this._onChildEvent('onChildTouchStart', e).child, el = child && (child.element || Ext.get(child));
  if (el) {
    el.on('touchmove', '_onChildTouchMove', this);
  }
}, _onChildTouchMove:function(e) {
  this._onChildEvent('onChildTouchMove', e);
}, _onChildTouchEnd:function(e) {
  var child = this._onChildEvent('onChildTouchEnd', e).child, el = child && (child.element || Ext.get(child));
  if (el) {
    el.un('touchmove', '_onChildTouchMove', this);
  }
}, _onChildTouchCancel:function(e) {
  var child = this._onChildEvent('onChildTouchCancel', e).child, el = child && (child.element || Ext.get(child));
  if (el) {
    el.un('touchmove', '_onChildTouchMove', this);
  }
}, _onChildTap:function(e) {
  var target = e.getTarget('.' + Ext.baseCSSPrefix + 'item-no-tap', this.element);
  if (!target) {
    this._onChildEvent('onChildTap', e);
  }
}, _onChildTapCancel:function(e) {
  this._onChildEvent('onChildTapCancel', e);
}, _onChildContextMenu:function(e) {
  this._onChildEvent('onChildContextMenu', e);
}, _onChildLongPress:function(e) {
  this._onChildEvent('onChildLongPress', e);
}, _onChildTapHold:function(e) {
  this._onChildEvent('onChildTapHold', e);
}, _onChildSingleTap:function(e) {
  this._onChildEvent('onChildSingleTap', e);
}, _onChildDoubleTap:function(e) {
  this._onChildEvent('onChildDoubleTap', e);
}, _onChildSwipe:function(e) {
  this._onChildEvent('onChildSwipe', e);
}, _onChildMouseOver:function(e) {
  var fromItem = e.getRelatedTarget(this.itemSelector), toItem = e.getTarget(this.itemSelector);
  if (toItem !== fromItem) {
    this._onChildEvent('onChildMouseOver', e);
  }
}, _onChildMouseOut:function(e) {
  var toItem = e.getRelatedTarget(this.itemSelector), fromItem = e.getTarget(this.itemSelector);
  if (toItem !== fromItem || !e.getRelatedTarget(this.eventDelegate)) {
    this._onChildEvent('onChildMouseOut', e);
  }
}, _onContainerTouchStart:function(e) {
  if (!e.getTarget(this.itemSelector)) {
    e.preventDefault();
    if (!this.bodyElement.getClientRegion().contains(e.getPoint())) {
      this.getNavigationModel().lastLocation = 'scrollbar';
    }
  }
}, setupChildEvent:Ext.privateFn, updateEmptyState:function(empty) {
  var me = this, items = me.items.items, showInEmptyState, hide, i, item, show;
  for (i = 0; i < items.length; ++i) {
    item = items[i];
    showInEmptyState = item.showInEmptyState;
    hide = show = false;
    if (showInEmptyState === false) {
      hide = !(show = !empty);
    } else {
      if (showInEmptyState) {
        if (typeof showInEmptyState === 'function') {
          hide = !(show = item.showInEmptyState(empty));
          if (show == null) {
            continue;
          }
        } else {
          hide = !(show = empty);
        }
      }
    }
    if (hide) {
      if (item.isInner) {
        me.setItemHidden(item, true);
      } else {
        item.hide();
      }
    } else {
      if (show) {
        if (item.isInner) {
          me.setItemHidden(item, false);
        } else {
          item.show();
        }
      }
    }
  }
}, applyNavigationModel:function(navigationModel) {
  if (navigationModel) {
    if (typeof navigationModel === 'string') {
      navigationModel = {type:navigationModel};
    }
    navigationModel = Ext.Factory.navmodel(Ext.apply({view:this}, navigationModel));
  }
  return navigationModel;
}, updateNavigationModel:function(navigationModel, oldNavigationModel) {
  Ext.destroy(oldNavigationModel);
}, getUseComponents:function() {
  return this.isComponentDataView;
}}});
Ext.define('Ext.theme.material.dataview.Abstract', {override:'Ext.dataview.Abstract', config:{itemRipple:{release:true, color:'default'}}});
Ext.define('Ext.dataview.GenericItem', {mixinId:'dataviewitem', isDataViewItem:true, config:{innerCls:null, contentCls:null, recordIndex:null}, updateRecordIndex:function(value) {
  this.el.dom.setAttribute('data-recordindex', value);
}, getDataview:function() {
  return this.parent;
}, updateInnerCls:function(cls, old) {
  this.innerElement.replaceCls(old, cls);
}, updateContentCls:function(cls, old) {
  this.getInnerHtmlElement().replaceCls(old, cls);
}, privates:{$dirty:false, dirtyCls:Ext.baseCSSPrefix + 'dirty', augmentToolHandler:function(tool, args) {
  var me = this;
  args[1] = {event:args.pop(), item:me, list:me.parent, record:me.getRecord(), tool:args[1]};
}, handleEmptyText:function(html) {
  var parent;
  if (!html) {
    parent = this.parent;
    if (parent && parent.getEmptyItemText) {
      html = parent.getEmptyItemText();
    }
  }
  return html;
}, syncDirty:function(record) {
  var me = this, dirty = record.dirty;
  if (dirty !== me.$dirty) {
    me.toggleCls(me.dirtyCls, dirty);
    me.$dirty = dirty;
  }
}}});
Ext.define('Ext.dataview.DataItem', function(DataItem) {
  return {extend:Ext.Container, alternateClassName:'Ext.dataview.component.DataItem', xtype:'dataitem', mixins:[Ext.dataview.GenericItem], config:{itemCls:null, dataMap:{cached:true, $value:null}}, html:'', classCls:Ext.baseCSSPrefix + 'dataitem', inheritUi:true, autoSize:null, defaultType:'component', referenceHolder:true, template:[{reference:'bodyElement', cls:Ext.baseCSSPrefix + 'body-el', uiCls:'body-el', children:[{reference:'innerElement', cls:Ext.baseCSSPrefix + 'inner-el', uiCls:'inner-el'}]}], 
  updateItemCls:function(newCls, oldCls) {
    this.el.replaceCls(oldCls, newCls);
  }, updateRecord:function(record) {
    if (this.destroying || this.destroyed) {
      return;
    }
    var me = this, dataMap = me.getDataMap(), tpl = me.getTpl(), data;
    if (dataMap) {
      DataItem.executeDataMap(record, me, dataMap);
    }
    me.syncDirty(record);
    if (tpl || !dataMap || me.hasListeners.updatedata) {
      data = me.parent.gatherData(record);
      if (tpl) {
        me.updateData(data);
      }
      if (me.hasListeners.updatedata) {
        me.fireEvent('updatedata', me, data);
      }
    }
  }, updateHtml:function(html, oldHtml) {
    this.callParent([this.handleEmptyText(html), oldHtml]);
  }, privates:{applyDataMap:function(dataMap) {
    return DataItem.parseDataMap(dataMap);
  }, getRenderTarget:function() {
    return this.innerElement;
  }, statics:{assignDataToItem:function(record, target, mappings, legacy) {
    var configMap = Ext.Config.map, cfg, dataPath, i, n, name, s, value;
    for (name in mappings) {
      s = legacy ? name : (cfg = configMap[name]) && cfg.names.set;
      if (!target[s]) {
        if (legacy) {
          Ext.raise('No method "' + name + '" on ' + target.$className);
        } else {
          Ext.raise('No config "' + name + '" on ' + target.$className);
        }
        continue;
      }
      dataPath = mappings[name];
      value = record;
      for (i = 0, n = dataPath.length; value && i < n; ++i) {
        value = value.interpret(dataPath[i]);
      }
      target[s](i < n ? null : value);
    }
  }, executeDataMap:function(record, item, dataMap) {
    var reference, legacy, target, mappings;
    for (reference in dataMap) {
      if (!(mappings = dataMap[reference])) {
        continue;
      }
      legacy = false;
      if (!(target = reference === '#' ? item : item.lookup(reference))) {
        if (typeof item[reference] === 'function') {
          target = item[reference]();
          legacy = true;
          if (!item.$dataMapWarning) {
            item.$dataMapWarning = true;
            Ext.log.warn('Using getters in dataMaps is deprecated (for ' + item.getId() + '); support will be removed in 7.0');
          }
        }
        if (!target) {
          continue;
        }
      }
      DataItem.assignDataToItem(record, target, mappings, legacy);
    }
  }, parseDataMap:function(dataMap) {
    var map = {}, inner, innerSrc, key1, key2;
    for (key1 in dataMap) {
      map[key1] = inner = {};
      innerSrc = dataMap[key1];
      for (key2 in innerSrc) {
        inner[key2] = innerSrc[key2].split('.');
      }
    }
    return map;
  }}}};
});
Ext.define('Ext.dataview.Component', {extend:Ext.dataview.Abstract, xtype:'componentdataview', isComponentDataView:true, config:{itemInnerCls:null, itemConfig:{xtype:'dataitem'}, itemContentCls:null, itemDataMap:null, maxItemCache:20, striped:null, itemCount:0}, firstCls:Ext.baseCSSPrefix + 'first', lastCls:Ext.baseCSSPrefix + 'last', oddCls:Ext.baseCSSPrefix + 'odd', beforeInitialize:function(config) {
  this.itemCache = [];
  this.callParent([config]);
}, isFirstItem:function(item) {
  return item === this.getFirstItem();
}, isFirstDataItem:function(item) {
  return item === this.getFirstDataItem();
}, isLastItem:function(item) {
  return item === this.getLastItem();
}, isLastDataItem:function(item) {
  return item === this.getLastDataItem();
}, doDestroy:function() {
  Ext.destroy(this.itemCache, this.dataRange);
  this.callParent();
}, onRender:function() {
  var me = this, itemConfig = me.getItemConfig();
  if (itemConfig.viewModel) {
    me.hasItemVm = true;
    if (!me.lookupViewModel()) {
      me.setViewModel(true);
    }
  }
  me.callParent();
}, getViewItems:function() {
  return this.getInnerItems().slice();
}, onStoreAdd:function(store, records, index) {
  var me = this;
  me.callParent(arguments);
  me.setItemCount(store.getCount());
  me.syncItemRange(me.getStoreChangeSyncIndex(index));
}, onStoreRemove:function(store, records, index) {
  var me = this, len = records.length, dataItems = me.dataItems.splice(index, len), itemCount = me.getItemCount(), i;
  me.callParent(arguments);
  if (!dataItems.length) {
    return;
  }
  for (i = len; i-- > 0;) {
    me.removeDataItem(dataItems[i]);
  }
  me.setItemCount(itemCount - len);
  me.syncItemRange(me.getStoreChangeSyncIndex(index));
}, updateItemInnerCls:function(cls) {
  if (!this.isConfiguring) {
    var items = this.dataItems, len = items.length, i, item;
    for (i = 0; i < len; i++) {
      item = items[i];
      if (item.setInnerCls) {
        item.setInnerCls(cls);
      }
    }
  }
}, applyItemConfig:function(itemConfig, oldItemConfig) {
  itemConfig = itemConfig || {};
  if (oldItemConfig && !itemConfig.xtype && !itemConfig.xclass) {
    var xtype = oldItemConfig.xtype, xclass = oldItemConfig.xclass;
    if (xtype || xclass) {
      itemConfig = Ext.apply({}, itemConfig);
      itemConfig[xclass ? 'xclass' : 'xtype'] = xclass || xtype;
    }
  }
  return itemConfig;
}, updateItemConfig:function() {
  if (!this.isConfiguring) {
    this.clearItems();
    this.refresh();
  }
}, updateItemContentCls:function(cls) {
  if (!this.isConfiguring) {
    var items = this.dataItems, len = items.length, i, item;
    for (i = 0; i < len; i++) {
      item = items[i];
      if (item.setContentCls) {
        item.setContentCls(cls);
      }
    }
  }
}, applyItemDataMap:function(dataMap) {
  return Ext.dataview.DataItem.parseDataMap(dataMap);
}, updateStriped:function(striped) {
  var me = this, dataItems = me.dataItems, oddCls = me.oddCls, i, el, odd;
  me.striped = !!striped;
  if (!me.isConfiguring) {
    for (i = 0; i < dataItems.length; ++i) {
      el = dataItems[i].el;
      odd = striped ? +el.dom.getAttribute('data-recordindex') : 0;
      el.toggleCls(oddCls, odd % 2);
    }
  }
}, privates:{dataRange:null, infinite:false, striped:false, _itemChangeHandlers:['changeItemRecordIndex', 'changeItemRecord', 'changeItemIsFirst', 'changeItemIsLast'], acquireItem:function(cfg, itemsFocusable) {
  var me = this, at = null, el, item;
  if (typeof cfg === 'number') {
    at = cfg;
    cfg = null;
  }
  if (!cfg) {
    cfg = me.getItemConfig();
    itemsFocusable = me.getItemsFocusable();
  }
  if (!(item = me.itemCache.pop())) {
    item = me.createDataItem(cfg);
    item = me.addDataItem(item, at);
    el = item.element;
    if (itemsFocusable) {
      (item.getFocusEl() || el).setTabIndex(-1);
    }
    el.dom.setAttribute('data-viewid', me.id);
  } else {
    item.removeCls(me._cachedRemoveClasses);
    me.addDataItem(item, at);
  }
  return item;
}, addDataItem:function(item, at) {
  var me = this;
  if (at === null) {
    at = me.findTailItem(false);
  }
  item = at < 0 ? me.add(item) : me.insert(at, item);
  me.dataItems.push(item);
  return item;
}, changeItem:function(itemIndex, recordIndex) {
  var me = this, store = me.store, page = store.currentPage, datasetIndex = recordIndex + (page ? (page - 1) * store.pageSize : 0), dataItems = me.dataItems, realIndex = itemIndex < 0 ? dataItems.length + itemIndex : itemIndex, item = dataItems[realIndex], storeCount = store.getCount(), handlers = me._itemChangeHandlers, options = {isFirst:!recordIndex, isLast:recordIndex === storeCount - 1, item:item, itemIndex:realIndex, record:me.dataRange.records[recordIndex], recordIndex:recordIndex, datasetIndex:datasetIndex}, 
  i, itemEl;
  options.afterEl = options.beforeEl = options.itemEl = itemEl = item.renderElement;
  options.itemClasses = itemEl.getClassMap(false);
  options.isFirstChanged = item.isFirst !== options.isFirst;
  options.isLastChanged = item.isLast !== options.isLast;
  for (i = 0; i < handlers.length; ++i) {
    me[handlers[i]](options);
  }
  itemEl.setClassMap(options.itemClasses, true);
  return options;
}, changeItemIsFirst:function(options) {
  if (!options.isFirstChanged) {
    return;
  }
  var me = this, firstCls = me.firstCls, item = options.item, itemClasses = options.itemClasses, items = me.scrollDockedItems, i, len;
  if (!(item.isFirst = options.isFirst)) {
    delete itemClasses[firstCls];
  } else {
    itemClasses[firstCls] = 1;
    if (items && !me.infinite) {
      items = items.start.items;
      len = items.length;
      for (i = 0; i < len; ++i) {
        items[i].renderElement.insertBefore(options.beforeEl);
      }
    }
  }
}, changeItemIsLast:function(options) {
  if (!options.isLastChanged) {
    return;
  }
  var me = this, item = options.item, itemClasses = options.itemClasses, lastCls = me.lastCls, items = me.scrollDockedItems, i, len;
  if (!(item.isLast = options.isLast)) {
    delete itemClasses[lastCls];
  } else {
    itemClasses[lastCls] = 1;
    if (items && !me.infinite) {
      items = items.end.items;
      len = items.length;
      for (i = 0; i < len; ++i) {
        items[i].renderElement.insertAfter(options.afterEl);
      }
    }
  }
}, changeItemRecord:function(options) {
  this.syncItemRecord(options);
}, changeItemRecordIndex:function(options) {
  var item = options.item, recordIndex = options.recordIndex, itemClasses = options.itemClasses, oddCls = this.oddCls;
  item.$datasetIndex = options.datasetIndex;
  if (item.isDataViewItem) {
    if (item.getRecordIndex() !== recordIndex) {
      item.setRecordIndex(recordIndex);
    }
  } else {
    item.el.dom.setAttribute('data-recordindex', recordIndex);
  }
  if (this.striped && options.recordIndex % 2) {
    itemClasses[oddCls] = 1;
  } else {
    delete itemClasses[oddCls];
  }
}, clearItemCaches:function() {
  var cache = this.itemCache;
  Ext.destroy(cache);
  cache.length = 0;
}, clearItems:function() {
  var me = this, dataItems = me.dataItems, len = dataItems.length, itemCache = me.itemCache, i;
  for (i = 0; i < len; ++i) {
    me.removeDataItem(dataItems[i], true);
  }
  Ext.destroy(itemCache);
  dataItems.length = itemCache.length = 0;
  me.setItemCount(0);
}, createDataItem:function(cfg) {
  var me = this, markDirty = me.getMarkDirty(), cls = markDirty ? me.markDirtyCls : '', itemCls = me.getItemCls(), config;
  if (itemCls) {
    if (markDirty) {
      cls += ' ';
    }
    cls += itemCls;
  }
  config = {xtype:me.getDefaultType(), cls:cls, tpl:me.getItemTpl(), $dataItem:'record'};
  cls = me.getItemInnerCls();
  if (cls) {
    config.innerCls = cls;
  }
  cls = me.getItemContentCls();
  if (cls) {
    config.contentCls = cls;
  }
  return Ext.apply(config, cfg || me.getItemConfig());
}, doClear:function() {
  this.setItemCount(0);
  this.callParent();
}, doRefresh:function(scrollToTop) {
  var me = this, storeCount = me.dataRange.records.length, scroller = me.getScrollable(), restoreFocus;
  ++me.refreshCounter;
  if (scroller && scrollToTop) {
    scroller.scrollTo(0, 0);
  }
  if (storeCount) {
    restoreFocus = me.saveFocusState();
    me.hideEmptyText();
    me.setItemCount(storeCount);
    me.syncItemRange();
    if (me.hasSelection()) {
      me.setItemSelection(me.getSelections(), true);
    }
    restoreFocus();
  } else {
    me.doClear();
  }
}, getFastItems:function() {
  return this.getInnerItems();
}, getStoreChangeSyncIndex:function(index) {
  return index;
}, removeCachedItem:function(item, preventCache, cache, max, preventRemoval) {
  var me = this, ret = false;
  if (!preventCache && cache.length < max) {
    if (preventRemoval) {
      me.setItemHidden(item, true);
    } else {
      me.remove(item, false);
    }
    cache.push(item);
  } else {
    item.destroy();
    ret = true;
  }
  return ret;
}, removeDataItem:function(item, preventCache) {
  return this.removeCachedItem(item, preventCache, this.itemCache, this.getMaxItemCache());
}, syncItemRange:function(start, end) {
  var count = this.store.getCount(), i;
  if (end == null) {
    end = count;
  }
  for (i = start || 0; i < end; ++i) {
    this.changeItem(i, i);
  }
}, syncItemRecord:function(options, tombstoneRec) {
  var me = this, item = options.item, itemClasses = options && options.itemClasses, oldRecord = item.getRecord(), record = tombstoneRec || options.record, dataMap = me.getItemDataMap(), el = item.el, viewModel = item.getViewModel(), selectedCls = me.selectedCls;
  if (oldRecord === record) {
    if (!tombstoneRec) {
      if (item.isRecordRefreshable) {
        item.refresh(options);
      } else {
        item.updateRecord(record, oldRecord);
      }
    }
  } else {
    if (me.getSelectable().isRowSelected(record)) {
      if (itemClasses) {
        itemClasses[selectedCls] = true;
      } else {
        el.addCls(selectedCls);
      }
    } else {
      if (itemClasses) {
        delete itemClasses[selectedCls];
      } else {
        el.removeCls(selectedCls);
      }
    }
    item.setRecord(record);
    item.el.dom.setAttribute('data-recordid', record.internalId);
  }
  if (dataMap) {
    Ext.dataview.DataItem.executeDataMap(record, item, dataMap);
  }
  if (viewModel) {
    viewModel.setData({record:options.record});
  }
}, traverseItem:function(item, delta) {
  var me = this, items = me.innerItems, next = null, cmp = item, i;
  if (item) {
    if (item.isElement) {
      cmp = Ext.getCmp(item.id);
    }
    i = items.indexOf(cmp);
    if (i > -1) {
      next = items[i + delta] || null;
    }
  }
  return next;
}, updateItemCount:function(count) {
  var me = this, items = me.dataItems, cfg, itemsFocusable;
  if (items.length < count) {
    cfg = me.getItemConfig();
    itemsFocusable = me.getItemsFocusable();
    while (items.length < count) {
      me.acquireItem(cfg, itemsFocusable);
    }
  }
  while (items.length > count) {
    me.removeDataItem(items.pop());
  }
}}}, function(ComponentDataView) {
  var proto = ComponentDataView.prototype;
  proto._cachedRemoveClasses = [proto.pressedCls, proto.selectedCls];
});
Ext.define('Ext.dataview.Pinnable', {mixinId:'dataviewpinnable', isDataViewPinnable:true, config:{pinned:null}, pinnedCls:Ext.baseCSSPrefix + 'pinned', updatePinned:function(value) {
  var me = this, el = me.el, pinnedCls = me.pinnedCls, pinnedClsMap = me._pinnedClsMap, classes = el.getClassMap(false);
  delete classes[pinnedClsMap.top];
  delete classes[pinnedClsMap.bottom];
  if (value) {
    classes[pinnedCls] = true;
    pinnedCls = pinnedClsMap[value];
    if (pinnedCls) {
      classes[pinnedCls] = true;
    }
  } else {
    delete classes[pinnedCls];
  }
  el.setClassMap(classes, true);
}, _pinnedClsMap:{top:Ext.baseCSSPrefix + 'pinned-top', bottom:Ext.baseCSSPrefix + 'pinned-bottom'}});
Ext.define('Ext.dataview.ItemHeader', {extend:Ext.Component, xtype:'itemheader', mixins:[Ext.mixin.Toolable, Ext.dataview.Pinnable], isItemHeader:true, config:{group:null, contentWidth:null}, html:'', classCls:Ext.baseCSSPrefix + 'itemheader', inheritUi:true, toolDefaults:{ui:'itemheader'}, template:[{reference:'bodyElement', cls:Ext.baseCSSPrefix + 'body-el', uiCls:'body-el'}], setGroup:function(group) {
  var me = this, was = me._group;
  me._group = group;
  me.updateGroup(group, was);
  return me;
}, updateGroup:function(group) {
  var me = this, data, grouper, html, list, tpl;
  if (group) {
    list = me.parent;
    grouper = list.getStore().getGrouper();
    tpl = grouper && grouper.owner === list && grouper.headerTpl || me.getTpl();
    if (tpl) {
      data = me.getGroupHeaderTplData();
      html = tpl.apply(data);
    }
  }
  me.setHtml(html || '');
}, getScrollerTarget:function() {
  return this.el;
}, doDestroy:function() {
  this.mixins.toolable.doDestroy.call(this);
  this.callParent();
}, privates:{augmentToolHandler:function(tool, args) {
  var info = args[1] = {event:args.pop(), group:this.getGroup(), itemHeader:args[0], tool:args[1]};
  args[0] = info.list = this.parent;
}, getGroupHeaderTplData:function(skipHtml) {
  var group = this.getGroup(), list = this.parent, data = group && {name:group.getGroupKey(), group:group, groupField:list.getStore().getGrouper().getProperty(), children:group.items, count:group.length};
  if (data) {
    data.value = group.items[0].data[data.groupField];
  }
  if (!skipHtml) {
    data.html = Ext.htmlEncode(data.name);
  }
  data.groupValue = data.value;
  return data;
}, getList:function() {
  return this.parent;
}, updateContentWidth:function(width) {
  var el = this._toolDockWrap || this.bodyElement;
  if (el) {
    el.setWidth(width ? width : null);
  }
}}});
Ext.define('Ext.dataview.Disclosable', {mixinId:'disclosable', isListItem:true, toolDefaults:{ui:'listitem'}, toolAnchorName:'innerElement', getDisclosure:function() {
  return this.lookupTool('disclosure');
}, privates:{invokeDisclosure:function(tool, handler, e) {
  var parent = this.parent;
  if (tool.type === 'disclosure' && !handler) {
    if (parent && parent.onItemDisclosureTap) {
      parent.onItemDisclosureTap(this, e);
      return true;
    }
  }
}, syncDisclosure:function(record) {
  var me = this, disclosure = me.getDisclosure(), parent = me.parent;
  if (disclosure) {
    disclosure.setHidden(parent.shouldHideDisclosure(record));
  }
}}});
Ext.define('Ext.dataview.SimpleListItem', {extend:Ext.Component, alternateClassName:'Ext.dataview.component.SimpleListItem', xtype:'simplelistitem', mixins:[Ext.dataview.Disclosable, Ext.mixin.Toolable, Ext.dataview.GenericItem, Ext.dataview.Pinnable], classCls:Ext.baseCSSPrefix + 'listitem', inheritUi:true, html:'', template:[{reference:'bodyElement', cls:Ext.baseCSSPrefix + 'body-el', uiCls:'body-el', children:[{reference:'innerElement', cls:Ext.baseCSSPrefix + 'inner-el', uiCls:'inner-el'}]}], 
doDestroy:function() {
  this.mixins.toolable.doDestroy.call(this);
  this.callParent();
}, handleFocusEvent:Ext.emptyFn, updateRecord:function(record) {
  if (this.destroying || this.destroyed) {
    return;
  }
  var me = this, dataview = me.parent, data = dataview && dataview.gatherData(record);
  me.updateData(data);
  me.syncDisclosure(record);
}, updateHtml:function(html, oldHtml) {
  this.callParent([this.handleEmptyText(html), oldHtml]);
}, privates:{getRenderTarget:function() {
  return this.innerElement;
}, invokeToolHandler:function(tool, handler, scope, args, e) {
  if (this.invokeDisclosure(tool, handler, e)) {
    return false;
  }
  return tool.invokeToolHandler(tool, handler, scope, args, e);
}}});
Ext.define('Ext.dataview.List', {extend:Ext.dataview.Component, alternateClassName:'Ext.List', xtype:'list', isList:true, mixins:[Ext.mixin.Bufferable], config:{bufferSize:20, disclosureProperty:'disclosure', grouped:true, groupFooter:{cached:true, $value:null}, groupHeader:{cached:true, $value:{xtype:'itemheader', tpl:'{html} ({count})'}}, indexBar:null, infinite:null, minimumBufferDistance:5, onItemDisclosure:{$value:null, merge:function(value, oldValue, target) {
  var t = value && target && target.$isClass && typeof value;
  if (t === 'string' || t === 'function') {
    return {handler:value, scope:'self'};
  }
  return value;
}}, pinFooters:false, pinHeaders:true, pinnedFooter:{lazy:true, $value:null}, pinnedHeader:{lazy:true, $value:{xtype:'itemheader'}}, preventSelectionOnDisclose:true, preventSelectionOnTool:true, rowLines:null, useSimpleItems:null, variableHeights:null, horizontalOverflow:null, innerCtHeight:null, innerWidth:null, pinnedFooterHeight:null, pinnedHeaderHeight:null, topRenderedIndex:null, verticalOverflow:null, visibleHeight:null, visibleLeft:null, visibleTop:null, visibleWidth:null}, bufferableMethods:{syncVerticalOverflow:1}, 
classCls:Ext.baseCSSPrefix + 'list', itemConfig:{xtype:'simplelistitem'}, maintainChildNodes:false, rowHeight:0, scrollable:{x:false, y:true}, storeEventListeners:{groupchange:'onStoreGroupChange', totalcountchange:'onStoreTotalCountChange'}, template:[{reference:'bodyElement', cls:Ext.baseCSSPrefix + 'body-el', uiCls:'body-el', children:[{reference:'outerCt', className:Ext.baseCSSPrefix + 'list-outer-ct', children:[{reference:'innerCt', className:Ext.baseCSSPrefix + 'list-inner-ct'}]}]}], beforeInitialize:function(config) {
  var me = this, infinite = me.getInfinite();
  if (!infinite) {
    me.innerCt.on('resize', 'onInnerCtResize', me);
  }
  me.gapMap = {};
  if (!me.itemTranslationMethod) {
    me.itemTranslationMethod = Ext.supports.TranslateYCausesHorizontalScroll ? 'cssposition' : 'csstransform';
  }
  me.groupingInfo = {headers:{config:me.getGroupHeader(), creator:'createGroupHeader', name:'$header', offset:0, unused:[]}, footers:{config:me.getGroupFooter(), creator:'createGroupFooter', name:'$footer', offset:1, unused:[]}};
  me.bodyElement.on({resize:'onBodyResize', scope:me});
  me.stickyItems = [];
  me.stickyItemsByRecordId = {};
  me.callParent([config]);
}, doDestroy:function() {
  var me = this, groupingInfo = me.groupingInfo, scrollInfo = me.scrollInfo;
  if (scrollInfo) {
    Ext.unraf(scrollInfo.timer);
  }
  Ext.destroy(me.resyncListener, groupingInfo.headers.unused, groupingInfo.footers.unused);
  me.callParent();
}, createIndexBar:function(config) {
  return Ext.apply({xtype:'indexbar', $initParent:this, parent:this, hidden:true}, config);
}, createPinnedFooter:function(config) {
  var ret = this.createPinnedHeaderFooter(config);
  ret.bottom = 0;
  ret.pinned = 'bottom';
  return ret;
}, createPinnedHeader:function(config) {
  var me = this, groupedHeader = me.getGroupHeader(), ret = me.createPinnedHeaderFooter(config), tools;
  ret.top = 0;
  ret.pinned = 'top';
  if (!ret.tpl && groupedHeader.tpl) {
    ret.tpl = groupedHeader.tpl;
  }
  if (!('tools' in ret)) {
    tools = groupedHeader && groupedHeader.tools;
    if (tools) {
      ret.tools = tools;
    }
  }
  return ret;
}, isGrouping:function() {
  var store = this.getGrouped() && this.store, grouper = store && store.getGrouper();
  return !!grouper;
}, isRecordRendered:function(recordIndex) {
  if (!this.infinite) {
    return true;
  }
  var renderInfo = this.renderInfo;
  if (recordIndex.isEntity) {
    recordIndex = this.store.indexOf(recordIndex);
  }
  return recordIndex >= renderInfo.indexTop && recordIndex < renderInfo.indexBottom;
}, mapToViewIndex:function(value) {
  var me = this, indexOffset;
  if (me.infinite && typeof value === 'number') {
    indexOffset = me.renderInfo.indexTop;
    value -= indexOffset;
  }
  return me.callParent([value, indexOffset]);
}, scrollToRecord:function(record, animation) {
  return this.ensureVisible({record:record, animation:animation});
}, shouldSelectItem:function(e) {
  var me = this, no = !me.callParent([e]), cmp;
  if (!no) {
    cmp = e.getTarget(me.toolSelector);
    cmp = cmp && me.el.contains(cmp) && Ext.Component.from(cmp);
    if (cmp) {
      no = cmp.preventSelection;
      if (no == null) {
        if (cmp.type === 'disclosure') {
          no = me.getPreventSelectionOnDisclose();
        } else {
          no = me.getPreventSelectionOnTool();
        }
      }
    }
  }
  return !no;
}, onBodyResize:function(el, info) {
  var me = this, height = info.height, width = info.width;
  if (width === me.getVisibleWidth()) {
    me.setVisibleHeight(height);
  } else {
    me.suspendSync = true;
    me.setVisibleHeight(me.outerCt.measure('h'));
    me.suspendSync = false;
    me.setVisibleWidth(width);
  }
}, onItemAdd:function(item, index) {
  var me = this;
  if (me.infinite) {
    if (item.$dataItem && me.variableHeights) {
      item.on('resize', 'onDataItemResize', me);
    }
    if (item.isInner) {
      item.setTranslatable({type:me.itemTranslationMethod});
    }
  }
  return me.callParent([item, index]);
}, onItemRemove:function(item, index, destroying) {
  var me = this, height = item.$height, scrollDock = item.scrollDock;
  me.callParent([item, index, destroying]);
  if (scrollDock && height) {
    Ext.Array.remove(me.scrollDockedItems[scrollDock].items, item);
    me.adjustScrollDockHeight(scrollDock, -height);
  }
}, onStoreAdd:function(store, records, index) {
  var me = this;
  me.syncEmptyState();
  if (me.infinite) {
    if (me.getVisibleHeight()) {
      me.refreshGrouping();
      me.resyncOnPaint();
    }
  } else {
    me.refreshGroupIndices();
    me.setItemCount(store.getCount());
    me.syncItemRange(Math.max(0, index - 1));
  }
}, onStoreRemove:function(store, records, index) {
  var me = this, navModel = this.getNavigationModel(), location;
  if (me.infinite) {
    if (me.getVisibleHeight()) {
      me.refreshGrouping();
      me.resyncOnPaint();
    }
    me.syncEmptyState();
  } else {
    me.refreshGroupIndices();
    me.callParent([store, records, index]);
  }
  if (navModel.location) {
    location = navModel.location.refresh();
    navModel.setLocation(location);
  }
}, onStoreUpdate:function(store, record, type, modifiedFieldNames, info) {
  var me = this;
  if (info && info.groupChanged && me.isGrouping()) {
    me.refreshGrouping();
    me.syncRows();
  } else {
    me.callParent([store, record, type, modifiedFieldNames, info]);
  }
}, updateGrouped:function() {
  var me = this;
  if (me.initialized) {
    me.refreshGrouping();
    me.syncRows();
  }
}, updateGroupFooter:function(footer) {
  var groupingInfo = this.groupingInfo;
  if (groupingInfo) {
    groupingInfo.footers.config = footer;
  }
}, applyGroupHeader:function(header) {
  var tpl = header && header.tpl;
  if (tpl != null) {
    header = Ext.apply({}, header);
    header.tpl = Ext.XTemplate.get(tpl);
  }
  return header;
}, updateGroupHeader:function(header) {
  var groupingInfo = this.groupingInfo;
  if (groupingInfo) {
    groupingInfo.headers.config = header;
  }
}, applyIndexBar:function(config, existing) {
  return Ext.updateWidget(existing, config, this, 'createIndexBar');
}, updateIndexBar:function(indexBar) {
  if (indexBar) {
    this.add(indexBar);
  }
}, applyItemConfig:function(itemConfig, oldItemConfig) {
  var ret = this.callParent([itemConfig, oldItemConfig]), disclosure, tools;
  if (this.getOnItemDisclosure()) {
    disclosure = {disclosure:true};
    tools = ret.tools;
    ret.tools = tools ? Ext.merge(disclosure, tools) : disclosure;
  }
  return ret;
}, updateInfinite:function(infinite) {
  var me = this;
  me.infinite = infinite;
  me.freezeConfig('infinite');
  if (infinite) {
    me.setItemHidden = me.setItemHiddenInfinite;
    me.el.addCls(me.infiniteCls);
    me.innerCt.addCls(me.infiniteCls);
    me.renderInfo = {atBegin:false, atEnd:false, bottom:0, height:0, top:0, indexBottom:0, indexTop:0};
    me.scrollInfo = {};
    me.getScrollable().on({scope:me, scroll:'onContainerScroll', scrollstart:'onContainerScrollStart', scrollend:'onContainerScrollEnd'});
  }
}, updatePinFooters:function(pinFooters) {
  var me = this, pinnedFooter = me.pinnedFooter;
  me.pinFooters = pinFooters;
  if (me.isConfiguring) {
    return;
  }
  if (me.setupFooterPinning()) {
    if (me.infinite) {
      me.syncPinnedFooter();
    }
  } else {
    if (pinnedFooter) {
      me.setItemHidden(pinnedFooter, true);
    }
  }
}, applyPinnedFooter:function(config, existing) {
  var me = this, ret = Ext.updateWidget(existing, config, me, 'createPinnedFooter'), index;
  if (!existing) {
    index = me.getIndexBar();
    if (index) {
      index = me.indexOf(index);
      me.insert(index, ret);
    } else {
      me.add(ret);
    }
    me.setItemHidden(ret, true);
  }
  return ret;
}, updatePinnedFooter:function(pinnedFooter) {
  var me = this;
  me.pinnedFooter = pinnedFooter;
  me.setupFooterPinning();
  if (pinnedFooter) {
    pinnedFooter.$pinnedFooter = true;
  }
}, updatePinHeaders:function(pinHeaders) {
  var me = this, pinnedHeader = me.pinnedHeader;
  me.pinHeaders = pinHeaders;
  if (me.isConfiguring) {
    return;
  }
  if (me.setupHeaderPinning()) {
    if (me.infinite) {
      me.syncPinnedHeader();
    }
  } else {
    if (pinnedHeader) {
      me.setItemHidden(pinnedHeader, true);
    }
  }
}, applyPinnedHeader:function(config, existing) {
  var me = this, ret = Ext.updateWidget(existing, config, me, 'createPinnedHeader');
  if (!existing && ret) {
    me.insert(0, ret);
    me.setItemHidden(ret, true);
  }
  return ret;
}, updatePinnedHeader:function(pinnedHeader) {
  var me = this;
  me.pinnedHeader = pinnedHeader;
  me.setupHeaderPinning();
  if (pinnedHeader) {
    pinnedHeader.$pinnedHeader = true;
  }
}, updateRowLines:function(rowLines) {
  this.innerCt.toggleCls(this.noRowLinesCls, rowLines === false);
}, updateUseSimpleItems:function(useSimpleItems) {
  if (!this.self._updateUseSimpleItemsWarning) {
    this.self._updateUseSimpleItemsWarning = true;
    Ext.log.warn('The Ext.List#useSimpleItems config is deprecated; ' + 'use itemConfig.xtype instead');
  }
  var itemConfig = this.getItemConfig();
  itemConfig = Ext.applyIf({xtype:useSimpleItems ? 'simplelistitem' : 'listitem'}, itemConfig);
  this.setItemConfig(itemConfig);
}, updateVariableHeights:function(variableHeights) {
  this.variableHeights = variableHeights;
}, privates:{toolSelector:'.' + Ext.baseCSSPrefix + 'tool:not(.' + Ext.baseCSSPrefix + 'passive)', infiniteCls:Ext.baseCSSPrefix + 'infinite', groupFirstCls:Ext.baseCSSPrefix + 'group-first', groupLastCls:Ext.baseCSSPrefix + 'group-last', groupedCls:Ext.baseCSSPrefix + 'grouped', hasPinnedFooterCls:Ext.baseCSSPrefix + 'has-pinned-footer', hasPinnedHeaderCls:Ext.baseCSSPrefix + 'has-pinned-header', noRowLinesCls:Ext.baseCSSPrefix + 'no-row-lines', stickyCls:Ext.baseCSSPrefix + 'sticky', tombstoneCls:Ext.baseCSSPrefix + 
'tombstone', blockingScroll:0, discardMeasureRow:false, gapAfter:0, groupingInfo:null, measuredFirstRow:false, pinnedFooter:null, pinnedHeader:null, lastAdjustedPosition:null, measuredHeight:null, renderInfo:null, suspendSync:false, onAnimationFrame:function() {
  var me = this, info = me.scrollInfo, x = info.x, y = info.y;
  if (x !== null) {
    me.setVisibleLeft(x);
  }
  if (y !== null) {
    me.setVisibleTop(y);
  }
  info.timer = null;
}, onContainerScroll:function(scroller, x, y, dx, dy) {
  var me = this, info = me.scrollInfo;
  if (!me.blockingScroll) {
    info.x = dx ? x : null;
    info.y = dy ? y : null;
    if (!info.timer) {
      info.timer = Ext.raf(me.onAnimationFrame, me);
    }
  }
}, onContainerScrollStart:function() {
  this.toggleHoverCls(false);
  this.doHover = false;
}, onContainerScrollEnd:function() {
  this.doHover = true;
  this.toggleHoverCls(true);
}, onDataItemResize:function(item, width, height) {
  var me = this, dataItems = me.dataItems, renderInfo = me.renderInfo, row = item.$dataRow || item, bottomUp, count, index, y;
  height += item.el.getMargin('tb');
  if (item.$height !== height) {
    item.$height = height;
    index = dataItems.indexOf(row);
    if (index > -1) {
      if (renderInfo.indexTop && renderInfo.indexBottom >= me.store.getCount()) {
        bottomUp = true;
        count = index + 1;
        y = row.$y1;
      } else {
        count = dataItems.length - index;
        y = row.$y0;
      }
      me.positionItems(y, bottomUp, count);
    }
  }
}, onItemDisclosureTap:function(item, e) {
  var me = this, record = item.getRecord(), index = me.store.indexOf(record);
  me.fireAction('disclose', [me, record, item, index, e], 'doDisclose');
}, _onChildTouchCancel:function(e) {
  if (!e.getTarget(this.toolSelector)) {
    this.callParent([e]);
  }
}, _onChildTouchEnd:function(e) {
  if (!e.getTarget(this.toolSelector)) {
    this.callParent([e]);
  }
}, _onChildTouchStart:function(e) {
  if (!e.getTarget(this.toolSelector)) {
    this.callParent([e]);
  }
}, onRangeAvailable:function() {
  this.syncRows();
}, onScrollDockItemHide:function(item) {
  var height = item.$height;
  if (height) {
    this.adjustScrollDockHeight(item.scrollDock, -height);
    item.$height = null;
  }
}, onScrollDockItemResize:function(item, width, height) {
  var was = item.$height;
  if (was !== height) {
    item.$height = height;
    this.adjustScrollDockHeight(item.scrollDock, height - was);
  }
}, onScrollDockItemShow:function(item) {
  var height = item.$height;
  if (height == null) {
    height = this.measureItem(item);
  }
  this.adjustScrollDockHeight(item.scrollDock, height);
}, onStoreGroupChange:function() {
  if (this.initialized) {
    this.refreshGrouping();
    this.syncRows();
  }
}, onStoreTotalCountChange:function() {
  if (this.getVisibleHeight()) {
    this.syncRowsToHeight();
  }
  this.syncEmptyState();
}, addDataItem:function(item, at) {
  var me = this, ret;
  ret = me.callParent([item, at]);
  ret.$height = me.variableHeights ? null : me.rowHeight;
  return ret;
}, addScrollDockedItem:function(item) {
  var me = this;
  if (me.infinite) {
    item.on({hide:'onScrollDockItemHide', resize:'onScrollDockItemResize', show:'onScrollDockItemShow', scope:me});
    item.$height = null;
    me.setItemHidden(item, true);
  }
}, adjustContentTop:function(adjust) {
  var me = this, rows = this.dataItems, len = rows.length, renderInfo = me.renderInfo, scrollDock = me.scrollDockedItems, i, row, decoration, item, items;
  for (i = 0; i < len; ++i) {
    row = rows[i];
    me.setItemPosition(row, row.$position + adjust);
    decoration = row.$header;
    if (decoration) {
      me.setItemPosition(decoration, decoration.$position + adjust);
    }
    decoration = row.$footer;
    if (decoration) {
      me.setItemPosition(decoration, decoration.$position + adjust);
    }
    row.$y0 += adjust;
    row.$y1 += adjust;
  }
  if (scrollDock) {
    if (renderInfo.atBegin) {
      items = scrollDock.start.items;
      len = items.length;
      for (i = 0; i < len; ++i) {
        item = items[i];
        if (!item.getHidden()) {
          me.setItemPosition(item, item.$position + adjust);
        }
      }
    }
    if (renderInfo.atEnd) {
      items = scrollDock.end.items;
      len = items.length;
      for (i = 0; i < len; ++i) {
        item = items[i];
        if (!item.getHidden()) {
          me.setItemPosition(item, item.$position + adjust);
        }
      }
    }
  }
}, adjustScrollDockHeight:function(which, amount) {
  var me = this, scrollDock = me.scrollDockedItems;
  scrollDock = scrollDock && scrollDock[which];
  if (scrollDock) {
    scrollDock.height += amount;
    me.resyncOnPaint();
  }
}, adjustRenderedRows:function(y, oldY) {
  var me = this, bufferSize = me.getBufferSize(), minimumBufferDistance = me.getMinimumBufferDistance(), renderInfo = me.renderInfo, indexTop = renderInfo.indexTop, indexBottom = renderInfo.indexBottom, rows = me.dataItems, rowCount = rows.length, height = me.getVisibleHeight(), storeCount = me.store.getCount(), visibleTopIndex = me.recordIndexByPosition(y), visibleBottomIndex = me.recordIndexByPosition(y + height), newIndexTop, delta;
  if (oldY < y) {
    if (indexBottom - visibleBottomIndex >= minimumBufferDistance) {
      return;
    }
  } else {
    if (visibleTopIndex - indexTop >= minimumBufferDistance) {
      return;
    }
  }
  newIndexTop = visibleTopIndex - (bufferSize >>> 1);
  newIndexTop = Math.max(0, Math.min(newIndexTop, storeCount - rowCount));
  delta = newIndexTop - indexTop;
  if (delta > 0 && delta < rowCount) {
    me.rollDown(delta);
  } else {
    if (delta < 0 && -delta < rowCount) {
      me.rollUp(-delta);
    } else {
      if (delta || me.refreshing) {
        me.teleport(y);
      }
    }
  }
}, bindStore:function(store) {
  var me = this, Model = store.getModel(), tombstoneRec = new Model;
  if (store.isBufferedStore) {
    Ext.raise('Did you mean to use Ext.data.virtual.Store? ' + '(Ext.data.BufferedStore is not supported)');
  }
  if (store.isVirtualStore && !me.infinite) {
    Ext.raise('Virtual stores require infinite:true');
  }
  me.dataRange = store.createActiveRange({prefetch:true, callback:'onRangeAvailable', scope:me});
  me.tombstoneRec = tombstoneRec;
  tombstoneRec.tombstone = true;
  if (me.getVisibleHeight()) {
    me.syncRowsToHeight();
  }
}, bisectPosition:function(y) {
  var rows = this.dataItems, begin = 0, end = rows.length - 1, middle, midVal;
  if (y < rows[0].$y0) {
    return -1;
  }
  while (begin <= end) {
    middle = begin + end >>> 1;
    midVal = rows[middle].$y0;
    if (y === midVal) {
      return middle;
    }
    if (midVal < y) {
      begin = middle + 1;
    } else {
      end = middle - 1;
    }
  }
  if (begin && y < rows[begin - 1].$y1) {
    --begin;
  }
  return begin;
}, blockAndScrollTo:function(y, anim) {
  var me = this, scroller = me.getScrollable();
  if (scroller.getPosition().y !== y) {
    scroller.on({single:true, priority:-1000, scroll:function() {
      --me.blockingScroll;
    }});
    ++me.blockingScroll;
  }
  return scroller.scrollTo(null, y, anim);
}, changeHeaderFooter:function(item, recordIndex, def, enabled) {
  var me = this, property = def.name, decoration = item[property] || null, infinite = me.infinite, group, destroyed;
  enabled = enabled && def.config;
  group = enabled && def.map[recordIndex];
  if (group) {
    if (!decoration) {
      if (!(decoration = def.unused.pop())) {
        decoration = me[def.creator]();
      }
      decoration = me.reorderItem(decoration, item, def.offset);
    }
    decoration.$dataRow = item;
    decoration.setGroup(group);
  } else {
    if (decoration) {
      destroyed = me.removeGroupItem(decoration, def.unused, !enabled);
      if (!destroyed && infinite) {
        me.setItemHidden(decoration, true);
        me.reorderItem(decoration);
      }
      decoration = null;
    }
  }
  item[property] = decoration;
}, changeItem:function(itemIndex, recordIndex) {
  var me = this, options = me.callParent([itemIndex, recordIndex]), item = options.item;
  if (me.infinite && me.variableHeights) {
    item.$height = null;
  }
  return options;
}, changeItemGrouping:function(options) {
  var me = this, enabled = me.isGrouping(), groupingInfo = me.groupingInfo, item = options.item, recordIndex = options.recordIndex;
  me.changeHeaderFooter(item, recordIndex, groupingInfo.headers, enabled);
  me.changeHeaderFooter(item, recordIndex, groupingInfo.footers, enabled);
}, changeItemIsFirst:function(options) {
  if (options.isFirstChanged) {
    var me = this, items = me.scrollDockedItems, i, len;
    me.callParent([options]);
    if (items && !options.isFirst && me.infinite) {
      items = items.start.items;
      len = items.length;
      for (i = 0; i < len; ++i) {
        me.setItemHidden(items[i], true);
      }
    }
  }
}, changeItemIsLast:function(options) {
  if (options.isLastChanged) {
    var me = this, items = me.scrollDockedItems, i, len;
    me.callParent([options]);
    if (items && !options.isLast && me.infinite) {
      items = items.end.items;
      len = items.length;
      for (i = 0; i < len; ++i) {
        me.setItemHidden(items[i], true);
      }
    }
  }
}, changeItemRecord:function(options) {
  var me = this, itemClasses = options.itemClasses, tombstoneCls = me.tombstoneCls;
  if (options.record) {
    delete itemClasses[tombstoneCls];
    me.syncItemRecord(options);
  } else {
    itemClasses[tombstoneCls] = 1;
    me.syncItemRecord(options, me.tombstoneRec);
  }
}, changeItemStuck:function(options) {
  var me = this, item = options.item, record = options.record, stickyItem = record && me.stickyItemsByRecordId[record.internalId] || null;
  if (item.$sticky) {
    if (record !== item.getRecord()) {
      me.dislodgeItem(item, options, stickyItem);
    }
  } else {
    if (stickyItem) {
      me.dislodgeItem(item, options, stickyItem);
      me.removeDataItem(item);
    }
  }
}, clearItemCaches:function() {
  var info = this.groupingInfo, headers = info.headers.unused, footers = info.footers.unused;
  this.callParent();
  Ext.destroy(headers, footers);
  headers.length = footers.length = 0;
}, constrainStickyItem:function(item) {
  var me = this, pinnedFooter = me.pinnedFooter, pinnedHeader = me.pinnedHeader, pinned = false, renderInfo = me.renderInfo, recordIndex = item.$recordIndex, h = me.measureItem(item, me), options = item.$sticky, y = options.pos, y0 = me.getVisibleTop(), y1 = y0 + me.getVisibleHeight() - h, ret = y, hide;
  if (options.floated) {
    me.setItemHidden(item, false);
    return null;
  }
  if (pinnedHeader) {
    y0 += me.measureItem(pinnedHeader);
  }
  if (pinnedFooter) {
    y1 -= me.measureItem(pinnedFooter);
  }
  if (recordIndex < renderInfo.indexTop) {
    hide = true;
    y = y0;
    pinned = 'top';
  } else {
    if (recordIndex >= renderInfo.indexBottom) {
      hide = true;
      y = y1;
      pinned = 'bottom';
    } else {
      if (y < y0) {
        y = y0;
        pinned = 'top';
      } else {
        if (y > y1) {
          y = y1;
          pinned = 'bottom';
        }
      }
    }
  }
  if (options.autoPin) {
    ret = y;
    if (item.isDataViewPinnable) {
      item.setPinned(pinned);
    }
  } else {
    if (hide) {
      me.setItemHidden(item, true);
    }
  }
  return ret;
}, createGroupFooter:function() {
  var me = this, footer = me.getGroupFooter();
  if (typeof footer === 'string') {
    footer = {xtype:footer};
  }
  footer = Ext.apply({$dataItem:'footer'}, footer);
  footer.$initParent = footer.ownerCmp = footer.list = me;
  return footer;
}, createGroupHeader:function() {
  var me = this, header = me.getGroupHeader();
  if (typeof header === 'string') {
    header = {xtype:header};
  }
  header = Ext.apply({$dataItem:'header'}, header);
  header.$initParent = header.ownerCmp = header.list = me;
  return header;
}, createPinnedHeaderFooter:function(config) {
  return Ext.merge({translatable:{type:'csstransform'}, isPinnedItem:true, list:this}, config);
}, dislodgeItem:function(item, options, replacement) {
  var me = this, dataItems = me.dataItems, sticky = item.$sticky;
  if (!replacement) {
    replacement = me.acquireItem(me.indexOf(item));
    dataItems.pop();
  } else {
    if (replacement.$sticky && !replacement.$sticky.dislodged) {
      me.dislodgeItem(replacement, {itemIndex:dataItems.indexOf(replacement)});
    }
  }
  me.dataItems[options.itemIndex] = options.item = replacement;
  replacement.$footer = item.$footer;
  replacement.$header = item.$header;
  replacement.$position = null;
  item.$footer = item.$header = null;
  if (sticky) {
    sticky.dislodged = true;
  }
  sticky = replacement.$sticky;
  if (sticky) {
    sticky.dislodged = false;
  }
}, doClear:function() {
  var me = this, groupingInfo = me.groupingInfo, headers = groupingInfo.headers.unused, footers = groupingInfo.footers.unused, scroller;
  Ext.destroy(headers, footers);
  footers.length = headers.length = 0;
  if (me.infinite) {
    me.setItemCount(0);
    me.lastAdjustedPosition = null;
    me.setVisibleTop(0);
    scroller = me.getScrollable();
    scroller.scrollTo(null, 0);
    me.refreshScrollerSize();
    me.syncEmptyState();
  } else {
    me.callParent();
  }
}, doDisclose:function(me, record, item, index, e) {
  var onItemDisclosure = me.getOnItemDisclosure(), handler = onItemDisclosure, scope;
  if (handler && handler !== true) {
    if (handler.handler) {
      scope = handler.scope;
      handler = handler.handler;
    }
    Ext.callback(handler, scope, [record, item, index, e], 0, me);
  }
}, doRefresh:function(scrollToTop) {
  var me = this, scroller = me.getScrollable(), store = me.store, storeCount = store.getCount(), preventSync, count, restoreFocus;
  if (me.infinite) {
    count = ++me.refreshCounter;
    me.refreshGrouping();
    if (storeCount) {
      me.hideEmptyText();
      if (count > 1 && scroller && scrollToTop) {
        restoreFocus = me.saveFocusState();
        me.blockAndScrollTo(0, false);
        me.lastAdjustedPosition = null;
        me.refreshing = true;
        me.syncRowsToHeight(false);
        me.resetVisibleTop();
        me.setVisibleTop(0);
        preventSync = true;
        me.refreshing = false;
        restoreFocus();
      }
    } else {
      if (me.dataItems.length && !store.hasPendingLoad()) {
        me.doClear();
      }
    }
    if (!preventSync) {
      me.resync(true);
    }
  } else {
    me.refreshGroupIndices();
    me.callParent([scrollToTop]);
  }
}, ensureVisibleScroll:function(plan) {
  var me = this, recIndex = plan.recordIndex, item = plan.item || (plan.item = me.itemFromRecord(recIndex)), scroller = me.getScrollable(), promise, y;
  if (item) {
    return scroller.ensureVisible(item.el, {align:plan.align, animation:plan.animation, highlight:plan.highlight, x:false});
  }
  y = Math.floor(scroller.getSize().y * (recIndex / me.store.getCount()));
  plan.animation = false;
  me.nextTeleportTopIndex = recIndex;
  me.setVisibleTop(y);
  delete me.nextTeleportTopIndex;
  promise = me.blockAndScrollTo(y, false);
  plan.item = me.itemFromRecord(recIndex);
  return promise.then(function() {
    if (!me.destroyed) {
      plan.item = me.itemFromRecord(recIndex);
    }
    return plan;
  });
}, getScrollableClientRegion:function() {
  return this.callParent().adjust(this.getPinnedHeaderHeight() || 0, 0, -(this.getPinnedFooterHeight() || 0), 0);
}, getItemTop:function(item) {
  var y;
  item = item.$header || item;
  if (this.infinite) {
    y = item.$y0;
  } else {
    y = this.getScrollable().getEnsureVisibleXY(item.element, {align:{y:'start?'}}).y;
  }
  return y;
}, getPositionedItemTarget:function(item) {
  if (item && item.layer === 'inner') {
    return this.callParent([item]);
  }
  return this.bodyElement;
}, getRenderTarget:function() {
  return this.innerCt;
}, getScrollerTarget:function() {
  return this.outerCt;
}, getStoreChangeSyncIndex:function(index) {
  return this.isGrouping() ? Math.max(0, index - 1) : index;
}, itemFromRecord:function(rec) {
  var me = this, store = me.store, index, item;
  if (store) {
    if (me.infinite) {
      index = rec.isEntity ? store.indexOf(rec) : rec;
      item = me.dataItems[index - me.renderInfo.indexTop];
    } else {
      item = me.callParent([rec]);
    }
  }
  return item || null;
}, measureItem:function(item, heightCache) {
  var height = item.$height;
  if (height == null) {
    if (this.variableHeights || !heightCache || !(height = heightCache.rowHeight)) {
      height = item.el.measure('h') + item.el.getMargin('tb');
      if (heightCache) {
        heightCache.rowHeight = height;
      }
    }
    item.$height = height;
    if (item.$pinnedFooter) {
      this.setPinnedFooterHeight(height);
    } else {
      if (item.$pinnedHeader) {
        this.setPinnedHeaderHeight(height);
      }
    }
  }
  return height;
}, measureItems:function() {
  var me = this, scrollDock = me.scrollDockedItems, rows = me.dataItems, i = rows.length, decoration, h, item, items, row, rowHeight, hasItemVm = me.hasItemVm;
  if (me.variableHeights) {
    if (hasItemVm) {
      me.lookupViewModel().notify();
    }
    while (i-- > 0) {
      row = rows[i];
      if (row.$height == null) {
        row.$height = me.measureItem(row);
      }
      decoration = row.$header;
      if (decoration && decoration.$height == null) {
        decoration.$height = me.measureItem(decoration);
      }
      decoration = row.$footer;
      if (decoration) {
        decoration.$height = me.measureItem(decoration);
      }
    }
  } else {
    if (i && !me.measuredFirstRow) {
      if (hasItemVm) {
        me.lookupViewModel().notify();
      }
      me.measuredFirstRow = true;
      row = rows[0];
      row.$height = null;
      me.rowHeight = rowHeight = me.measureItem(row);
      while (i-- > 0) {
        rows[i].$height = rowHeight;
      }
    }
  }
  if (scrollDock) {
    for (h = 0, items = scrollDock.start.items, i = items.length; i-- > 0;) {
      item = items[i];
      if (!item.getHidden()) {
        h += item.$height || me.measureItem(item);
      }
    }
    scrollDock.start.height = h;
    for (h = 0, items = scrollDock.end.items, i = items.length; i-- > 0;) {
      item = items[i];
      if (!item.getHidden()) {
        h += item.$height || me.measureItem(item);
      }
    }
    scrollDock.end.height = h;
  }
}, onInnerCtResize:function(innerCt) {
  this.syncVerticalOverflow();
}, positionItems:function(position, bottomUp, count) {
  var me = this, renderInfo = me.renderInfo, rows = me.dataItems, len = rows.length, scrollDock = me.scrollDockedItems, i, item, items, y;
  if (bottomUp) {
    me.positionItemsBottomUp(position, count);
  } else {
    me.positionItemsTopDown(position, count);
  }
  if (len) {
    renderInfo.top = rows[0].$y0;
    renderInfo.bottom = rows[len - 1].$y1;
  } else {
    if (scrollDock) {
      renderInfo.top = renderInfo.bottom = scrollDock.start.height || 0;
    }
  }
  renderInfo.height = renderInfo.bottom - renderInfo.top;
  if (renderInfo.atEnd) {
    y = renderInfo.bottom;
    y += me.gapAfter;
    if (scrollDock) {
      items = scrollDock.end.items;
      len = items.length;
      for (i = 0; i < len; ++i) {
        item = items[i];
        if (!item.getHidden()) {
          y += me.setItemPosition(item, y);
        }
      }
    }
  }
  me.refreshScrollerSize();
}, positionItemsBottomUp:function(position, count) {
  var me = this, groupingInfo = me.groupingInfo, footers = groupingInfo.footers, headers = groupingInfo.headers, renderInfo = me.renderInfo, rows = me.dataItems, scrollDock = me.scrollDockedItems, y = position, indexTop = renderInfo.indexTop, decoration, ht, i, item, row, y1, stickyPos;
  for (i = count; i-- > 0;) {
    row = rows[i];
    y1 = y;
    decoration = row.$footer;
    if (decoration) {
      if ((ht = decoration.$height) == null) {
        ht = me.measureItem(decoration, footers);
      }
      y -= ht;
      me.setItemPosition(decoration, y);
    }
    y -= row.$height;
    if (row.$sticky) {
      row.$sticky.pos = y;
      stickyPos = me.constrainStickyItem(row);
      if (stickyPos !== null) {
        me.setItemPosition(row, stickyPos);
      }
    } else {
      me.setItemPosition(row, y);
    }
    decoration = row.$header;
    if (decoration) {
      if ((ht = decoration.$height) == null) {
        ht = me.measureItem(decoration, headers);
      }
      y -= ht;
      me.setItemPosition(decoration, y);
    }
    y -= me.gapMap[i + indexTop] || 0;
    row.$y0 = y;
    row.$y1 = y1;
  }
  if (renderInfo.atBegin && scrollDock) {
    scrollDock = scrollDock.start.items;
    for (i = scrollDock.length; i-- > 0;) {
      item = scrollDock[i];
      if (!item.getHidden()) {
        y -= item.$height;
        me.setItemPosition(item, y);
      }
    }
  }
  if (y < 0 || y > 0 && renderInfo.indexTop === 0) {
    me.adjustContentTop(-y);
  }
}, positionItemsTopDown:function(position, count) {
  var me = this, groupingInfo = me.groupingInfo, footers = groupingInfo.footers, headers = groupingInfo.headers, rows = me.dataItems, len = rows.length, scrollDock = me.scrollDockedItems, indexTop = me.renderInfo.indexTop, y = position, decoration, i, item, row, y0, stickyPos;
  count = count || len;
  if (me.renderInfo.atBegin && count === len) {
    if (scrollDock) {
      scrollDock = scrollDock.start.items;
      y = 0;
      for (i = 0; i < scrollDock.length; ++i) {
        item = scrollDock[i];
        if (!item.getHidden()) {
          y += me.setItemPosition(item, y);
        }
      }
    } else {
      if (y && !Object.keys(me.gapMap).length) {
        Ext.raise('Top-most item should be positioned at 0 not ' + y);
      }
    }
  }
  for (i = len - count; i < len; ++i) {
    row = rows[i];
    y0 = y;
    y += me.gapMap[indexTop + i] || 0;
    decoration = row.$header;
    if (decoration) {
      if (decoration.$height == null) {
        me.measureItem(decoration, headers);
      }
      y += me.setItemPosition(decoration, y);
    }
    if (row.$sticky) {
      row.$sticky.pos = y;
      stickyPos = me.constrainStickyItem(row);
      if (stickyPos !== null) {
        y += me.setItemPosition(row, stickyPos);
      }
    } else {
      y += me.setItemPosition(row, y);
    }
    decoration = row.$footer;
    if (decoration) {
      if (decoration.$height == null) {
        me.measureItem(decoration, footers);
      }
      y += me.setItemPosition(decoration, y);
    }
    row.$y0 = y0;
    row.$y1 = y;
  }
}, refreshGrouping:function() {
  var me = this, grouped = me.isGrouping(), infinite = me.infinite, item;
  me.toggleCls(me.groupedCls, grouped);
  if (infinite) {
    item = grouped && me.getPinFooters() ? me.getPinnedFooter() : me.pinnedFooter;
    if (item) {
      me.setItemHidden(item, true);
    }
    item = grouped && me.getPinHeaders() ? me.getPinnedHeader() : me.pinnedHeader;
    if (item) {
      me.setItemHidden(item, true);
    }
  }
  me.refreshGroupIndices();
  me.syncIndexBar();
}, refreshGroupIndices:function() {
  var me = this, store = me.store, groups = me.isGrouping() ? store.getGroups() : null, groupingInfo = me.groupingInfo, footers = groupingInfo.footers, headers = groupingInfo.headers, groupCount = groups && groups.length, firstRecordIndex, footerIndices, footerMap, group, headerIndices, headerMap, i, previous;
  me.groups = groups;
  if (groupCount) {
    headers.map = headerMap = {};
    headers.indices = headerIndices = [];
    footers.map = footerMap = {};
    footers.indices = footerIndices = [];
    for (i = 0; i < groupCount; ++i) {
      group = groups.getAt(i);
      firstRecordIndex = store.indexOf(group.first());
      headerIndices.push(firstRecordIndex);
      headerMap[firstRecordIndex] = group;
      if (previous) {
        footerIndices.push(firstRecordIndex - 1);
        footerMap[firstRecordIndex - 1] = previous;
      }
      previous = group;
    }
    i = store.getCount() - 1;
    footerIndices.push(i);
    footerMap[i] = group;
  } else {
    headers.map = headers.indices = footers.map = footers.indices = null;
  }
}, refreshScrollerSize:function() {
  var me = this, store = me.store, h, renderInfo, scrollDock, storeCount;
  if (store && me.infinite) {
    me.syncContentTop();
    renderInfo = me.renderInfo;
    scrollDock = me.scrollDockedItems;
    storeCount = store.getCount();
    h = renderInfo.bottom + (storeCount - renderInfo.indexBottom) * me.rowHeight;
    scrollDock = scrollDock && scrollDock.end;
    if (scrollDock) {
      h += scrollDock.height;
    }
    me.getScrollable().setSize({x:null, y:h});
    me.setVerticalOverflow(h > me.getVisibleHeight());
  }
}, reorderItem:function(item, ref, offset) {
  offset = offset || 0;
  var me = this, innerItems = me.innerItems, innerCount = innerItems.length, innerIndex = ref == null ? innerCount : ref.isWidget ? innerItems.indexOf(ref) + offset : ref, items = me.items, index = innerIndex < innerCount ? items.indexOf(innerItems[innerIndex]) : items.length;
  if (!item.isWidget || !me.infinite || me.maintainChildNodes || item.parent !== me) {
    item = me.insert(index, item);
  } else {
    items.insert(index, item);
    index = innerItems.indexOf(item);
    if (index > -1) {
      innerItems.splice(index, 1);
      if (index < innerIndex) {
        --innerIndex;
      }
    }
    if (innerIndex < innerCount) {
      innerItems.splice(innerIndex, 0, item);
    } else {
      innerItems.push(item);
    }
  }
  return item;
}, getRecordIndexFromPoint:function(x, y) {
  if (this.infinite) {
    return this.recordIndexByPosition(Math.max(0, Math.min(y, this.getScrollable().getSize().y)));
  } else {
    return this.callParent([x, y]);
  }
}, getItemFromPoint:function(x, y) {
  if (this.infinite) {
    return this.dataItems[this.recordIndexByPosition(Math.max(0, Math.min(y, this.getScrollable().getSize().y))) - this.renderInfo.indexTop];
  } else {
    return this.callParent([x, y]);
  }
}, recordIndexByPosition:function(y) {
  var me = this, renderInfo = me.renderInfo, renderTop = renderInfo.top, renderBottom = renderInfo.bottom, indexTop = renderInfo.indexTop, ret;
  if (y < renderTop) {
    ret = Math.floor(y / renderTop * indexTop);
  } else {
    if (y < renderBottom) {
      ret = indexTop + me.bisectPosition(y);
    } else {
      y -= renderBottom;
      ret = Math.min(renderInfo.indexBottom + Math.floor(y / me.rowHeight), me.store.getCount() - 1);
    }
  }
  return ret;
}, removeDataItem:function(item, preventCache) {
  var me = this, header = item.$header, footer = item.$footer, groupingInfo = me.groupingInfo;
  if (header) {
    me.removeGroupItem(header, groupingInfo.headers.unused, preventCache);
  }
  if (footer) {
    me.removeGroupItem(footer, groupingInfo.footers.unused, preventCache);
  }
  item.$header = item.$footer = null;
  return me.callParent([item, preventCache]);
}, removeGroupItem:function(item, cache, preventCache) {
  var destroyed = this.removeCachedItem(item, preventCache, cache, this.getMaxItemCache(), this.infinite);
  if (!destroyed) {
    item.$dataRow = null;
    item.setGroup(null);
  }
  return destroyed;
}, resync:function(force) {
  var me = this, height = me.outerCt.measure('h');
  me.resyncListener = null;
  if (height) {
    if (height === me.getVisibleHeight()) {
      me.syncRowsToHeight(force);
    } else {
      me.setVisibleHeight(height);
    }
  }
}, resyncOnPaint:function() {
  this.whenVisible('resync', [true]);
}, rollDown:function(count) {
  var me = this, dataItems = me.dataItems, renderInfo = me.renderInfo, indexBottom = renderInfo.indexBottom, tailItem = dataItems[dataItems.length - 1], innerTailIndex = me.innerItems.indexOf(tailItem) + 1, adjust, decoration, i, row;
  if (tailItem.$footer) {
    ++innerTailIndex;
  }
  me.setTopRenderedIndex(renderInfo.indexTop + count);
  for (i = 0; i < count; i++) {
    row = dataItems.shift();
    dataItems.push(row);
    adjust = (row.$header ? 1 : 0) + (row.$footer ? 1 : 0);
    me.changeItem(-1, indexBottom + i);
    adjust -= (row.$header ? 1 : 0) + (row.$footer ? 1 : 0);
    innerTailIndex -= adjust;
    decoration = row.$header;
    if (decoration) {
      me.reorderItem(decoration, innerTailIndex);
    }
    me.reorderItem(row, innerTailIndex);
    decoration = row.$footer;
    if (decoration) {
      me.reorderItem(decoration, innerTailIndex);
    }
  }
  me.measureItems();
  me.positionItems(renderInfo.bottom, false, count);
}, rollUp:function(count) {
  var me = this, dataItems = me.dataItems, innerItems = me.innerItems, renderInfo = me.renderInfo, indexTop = renderInfo.indexTop, headItem = dataItems[0], innerHeadIndex = innerItems.indexOf(headItem), decoration, i, row;
  if (headItem.$header) {
    --innerHeadIndex;
  }
  me.setTopRenderedIndex(indexTop - count);
  --indexTop;
  for (i = 0; i < count; i++) {
    row = dataItems.pop();
    dataItems.unshift(row);
    me.changeItem(0, indexTop - i);
    decoration = row.$footer;
    if (decoration) {
      me.reorderItem(decoration, innerHeadIndex);
    }
    me.reorderItem(row, innerHeadIndex);
    decoration = row.$header;
    if (decoration) {
      me.reorderItem(decoration, innerHeadIndex);
    }
  }
  me.measureItems();
  me.positionItems(renderInfo.top, true, count);
}, setGaps:function(gaps) {
  var me = this;
  gaps = gaps || {};
  if (!Ext.Object.equals(me.gapMap, gaps)) {
    me.gapMap = gaps;
    me.gapAfter = me.gapMap[me.store.getCount()] || 0;
    me.syncRowsToHeight(true);
  }
}, setItemHiddenInfinite:function(item, hide) {
  if (!hide) {
    item.$hidden = false;
  } else {
    if (!item.$hidden) {
      item.$hidden = true;
      item.$position = null;
      item.translate(0, -10000);
    }
  }
}, setItemPosition:function(item, y) {
  if (item.$hidden) {
    this.setItemHidden(item, false);
  }
  if (item.$position !== y) {
    item.$position = y;
    item.translate(null, y);
  }
  return item.$height;
}, setupFooterPinning:function() {
  var me = this;
  return me.setupGroupPinning(me.getPinFooters(), me.pinnedFooter, me.hasPinnedFooterCls, 'setPinnedFooterHeight');
}, setupGroupPinning:function(pin, item, cls, setter) {
  var isPinning = pin && !!item;
  if (!isPinning) {
    this[setter](0);
  }
  this.el.toggleCls(cls, isPinning);
  return isPinning;
}, setupHeaderPinning:function() {
  var me = this;
  return me.setupGroupPinning(me.getPinHeaders(), me.pinnedHeader, me.hasPinnedHeaderCls, 'setPinnedHeaderHeight');
}, shouldHideDisclosure:function(record) {
  var name, show;
  if (this.getOnItemDisclosure()) {
    name = this.getDisclosureProperty();
    show = !name || record.data[name] !== false;
  }
  return !show;
}, stickItem:function(item, options) {
  var me = this, opt = item.$sticky, record = item.getRecord(), stickyCls = me.stickyCls, stickyItems = me.stickyItems, stickyItemsByRecordId = me.stickyItemsByRecordId, stickyPos;
  if (!me.infinite) {
    Ext.raise('Only infinite lists support sticky items');
  }
  if (options) {
    if (!opt) {
      stickyItems.push(item);
      stickyItemsByRecordId[record.internalId] = item;
      item.addCls(stickyCls);
      item.$sticky = opt = {pos:item.$position};
    }
    Ext.apply(opt, options);
    stickyPos = me.constrainStickyItem(item);
    if (stickyPos !== null) {
      me.setItemPosition(item, stickyPos);
    }
  } else {
    if (opt) {
      Ext.Array.remove(stickyItems, item);
      delete stickyItemsByRecordId[record.internalId];
      item.removeCls(stickyCls);
      item.$sticky = null;
      if (opt.autoPin && item.isDataViewPinnable) {
        item.setPinned(false);
      }
      if (opt.floated) {
        delete item.$position;
      }
      if (opt.dislodged) {
        me.removeDataItem(item);
      } else {
        me.setItemPosition(item, opt.pos);
      }
    }
  }
}, syncContentTop:function() {
  var me = this, renderInfo = me.renderInfo, visibleTop = me.getVisibleTop(), visibleHeight = me.getVisibleHeight(), bufferZone = me.getMinimumBufferDistance() * me.rowHeight, adjust;
  if (renderInfo.atEnd) {
    return;
  }
  adjust = visibleTop + visibleHeight - (renderInfo.bottom - bufferZone);
  if (adjust < 0) {
    return;
  }
  me.getScrollable().scrollBy(null, -adjust, false);
}, syncIndexBar:function() {
  var me = this, indexBar = me.getIndexBar(), store = me.store;
  if (indexBar) {
    indexBar.setHidden(me.getEmptyState() || !store || !store.getGrouper());
  }
}, syncPinnedFooter:function(visibleTop) {
  var me = this, dataItems = me.dataItems, len = dataItems.length, pinnedFooter = me.pinnedFooter, renderInfo = me.renderInfo, grouping = me.pinFooters && pinnedFooter && len && me.isGrouping(), hide = pinnedFooter, indexTop = renderInfo.indexTop, scrollDock = me.scrollDockedItems, bottom, footerIndices, footers, height, index, totalHeight, visibleBottomIndex, y, gap;
  visibleTop = visibleTop || me.getVisibleTop();
  if (grouping) {
    totalHeight = me.getScrollable().getSize().y;
    bottom = visibleTop + me.getVisibleHeight();
    hide = bottom <= me.renderInfo.top || bottom >= totalHeight - (scrollDock ? scrollDock.end.height : 0) - me.gapAfter;
    if (!hide) {
      visibleBottomIndex = me.bisectPosition(bottom - 1) + indexTop;
      footers = me.groupingInfo.footers;
      footerIndices = footers.indices;
      index = Ext.Number.binarySearch(footerIndices, visibleBottomIndex);
      pinnedFooter.setGroup(footers.map[footerIndices[index]]);
      if (visibleBottomIndex === footerIndices[index] && dataItems[visibleBottomIndex - indexTop].$y1 === bottom) {
        hide = true;
      } else {
        if (index) {
          index = footerIndices[index - 1];
          if (index < indexTop) {
            y = 0;
          } else {
            y = dataItems[index - indexTop].$y1;
            gap = me.gapMap[index + 1] || 0;
            if (gap) {
              if (!(hide = bottom - y < gap)) {
                y += gap;
              }
            }
          }
        } else {
          y = scrollDock ? scrollDock.start.height : 0;
        }
      }
      if (!hide) {
        height = me.measureItem(pinnedFooter);
        y = bottom - y;
        y = y < height ? height - y : 0;
        me.setItemPosition(pinnedFooter, y);
      }
    }
  }
  if (hide) {
    me.setItemHidden(pinnedFooter, true);
  } else {
    if (pinnedFooter) {
      me.syncPinnedHorz(pinnedFooter);
    }
  }
}, syncPinnedHeader:function(visibleTop) {
  var me = this, dataItems = me.dataItems, len = dataItems.length, pinnedHeader = me.pinnedHeader, renderInfo = me.renderInfo, grouping = me.pinHeaders && pinnedHeader && len && me.isGrouping(), hide = pinnedHeader, indexTop = renderInfo.indexTop, scrollDock = me.scrollDockedItems, headerIndices, headers, height, index, visibleTopIndex, y, headerIndex, gap, item;
  visibleTop = visibleTop || me.getVisibleTop();
  if (grouping) {
    hide = scrollDock && visibleTop <= scrollDock.start.height || (visibleTopIndex = me.bisectPosition(visibleTop)) < 0 || visibleTopIndex >= len;
    if (!hide) {
      visibleTopIndex += indexTop;
      headers = me.groupingInfo.headers;
      headerIndices = headers.indices;
      index = Ext.Number.binarySearch(headerIndices, visibleTopIndex);
      if (headerIndices[index] !== visibleTopIndex) {
        --index;
      }
      headerIndex = headerIndices[index];
      pinnedHeader.setGroup(headers.map[headerIndex]);
      if (headerIndex > indexTop) {
        item = dataItems[headerIndex - indexTop];
        gap = me.gapMap[headerIndex] || 0;
        if (gap) {
          hide = visibleTop - item.$y0 < gap;
        }
      }
      if (!hide) {
        ++index;
        if (index < headerIndices.length) {
          index = headerIndices[index] - indexTop;
          y = index < len ? dataItems[index].$y0 - visibleTop : 0;
        } else {
          y = renderInfo.bottom - visibleTop;
          hide = y <= 0;
        }
        if (!hide) {
          height = me.measureItem(pinnedHeader);
          y = y && y < height ? y - height : 0;
          me.setItemPosition(pinnedHeader, y || 0);
        }
      }
    }
  }
  if (hide) {
    me.setItemHidden(pinnedHeader, true);
  } else {
    if (pinnedHeader) {
      me.syncPinnedHorz(pinnedHeader);
    }
  }
}, syncPinnedHorz:function(item) {
  var me = this, scroller = item.getScrollable();
  if (!scroller) {
    item.setScrollable({x:false, y:false});
    scroller = item.getScrollable();
  }
  if (item.isItemHeader) {
    item.setContentWidth(me.getInnerWidth());
  }
  scroller.scrollTo(me.getVisibleLeft(), null);
}, syncRows:function(bottomUp) {
  var me = this, renderInfo = me.renderInfo, scrollDock = me.scrollDockedItems, maxHeight = me.getMaxHeight(), i, position, indexTop, len, innerCt, contentHeight, height;
  if (!me.infinite) {
    me.syncItemRange();
    return;
  }
  len = me.dataItems.length;
  indexTop = renderInfo.indexTop;
  if (len) {
    if (bottomUp) {
      position = renderInfo.bottom;
    } else {
      position = renderInfo.top;
      if (!indexTop && scrollDock) {
        position = scrollDock.start.height;
      }
    }
    for (i = 0; i < len; ++i) {
      me.changeItem(i, indexTop + i);
    }
  }
  me.measureItems();
  me.positionItems(position, bottomUp, len);
  if (me.pinnedHeader) {
    me.syncPinnedHeader();
  }
  if (me.pinnedFooter) {
    me.syncPinnedFooter();
  }
  if (me.stickyItems.length) {
    me.syncStickyItems();
  }
  if (maxHeight) {
    innerCt = me.innerCt;
    contentHeight = renderInfo.bottom + me.gapAfter;
    if (scrollDock) {
      contentHeight += scrollDock.end.height;
    }
    height = innerCt.measure('h');
    height = me.el.measure('h') - height + me.el.getBorderWidth('tb');
    height = Math.min(maxHeight - height, contentHeight);
    me.setInnerCtHeight(height);
  }
}, syncRowsToHeight:function(force) {
  var me = this, bufferZone = me.getBufferSize(), infinite = me.infinite, rowCountWas = me.getItemCount(), rowHeight = me.rowHeight, firstTime = !rowHeight, renderInfo = me.renderInfo, oldIndexBottom = renderInfo && renderInfo.indexBottom, storeCount = me.store.getCount(), visibleHeight = me.getMaxHeight() || me.getVisibleHeight(), indexTop, row, rowCount;
  if (firstTime) {
    if (!rowCountWas) {
      me.setItemCount(1);
    }
    row = me.dataItems[0];
    row.$height = null;
    me.rowHeight = rowHeight = me.measureItem(row);
    if (!rowCountWas && me.discardMeasureRow) {
      row.destroy();
      me.dataItems.length = 0;
      me.setItemCount(0);
    }
  }
  if (infinite) {
    rowCount = Math.ceil(visibleHeight / rowHeight) + bufferZone;
    rowCount = Math.min(rowCount, storeCount);
  } else {
    rowCount = storeCount;
  }
  me.setItemCount(rowCount);
  if (firstTime && me.store.isVirtualStore || rowCountWas !== rowCount || storeCount < oldIndexBottom) {
    if (infinite) {
      indexTop = Math.min(storeCount - rowCount, renderInfo.indexTop);
      indexTop = Math.max(0, indexTop);
      if (indexTop === me.getTopRenderedIndex()) {
        me.updateTopRenderedIndex(indexTop);
      } else {
        me.setTopRenderedIndex(indexTop);
      }
    }
    if (firstTime) {
      me.refreshGrouping();
    }
    force = force !== false;
    if (force && storeCount < oldIndexBottom) {
      renderInfo.top = renderInfo.indexTop * me.rowHeight;
    }
  }
  if (force) {
    me.syncRows();
  }
}, syncStickyItems:function() {
  var me = this, stickyItems = me.stickyItems, n = stickyItems.length, i, stickyItem, stickyPos;
  for (i = 0; i < n; ++i) {
    stickyPos = me.constrainStickyItem(stickyItem = stickyItems[i]);
    if (stickyPos !== null) {
      me.setItemPosition(stickyItem, stickyPos);
    }
  }
}, doSyncVerticalOverflow:function() {
  var scroller = this.getScrollable();
  this.setVerticalOverflow(scroller.getSize().y > scroller.getClientSize().y);
}, resetVisibleTop:function() {
  this.lastAdjustedPosition = this._visibleTop = null;
}, teleport:function(y) {
  var me = this, scrollSize = me.getScrollable().getSize(), renderInfo = me.renderInfo, rowCount = me.dataItems.length, storeCount = me.store.getCount(), indexMax = storeCount - rowCount, backOff = me.getBufferSize(), scrollDock = me.scrollDockedItems, nextTeleportTopIndex = me.nextTeleportTopIndex, bottomUp, indexTop;
  if (nextTeleportTopIndex !== undefined) {
    indexTop = nextTeleportTopIndex;
  } else {
    indexTop = Math.floor(y / scrollSize.y * storeCount);
  }
  if (indexTop < indexMax) {
    backOff = Math.min(indexTop, backOff >>> 1);
    indexTop -= backOff;
    if (indexTop) {
      renderInfo.top = Math.max(0, y - me.rowHeight * backOff);
    } else {
      renderInfo.top = scrollDock ? scrollDock.start.height : 0;
    }
  } else {
    bottomUp = true;
    indexTop = indexMax;
    renderInfo.bottom = scrollSize.y - me.gapAfter;
    if (scrollDock) {
      renderInfo.bottom -= scrollDock.end.height;
    }
  }
  me.setTopRenderedIndex(indexTop);
  me.syncRows(bottomUp);
}, traverseItem:function(item, delta) {
  var me = this, dataItems = me.dataItems, renderInfo = me.renderInfo, next;
  if (item && me.infinite) {
    if (delta < 0) {
      if (item === dataItems[0] && !item.isFirst) {
        next = renderInfo.indexTop;
      }
    } else {
      if (item === dataItems[dataItems.length - 1] && !item.isLast) {
        next = renderInfo.indexBottom + 1;
      }
    }
  }
  return next ? next - 1 : this.callParent([item, delta]);
}, updateEmptyState:function(empty, was) {
  this.callParent([empty, was]);
  this.syncIndexBar();
}, updateHorizontalOverflow:function(overflow) {
  var scroller = this.getScrollable();
  scroller.setX(overflow);
  if (!overflow) {
    scroller.scrollTo(0, null);
  }
}, updateInnerCtHeight:function(height) {
  this.innerCt.setHeight(height);
}, updateInnerWidth:function(innerWidth) {
  var me = this, innerCt = me.innerCt, pinnedHeader = me.pinnedHeader, pinnedFooter = me.pinnedFooter, width;
  if (innerWidth == null) {
    innerCt.setStyle('width', '');
    me.setHorizontalOverflow(false);
  } else {
    innerCt.setStyle('width', innerWidth + 'px');
    width = me.getVisibleWidth();
    if (width != null) {
      me.setHorizontalOverflow(width < innerWidth);
    }
  }
  if (pinnedHeader) {
    me.syncPinnedHorz(pinnedHeader);
  }
  if (pinnedFooter) {
    me.syncPinnedHorz(pinnedFooter);
  }
}, updatePinnedFooterHeight:function(height) {
  var me = this;
  if (!me.destroyed && !me.destroying) {
    me.fireEvent('pinnedfooterheightchange', me, height);
  }
}, updatePinnedHeaderHeight:function(height) {
  var me = this;
  if (!me.destroyed && !me.destroying) {
    me.fireEvent('pinnedheaderheightchange', me, height);
  }
}, updateTopRenderedIndex:function(top) {
  var me = this, store = me.store, renderInfo = me.renderInfo, bottom = top + me.dataItems.length;
  renderInfo.atBegin = !top;
  renderInfo.atEnd = bottom === me.store.getCount();
  renderInfo.indexTop = top;
  renderInfo.indexBottom = bottom;
  if (top === bottom && store.isVirtualStore) {
    bottom = top + store.getPageSize();
  }
  me.dataRange['goto'](top, bottom);
}, updateVerticalOverflow:function(overflow) {
  var me = this, items = me.items.items, n = items.length, i, item, width;
  if (me.infinite) {
    width = overflow ? Ext.getScrollbarSize().reservedWidth : null;
    for (i = 0; i < n; ++i) {
      item = items[i];
      if (item.isPinnedItem) {
        item.el.setStyle('width', width);
      }
    }
    me.syncPinnedHeader();
    me.syncPinnedFooter();
  }
  me.fireEvent('verticaloverflowchange', me, overflow);
}, updateVisibleHeight:function() {
  var me = this;
  if (me.infinite) {
    if (me.store) {
      me.syncRowsToHeight();
    }
  } else {
    me.syncVerticalOverflow();
  }
}, updateVisibleLeft:function() {
  var me = this;
  if (me.infinite && !me.suspendSync) {
    me.syncPinnedHeader();
    me.syncPinnedFooter();
    if (me.stickyItems.length) {
      me.syncStickyItems();
    }
  }
}, updateVisibleTop:function(y) {
  var me = this, oldY = me.lastAdjustedPosition;
  if (me.infinite) {
    if (me.dataItems.length && (oldY == null || Math.abs(y - oldY) > me.rowHeight)) {
      me.lastAdjustedPosition = y;
      me.adjustRenderedRows(y, oldY);
    }
    me.syncPinnedHeader(y);
    me.syncPinnedFooter(y);
    if (me.stickyItems.length) {
      me.syncStickyItems();
    }
  }
}, updateVisibleWidth:function(width) {
  var me = this, innerWidth = me.getInnerWidth();
  if (innerWidth != null) {
    me.setHorizontalOverflow(width < innerWidth);
  }
}}}, function(List) {
  var proto = List.prototype, handlers = proto._itemChangeHandlers = proto._itemChangeHandlers.slice();
  handlers.unshift('changeItemStuck');
  handlers.push('changeItemGrouping');
});
Ext.define('Ext.theme.material.dataview.List', {override:'Ext.dataview.List', config:{rowLines:false}});
Ext.define('Ext.dataview.BoundListLocation', {extend:Ext.dataview.Location, next:function(options) {
  var me = this, candidate = me.nextItem(options), item = candidate && candidate.get();
  while (candidate && (!item || !candidate.record)) {
    if (candidate.equals(me)) {
      return;
    }
    candidate = candidate.nextItem(options);
    item = candidate && candidate.get();
  }
  return candidate;
}, previous:function(options) {
  var me = this, candidate = me.previousItem(options), item = candidate && candidate.get();
  while (candidate && (!item || !candidate.record)) {
    if (candidate.equals(me)) {
      return;
    }
    candidate = candidate.previousItem(options);
    item = candidate && candidate.get();
  }
  return candidate;
}});
Ext.define('Ext.dataview.BoundListNavigationModel', {extend:Ext.dataview.NavigationModel, alias:'navmodel.boundlist', config:{navigateOnSpace:true}, locationClass:'Ext.dataview.BoundListLocation', privates:{getKeyNavCfg:function(view) {
  if (this.keyboard !== false) {
    var eventEl = (view.ownerField || view).getFocusEl();
    if (eventEl) {
      var me = this;
      return {target:eventEl, eventName:'keydown', defaultEventAction:'stopEvent', esc:me.onKeyEsc, up:me.onKeyUp, down:me.onKeyDown, right:me.onKeyRight, left:me.onKeyLeft, pageDown:me.onKeyPageDown, pageUp:me.onKeyPageUp, home:me.onKeyHome, end:me.onKeyEnd, tab:me.onKeyTab, space:me.onKeySpace, enter:me.onKeyEnter, A:{ctrl:true, handler:me.onSelectAllKeyPress}, priority:1001, scope:me};
    }
  }
}, getViewListeners:function(view) {
  var result = this.callParent([view]);
  result.childtouchstart = 'onChildTouchStart';
  result.childTap = 'onChildTap';
  return result;
}, doFocus:Ext.privateFn, handleLocationChange:function(location, options) {
  var target = location.sourceElement, ownerField = this.getView().ownerField;
  if (target && ownerField) {
    ownerField.inputElement.dom.setAttribute('aria-activedescendant', target.id);
  }
  this.callParent([location, options]);
}, onChildTouchStart:function(view, location) {
  var e = location.event;
  if (e.pointerType !== 'touch') {
    e.preventDefault();
  }
}, onChildTap:function(view, location) {
  var e = location.event, newLocation;
  if (!view.destroyed) {
    if (e.pointerType === 'touch') {
      e.preventDefault();
    }
    newLocation = this.createLocation(location.item);
    if (this.location && this.location.equals(newLocation)) {
      this.onNavigate(e);
    } else {
      this.setLocation(newLocation, {event:location.event, animation:true});
    }
  }
  if (e.pointerType === 'touch') {
    e.stopEvent();
  }
}, onChildTrigger:Ext.privateFn, onKeyLeft:function() {
  return true;
}, onKeyRight:function() {
  return true;
}, onKeySpace:function(e) {
  if (this.getNavigateOnSpace()) {
    e.preventDefault();
    this.onNavigate(e);
  }
  return true;
}, onKeyEsc:function() {
  var view = this.getView(), field = view.ownerField;
  if (field && view.isVisible()) {
    field.collapse();
  } else {
    return true;
  }
}, onKeyTab:function(e) {
  var view = this.getView(), field = view.ownerField;
  if (view.isVisible()) {
    if (field.getSelectOnTab()) {
      this.selectHighlighted(e);
    }
    if (field.collapse) {
      field.collapse();
    }
  }
  return true;
}, onKeyEnter:function(e) {
  var view = this.getView(), selectable = view.getSelectable(), field = view.ownerField;
  e.stopEvent();
  if (selectable.isSelected(this.location.record) && field.collapse) {
    field.collapse();
  } else {
    this.selectHighlighted(e);
  }
  e.fromBoundList = true;
  field.fireEvent('specialkey', field, e);
  return false;
}, onNavigate:function(event) {
  var doNavigate = event && (event.pointerType || this.getNavigateOnSpace() && event.keyCode === event.SPACE), view = this.getView(), field = view.getRefOwner();
  if (doNavigate) {
    this.callParent([event]);
    if (field && field.maybeCollapse) {
      field.maybeCollapse(event);
    }
  }
}, selectHighlighted:function(e) {
  var me = this, view = me.getView(), store = view.getStore(), selectable = view.getSelectable(), location = me.location, highlightedRec, index;
  if (view.getViewItems().length) {
    highlightedRec = location.record;
    if (highlightedRec) {
      if (e.getKey() === e.ENTER || !selectable.isSelected(highlightedRec)) {
        selectable.selectWithEvent(highlightedRec, e);
        if (!view.getStore().contains(highlightedRec)) {
          index = Math.min(location.recordIndex, store.getCount() - 1);
          me.setLocation(store.getAt(index));
        }
      }
    }
  }
}}});
Ext.define('Ext.dataview.BoundList', {extend:Ext.dataview.List, xtype:'boundlist', tabIndex:null, focusEl:null, itemsFocusable:false, navigationModel:{type:'boundlist'}, itemConfig:{cls:Ext.baseCSSPrefix + 'boundlistitem', tools:{selected:{zone:'start', passive:true, cls:Ext.baseCSSPrefix + 'selected-icon', iconCls:Ext.baseCSSPrefix + 'fa fa-check'}}}, onFocusEnter:Ext.emptyFn, onFocusLeave:Ext.emptyFn, privates:{beforeSelectionRefresh:function(toDeselect, toReselect) {
  var len = toDeselect.length, i, rec;
  for (i = 0; i < len;) {
    rec = toDeselect[i];
    if (rec.isEntered) {
      toDeselect.splice(i, 1);
      len--;
    } else {
      i++;
    }
  }
}}});
Ext.define('Ext.dataview.DataView', {extend:Ext.dataview.Abstract, alternateClassName:'Ext.DataView', xtype:'dataview', isElementDataView:true, constructor:function(config) {
  if (config && config.useComponents) {
    if (this.self !== Ext.dataview.DataView) {
      Ext.raise('The useComponents config has been replaced by Ext.dataview.Component');
    }
    Ext.log.warn('The useComponents config has been replaced by Ext.dataview.Component');
    return new Ext.dataview['Component'](config);
  }
  if (this.useComponents) {
    Ext.raise('The useComponents config has been replaced by Ext.dataview.Component');
  }
  this.callParent([config]);
}, getViewItems:function() {
  return Array.prototype.slice.call(this.getFastItems());
}, onStoreAdd:function(store, records, index) {
  this.callParent(arguments);
  this.renderItems(index, index + records.length);
}, onStoreRemove:function(store, records, index) {
  this.removeItems(index, index + records.length);
}, privates:{dirtyCls:Ext.baseCSSPrefix + 'dirty', changeItem:function(recordIndex) {
  var me = this, dataItems = me.dataItems, item = dataItems[recordIndex], record = me.dataRange.records[recordIndex], storeCount = me.store.getCount(), options = {isFirst:!recordIndex, isLast:recordIndex === storeCount - 1, item:item, record:record, recordIndex:recordIndex};
  me.syncItemRecord(options);
}, clearItems:function() {
  var elements = this.dataItems, dom;
  while (elements.length) {
    dom = elements.pop();
    Ext.fly(dom).destroy();
  }
}, createDataItem:function(index, record) {
  var me = this, store = me.store, data = me.gatherData(record, index), markDirty = me.getMarkDirty(), dom, itemEl;
  itemEl = Ext.Element.create(me.getItemElementConfig(index, data, store));
  dom = itemEl.dom;
  if (markDirty) {
    itemEl.addCls(me.markDirtyCls);
  }
  dom.setAttribute('data-viewid', me.id);
  dom.setAttribute('data-recordid', record.internalId);
  dom.setAttribute('data-recordindex', index);
  return itemEl;
}, doClear:function() {
  this.clearItems();
  this.callParent();
}, resetSelection:function(records) {
  this.setItemSelection(records, false);
}, doRefresh:function(scrollToTop) {
  var me = this, records = me.dataRange.records, storeCount = records.length, itemCount = me.dataItems.length, scroller = me.getScrollable(), restoreFocus, i;
  if (scroller && scrollToTop) {
    scroller.scrollTo(0, 0);
  }
  ++me.refreshCounter;
  if (!storeCount) {
    me.doClear();
  } else {
    restoreFocus = me.saveFocusState();
    me.hideEmptyText();
    me.resetSelection(records);
    if (itemCount > storeCount) {
      me.removeItems(storeCount, itemCount);
      itemCount = storeCount;
    } else {
      if (itemCount < storeCount) {
        me.renderItems(itemCount, storeCount);
      }
    }
    for (i = 0; i < itemCount; ++i) {
      me.changeItem(i);
    }
    if (me.hasSelection()) {
      me.setItemSelection(me.getSelections(), true);
    }
    restoreFocus();
  }
}, getFastItems:function() {
  return this.getRenderTarget().dom.childNodes;
}, getItemElementConfig:function(index, data, store) {
  var me = this, result = {cls:me.baseCls + '-item ' + (me.getItemCls() || ''), html:me.renderItemTpl(index, data, store)};
  if (me.getItemsFocusable()) {
    result.tabIndex = -1;
  }
  return result;
}, removeItems:function(from, to) {
  var me = this, items = me.dataItems.splice(from, to - from), i;
  for (i = 0; i < items.length; ++i) {
    Ext.fly(items[i]).destroy();
  }
}, renderItems:function(from, to) {
  var me = this, dataItems = me.dataItems, records = me.dataRange.records, parentNode = me.getRenderTarget().dom, args = [from, 0], before = me.dataItems[from] || null, dom, i;
  if (records.length) {
    me.hideEmptyText();
  }
  if (!before) {
    before = me.findTailItem(true);
    before = before && before.el.dom;
  }
  for (i = from; i < to; ++i) {
    args.push(dom = me.createDataItem(i, records[i]).dom);
    parentNode.insertBefore(dom, before);
  }
  dataItems.splice.apply(dataItems, args);
}, renderItemTpl:function(index, data, store) {
  var itemTpl = this.getItemTpl(), parent = store.getData().items, value;
  data.xcount = typeof data.xcount === 'number' ? data.xcount : store.getCount();
  data.xindex = typeof data.xindex === 'number' ? data.xindex : index;
  value = itemTpl.apply(data, parent, index + 1, parent.length);
  value = value == null ? '' : String(value);
  return value || this.getEmptyItemText();
}, syncItemRecord:function(options) {
  var me = this, item = options.item, record = options.record, store = me.store, recordIndex = options ? options.recordIndex : store.indexOf(record), data = me.gatherData(record, recordIndex), dirtyCls = me.$dirty;
  item.innerHTML = me.renderItemTpl(recordIndex, data, store);
  item.setAttribute('data-recordid', record.internalId);
  item.setAttribute('data-recordindex', recordIndex);
  Ext.fly(item).toggleCls(me.dirtyCls, record.dirty);
}, traverseItem:function(item, delta) {
  var me = this, items = me.getRenderTarget().dom.childNodes, next = null, dom, i;
  if (item) {
    if (item.isElement) {
      dom = item.dom;
    } else {
      if (item.isWidget) {
        dom = item.el.dom;
      }
    }
    i = Array.prototype.indexOf.call(items, dom);
    if (i > -1) {
      next = items[i + delta] || null;
      if (next) {
        next = Ext.getCmp(next.id) || next;
      }
    }
  }
  return next;
}}});
Ext.define('Ext.dataview.IndexBar', {extend:Ext.Component, alternateClassName:'Ext.IndexBar', xtype:'indexbar', cachedConfig:{letters:'ABCDEFGHIJKLMNOPQRSTUVWXYZ'}, config:{animation:true, autoHide:false, dynamic:false, listPrefix:null, indicator:true}, eventedConfig:{direction:'vertical'}, top:0, bottom:0, left:0, right:0, inheritUi:true, autoHideCls:Ext.baseCSSPrefix + 'autohide', classCls:Ext.baseCSSPrefix + 'indexbar', horizontalCls:Ext.baseCSSPrefix + 'horizontal', indexedCls:Ext.baseCSSPrefix + 
'indexed', indexedHorizontalCls:Ext.baseCSSPrefix + 'indexed-horizontal', indexedVerticalCls:Ext.baseCSSPrefix + 'indexed-vertical', indexedNoAutoHideCls:Ext.baseCSSPrefix + 'indexed-no-autohide', indicatorCls:Ext.baseCSSPrefix + 'indexbar-indicator', pressedCls:Ext.baseCSSPrefix + 'pressed', verticalCls:Ext.baseCSSPrefix + 'vertical', element:{reference:'element', cls:Ext.baseCSSPrefix + 'unselectable', children:[{reference:'bodyElement', cls:Ext.baseCSSPrefix + 'body-el'}]}, initialize:function() {
  var me = this, bodyElement = me.bodyElement;
  me.callParent();
  bodyElement.addClsOnClick(me.pressedCls);
  bodyElement.on({touchstart:'onTouchStart', touchend:'onTouchEnd', mouseover:'onMouseOver', mouseout:'onMouseOut', drag:'onDrag', dragEnd:'onDragEnd', scope:me});
}, getVertical:function() {
  return this.getDirection() === 'vertical';
}, setVertical:function(vertical) {
  return this.setDirection(vertical ? 'vertical' : 'horizontal');
}, onAdded:function(parent, instanced) {
  var me = this;
  parent.el.addCls(me.indexedCls);
  me.parentListeners = parent.on({pinnedfooterheightchange:'onPinnedFooterHeightChange', pinnedheaderheightchange:'onPinnedHeaderHeightChange', verticaloverflowchange:'onVerticalOverflowChange', destroyable:true, scope:me});
  me.callParent([parent, instanced]);
}, onRemoved:function(destroying) {
  var me = this, parent = me.parent;
  Ext.destroy(me.parentListeners);
  if (parent && !parent.destroying && !parent.destroyed) {
    parent.el.removeCls(me.indexedCls);
  }
  me.callParent([destroying]);
}, privates:{parentListeners:null, onDrag:function(e) {
  this.trackMove(e, false);
}, onDragEnd:function(e) {
  var me = this, indicator = me.getIndicator();
  me.trackMove(e, true);
  if (indicator && me.indicator) {
    me.indicator.hide();
  }
}, onMouseOver:function() {
  var me = this;
  me.$isMouseOver = true;
  if (me.shouldAutoHide('over')) {
    me.bodyElement.show();
  }
}, onMouseOut:function() {
  var me = this;
  me.$isMouseOver = false;
  if (me.shouldAutoHide('out')) {
    me.bodyElement.hide();
  }
}, onPinnedFooterHeightChange:function(list, height) {
  this.setBottom(height);
}, onPinnedHeaderHeightChange:function(list, height) {
  this.setTop(height);
}, onTouchStart:function(e) {
  var me = this;
  me.$isPressing = true;
  me.pageBox = me.bodyElement.getBox();
  me.onDrag(e);
  if (me.shouldAutoHide('press')) {
    me.bodyElement.show();
  }
}, onTouchEnd:function(e) {
  var me = this;
  me.$isPressing = false;
  if (me.shouldAutoHide('release')) {
    me.bodyElement.hide();
  }
  me.onDragEnd(e);
}, onVerticalOverflowChange:function(list, verticalOverflow) {
  this.setRight(verticalOverflow ? Ext.getScrollbarSize().width : 0);
}, scrollToClosestByIndex:function(index) {
  var me = this, list = me.parent, key = index.toLowerCase(), store = list.getStore(), groups = store.getGroups(), ln = groups.length, group, groupKey, i, closest, item, record;
  for (i = 0; i < ln; i++) {
    group = groups.getAt(i);
    groupKey = group.getGroupKey().toLowerCase();
    if (groupKey >= key) {
      closest = group;
      break;
    }
    closest = group;
  }
  if (closest) {
    record = closest.first();
    if (!list.getInfinite()) {
      item = list.itemFromRecord(record).$header;
    }
    list.ensureVisible(record, {animation:me.getAnimation(), item:item, align:{y:'start'}});
  }
}, shouldAutoHide:function(trigger) {
  var me = this, autoHide = me.getAutoHide(), ret = false;
  if (autoHide) {
    if (autoHide === 'pressed' || !Ext.os.is.Desktop) {
      ret = trigger === 'press' || trigger === 'release';
    } else {
      ret = trigger === 'over' || trigger === 'release' && !me.$isMouseOver || trigger === 'out' && !me.$isPressing;
    }
  }
  return ret;
}, syncIndicatorPosition:function(point, target, isValidTarget) {
  var me = this, isUsingIndicator = me.getIndicator(), direction = me.getDirection(), renderElement = me.renderElement, bodyElement = me.bodyElement, indicator = me.indicator, indicatorInner = me.indicatorInner, first = bodyElement.getFirstChild(), last = bodyElement.getLastChild(), indexbarWidth, indexbarHeight, indicatorSpacing, firstPosition, lastPosition, indicatorSize;
  if (isUsingIndicator && indicator) {
    indicator.show();
    if (direction === 'vertical') {
      indicatorSize = indicator.getHeight();
      indexbarWidth = bodyElement.getWidth();
      indicatorSpacing = bodyElement.getMargin('lr');
      firstPosition = first.getY();
      lastPosition = last.getY();
      if (point.y < firstPosition) {
        target = first;
      } else {
        if (point.y > lastPosition) {
          target = last;
        }
      }
      if (isValidTarget) {
        indicatorInner.setHtml(target.getHtml().toUpperCase());
      }
      indicator.setTop(target.getY() - renderElement.getY() - indicatorSize / 2 + target.getHeight() / 2);
      indicator.setRight(indicatorSpacing + indexbarWidth);
    } else {
      indicatorSize = indicator.getWidth();
      indicatorSpacing = bodyElement.getMargin('tb');
      indexbarHeight = bodyElement.getHeight();
      firstPosition = first.getX();
      lastPosition = last.getX();
      if (point.x < firstPosition) {
        target = first;
      } else {
        if (point.x > lastPosition) {
          target = last;
        }
      }
      indicator.setLeft(target.getX() - renderElement.getX() - indicatorSize / 2 + target.getWidth() / 2);
      indicator.setBottom(indicatorSpacing + indexbarHeight);
    }
    indicatorInner.setHtml(target.getHtml().toUpperCase());
  }
}, trackMove:function(event, drop) {
  var me = this, el = me.bodyElement, pageBox = me.pageBox || (me.pageBox = me.el.getBox()), point = Ext.util.Point.fromEvent(event), target, isValidTarget;
  if (me.getDirection() === 'vertical') {
    if (point.y > pageBox.bottom || point.y < pageBox.top) {
      return;
    }
    target = Ext.Element.fromPoint(pageBox.left + pageBox.width / 2, point.y);
    isValidTarget = target && target.getParent() === el;
  } else {
    if (point.x > pageBox.right || point.x < pageBox.left) {
      return;
    }
    target = Ext.Element.fromPoint(point.x, pageBox.top + pageBox.height / 2);
    isValidTarget = target && target.getParent() === el;
  }
  if (target && isValidTarget) {
    if (me.getIndicator()) {
      me.syncIndicatorPosition(point, target, isValidTarget);
    }
    if (drop || me.getDynamic()) {
      me.scrollToClosestByIndex(target.dom.innerHTML);
    }
  }
}, updateAutoHide:function(autoHide) {
  var me = this, parentEl = me.parent.el, autoHideCls = me.autoHideCls, indexedNoAutoHideCls = me.indexedNoAutoHideCls;
  me.bodyElement.setVisibilityMode(Ext.Element.OPACITY);
  if (autoHide) {
    me.addCls(autoHideCls);
    me.bodyElement.hide();
    parentEl.removeCls(indexedNoAutoHideCls);
  } else {
    me.removeCls(autoHideCls);
    me.bodyElement.show();
    parentEl.addCls(indexedNoAutoHideCls);
  }
}, updateDirection:function(direction) {
  var me = this, verticalCls = me.verticalCls, horizontalCls = me.horizontalCls, indexedVerticalCls = me.indexedVerticalCls, indexedHorizontalCls = me.indexedHorizontalCls, oldCls, newCls, oldIndexedCls, newIndexedCls;
  if (direction === 'vertical') {
    oldCls = horizontalCls;
    newCls = verticalCls;
    oldIndexedCls = indexedHorizontalCls;
    newIndexedCls = indexedVerticalCls;
  } else {
    oldCls = verticalCls;
    newCls = horizontalCls;
    oldIndexedCls = indexedVerticalCls;
    newIndexedCls = indexedHorizontalCls;
  }
  me.element.replaceCls(oldCls, newCls);
  me.bodyElement.replaceCls(oldCls, newCls);
  me.parent.element.replaceCls(oldIndexedCls, newIndexedCls);
}, updateIndicator:function(indicator) {
  var me = this, config = {cls:me.indicatorCls};
  if (indicator && indicator !== true) {
    config = Ext.apply(config, indicator);
  }
  if (indicator) {
    me.indicator = me.el.appendChild(config);
    me.indicatorInner = me.indicator.appendChild({cls:me.indicatorCls + '-inner'});
    me.indicator.hide(false);
  } else {
    if (me.indicator) {
      me.indicator.destroy();
      me.indicatorInner.destroy();
      me.indicator = me.indicatorInner = null;
    }
  }
}, updateLetters:function(letters) {
  var bodyElement = this.bodyElement, len = letters.length, i;
  bodyElement.setHtml('');
  if (letters) {
    for (i = 0; i < len; i++) {
      bodyElement.createChild({cls:Ext.baseCSSPrefix + 'indexbar-item', html:letters[i]});
    }
  }
}, updateListPrefix:function(listPrefix) {
  if (listPrefix && listPrefix.length) {
    this.bodyElement.createChild({html:listPrefix}, 0);
  }
}, updateUi:function(ui, oldUi) {
  var me = this, list = me.parent, listElement = list.element, indexedCls = me.indexedCls;
  if (oldUi) {
    listElement.removeCls(oldUi, indexedCls);
  }
  if (ui) {
    listElement.addCls(ui, indexedCls);
  }
  me.callParent([ui, oldUi]);
}}});
Ext.define('Ext.theme.material.dataview.IndexBar', {override:'Ext.dataview.IndexBar', config:{autoHide:true, letters:['*', '#', 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z']}});
Ext.define('Ext.layout.HBox', {extend:Ext.layout.Box, alias:'layout.hbox', config:{vertical:false}});
Ext.define('Ext.tip.ToolTip', {extend:Ext.Panel, xtype:'tooltip', floated:true, hidden:true, shadow:true, border:true, bodyBorder:false, anchor:false, closeAction:'hide', config:{align:'l-r?', alignDelegate:null, allowOver:null, anchorToTarget:true, autoHide:true, delegate:null, dismissDelay:5000, hideDelay:300, mouseOffset:[15, 18], quickShowInterval:250, showDelay:500, showOnTap:null, target:null, trackMouse:false}, classCls:Ext.baseCSSPrefix + 'tooltip', headerCls:Ext.baseCSSPrefix + 'tooltipheader', 
titleCls:Ext.baseCSSPrefix + 'tooltiptitle', toolCls:[Ext.baseCSSPrefix + 'paneltool', Ext.baseCSSPrefix + 'tooltiptool'], closeToolText:null, constructor:function(config) {
  this.currentTarget = new Ext.dom.Fly;
  this.callParent([config]);
}, getRefOwner:function() {
  var target = this.getTarget();
  return target && target.isComponent ? target : this.callParent();
}, updateAnchor:function() {
  this.doRealignToTarget();
}, applyAlign:function(align) {
  var lastChar = align[align.length - 1];
  if (lastChar !== '?' && lastChar !== '!') {
    align += '?';
  }
  return align;
}, updateAlign:function() {
  this.doRealignToTarget();
}, updateAllowOver:function(allowOver) {
  var me = this;
  me.overListeners = Ext.destroy(me.overListeners);
  if (allowOver) {
    me.overListeners = me.el.on({mouseenter:'onTipOver', mouseleave:'onTipOut', scope:me, destroyable:true});
  }
}, applyTarget:function(target) {
  if (target) {
    if (!target.isComponent) {
      target = Ext.get(target.el || target);
    }
  }
  return target;
}, updateTarget:function(target, oldTarget) {
  var me = this;
  if (oldTarget) {
    oldTarget.un('destroy', me.destroy, me);
  }
  if (target) {
    if (target.isComponent) {
      me.targetElement = target.element;
      target.on('destroy', me.destroy, me);
    } else {
      me.targetElement = Ext.get(target);
    }
  } else {
    me.targetElement = null;
  }
  me.attachTargetListeners();
}, updateTrackMouse:function(trackMouse) {
  if (trackMouse) {
    this.setAllowOver(trackMouse);
  }
}, updateDisabled:function(disabled, oldDisabled) {
  var me = this, val;
  me.callParent([disabled, oldDisabled]);
  if (disabled) {
    me.clearTimers();
    me.hide();
    val = null;
  }
  me.attachTargetListeners(val);
}, updateShowOnTap:function(showOnTap) {
  if (!this.isConfiguring) {
    this.attachTargetListeners();
  }
}, realignToTarget:function() {
  this.doRealignToTarget();
}, showBy:function(target, alignment, passedOptions) {
  var me = this, alignTarget = target, alignDelegate = me.getAlignDelegate();
  if (target.isEvent) {
    me.alignToEvent(target);
  } else {
    if (target.isWidget) {
      me.updateCurrentTarget(target.element.dom);
    } else {
      if (target.isElement) {
        me.updateCurrentTarget(target.dom);
      } else {
        if (target.nodeType) {
          me.updateCurrentTarget(target);
        }
      }
    }
    if (alignDelegate) {
      target = Ext.fly(target);
      alignTarget = target.down(alignDelegate, true) || target.up(alignDelegate, me.targetElement, true);
    }
    me.callParent([alignTarget, alignment || me.getAlign(), passedOptions]);
  }
}, beforeShow:function(options) {
  var me = this, result = me.callParent(arguments);
  if (result !== false) {
    if (!options.alignment && (me.pointerEvent || me.getTarget())) {
      options.alignment = {component:me.targetElement, alignment:me.getAlign(), options:{overlap:me.getTrackMouse() && !me.getAnchor()}};
    }
    me.clearTimer('dismiss');
  }
}, afterShow:function() {
  var me = this;
  me.callParent(arguments);
  me.postprocessShow();
  me.mousedownListener = Ext.on({mousedown:'onDocMouseDown', scope:me, destroyable:true});
}, hide:function() {
  var me = this;
  me.clearTimer('hide');
  me.clearTimer('dismiss');
  me.callParent();
  me.lastHidden = new Date;
  me.updateCurrentTarget(null);
  Ext.destroy(me.mousedownListener);
}, doDestroy:function() {
  var me = this;
  me.clearTimers();
  me.setTarget(null);
  me.destroyMembers('mousedownListener', 'overListeners');
  me.callParent();
}, privates:{allowRealign:true, onDocMouseDown:function(e) {
  var me = this, delegate = me.getDelegate();
  if (e.within(me.el.dom)) {
    if (e.pointerType !== 'mouse' && me.getAllowOver()) {
      me.clearTimer('dismiss');
    }
  } else {
    if (!me.getClosable()) {
      if (e.within(me.targetElement) && (!delegate || e.getTarget(delegate, me.targetElement))) {
        me.delayHide();
      } else {
        me.disable();
        me.enableTimer = Ext.defer(me.enable, 100, me);
      }
    }
  }
}, onTargetOver:function(e) {
  var me = this, myTarget = me.targetElement, delegate = me.getDelegate(), currentTarget = me.currentTarget, newTarget;
  if (me.getDisabled()) {
    return;
  }
  if (me.getAllowOver() && me.el.contains(e.target)) {
    return;
  }
  if (delegate) {
    if (currentTarget.contains(e.target)) {
      return;
    }
    newTarget = e.getTarget(delegate, myTarget);
    if (newTarget && e.getRelatedTarget(delegate) === newTarget) {
      return;
    }
  } else {
    if (!myTarget.contains(e.relatedTarget)) {
      newTarget = myTarget.dom;
    } else {
      return;
    }
  }
  if (newTarget) {
    me.handleTargetOver(e, newTarget);
  } else {
    if (currentTarget.dom) {
      me.handleTargetOut();
    }
  }
}, handleTargetOver:function(e, newTarget) {
  var me = this, myListeners = me.hasListeners;
  me.pointerEvent = e;
  me.updateCurrentTarget(newTarget);
  if (me.isVisible()) {
    if (myListeners.beforeshow && me.fireEvent('beforeshow', me) === false) {
      return me.hide();
    }
    me.clearTimer('hide');
    me.clearTimer('dismiss');
    me.showByTarget(newTarget);
    if (myListeners.show) {
      me.fireEvent('show', me);
    }
    me.postprocessShow();
  } else {
    me.delayShow(newTarget);
  }
}, postprocessShow:function() {
  var me = this, dismissDelay = me.getDismissDelay();
  me.clearTimer('show');
  if (dismissDelay && me.getAutoHide()) {
    me.dismissTimer = Ext.defer(me.hide, dismissDelay, me);
  }
  me.toFront();
}, onTargetTap:function(e) {
  if (e.pointerType !== 'mouse' && Ext.fly(e.target).isVisible(true)) {
    this.onTargetOver(e);
  }
}, onTargetOut:function(e) {
  if (this.currentTarget.dom && !this.currentTarget.contains(e.relatedTarget)) {
    if (!this.getAllowOver() && e.within(this.el, true)) {
      this.handleTargetOut();
    }
  }
}, handleTargetOut:function() {
  var me = this;
  if (me.showTimer) {
    me.clearTimer('show');
  }
  if (me.isVisible() && me.getAutoHide()) {
    me.delayHide();
  }
}, onTipOver:function() {
  this.clearTimer('hide');
  this.clearTimer('dismiss');
}, onTipOut:function(e) {
  if (!this.currentTarget.dom || !e.getPoint().isContainedBy(this.currentTarget.getRegion())) {
    this.handleTargetOut();
  }
}, onMouseMove:function(e) {
  var me = this, dismissDelay = me.getDismissDelay();
  if (!me.el.contains(e.target)) {
    me.pointerEvent = e;
  }
  if (me.isVisible() && me.currentTarget.contains(e.target)) {
    if (dismissDelay && me.getAutoHide() !== false) {
      me.clearTimer('dismiss');
      me.dismissTimer = Ext.defer(me.hide, dismissDelay, me);
    }
    if (me.getTrackMouse()) {
      me.alignToEvent(e);
    }
  }
}, delayShow:function(target) {
  var me = this;
  me.clearTimer('hide');
  if (me.getHidden() && !me.showTimer) {
    if (me.getDelegate() && Ext.Date.getElapsed(me.lastHidden) < me.getQuickShowInterval()) {
      me.showByTarget(target);
    } else {
      me.showTimer = Ext.defer(me.showByTarget, !me.pointerEvent || me.pointerEvent.pointerType === 'mouse' ? me.getShowDelay() : 0, me, [target]);
    }
  } else {
    if (!me.getHidden() && me.getAutoHide() !== false) {
      me.showByTarget(target);
    }
  }
}, showByTarget:function(target) {
  var me = this, isTarget = me.getAnchorToTarget() && !me.getTrackMouse();
  me.lastShowWasPointer = !isTarget;
  me.showBy(isTarget ? target : me.pointerEvent, me.getAlign(), {overlap:me.getTrackMouse() && !me.getAnchor()});
}, delayHide:function() {
  var me = this;
  if (!me.isHidden() && !me.hideTimer) {
    me.clearTimer('dismiss');
    me.hideTimer = Ext.defer(me.hide, me.getHideDelay(), me);
  }
}, alignToEvent:function(event) {
  var me = this, options = {overlap:me.getTrackMouse() && !me.getAnchor()}, mouseOffset = me.getMouseOffset(), target = event.getPoint().adjust(-Math.abs(mouseOffset[1]), Math.abs(mouseOffset[0]), Math.abs(mouseOffset[1]), -Math.abs(mouseOffset[0])), align = me.getAnchor() ? me.getAlign() : null;
  if (!align && mouseOffset) {
    if (mouseOffset[0] > 0) {
      if (mouseOffset[1] > 0) {
        align = 'tl-br?';
      } else {
        align = 'bl-tr?';
      }
    } else {
      if (mouseOffset[1] > 0) {
        align = 'tr-bl?';
      } else {
        align = 'br-tl?';
      }
    }
  }
  if (me.isVisible()) {
    me.clearTimer('hide');
    me.alignTo(target, align, options);
  } else {
    me.showBy(target, align, options);
  }
}, _timerNames:{}, clearTimer:function(name) {
  var me = this, names = me._timerNames, propName = names[name] || (names[name] = name + 'Timer'), timer = me[propName];
  if (timer) {
    Ext.undefer(timer);
    me[propName] = null;
    if (name === 'show' && me.isHidden()) {
      me.updateCurrentTarget(null);
    }
  }
}, clearTimers:function() {
  var me = this;
  me.clearTimer('show');
  me.clearTimer('dismiss');
  me.clearTimer('hide');
  me.clearTimer('enable');
}, clipTo:function(clippingEl, sides) {
  var clippingRegion;
  if (clippingEl.isRegion) {
    clippingRegion = clippingEl;
  } else {
    clippingRegion = (clippingEl.isComponent ? clippingEl.el : Ext.fly(clippingEl)).getConstrainRegion();
  }
  this.callParent([clippingRegion, sides]);
  this.tipElement.clipTo(clippingRegion, sides);
}, doRealignToTarget:function() {
  var me = this, currentTarget = me.currentTarget, dom = currentTarget && currentTarget.dom;
  me.clearTimers();
  if (me.allowRealign && me.isVisible() && dom) {
    me.realign(null, me.getAlign());
  }
}, updateCurrentTarget:function(dom) {
  var me = this, currentTarget = me.currentTarget, was = currentTarget.dom;
  currentTarget.attach(dom);
  if (!me.isConfiguring) {
    me.fireEvent('hovertarget', me, currentTarget, was);
  }
}, attachTargetListeners:function(target) {
  var me = this, listeners;
  me.targetListeners = Ext.destroy(me.targetListeners);
  if (target === null) {
    return;
  }
  target = me.targetElement;
  if (target) {
    listeners = {mouseover:'onTargetOver', mouseout:'onTargetOut', mousemove:'onMouseMove', scope:me, destroyable:true};
    if (me.getShowOnTap()) {
      listeners.tap = 'onTargetTap';
    }
    me.targetListeners = target.on(listeners);
  }
}}});
Ext.define('Ext.field.trigger.Expand', {extend:Ext.field.trigger.Trigger, xtype:'expandtrigger', alias:'trigger.expand', classCls:Ext.baseCSSPrefix + 'expandtrigger', isExpandTrigger:true, handler:'onExpandTap', scope:'this'});
Ext.define('Ext.field.Picker', {extend:Ext.field.Text, xtype:'pickerfield', config:{picker:{lazy:true, $value:'auto'}, floatedPicker:{lazy:true, $value:null}, edgePicker:{lazy:true, $value:null}, clearable:false, matchFieldWidth:true, floatedPickerAlign:'tl-bl?', pickerSlotAlign:'center', hideTrigger:false, focusTrap:{lazy:true, $value:{tabIndex:-1, cls:'x-hidden-clip'}}}, triggers:{expand:{type:'expand'}}, alignTarget:'bodyElement', keyMap:{scope:'this', DOWN:'onDownArrow', ESC:'onEsc'}, keyMapTarget:'inputElement', 
autoComplete:false, classCls:Ext.baseCSSPrefix + 'pickerfield', initialize:function() {
  var me = this;
  me.callParent();
  Ext.on('hide', 'onGlobalHide', me);
  me.inputElement.on('click', 'onInputElementClick', me);
}, onFocus:function(e) {
  var me = this;
  me.callParent([e]);
  if (Ext.isTouchMode()) {
    me.getFocusTrap().focus();
    if (!me.focusingFromExpandTrigger) {
      me.expand();
    } else {
      me.focusingFromExpandTrigger = false;
    }
  }
}, onFocusMove:function(info) {
  var me = this, focusTrap;
  me.callParent([info]);
  if (Ext.isTouchMode()) {
    focusTrap = me.getFocusTrap();
    if (info.fromElement === focusTrap.dom && info.toElement === me.getFocusEl().dom) {
      if (me.getEditable()) {
        me.collapse();
      } else {
        focusTrap.focus();
        me.expand();
      }
    }
  }
}, onFocusLeave:function(e) {
  this.callParent([e]);
  this.collapse();
}, onEsc:function(e) {
  if (Ext.isIE) {
    e.preventDefault();
  }
  if (this.expanded) {
    this.collapse();
    e.stopEvent();
  }
}, onDownArrow:function(e) {
  var me = this;
  if (e.time - me.lastDownArrow > 150) {
    delete me.lastDownArrow;
  }
  if (!me.expanded) {
    e.stopEvent();
    me.onExpandTap();
    me.setPickerLocation(true);
    me.lastDownArrow = e.time;
  } else {
    if (!e.stopped && e.time - me.lastDownArrow < 150) {
      delete me.lastDownArrow;
    }
  }
}, setPickerLocation:Ext.emptyFn, updateHideTrigger:function(hideTrigger) {
  var triggers = this.getTriggers(), expand = triggers && triggers.expand;
  if (expand) {
    expand.setHidden(hideTrigger);
  }
}, applyPicker:function(picker) {
  var me = this, pickerListeners = {show:'onPickerShow', hide:'onPickerHide', scope:me}, type = picker, config;
  if (!type) {
    type = 'auto';
  } else {
    if (Ext.isObject(picker)) {
      type = null;
      if (!picker.isWidget && !picker.xtype) {
        config = picker;
        type = 'auto';
      }
    }
  }
  if (type) {
    if (type === 'auto') {
      type = me.getAutoPickerType();
    }
    if (type === 'edge') {
      picker = me.createEdgePicker(config);
    } else {
      if (type !== 'floated') {
        Ext.raise('Picker type must be "edge" or "floated" not "' + type + '"');
      } else {
        picker = me.createFloatedPicker(config);
        pickerListeners.resize = pickerListeners.hiddenchange = 'realignFloatedPicker';
      }
    }
  }
  if (picker.isWidget) {
    picker.ownerField = me;
  } else {
    picker = Ext.apply({ownerField:me}, picker);
    me.fireEvent('beforepickercreate', me, picker);
    picker = Ext.create(picker);
  }
  me.pickerType = type || (picker.isViewportMenu ? 'edge' : 'floated');
  me.fireEvent('pickercreate', me, picker);
  picker.on(pickerListeners);
  return picker;
}, getAutoPickerType:function() {
  return Ext.platformTags.phone ? 'edge' : 'floated';
}, updatePicker:function(picker) {
  var value = this.getValue();
  if (picker && picker.setValue && value != null) {
    if (this.pickerType === 'floated' || picker.isPicker) {
      picker.setValue(value);
    }
  }
}, applyFocusTrap:function(focusTrap) {
  var result = this.el.appendChild(Ext.dom.Element.create(focusTrap));
  result.$isFocusTrap = true;
  return result;
}, onResize:function() {
  var picker = this.getConfig('picker', false, true);
  if (picker && picker.isVisible()) {
    this.realignFloatedPicker();
  }
}, realignFloatedPicker:function(picker) {
  var me = this;
  picker = me.getConfig('picker', false, true);
  if (picker && picker.isVisible()) {
    if (me.getMatchFieldWidth()) {
      picker.setWidth(me[me.alignTarget].getWidth());
    }
    picker.realign(me[me.alignTarget], me.getFloatedPickerAlign(), {minHeight:100});
    me.setPickerLocation();
  }
}, onInputElementClick:function(e) {
  var me = this;
  if (e.pointerType === 'mouse' && (!me.getEditable() && !me.getReadOnly())) {
    me[me.expanded ? 'collapse' : 'expand']();
  }
}, onExpandTap:function() {
  if (this.expanded) {
    this.collapse();
  } else {
    this.expand();
  }
  return false;
}, expand:function() {
  if (!this.expanded && !this.getDisabled()) {
    this.showPicker();
  }
}, collapse:function() {
  var picker;
  if (this.expanded) {
    picker = this.getPicker();
    if (this.pickerType === 'edge') {
      Ext['Viewport'].removeMenu(picker.getSide(), true);
    } else {
      picker.hide();
    }
  }
}, collapseIf:function(e) {
  var me = this;
  if (!me.destroyed && (!e.within(me.bodyElement, false, true) && !me.owns(e.target))) {
    me.collapse();
  }
}, showPicker:function() {
  var me = this, alignTarget = me[me.alignTarget], picker = me.getPicker();
  if (me.pickerType === 'floated') {
    if (me.getMatchFieldWidth()) {
      picker.setWidth(alignTarget.getWidth());
    }
    picker.showBy(alignTarget, me.getFloatedPickerAlign(), {minHeight:100});
    me.touchListeners = Ext.getDoc().on({translate:false, touchstart:me.collapseIf, scope:me, delegated:false, destroyable:true});
  } else {
    picker.show();
    me.setShowPickerValue(picker);
  }
}, updatePickerValue:function(picker, value) {
  var slot = picker.getSlots()[0], name = slot.name || slot.getName(), pickerValue = {};
  pickerValue[name] = value;
  picker.setValue(pickerValue);
}, onPickerShow:function() {
  var me = this;
  me.expanded = true;
  if (me.pickerType === 'edge') {
    me.el.dom.scrollIntoView();
  }
  me.hideEventListeners = Ext.on({mousedown:'collapseIf', scroll:'onGlobalScroll', scope:me, destroyable:true});
  me.fireEvent('expand', me);
}, onPickerHide:function() {
  var me = this;
  me.expanded = false;
  Ext.destroy(me.hideEventListeners, me.touchListeners);
  me.fireEvent('collapse', me);
}, doDestroy:function() {
  this.destroyMembers('picker', 'hideEventListeners', 'touchListeners', 'focusTrap');
  this.callParent();
}, privates:{onGlobalHide:function(cmp) {
  if (this === cmp || cmp.isAncestor(this)) {
    this.collapse();
  }
}, onGlobalScroll:function(scroller, x, y) {
  var me = this, scrollingEl = scroller.getElement();
  if (me.expanded) {
    if (me.pickerType === 'edge') {
      return;
    }
    if (!me.getPicker().owns(scrollingEl) && scrollingEl.dom !== document.body) {
      me.collapse();
    }
  }
}, revertFocusTo:function(target) {
  if (Ext.isTouchMode()) {
    this.getFocusTrap().focus();
  } else {
    target.focus();
  }
}, setShowPickerValue:function(picker) {
  var value = this.getValue();
  if (value != null) {
    this.updatePickerValue(picker, value);
  }
}}});
Ext.define('Ext.picker.Slot', {extend:Ext.dataview.DataView, xtype:'pickerslot', isSlot:true, config:{title:null, showTitle:true, cls:Ext.baseCSSPrefix + 'picker-slot', name:null, value:null, flex:1, align:'left', displayField:'text', valueField:'value', itemTpl:null, scrollable:{x:false, y:true, scrollbars:false}, verticallyCenterItems:true}, tabIndex:null, focusEl:null, itemsFocusable:false, scrollToTopOnRefresh:false, snapSelector:'.' + Ext.baseCSSPrefix + 'dataview-item', selectedIndex:0, deselectable:false, 
navigationModel:{type:'boundlist', keyboard:false}, onFocusEnter:Ext.emptyFn, onFocusLeave:Ext.emptyFn, applyTitle:function(title) {
  if (title) {
    title = Ext.create('Ext.Component', {cls:Ext.baseCSSPrefix + 'picker-slot-title', docked:'top', html:title});
  }
  return title;
}, updateTitle:function(newTitle, oldTitle) {
  if (newTitle) {
    this.add(newTitle);
    this.setupBar();
  }
  if (oldTitle) {
    this.remove(oldTitle);
  }
}, updateShowTitle:function(showTitle) {
  var title = this.getTitle(), mode = showTitle ? 'show' : 'hide';
  if (title) {
    title.on(mode, this.setupBar, this, {single:true, delay:50});
    title[showTitle ? 'show' : 'hide']();
  }
}, updateDisplayField:function(newDisplayField) {
  if (!this.config.itemTpl) {
    this.setItemTpl('\x3cdiv class\x3d"' + Ext.baseCSSPrefix + 'picker-item {cls} \x3ctpl if\x3d"extra"\x3e' + Ext.baseCSSPrefix + 'picker-invalid\x3c/tpl\x3e"\x3e{' + newDisplayField + '}\x3c/div\x3e');
  }
}, updateAlign:function(newAlign, oldAlign) {
  var element = this.element;
  element.addCls(Ext.baseCSSPrefix + 'picker-' + newAlign);
  element.removeCls(Ext.baseCSSPrefix + 'picker-' + oldAlign);
}, applyData:function(data) {
  var parsedData = [], ln = data && data.length, i, item, obj;
  if (data && Ext.isArray(data) && ln) {
    for (i = 0; i < ln; i++) {
      item = data[i];
      obj = {};
      if (Ext.isArray(item)) {
        obj[this.valueField] = item[0];
        obj[this.displayField] = item[1];
      } else {
        if (Ext.isString(item)) {
          obj[this.valueField] = item;
          obj[this.displayField] = item;
        } else {
          if (Ext.isObject(item)) {
            obj = item;
          }
        }
      }
      parsedData.push(obj);
    }
  }
  return data;
}, initialize:function() {
  var me = this;
  me.callParent();
  me.on({scope:me, painted:'onPainted', single:true});
  me.picker.on({scope:me, beforehiddenchange:'onBeforeHiddenChange'});
}, onPainted:function() {
  this.setupBar();
}, onResize:function() {
  var value = this.getValue();
  if (value) {
    this.doSetValue(value);
  }
}, onBeforeHiddenChange:function(picker, hidden) {
  if (!hidden) {
    this.doSetValue(this.getValue());
  }
}, getPicker:function() {
  if (!this.picker) {
    this.picker = this.getParent();
  }
  return this.picker;
}, setupBar:function() {
  if (!this.isPainted()) {
    return;
  }
  var me = this, title = me.getTitle(), titleHeight = me.getShowTitle() && title ? title.el.measure('h') : 0, barHeight = me.getPicker().bar.measure('h'), offset;
  if (me.getVerticallyCenterItems()) {
    offset = Math.ceil((me.el.measure('h') - titleHeight - barHeight) / 2);
    me.bodyElement.setStyle({'padding-top':offset + 'px'});
    if (!me.bottomSpacer) {
      me.bottomSpacer = me.add({xtype:'component', scrollDock:'end', height:offset, style:'pointer-events: none'});
    } else {
      me.bottomSpacer.setHeight(offset);
    }
  }
  me.doSetValue(me.getValue());
}, getScrollableClientRegion:function() {
  return this.picker.bar.getClientRegion();
}, scrollToItem:function(item, animated) {
  this.getScrollable().scrollIntoView(item.el, false, animated);
}, onScrollEnd:function(x, y) {
  var me = this, viewItems = me.getViewItems(), index = Ext.Number.constrain(Math.round(y / me.picker.bar.measure('h')), 0, viewItems.length - 1), item = viewItems[index];
  if (item) {
    me.selectedIndex = index;
    me.selectedNode = item;
    me.setValueAnimated(me.getValue(true));
    me.fireEvent('slotpick', me, me.getValue(), me.selectedNode);
  }
}, getValue:function(useDom) {
  var store = this.getStore(), record, value;
  if (!store) {
    return;
  }
  if (!useDom) {
    return this._value;
  }
  if (this._value === false) {
    return null;
  }
  record = store.getAt(this.selectedIndex);
  value = record ? record.get(this.getValueField()) : null;
  return value;
}, setValue:function(value) {
  return this.doSetValue(value);
}, setValueAnimated:function(value) {
  return this.doSetValue(value, true);
}, doSetValue:function(value, animated) {
  var me = this, hasSelection = true, store, index, item;
  store = me.getStore();
  index = store ? store.findExact(me.getValueField(), value) : -1;
  if (index === -1) {
    hasSelection = false;
    index = 0;
  }
  me.selectedIndex = index;
  if (me.refreshCounter) {
    item = Ext.get(me.getViewItems()[index]);
    if (item) {
      me.scrollToItem(item, animated);
      if (hasSelection) {
        me.select(me.selectedIndex);
      }
    }
  }
  me._value = value;
}, privates:{forceRefreshOnRender:true}});
Ext.define('Ext.picker.Picker', {extend:Ext.Sheet, alias:'widget.picker', alternateClassName:'Ext.Picker', isPicker:true, config:{doneButton:true, cancelButton:true, useTitles:false, slots:null, value:null, height:220, layout:{type:'hbox', align:'stretch'}, centered:false, left:0, right:0, bottom:0, defaultType:'pickerslot', toolbarPosition:'top', toolbar:{xtype:'titlebar'}, side:'bottom'}, baseCls:Ext.baseCSSPrefix + 'picker', floated:true, focusEl:null, focusable:true, tabIndex:-1, initialize:function() {
  this.callParent();
  this.on({scope:this, delegate:'pickerslot', slotpick:'onSlotPick'});
}, getTemplate:function() {
  var me = this, clsPrefix = Ext.baseCSSPrefix, template = me.callParent();
  template[0].children[0].children = [{reference:'mask', cls:clsPrefix + 'picker-mask', children:[{reference:'bar', cls:clsPrefix + 'picker-bar'}]}];
  return template;
}, applyToolbar:function(config, oldToolbar) {
  if (config) {
    if (config === true) {
      config = {};
    }
    Ext.applyIf(config, {docked:this.getToolbarPosition()});
  }
  return Ext.factory(config, 'Ext.TitleBar', oldToolbar);
}, updateToolbar:function(newToolbar) {
  if (newToolbar) {
    this.add(newToolbar);
  }
}, applyDoneButton:function(config, oldButton) {
  if (config) {
    if (config === true) {
      config = {};
    }
    if (typeof config == 'string') {
      config = {text:config};
    }
    Ext.applyIf(config, {align:'right', text:'Done'});
  }
  return Ext.factory(config, 'Ext.Button', oldButton);
}, updateDoneButton:function(newDoneButton) {
  var toolbar = this.getToolbar();
  if (newDoneButton) {
    toolbar.add(newDoneButton);
    newDoneButton.on('tap', this.onDoneButtonTap, this);
  }
}, applyCancelButton:function(config, oldButton) {
  if (config) {
    if (Ext.isBoolean(config)) {
      config = {};
    }
    if (typeof config == 'string') {
      config = {text:config};
    }
    Ext.applyIf(config, {align:'left', text:'Cancel'});
  }
  return Ext.factory(config, 'Ext.Button', oldButton);
}, updateCancelButton:function(newCancelButton) {
  var toolbar = this.getToolbar();
  if (newCancelButton) {
    toolbar.add(newCancelButton);
    newCancelButton.on('tap', this.onCancelButtonTap, this);
  }
}, updateUseTitles:function(useTitles) {
  var innerItems = this.getInnerItems(), ln = innerItems.length, cls = Ext.baseCSSPrefix + 'use-titles', i, innerItem;
  if (useTitles) {
    this.addCls(cls);
  } else {
    this.removeCls(cls);
  }
  for (i = 0; i < ln; i++) {
    innerItem = innerItems[i];
    if (innerItem.isSlot) {
      innerItem.setShowTitle(useTitles);
    }
  }
}, applySlots:function(slots) {
  if (slots) {
    var ln = slots.length, i;
    for (i = 0; i < ln; i++) {
      slots[i].picker = this;
    }
  }
  return slots;
}, updateSlots:function(newSlots) {
  var me = this, bcss = Ext.baseCSSPrefix, innerItems;
  me.removeAll();
  if (newSlots) {
    me.add(newSlots);
  }
  innerItems = me.getInnerItems();
  if (innerItems.length > 0) {
    innerItems[0].addCls(bcss + 'first');
    innerItems[innerItems.length - 1].addCls(bcss + 'last');
  }
  me.updateUseTitles(me.getUseTitles());
  me.setValue(me.getValue());
}, onDoneButtonTap:function() {
  var me = this, oldValue = me._value, newValue = me.getValue(true);
  if (newValue != oldValue) {
    me._values = me._value = newValue;
    me.fireEvent('change', me, newValue);
  }
  me.hide();
  Ext.util.InputBlocker.unblockInputs();
}, onCancelButtonTap:function() {
  this.fireEvent('cancel', this);
  this.hide();
  Ext.util.InputBlocker.unblockInputs();
}, onSlotPick:function(slot) {
  this.fireEvent('pick', this, this.getValue(true), slot);
}, afterShow:function(me) {
  me.callParent([me]);
  if (!me.isHidden()) {
    me.setValue(me._value);
  }
  Ext.util.InputBlocker.blockInputs();
}, updateDisplayed:function(displayed, oldDisplayed) {
  this.callParent([displayed, oldDisplayed]);
  Ext.util.InputBlocker.blockInputs();
}, setValue:function(values, animated) {
  var me = this, slots = me.getInnerItems(), ln = slots.length, key, slot, i, value;
  if (!values) {
    values = {};
    for (i = 0; i < ln; i++) {
      values[slots[i].getName()] = null;
    }
  }
  for (key in values) {
    value = values[key];
    for (i = 0; i < slots.length; i++) {
      slot = slots[i];
      if (slot.getName() == key) {
        if (animated) {
          slot.setValueAnimated(value);
        } else {
          slot.setValue(value);
        }
        break;
      }
    }
  }
  me._values = me._value = values;
  return me;
}, setValueAnimated:function(values) {
  this.setValue(values, true);
}, getValue:function(useDom) {
  var values = {}, items = this.getItems().items, ln = items.length, item, i;
  if (useDom) {
    for (i = 0; i < ln; i++) {
      item = items[i];
      if (item && item.isSlot) {
        values[item.getName()] = item.getValue(useDom);
      }
    }
    this._values = values;
  }
  return this._values;
}, getValues:function() {
  return this.getValue();
}, privates:{_revertFocus:function() {
  var ownerField = this.ownerField;
  if (this.rendered && ownerField && ownerField.containsFocus) {
    ownerField.revertFocusTo(ownerField.ariaEl);
  }
}}});
Ext.define('Ext.picker.Tablet', {extend:Ext.Panel, alias:'widget.tabletpicker', isPicker:true, focusable:true, tabIndex:-1});
Ext.define('Ext.field.Select', {extend:Ext.field.Picker, xtype:'selectfield', alternateClassName:'Ext.form.Select', isSelectField:true, config:{valueCollection:true, valueField:'value', itemTpl:false, displayTpl:null, displayField:'text', store:null, options:null, hiddenName:null, autoSelect:false, autoFocus:true, autoFocusLast:true, selection:null, autoLoadOnValue:false, forceSelection:true, valueNotFoundText:null, selectOnTab:true}, editable:false, floatedPicker:{xtype:'boundlist', infinite:false, 
navigationModel:{disabled:true}, scrollToTopOnRefresh:false, loadingHeight:70, maxHeight:300, floated:true, axisLock:true, hideAnimation:null}, edgePicker:{xtype:'picker', cover:true}, classCls:Ext.baseCSSPrefix + 'selectfield', twoWayBindable:{selection:1}, publishes:{selection:1}, applyValueCollection:function(valueCollection) {
  if (!valueCollection.isCollection) {
    valueCollection = new Ext.util.Collection(valueCollection);
  }
  valueCollection.addObserver(this);
  return valueCollection;
}, createSelectionRecord:function(data) {
  var Model = this.getStore().getModel();
  return new Model(data);
}, completeEdit:Ext.emptyFn, expand:function() {
  if (this.getStore()) {
    this.callParent();
  }
}, maybeCollapse:function(event) {
  var record = event.to && event.to.record, selection = this.getSelection();
  if (record === selection) {
    this.collapse();
  }
}, onCollectionRemove:function(valueCollection, chunk) {
  var selection = valueCollection.getRange();
  if (!chunk.replacement) {
    this.setSelection(selection.length ? selection[0] : null);
  }
}, onCollectionAdd:function(valueCollection, adds) {
  var selection = valueCollection.getRange();
  this.setSelection(selection[0]);
}, clearValue:function() {
  var me = this;
  me.forceInputChange = true;
  me.setValue(null);
  me.forceInputChange = false;
  me.syncEmptyState();
}, applyValue:function(value, oldValue) {
  this.getOptions();
  var me = this, store = me.getStore();
  me.syncMode = 'value';
  if (value && value.isEntity) {
    me.setSelection(value);
    return;
  }
  if (me.isConfiguring) {
    me.originalValue = value;
  }
  if (store && value) {
    if (me.getAutoLoadOnValue() && !store.isLoaded() && !store.hasPendingLoad()) {
      store.load();
    }
  }
  return me.transformValue(value);
}, updateValue:function(value, oldValue) {
  this.syncValue();
  Ext.field.Field.prototype.updateValue.call(this, value, oldValue);
}, transformValue:function(value) {
  if (value == null || value === '') {
    value = this.getForceSelection() ? null : '';
  }
  return value;
}, findRecordByValue:function(value) {
  var me = this, store = me.getStore(), valueField = me.getValueField(), result, ret = null;
  if (store) {
    result = store.byValue.get(value);
    if (result) {
      ret = result[0] || result;
    }
  }
  if (!ret) {
    ret = me.getValueCollection().findBy(function(record) {
      return record.get(valueField) === value;
    });
  }
  return ret;
}, findRecordByDisplay:function(value) {
  var store = this.getStore(), result, ret = false;
  if (store) {
    result = store.byText.get(value);
    if (result) {
      ret = result[0] || result;
    }
  }
  return ret;
}, updateSelection:function(selection, oldSelection) {
  var me = this, isNull = selection == null, valueCollection = me.getValueCollection(), valueField = me.getValueField(), oldValue = me._value, newValue = null, picker, spliceArgs;
  if (me._ignoreSelection || me.destroyed || me.destroying) {
    return;
  }
  if (isNull || !valueCollection.containsAll(selection)) {
    spliceArgs = [0, valueCollection.getCount()];
    if (!isNull) {
      spliceArgs.push(selection);
    }
    valueCollection.splice.apply(valueCollection, spliceArgs);
    if (me.destroyed) {
      return;
    }
  }
  if (selection) {
    if (valueField) {
      newValue = selection.get(valueField);
      me.setValue(newValue);
    }
    if (me.fireEvent('select', me, selection) === false) {
      me.setValue(oldValue);
      me._selection = oldSelection;
    }
  } else {
    me.clearValue();
  }
  if (me.destroyed) {
    return;
  }
  me.setFieldDisplay(selection);
  picker = me.getConfig('picker', false, true);
  if (picker && picker.isVisible()) {
    if (selection && oldSelection && selection.id === oldSelection.id) {
      picker.refresh();
    } else {
      if (!(selection && selection.isEntered)) {
        me.collapse();
      }
    }
  }
}, getRecordDisplayData:function(record) {
  return record.getData();
}, createFloatedPicker:function() {
  var me = this, result = Ext.merge({ownerCmp:me, store:me._pickerStore || me.getStore(), selectable:{selected:me.getValueCollection(), selectedRecord:me.getSelection(), mode:'single', deselectable:false}, itemTpl:me.getItemTpl()}, me.getFloatedPicker());
  result.navigationModel.navigateOnSpace = !me.getEditable();
  return result;
}, createEdgePicker:function() {
  var me = this;
  return Ext.merge({ownerCmp:me, slots:[{align:me.getPickerSlotAlign(), name:me.getValueField(), valueField:me.getValueField(), displayField:me.getDisplayField(), value:me.getValue(), store:me._pickerStore || me.getStore()}], listeners:{change:me.onPickerChange, scope:me}, setStore:function(store) {
    this.child('pickerslot').setStore(store);
  }, deselectAll:function() {
    this.child('pickerslot').deselectAll();
  }}, me.getEdgePicker());
}, setPickerLocation:function(fromKeyboard) {
  var me = this, picker = me.getConfig('picker', false, true), store, location;
  if (picker && me.expanded) {
    if (picker.isPicker) {
      picker = picker.innerItems[0];
    }
    store = picker.getStore();
    if (picker.getViewItems().length) {
      location = picker.getSelectable().getLastSelected();
      if (!location || !store.contains(location)) {
        if (fromKeyboard || me.getAutoFocusLast()) {
          location = picker.getNavigationModel().lastLocation;
          if (location) {
            location = location.refresh();
          }
        }
        if (!location && (fromKeyboard || me.getAutoFocus())) {
          location = store.getAt(0);
        }
      }
      picker.getNavigationModel().setLocation(location);
    }
  }
}, updatePickerValue:function(picker, value) {
  var name = this.getValueField(), pickerValue = {};
  if (!value) {
    value = this.getValue();
  }
  pickerValue[name] = value;
  picker.setValue(pickerValue);
}, onPickerShow:function(picker) {
  this.callParent([picker]);
  if (this.pickerType === 'floated') {
    picker.getNavigationModel().enable();
  }
}, onPickerHide:function(picker) {
  var navModel;
  this.callParent([picker]);
  if (!picker.destroying && this.pickerType === 'floated') {
    navModel = picker.getNavigationModel();
    navModel.setLocation(null);
    navModel.disable();
  }
}, onPickerChange:function(picker, value) {
  this.setValue(this.findRecordByValue(value[this.getValueField()]));
}, applyItemTpl:function(itemTpl) {
  if (itemTpl === false) {
    itemTpl = '\x3cspan class\x3d"x-list-label"\x3e{' + this.getDisplayField() + ':htmlEncode}\x3c/span\x3e';
  }
  return itemTpl;
}, applyDisplayTpl:function(displayTpl) {
  if (displayTpl && !displayTpl.isTemplate) {
    displayTpl = new Ext.XTemplate(displayTpl);
  }
  return displayTpl;
}, applyOptions:function(options) {
  if (options) {
    var len = options.length, valueField = this.getValueField(), displayField = this.getDisplayField(), i, value, option;
    options = Ext.Array.slice(options);
    for (i = 0; i < len; i++) {
      value = options[i];
      if (Ext.isPrimitive(value)) {
        options[i] = option = {};
        option.id = value;
        option[valueField] = value;
        if (displayField && displayField !== valueField) {
          option[displayField] = value;
        }
      }
    }
    options = Ext.data.StoreManager.lookup({fields:[valueField, displayField], data:options});
  }
  return options;
}, updateOptions:function(options, oldOptions) {
  if (options) {
    this.setStore(options);
  } else {
    if (oldOptions === this.getStore()) {
      this.setStore(null);
    }
  }
}, applyStore:function(store) {
  if (store) {
    store = Ext.data.StoreManager.lookup(store);
  }
  return store;
}, updateStore:function(store, oldStore) {
  var me = this, valueField = me.getValueField(), displayField = me.getDisplayField(), extraKeySpec;
  if (oldStore) {
    if (oldStore.getAutoDestroy()) {
      oldStore.destroy();
    } else {
      oldStore.byValue = oldStore.byText = Ext.destroy(oldStore.byValue, oldStore.byText);
    }
  }
  if (store) {
    extraKeySpec = {byValue:{rootProperty:'data', unique:false, property:valueField}};
    if (displayField !== valueField) {
      extraKeySpec.byText = {rootProperty:'data', unique:false, property:displayField};
    }
    store.setExtraKeys(extraKeySpec);
    if (displayField === valueField) {
      store.byText = store.byValue;
    }
    store.on({scope:me, add:'onStoreDataChanged', remove:'onStoreDataChanged', update:'onStoreRecordUpdated', load:{fn:'onStoreLoad', priority:-1}});
    if (store.isLoaded() && !store.hasPendingLoad()) {
      me.syncValue();
    } else {
      if (me.getValue() != null && me.getAutoLoadOnValue() && !store.isLoaded() && !store.hasPendingLoad()) {
        store.load();
      }
    }
  }
  me.updatePickerStore();
}, applyValueField:function(valueField) {
  if (valueField == null) {
    valueField = this.getDisplayField();
  }
  return valueField;
}, updateValueField:function(valueField) {
  var store = this.getStore();
  if (store && !this.isConfiguring) {
    store.byValue.setCollection(null);
    store.setExtraKeys({byValue:{rootProperty:'data', unique:false, property:valueField}});
  }
}, applyDisplayField:function(displayField) {
  if (displayField == null) {
    displayField = this.getValueField();
  }
  return displayField;
}, updateDisplayField:function(displayField) {
  var store = this.getStore();
  if (store && !this.isConfiguring) {
    store.byText.setCollection(null);
    store.setExtraKeys({byText:{rootProperty:'data', unique:false, property:displayField}});
  }
}, onStoreLoad:function(store, records, success) {
  var filtering = this.isFiltering;
  this.isFiltering = false;
  if (success) {
    this.syncMode = filtering ? 'filter' : 'store';
    this.syncValue();
  }
}, syncValue:function() {
  var me = this, store = me.getStore(), valueField = me.getValueField(), displayField = me.getDisplayField(), forceSelection = me.getForceSelection(), valueNotFoundText = me.getValueNotFoundText(), is, isCleared, isInput, value, matchedRecord, dataObj;
  if (me.reconcilingValue || !store || !store.isLoaded() || store.hasPendingLoad()) {
    return;
  }
  me.reconcilingValue = true;
  me.getSelection();
  is = {};
  is[me.syncMode] = true;
  value = (isInput = is.input || is.filter) ? me.getInputValue() : me.getValue();
  isCleared = value == null || value === '';
  if (!isCleared) {
    matchedRecord = (isInput ? store.byText : store.byValue).get(value);
    if (matchedRecord) {
      if (!matchedRecord.isEntity) {
        matchedRecord = matchedRecord[0];
      }
    } else {
      if (!forceSelection) {
        matchedRecord = me.findRecordByValue(value);
      }
    }
  }
  if (!isCleared && !matchedRecord && !forceSelection) {
    dataObj = {};
    dataObj[displayField] = value;
    if (valueField && displayField !== valueField) {
      dataObj[valueField] = value;
    }
    matchedRecord = me.createSelectionRecord(dataObj);
    matchedRecord.isEntered = true;
  } else {
    if (isInput || is.store) {
      if (!matchedRecord && forceSelection) {
        me.setValue(null);
        me.setSelection(null);
        if (!is.filter) {
          me.setFieldDisplay();
        }
      }
    } else {
      if (isCleared) {
        if (me.mustAutoSelect()) {
          matchedRecord = store.first();
          if (me.getAutoSelect() === 'initial') {
            me.setAutoSelect(false);
          }
        } else {
          me.setSelection(null);
        }
      } else {
        if (!matchedRecord && valueNotFoundText) {
          me.setError(valueNotFoundText);
        }
      }
    }
  }
  if (matchedRecord) {
    me.setSelection(matchedRecord);
  }
  me.reconcilingValue = false;
}, onStoreDataChanged:function() {
  if (this.getForceSelection()) {
    var value = this.getValue();
    if (value != null) {
      this.setValue(value);
    }
  }
}, onStoreRecordUpdated:function(store, record) {
  if (this.getValueCollection().contains(record)) {
    this.updateSelection(this.getSelection());
  }
}, reset:function() {
  var me = this, picker = me.getConfig('picker', false, true), record = me.originalValue || null, store;
  if (me.getAutoSelect()) {
    store = me.getStore();
    record = record != null ? record : store && store.getAt(0);
  } else {
    if (picker) {
      picker.deselectAll();
    }
  }
  me.setValue(record);
  return me;
}, doDestroy:function() {
  var store = this.getStore();
  if (store && !store.destroyed && store.getAutoDestroy()) {
    store.destroy();
  }
  this.destroyMembers('options');
  this.callParent();
}, privates:{syncMode:null, mustAutoSelect:function() {
  var me = this, autoSelect = me.getAutoSelect();
  if (autoSelect && !(me.isConfiguring || autoSelect === 'initial')) {
    autoSelect = !me.getClearable() && me.getRequired();
  }
  return !!autoSelect;
}, updatePickerStore:function() {
  var me = this, picker = me.getConfig('picker', false, true), store = me.getStore(), localFiltering = me.getQueryMode && me.getQueryMode() === 'local', result = store;
  if (localFiltering) {
    if (me._pickerStore && me._pickerStore.isChainedStore) {
      me._pickerStore.setConfig({source:store});
    } else {
      me._pickerStore = result = Ext.data.StoreManager.lookup({type:'chained', source:store}, null, me);
    }
  } else {
    me._pickerStore = result = store;
  }
  if (picker) {
    picker.setStore(result);
  }
}, setFieldDisplay:function(selection) {
  var me = this, inputValue = '', displayTpl;
  if (selection) {
    displayTpl = me.getDisplayTpl();
    if (displayTpl) {
      inputValue = displayTpl.apply(me.getRecordDisplayData(selection));
    } else {
      inputValue = selection.get(me.getDisplayField());
    }
  }
  me.setInputValue(inputValue);
  me.syncEmptyState();
}}});
Ext.define('Ext.field.ComboBox', {extend:Ext.field.Select, xtype:['combobox', 'comboboxfield'], alternateClassName:['Ext.form.field.ComboBox'], config:{primaryFilter:true, queryParam:'query', queryMode:'remote', queryCaching:true, queryDelay:true, minChars:null, anyMatch:false, caseSensitive:false, typeAhead:false, typeAheadDelay:250, triggerAction:'all', allQuery:null, enableRegEx:null}, autoSelect:false, editable:true, forceSelection:false, lastQuery:{}, picker:'floated', onInput:function(e) {
  var me = this, filterTask = me.doFilterTask, value = me.inputElement.dom.value, filters = me.getStore().getFilters();
  if (!me.getForceSelection() || value === '' && !me.getRequired()) {
    me.callParent([e]);
  } else {
    me._inputValue = value;
    me.syncEmptyState();
  }
  if (value.length) {
    if (!filterTask) {
      filterTask = me.doFilterTask = new Ext.util.DelayedTask(me.doRawFilter, me);
    }
    filterTask.delay(me.getQueryDelay());
  } else {
    me.collapse();
    filters.beginUpdate();
    me.getPrimaryFilter().setDisabled(true);
    filters.endUpdate();
  }
}, doRawFilter:function() {
  var me = this, rawValue = me.inputElement.dom.value, lastQuery = me.lastQuery.query, isErase = lastQuery && lastQuery.length > rawValue.length;
  me.doFilter({query:rawValue, isErase:isErase});
}, onExpandTap:function() {
  var me = this, triggerAction = me.getTriggerAction();
  if (me.expanded) {
    me.collapse();
  } else {
    if (!me.getReadOnly() && !me.getDisabled()) {
      if (triggerAction === 'all') {
        me.doFilter({query:me.getAllQuery(), force:true});
      } else {
        if (triggerAction === 'last') {
          me.doFilter({query:me.lastQuery.query, force:true});
        } else {
          me.doFilter({query:me.inputElement.dom.value});
        }
      }
    }
  }
}, clearValue:function() {
  var me = this, inputMask = me.getInputMask();
  if (inputMask) {
  } else {
    me.setValue(null);
    me.setFieldDisplay();
  }
  me.syncEmptyState();
}, doFilter:function(query) {
  var me = this, isLocal = me.getQueryMode() === 'local', lastQuery = me.lastQuery, store = me.getStore() && me._pickerStore, filter = me.getPrimaryFilter(), filters = store.getFilters(), queryPlan = me.beforeFilter(Ext.apply({filterGeneration:filter.generation, lastQuery:lastQuery || {}, combo:me, cancel:false}, query)), picker;
  if (store && queryPlan !== false && !queryPlan.cancel) {
    if (me.getEnableRegEx()) {
      try {
        queryPlan.query = new RegExp(queryPlan.query);
      } catch (e$33) {
        queryPlan.query = null;
      }
    }
    filter.setValue(queryPlan.query);
    if (!me.getQueryCaching() || filter.generation !== lastQuery.filterGeneration || query.force) {
      if (Ext.isEmpty(queryPlan.query)) {
        filter.setDisabled(true);
      } else {
        filter.setDisabled(false);
        me.isFiltering = !isLocal;
      }
      me.lastQuery = queryPlan;
      filters.beginUpdate();
      filters.endUpdate();
    }
    if (me.getTypeAhead()) {
      me.doTypeAhead(queryPlan);
    }
    picker = me.getPicker();
    if (!isLocal || store.getCount() || picker.getEmptyText && picker.getEmptyText()) {
      me.expand();
      return true;
    } else {
      me.collapse();
    }
  }
  return false;
}, beforeFilter:function(queryPlan) {
  var me = this, query = queryPlan.query, len;
  if (me.fireEvent('beforequery', queryPlan) === false) {
    queryPlan.cancel = true;
  } else {
    if (!queryPlan.cancel) {
      len = query && query.length;
      if (!queryPlan.force && len && len < me._getMinChars()) {
        queryPlan.cancel = true;
      }
    }
  }
  return queryPlan;
}, completeEdit:function() {
  var me = this, inputValue = me.getInputValue();
  if (me.doFilterTask) {
    me.doFilterTask.cancel();
  }
  if (inputValue) {
    me.syncMode = 'input';
    me.syncValue();
  }
  if (me.getTypeAhead()) {
    me.select(inputValue ? inputValue.length : 0);
  }
}, onStoreDataChanged:function(store) {
  this.callParent([store]);
}, onStoreFilterChange:function() {
  var me = this, store = me.getStore(), selection = me.getSelection() || null, toRemove = [];
  if (selection && !me.destroying && store && store.isLoaded() && me.getPrimaryFilter().getDisabled()) {
    if (!selection.isEntered && !store.contains(selection)) {
      toRemove.push(selection);
    }
    if (toRemove.length) {
      this.getValueCollection().remove(toRemove);
    }
  }
}, onListSelect:Ext.emptyFn, applyQueryDelay:function(queryDelay) {
  if (queryDelay === true) {
    queryDelay = this.getQueryMode() === 'local' ? 10 : 500;
  }
  return queryDelay;
}, applyPrimaryFilter:function(filter, oldFilter) {
  var me = this, store = me.getStore() && me._pickerStore, isInstance = filter && filter.isFilter;
  if (store && oldFilter) {
    if (filter) {
      if (isInstance) {
        store.removeFilter(oldFilter, true);
      } else {
        oldFilter.setConfig(filter);
        return;
      }
    } else {
      if (!store.destroyed) {
        store.getFilters().remove(oldFilter);
      }
    }
  }
  if (filter) {
    if (filter === true) {
      filter = {id:me.id + '-primary-filter', anyMatch:me.getAnyMatch(), caseSensitive:me.getCaseSensitive(), root:'data', property:me.getDisplayField(), value:me.inputElement.dom.value, disabled:true};
    }
    if (!filter.isFilter) {
      filter = new Ext.util.Filter(filter);
    }
    filter.serialize = function() {
      return me.serializePrimaryFilter(this);
    };
    if (store) {
      store.addFilter(filter, true);
    }
  }
  return filter;
}, updateOptions:function(options, oldOptions) {
  if (options) {
    this.setQueryMode('local');
  }
  this.callParent([options, oldOptions]);
}, updatePicker:function(picker, oldPicker) {
  if (picker) {
    picker.getSelectable().ignoredFilter = this.getPrimaryFilter();
  }
  this.callParent([picker, oldPicker]);
}, updateStore:function(store, oldStore) {
  var me = this, isRemote = me.getQueryMode() === 'remote', primaryFilter, proxy, oldFilters;
  if (isRemote) {
    store.setRemoteFilter(true);
    proxy = store.getProxy();
    if (proxy.setFilterParam) {
      proxy.setFilterParam(me.getQueryParam());
    }
  }
  me.callParent([store, oldStore]);
  primaryFilter = me.getPrimaryFilter();
  if (primaryFilter) {
    if (oldStore && !oldStore.destroyed) {
      oldFilters = oldStore.getFilters();
      oldFilters && oldFilters.remove(primaryFilter);
    }
    me._pickerStore.addFilter(primaryFilter, true);
  }
  if (me.getQueryMode() === 'local') {
    store.on({filterchange:'onStoreFilterChange', scope:me});
  }
}, serializePrimaryFilter:function(filter) {
  return filter.getValue();
}, doDestroy:function() {
  var me = this;
  me.setPrimaryFilter(null);
  if (me.typeAheadTask) {
    me.typeAheadTask = me.typeAheadTask.cancel();
  }
  me.callParent();
}, doTypeAhead:function(queryPlan) {
  var me = this;
  if (!me.typeAheadTask) {
    me.typeAheadTask = new Ext.util.DelayedTask(me.onTypeAhead, me);
  }
  if (!queryPlan.lastQuery.query || !queryPlan.query || queryPlan.query.length > queryPlan.lastQuery.query.length || !Ext.String.startsWith(queryPlan.lastQuery.query, queryPlan.query)) {
    me.typeAheadTask.delay(me.getTypeAheadDelay());
  }
}, onTypeAhead:function() {
  var me = this, displayField = me.getDisplayField(), inputEl = me.inputElement.dom, rawValue = inputEl.value, store = me.getStore(), record = store.findRecord(displayField, rawValue), newValue, len, selStart;
  if (record) {
    newValue = record.get(displayField);
    len = newValue.length;
    selStart = rawValue.length;
    if (selStart !== 0 && selStart !== len) {
      inputEl.value = me._inputValue = newValue;
      me.select(selStart, len);
    }
  }
}, privates:{_getMinChars:function() {
  var result = this.getMinChars();
  if (result == null) {
    result = this.getQueryMode() === 'remote' ? 4 : 0;
  }
  return result;
}, setFieldDisplay:function(selection) {
  var me = this, inputValue;
  me.callParent([selection]);
  if (me.getTypeAhead()) {
    inputValue = me.getInputValue();
    me.select(inputValue ? inputValue.length : 0);
  }
}}});
Ext.define('Ext.field.Manager', {mixinId:'fieldmanager', fillRecord:function(record) {
  var values, name;
  if (record) {
    values = this.getValues();
    for (name in values) {
      if (values.hasOwnProperty(name) && record.getField(name)) {
        record.set(name, values[name]);
      }
    }
  }
  return this;
}, consumeRecord:function(record) {
  var data = record && record.data;
  if (data) {
    this.setValues(data);
  }
}, setValues:function(values) {
  var fields = this.getFields(), name, field, value, ln, i, f;
  values = values || {};
  for (name in values) {
    if (values.hasOwnProperty(name)) {
      field = fields[name];
      value = values[name];
      if (field) {
        if (Ext.isArray(field)) {
          ln = field.length;
          for (i = 0; i < ln; i++) {
            f = field[i];
            if (f.isRadio) {
              f.setGroupValue(value);
              break;
            } else {
              if (f.isCheckbox) {
                if (Ext.isArray(value)) {
                  f.setChecked(value.indexOf(f._value) != -1);
                } else {
                  f.setChecked(value == f._value);
                }
              } else {
                if (Ext.isArray(value)) {
                  f.setValue(value[i]);
                }
              }
            }
          }
        } else {
          if (field.isRadio || field.isCheckbox) {
            field.setChecked(value);
          } else {
            field.setValue(value);
          }
        }
        if (this.getTrackResetOnLoad && this.getTrackResetOnLoad()) {
          field.resetOriginalValue();
        }
      }
    }
  }
  return this;
}, getValues:function(enabled, all) {
  var fields = this.getFields(), values = {}, isArray = Ext.isArray, field, value, addValue, bucket, name, ln, i;
  addValue = function(field, name) {
    if (!all && (!name || name === 'null') || field.isFile) {
      return;
    }
    if (field.isCheckbox) {
      value = field.getSubmitValue();
    } else {
      value = field.getValue();
    }
    if (!(enabled && field.getDisabled())) {
      if (field.isRadio) {
        if (field.isChecked()) {
          values[name] = value;
        }
      } else {
        bucket = values[name];
        if (!Ext.isEmpty(bucket)) {
          if (!field.isCheckbox || field.isChecked()) {
            if (!isArray(bucket)) {
              bucket = values[name] = [bucket];
            }
            if (isArray(value)) {
              bucket = values[name] = bucket.concat(value);
            } else {
              bucket.push(value);
            }
          }
        } else {
          values[name] = value;
        }
      }
    }
  };
  for (name in fields) {
    if (fields.hasOwnProperty(name)) {
      field = fields[name];
      if (isArray(field)) {
        ln = field.length;
        for (i = 0; i < ln; i++) {
          addValue(field[i], name);
        }
      } else {
        addValue(field, name);
      }
    }
  }
  return values;
}, reset:function(clearInvalid) {
  this.getFields(false).forEach(function(field) {
    field.reset();
    if (clearInvalid) {
      field.setError(null);
    }
  });
  return this;
}, updateDisabled:function(newDisabled) {
  this.getFields(false).forEach(function(field) {
    field.setDisabled(newDisabled);
  });
  return this;
}, setErrors:function(errors) {
  var setError = function(field, fieldname) {
    if (field) {
      messages = errors[fieldname];
      if (messages === null || Ext.isArray(messages) && messages.length === 0) {
        field.setError(null);
      } else {
        field.setError(messages);
      }
    }
  }, fieldname, field, messages, i, length;
  if (!Ext.isObject(errors)) {
    Ext.raise('setErrors requires an Object parameter');
  }
  for (fieldname in errors) {
    field = this.lookupName(fieldname) || this.lookup(fieldname);
    if (Ext.isArray(field)) {
      for (i = 0, length = field.length; i < length; i++) {
        setError(field[i], fieldname);
      }
    } else {
      setError(field, fieldname);
    }
  }
  return this;
}, clearErrors:function() {
  var fields = this.getFields(false), i, length, field;
  for (i = 0, length = fields.length; i < length; i++) {
    field = fields[i];
    if (field.getName() && field.setError) {
      field.setError(null);
    }
  }
  return this;
}, getErrors:function() {
  var errors = {}, fields = this.getFields(false).filter(function(field) {
    return field.getName();
  }), i, length, field, error;
  for (i = 0, length = fields.length; i < length; i++) {
    field = fields[i];
    error = field.getError();
    if (!error || !error.length) {
      error = null;
    }
    errors[field.getName()] = error;
  }
  return errors;
}, isValid:function() {
  var fields = this.getFields(false), i, length;
  for (i = 0, length = fields.length; i < length; i++) {
    if (!fields[i].isValid()) {
      return false;
    }
  }
  return true;
}, validate:function(skipLazy) {
  var fields = this.getFields(false), valid = true, i, length;
  for (i = 0, length = fields.length; i < length; i++) {
    if (!fields[i].validate(skipLazy)) {
      valid = false;
    }
  }
  return valid;
}, getFields:function(byName, deep) {
  var selector = (deep === false ? '\x3e ' : '') + 'field' + (byName ? '[name\x3d' + byName + ']' : ''), fields = this.query(selector), asArray = byName === false, obj, i, length, field, name, bucket;
  if (!fields && asArray) {
    return [];
  } else {
    if (fields && !asArray) {
      if (!byName) {
        obj = {};
        for (i = 0, length = fields.length; i < length; i++) {
          field = fields[i];
          name = field.getName();
          bucket = obj[name];
          if (bucket) {
            if (Ext.isArray(bucket)) {
              bucket.push(field);
            } else {
              obj[name] = [bucket, field];
            }
          } else {
            obj[name] = field;
          }
        }
        return obj;
      } else {
        if (fields.length < 2) {
          return fields[0];
        }
      }
    }
  }
  return fields;
}, getFocusedField:function() {
  var fields = this.getFields(false), ln = fields.length, field, i;
  for (i = 0; i < ln; i++) {
    field = fields[i];
    if (field.hasFocus) {
      return field;
    }
  }
  return null;
}, getNextField:function() {
  var fields = this.getFields(false), focusedField = this.getFocusedField(), index;
  if (focusedField) {
    index = fields.indexOf(focusedField);
    if (index !== fields.length - 1) {
      index++;
      return fields[index];
    }
  }
  return false;
}, focusNextField:function() {
  var field = this.getNextField();
  if (field) {
    field.focus();
    return field;
  }
  return false;
}, getPreviousField:function() {
  var fields = this.getFields(false), focusedField = this.getFocusedField(), index;
  if (focusedField) {
    index = fields.indexOf(focusedField);
    if (index !== 0) {
      index--;
      return fields[index];
    }
  }
  return false;
}, focusPreviousField:function() {
  var field = this.getPreviousField();
  if (field) {
    field.focus();
    return field;
  }
  return false;
}});
Ext.define('Ext.field.trigger.Date', {extend:Ext.field.trigger.Expand, xtype:'datetrigger', alias:'trigger.date', classCls:Ext.baseCSSPrefix + 'datetrigger'});
Ext.define('Ext.picker.Date', {extend:Ext.picker.Picker, xtype:'datepicker', alternateClassName:'Ext.DatePicker', config:{yearFrom:1980, yearTo:(new Date).getFullYear(), monthText:'Month', dayText:'Day', yearText:'Year', slotOrder:['month', 'day', 'year'], doneButton:true}, initialize:function() {
  var me = this;
  me.callParent();
  me.on({scope:me, delegate:'\x3e slot', slotpick:me.onSlotPick});
  me.on({scope:me, show:me.onSlotPick});
}, setValue:function(value, animated) {
  var me = this;
  if (Ext.isDate(value)) {
    value = {day:value.getDate(), month:value.getMonth() + 1, year:value.getFullYear()};
  }
  me.callParent([value, animated]);
  if (me.rendered) {
    me.onSlotPick();
  }
  return me;
}, getValue:function(useDom) {
  var values = {}, items = this.getItems().items, ln = items.length, daysInMonth, day, month, year, item, i;
  for (i = 0; i < ln; i++) {
    item = items[i];
    if (item.isSlot) {
      values[item.getName()] = item.getValue(useDom);
    }
  }
  if (values.year === null && values.month === null && values.day === null) {
    return null;
  }
  year = Ext.isNumber(values.year) ? values.year : 1;
  month = Ext.isNumber(values.month) ? values.month : 1;
  day = Ext.isNumber(values.day) ? values.day : 1;
  if (month && year && month && day) {
    daysInMonth = this.getDaysInMonth(month, year);
  }
  day = daysInMonth ? Math.min(day, daysInMonth) : day;
  return new Date(year, month - 1, day);
}, updateYearFrom:function() {
  if (this.initialized) {
    this.createSlots();
  }
}, updateYearTo:function() {
  if (this.initialized) {
    this.createSlots();
  }
}, updateMonthText:function(newMonthText, oldMonthText) {
  var innerItems = this.getInnerItems, ln = innerItems.length, item, i;
  if (this.initialized) {
    for (i = 0; i < ln; i++) {
      item = innerItems[i];
      if (typeof item.title == 'string' && item.title == oldMonthText || item.title.html == oldMonthText) {
        item.setTitle(newMonthText);
      }
    }
  }
}, updateDayText:function(newDayText, oldDayText) {
  var innerItems = this.getInnerItems, ln = innerItems.length, item, i;
  if (this.initialized) {
    for (i = 0; i < ln; i++) {
      item = innerItems[i];
      if (typeof item.title == 'string' && item.title == oldDayText || item.title.html == oldDayText) {
        item.setTitle(newDayText);
      }
    }
  }
}, updateYearText:function(yearText) {
  var innerItems = this.getInnerItems, ln = innerItems.length, item, i;
  if (this.initialized) {
    for (i = 0; i < ln; i++) {
      item = innerItems[i];
      if (item.title == this.yearText) {
        item.setTitle(yearText);
      }
    }
  }
}, constructor:function() {
  this.callParent(arguments);
  this.createSlots();
}, createSlots:function() {
  var me = this, slotOrder = me.getSlotOrder(), yearsFrom = me.getYearFrom(), yearsTo = me.getYearTo(), years = [], days = [], months = [], slots = [], reverse = yearsFrom > yearsTo, ln, i, daysInMonth;
  while (yearsFrom) {
    years.push({text:yearsFrom, value:yearsFrom});
    if (yearsFrom === yearsTo) {
      break;
    }
    if (reverse) {
      yearsFrom--;
    } else {
      yearsFrom++;
    }
  }
  daysInMonth = me.getDaysInMonth(1, (new Date).getFullYear());
  for (i = 0; i < daysInMonth; i++) {
    days.push({text:i + 1, value:i + 1});
  }
  for (i = 0, ln = Ext.Date.monthNames.length; i < ln; i++) {
    months.push({text:Ext.Date.monthNames[i], value:i + 1});
  }
  slotOrder.forEach(function(item) {
    slots.push(me.createSlot(item, days, months, years));
  });
  me.setSlots(slots);
}, createSlot:function(name, days, months, years) {
  var me = this, result;
  switch(name) {
    case 'year':
      result = {name:'year', align:'center', data:years, title:me.getYearText(), flex:3};
      break;
    case 'month':
      result = {name:name, align:'right', data:months, title:me.getMonthText(), flex:4};
      break;
    case 'day':
      result = {name:'day', align:'center', data:days, title:me.getDayText(), flex:2};
  }
  if (me._value) {
    result.value = me._value[name];
  }
  return result;
}, onSlotPick:function() {
  var me = this, addDays = [], value, daySlot, valueField, dayStore, dayData, daysInMonth, slotCount, year, month, i, spliceArgs;
  if (me.isConfiguring) {
    return;
  }
  value = me.getValue(true);
  daySlot = me.getDaySlot();
  me.callParent(arguments);
  if (!daySlot) {
    return;
  }
  valueField = daySlot.getValueField();
  dayStore = daySlot.getStore();
  dayData = dayStore.getData();
  slotCount = dayStore.getCount();
  year = value.getFullYear();
  month = value.getMonth();
  daysInMonth = me.getDaysInMonth(month + 1, year);
  if (slotCount === daysInMonth) {
    return;
  }
  if (daysInMonth > slotCount) {
    for (i = slotCount; i < daysInMonth; i++) {
      addDays.push(dayStore.createModel({text:i + 1, value:i + 1}));
    }
    spliceArgs = [slotCount, 0, addDays];
  } else {
    spliceArgs = [daysInMonth, 5];
  }
  dayData.splice.apply(dayData, spliceArgs);
  i = dayStore.find(valueField, value.getDate());
  if (i == -1) {
    return;
  }
  daySlot.selectedIndex = i;
  daySlot.scrollToItem(daySlot.mapToItem(i));
  daySlot.setValue(daySlot.getValue(true));
}, getDaySlot:function() {
  var innerItems = this.getInnerItems(), ln = innerItems.length, i, slot;
  if (this.daySlot) {
    return this.daySlot;
  }
  for (i = 0; i < ln; i++) {
    slot = innerItems[i];
    if (slot.isSlot && slot.getName() == 'day') {
      this.daySlot = slot;
      return slot;
    }
  }
  return null;
}, getDaysInMonth:function(month, year) {
  var daysInMonth = [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];
  return month == 2 && this.isLeapYear(year) ? 29 : daysInMonth[month - 1];
}, isLeapYear:function(year) {
  return !!((year & 3) === 0 && (year % 100 || year % 400 === 0 && year));
}, onDoneButtonTap:function() {
  var me = this, oldValue = me._value, newValue = me.getValue(true), testValue = newValue;
  if (Ext.isDate(newValue)) {
    testValue = newValue.toDateString();
  }
  if (Ext.isDate(oldValue)) {
    oldValue = oldValue.toDateString();
  }
  if (testValue != oldValue) {
    me.ownerField.onPickerChange(me, newValue);
    me.fireEvent('change', me, newValue);
  }
  me.hide();
  Ext.util.InputBlocker.unblockInputs();
}});
Ext.define('Ext.layout.Carousel', {extend:Ext.layout.Auto, alias:'layout.carousel', config:{visibleChildren:1, frontIndex:{$value:true, lazy:true}, animation:true}, vertical:false, targetCls:Ext.baseCSSPrefix + 'layout-carousel', wrapCls:Ext.baseCSSPrefix + 'layout-carousel-wrap', itemCls:Ext.baseCSSPrefix + 'layout-carousel-item', singularCls:Ext.baseCSSPrefix + 'layout-carousel-singular', destroy:function() {
  var container = this.getContainer();
  Ext.destroy(container.carouselElement, this.activeAnim);
  this.callParent();
}, updateContainer:function(container, oldContainer) {
  var me = this;
  me.callParent([container, oldContainer]);
  container.bodyElement.addCls(me.wrapCls);
  container.carouselElement = container.getRenderTarget().appendChild({cls:me.targetCls});
  Ext.override(container, {privates:{getRenderTarget:function() {
    return this.carouselElement;
  }}});
}, onContainerInitialized:function() {
  var me = this;
  me.callParent();
  if (!me.frontItem) {
    me.setFrontItem(me.getFrontIndex(), false);
  }
}, updateVisibleChildren:function(count) {
  var me = this, target = me.getContainer().getRenderTarget(), pct, items, item, i, len;
  items = me.getLayoutItems();
  pct = me.calcItemBasis(count) + '%';
  if (items.length > count) {
    target.setStyle('left', '-' + pct);
    target.setStyle('transform', 'translateX(' + pct + ')');
  }
  for (i = 0, len = items.length; i < len; i++) {
    item = items[i];
    item.el.setStyle('flex-basis', pct);
  }
  target.toggleCls(me.singularCls, count === 1);
}, applyFrontIndex:function(itemIdx) {
  var count, index;
  if (typeof itemIdx !== 'number') {
    count = this.getVisibleChildren();
    index = count - 1;
    itemIdx = !index ? index : index % 2 ? Math.floor(index / 2) + 1 : index / 2;
  }
  return itemIdx;
}, applyDuration:function(duration) {
  if (typeof duration !== 'number') {
    duration = parseInt(duration, 10) || 500;
  }
  return duration;
}, calcItemBasis:function(count) {
  count = count != null ? count : this.getVisibleChildren();
  return count === 1 ? 100 : !(count % 2) ? 100 / count : (100 / count).toFixed(5);
}, insertInnerItem:function(item, index) {
  var me = this;
  me.callParent([item, index]);
  if (index === 0) {
    me.frontItem = item;
  }
  item.el.setStyle('order', index + 1);
  item.el.setStyle('flex-basis', me.calcItemBasis() + '%');
}, getLayoutItemCount:function() {
  return this.getLayoutItems().length;
}, getLayoutItems:function() {
  return this.getContainer().getInnerItems();
}, getItemIndex:function(item) {
  return this.getContainer().innerIndexOf(item);
}, shiftIndex:function(index, increment) {
  var count = this.getLayoutItemCount();
  index += increment;
  if (increment < 0) {
    index = index < 0 ? count - 1 : index;
  } else {
    if (increment > 0) {
      index = index >= count ? 0 : index;
    }
  }
  return index;
}, getVisibleItems:function() {
  return this.visibleItems;
}, getEdgeItem:function(increment) {
  var items = this.getOrderedLayoutItems();
  return increment < 0 ? items[0] : items[items.length - 1];
}, getFirstVisibleItem:function() {
  return this.getVisibleItems()[0];
}, getLastVisibleItem:function() {
  var items = this.getVisibleItems();
  return items[items.length - 1];
}, getFrontItem:function() {
  return this.frontItem;
}, getFrontItemIndex:function() {
  return this.getItemIndex(this.getFrontItem());
}, getOrderedLayoutItems:function() {
  var items = Ext.Array.clone(this.getLayoutItems());
  return items.sort(this.sortByOrder);
}, setFrontItem:function(index, animate) {
  var me = this, container = me.getContainer(), target = container.getRenderTarget(), frontIndex = me.getFrontIndex(), visibleChildren = me.getVisibleChildren(), items, item, frontItem, oldFrontItem, oldFrontIndex, visibleItems, direction, basis, i, len, ret, deferred;
  items = me.getLayoutItems();
  if (items.length < visibleChildren) {
    return Ext.Deferred.getCachedResolved();
  }
  if (typeof index !== 'number') {
    index = items.indexOf(index);
  }
  basis = me.calcItemBasis();
  target.setStyle('left', '-' + basis + '%');
  oldFrontItem = me.getFrontItem();
  me.frontItem = frontItem = items[index];
  frontIndex++;
  items = items.slice(index).concat(items.slice(0, index));
  oldFrontIndex = items.indexOf(oldFrontItem);
  items = items.slice(-frontIndex).concat(items.slice(0, items.length - frontIndex));
  if (animate == null) {
    animate = me.getAnimation();
  }
  if (animate) {
    if (typeof animate === 'boolean') {
      animate = {};
    }
    direction = oldFrontIndex > -1 && oldFrontIndex <= Math.floor(items.length / 2) ? 1 : -1;
    Ext.destroy(me.activeAnim);
    deferred = new Ext.Deferred;
    ret = deferred.promise;
    me.activeAnim = Ext.Animator.run(Ext.apply({element:target, to:{transform:{translateX:basis * direction + '%'}}, callback:function() {
      me.orderItems(items);
      deferred.resolve();
      me.activeAnim = null;
    }}, animate));
  }
  me.visibleItems = visibleItems = [];
  for (i = 0, len = items.length; i < len; i++) {
    item = items[i];
    if (i > 0 && i <= visibleChildren) {
      visibleItems.push(item);
    }
    item.$carouselOrder = i + 1;
  }
  if (!animate) {
    me.orderItems(items);
    ret = Ext.Deferred.getCachedResolved();
  }
  visibleItems.sort(me.sortByOrder);
  return ret;
}, getMoveItem:function(increment) {
  var index = this.getFrontItemIndex();
  index = this.shiftIndex(index, increment);
  return this.getLayoutItems()[index];
}, cancelAnimation:function() {
  Ext.destroy(this.activeAnim);
}, move:function(increment, animate) {
  return this.setFrontItem(this.getMoveItem(increment), animate);
}, prev:function(animate) {
  return this.move(-1, animate);
}, next:function(animate) {
  return this.move(1, animate);
}, privates:{orderItems:function(items) {
  var len = items.length, i, item;
  for (i = 0; i < len; ++i) {
    item = items[i];
    item.el.setStyle('order', item.$carouselOrder + 1);
  }
}, sortByOrder:function(a, b) {
  return +a.$carouselOrder - b.$carouselOrder;
}}});
Ext.define('Ext.panel.DateView', {extend:Ext.Widget, xtype:'dateview', config:{specialDates:null, specialDays:null, monthOffset:0}, cachedConfig:{captionFormat:null, dateCellFormat:null, format:null, headerLength:null, hideCaption:true, hideOutside:true, startDay:null, weekendDays:null}, element:{reference:'element'}, tableTpl:{reference:'tableElement', tag:'table', cellspacing:'0', cellpadding:'0', children:[]}, captionTpl:{reference:'captionElement', tag:'caption'}, headTpl:{tag:'thead', reference:'headElement'}, 
headRowTpl:{tag:'tr'}, headCellTpl:{tag:'th', cls:Ext.baseCSSPrefix + 'cell', children:[{tag:'div', cls:Ext.baseCSSPrefix + 'inner ' + Ext.dom.Element.unselectableCls}]}, bodyTpl:{tag:'tbody', reference:'bodyElement'}, bodyRowTpl:{tag:'tr'}, bodyCellTpl:{tag:'td', cls:Ext.baseCSSPrefix + 'cell', tabIndex:-1, children:[{tag:'div', cls:Ext.baseCSSPrefix + 'inner ' + Ext.dom.Element.unselectableCls}]}, rows:6, columns:7, cellCls:Ext.baseCSSPrefix + 'cell', emptyCls:Ext.baseCSSPrefix + 'empty', weekendDayCls:Ext.baseCSSPrefix + 
'weekend', disabledDayCls:Ext.baseCSSPrefix + 'disabled', specialDateCls:Ext.baseCSSPrefix + 'special', todayCls:Ext.baseCSSPrefix + 'today', outsideCls:Ext.baseCSSPrefix + 'outside', prevMonthCls:Ext.baseCSSPrefix + 'prev-month', nextMonthCls:Ext.baseCSSPrefix + 'next-month', currentMonthCls:Ext.baseCSSPrefix + 'current-month', constructor:function(config) {
  this.firstOfMonth = Ext.Date.getFirstDateOfMonth(new Date);
  this.callParent([config]);
}, initElement:function() {
  var me = this;
  me.callParent();
  me.headCells = me.headElement.query('th');
  me.bodyCells = me.bodyElement.query('td');
  me.cellMap = {};
}, getMonth:function() {
  return Ext.Date.add(this.firstOfMonth, Ext.Date.MONTH, this.getMonthOffset());
}, getTemplate:function() {
  var me = this, table = me.tableTpl, headRow = me.headRowTpl, headCell = me.headCellTpl, bodyRow = me.bodyRowTpl, bodyCell = me.bodyCellTpl, rows = me.rows, columns = me.columns, headTpl, bodyTpl, i, len;
  headRow = Ext.apply({children:[]}, headRow);
  bodyRow = Ext.apply({children:[]}, bodyRow);
  for (i = 0, len = columns; i < len; i++) {
    headRow.children.push(headCell);
    bodyRow.children.push(bodyCell);
  }
  headTpl = Ext.apply({children:[]}, me.headTpl);
  headTpl.children.push(headRow);
  bodyTpl = Ext.apply({children:[]}, me.bodyTpl);
  for (i = 0, len = rows; i < len; i++) {
    bodyTpl.children.push(bodyRow);
  }
  table.children = [me.captionTpl, headTpl, bodyTpl];
  return [table];
}, getCellByDate:function(date) {
  return date ? this.cellMap[date.getTime()] : null;
}, updateWeekendDays:function() {
  if (!this.isConfiguring) {
    this.refresh();
  }
}, updateStartDay:function(dayIndex) {
  var cells = this.headCells, weekendDays = this.getWeekendDays(), weekendCls = this.weekendDayCls, headerLength = this.getHeaderLength(), cell, i, len, offsetIdx;
  for (i = 0, len = cells.length; i < len; i++) {
    cell = cells[i];
    offsetIdx = (i + dayIndex) % 7;
    cell.firstChild.innerHTML = Ext.Date.getShortDayName(offsetIdx).substr(0, headerLength);
    Ext.fly(cell).toggleCls(weekendCls, !!weekendDays[offsetIdx]);
  }
}, updateSpecialDates:function() {
  if (!this.isConfiguring) {
    this.refresh();
  }
}, updateSpecialDays:function() {
  if (!this.isConfiguring) {
    this.refresh();
  }
}, applyMonthOffset:function(offset) {
  return !isNaN(offset) ? offset : 0;
}, updateMonthOffset:function() {
  this.refresh();
}, updateCaptionFormat:function(format) {
  var month = this.getMonth();
  if (month) {
    this.captionElement.setHtml(Ext.Date.format(month, format));
  }
}, updateHideCaption:function(hide) {
  this.toggleCls(Ext.baseCSSPrefix + 'hide-caption', hide);
}, refresh:function() {
  var me = this, ExtDate = Ext.Date, cells = me.bodyCells, monthStart, startOffset, startDate, startDay, date, cellMap, cell, params, i, len, outPrev, outNext, currentMonth, month;
  if (me.refreshing) {
    return;
  }
  me.refreshing = true;
  monthStart = me.getMonth();
  startDay = me.getStartDay();
  startOffset = startDay - monthStart.getDay();
  if (startOffset > 0) {
    startOffset -= 7;
  }
  startDate = ExtDate.add(monthStart, ExtDate.DAY, startOffset);
  cellMap = me.cellMap = {};
  currentMonth = monthStart.getMonth();
  params = {today:Ext.Date.clearTime(new Date), weekendDays:me.getWeekendDays(), specialDates:me.getSpecialDates(), specialDays:me.getSpecialDays(), format:me.getFormat(), dateCellFormat:me.getDateCellFormat(), hideOutside:me.getHideOutside()};
  for (i = 0, len = cells.length; i < len; i++) {
    cell = cells[i];
    date = ExtDate.add(startDate, ExtDate.DAY, i);
    month = date.getMonth();
    outPrev = month < currentMonth;
    outNext = month > currentMonth;
    cellMap[date.getTime()] = cell;
    params.cell = cell;
    params.date = date;
    params.outside = outPrev || outNext;
    params.outsidePrevious = outPrev;
    params.outsideNext = outNext;
    me.refreshCell(params);
  }
  me.captionElement.setHtml(Ext.Date.format(monthStart, me.getCaptionFormat()));
  me.refreshing = false;
}, refreshCell:function(params) {
  var me = this, cell = params.cell, date = params.date, dayOfWeek = date.getDay(), ms = date.getTime(), specialDates = params.specialDates, specialDays = params.specialDays, cls = [me.cellCls], formatted = Ext.Date.format(date, params.format), empty = params.outside && params.hideOutside, html, special, disabled;
  if (!empty) {
    if (params.outsidePrevious) {
      cls.push(me.outsideCls, me.prevMonthCls);
    } else {
      if (params.outsideNext) {
        cls.push(me.outsideCls, me.nextMonthCls);
      } else {
        cls.push(me.currentMonthCls);
        if (Ext.Date.isEqual(date, params.today)) {
          cls.push(me.todayCls);
        }
      }
    }
    if (params.weekendDays[dayOfWeek]) {
      cls.push(me.weekendDayCls);
    }
    if (!special && specialDays) {
      special = specialDays[dayOfWeek];
    }
    if (specialDates) {
      special = specialDates.dates[ms] || specialDates.re && specialDates.re.test(formatted);
    }
    if (special) {
      cls.push(me.specialDateCls);
    }
  } else {
    cls.push(me.emptyCls);
  }
  disabled = me.getParent().isDateDisabled(date);
  if (!empty && disabled) {
    cls.push(me.disabledDayCls);
  }
  cell.tabIndex = -1;
  if (empty) {
    html = '\x26#160;';
  } else {
    html = Ext.Date.format(date, params.dateCellFormat);
  }
  cell.firstChild.innerHTML = html;
  if (me.transformCellCls) {
    me.transformCellCls(date, cls);
  }
  cell.className = cls.join(' ');
  cell.date = date;
  cell.disabled = disabled;
}, ownsDate:function(d) {
  var curr = this.getMonth();
  return d.getFullYear() === curr.getFullYear() && d.getMonth() === curr.getMonth();
}, privates:{measurePaneSize:function() {
  var el = this.element.first();
  return el.measure('w') + el.getMargin('lr');
}}});
Ext.define('Ext.panel.Title', {extend:Ext.Component, xtype:'paneltitle', isPanelTitle:true, cachedConfig:{textAlign:'left', iconAlign:'left', rotation:0, rotateIcon:null}, config:{text:'', icon:null, iconCls:null}, weight:-10, inheritUi:true, element:{reference:'element', cls:Ext.baseCSSPrefix + 'unselectable'}, template:[{reference:'bodyElement', cls:Ext.baseCSSPrefix + 'body-el', children:[{reference:'iconElement', cls:Ext.baseCSSPrefix + 'icon-el ' + Ext.baseCSSPrefix + 'font-icon'}, {reference:'textElement', 
cls:Ext.baseCSSPrefix + 'text-el'}]}], verticalCls:Ext.baseCSSPrefix + 'vertical', horizontalCls:Ext.baseCSSPrefix + 'horizontal', rotateIconCls:Ext.baseCSSPrefix + 'rotate-icon', iconAlignVerticalCls:Ext.baseCSSPrefix + 'icon-align-vertical', hasIconCls:Ext.baseCSSPrefix + 'has-icon', _textAlignClasses:{left:Ext.baseCSSPrefix + 'text-align-left', center:Ext.baseCSSPrefix + 'text-align-center', right:Ext.baseCSSPrefix + 'text-align-right'}, _iconAlignClasses:{top:Ext.baseCSSPrefix + 'icon-align-top', 
right:Ext.baseCSSPrefix + 'icon-align-right', bottom:Ext.baseCSSPrefix + 'icon-align-bottom', left:Ext.baseCSSPrefix + 'icon-align-left'}, _rotationClasses:{90:Ext.baseCSSPrefix + 'rotate-90', 270:Ext.baseCSSPrefix + 'rotate-270'}, classCls:Ext.baseCSSPrefix + 'paneltitle', _titleSuffix:'-title', afterRender:function() {
  if (Ext.isSafari) {
    this.repaintBodyElement();
  }
  this.callParent();
}, updateIcon:function(icon, oldIcon) {
  var me = this, iconEl;
  me.syncIconVisibility();
  iconEl = me.iconElement;
  iconEl.setStyle('background-image', icon ? 'url(' + icon + ')' : '');
}, updateIconAlign:function(align, oldAlign) {
  var me = this, iconAlignClasses = me._iconAlignClasses, el = me.el;
  if (oldAlign) {
    el.removeCls(iconAlignClasses[oldAlign]);
  }
  if (align) {
    el.addCls(iconAlignClasses[align]);
  }
  el.toggleCls(me.iconAlignVerticalCls, align === 'top' || align === 'bottom');
}, updateIconCls:function(cls, oldCls) {
  var iconEl = this.iconElement;
  this.syncIconVisibility();
  if (oldCls) {
    iconEl.removeCls(oldCls);
  }
  if (cls) {
    iconEl.addCls(cls);
  }
}, updateRotation:function(rotation, oldRotation) {
  var me = this, verticalCls = me.verticalCls, horizontalCls = me.horizontalCls, el = me.el;
  if (oldRotation != 0) {
    el.removeCls(me._rotationClasses[oldRotation]);
  }
  if (rotation == 0) {
    el.replaceCls(verticalCls, horizontalCls);
  } else {
    el.replaceCls(horizontalCls, [verticalCls, me._rotationClasses[rotation]]);
  }
  if (Ext.isSafari && this.rendered) {
    this.repaintBodyElement();
  }
}, updateRotateIcon:function(rotateIcon) {
  this.el.toggleCls(this.rotateIconCls, !!rotateIcon);
}, updateText:function(text) {
  var el = this.textElement.dom;
  el.innerHTML = text || '\x26#160;';
  el.setAttribute('data-title', text);
}, updateTextAlign:function(align, oldAlign) {
  var me = this, textAlignClasses = me._textAlignClasses;
  if (oldAlign) {
    me.removeCls(textAlignClasses[oldAlign]);
  }
  if (align) {
    me.addCls(textAlignClasses[align]);
  }
}, privates:{repaintBodyElement:function() {
  var bodyElement = this.bodyElement.dom, bodyStyle = bodyElement.style;
  bodyStyle.width = '-webkit-min-content';
  bodyElement.offsetWidth;
  bodyStyle.width = '';
}, syncIconVisibility:function() {
  this.el.toggleCls(this.hasIconCls, !!(this.getIcon() || this.getIconCls()));
}}, deprecated:{'6.5':{configs:{glyph:null}}}});
Ext.define('Ext.panel.DateTitle', {extend:Ext.panel.Title, xtype:'datetitle', classCls:Ext.baseCSSPrefix + 'datetitle', template:[{reference:'bodyElement', cls:Ext.baseCSSPrefix + 'body-el', children:[{reference:'iconElement', cls:Ext.baseCSSPrefix + 'icon-el ' + Ext.baseCSSPrefix + 'font-icon'}, {cls:Ext.baseCSSPrefix + 'text-container-el', children:[{reference:'yearElement', cls:Ext.baseCSSPrefix + 'year-el'}, {reference:'textElement', cls:Ext.baseCSSPrefix + 'text-el'}]}]}], config:{split:{cached:true, 
$value:false}, titleActive:{cached:true, $value:true}, year:null}, initialize:function() {
  var me = this;
  me.callParent();
  me.yearElement.on('tap', 'onYearTap', me);
  me.textElement.on('tap', 'onTextTap', me);
}, updateSplit:function(split) {
  this.yearElement.setDisplayed(split);
  this.toggleCls(Ext.baseCSSPrefix + 'split', split);
}, updateTitleActive:function(titleActive) {
  var cls = Ext.baseCSSPrefix + 'inactive';
  this.textElement.toggleCls(cls, !titleActive);
  this.yearElement.toggleCls(cls, titleActive);
}, updateYear:function(year) {
  this.yearElement.dom.textContent = year;
}, privates:{onTextTap:function(e) {
  this.fireEvent('titletap', this, e);
}, onYearTap:function(e) {
  this.fireEvent('yeartap', this, e);
}}});
Ext.define('Ext.panel.YearPicker', {extend:Ext.dataview.BoundList, xtype:'yearpicker', classCls:Ext.baseCSSPrefix + 'yearpicker', config:{defaultOffset:100, end:undefined, start:undefined}, itemConfig:{ui:'yearpicker', tools:null}, itemTpl:'{year}', pinFooters:false, pinHeaders:false, scrollToTopOnRefresh:false, initialize:function() {
  this.callParent();
  this.rebuildStore();
}, focusYear:function(year) {
  var me = this, rec = me.getStore().getById(year), item = me.mapToItem(rec), scrollable = me.getScrollable(), y = scrollable.getEnsureVisibleXY(item.element, {align:{y:'center?'}}).y;
  scrollable.scrollTo(null, y, false);
  me.getNavigationModel().setLocation(rec);
  me.select(rec);
}, onChildTap:function(location) {
  var rec = location.record;
  if (rec) {
    location.event.stopEvent();
    this.fireEvent('yeartap', this, rec.id);
  }
}, applyEnd:function(end) {
  if (!end) {
    end = (new Date).getFullYear() + this.getDefaultOffset();
  }
  return end;
}, updateEnd:function() {
  this.rebuildStore();
}, applyStart:function(start) {
  if (!start) {
    start = (new Date).getFullYear() - this.getDefaultOffset();
  }
  return start;
}, updateStart:function() {
  this.rebuildStore();
}, privates:{forceRefreshOnRender:true, rebuildStore:function() {
  var me = this, start = me.getStart(), end = me.getEnd(), store = me.getStore(), data, i;
  if (me.isConfiguring) {
    return;
  }
  if (!store) {
    store = new Ext.data.Store({autoDestroy:true});
    me.setStore(store);
  }
  data = [];
  for (i = start; i <= end; ++i) {
    data.push({id:i, year:i});
  }
  store.loadData(data);
}}});
Ext.define('Ext.panel.Date', {extend:Ext.Panel, xtype:'datepanel', config:{animation:true, autoConfirm:false, captionFormat:{$value:'F Y', cached:true}, dateCellFormat:{$value:'j', cached:true}, disabledDates:null, disabledDays:null, focusableDate:null, format:{$value:Ext.Date.defaultFormat, cached:true}, handler:null, headerFormat:{$value:'D, M j Y', cached:true}, headerLength:1, hideCaptions:true, hideOutside:false, maxDate:null, minDate:null, navigationPosition:'header', nextText:'Next Month (Control+Right)', 
panes:1, prevText:'Previous Month (Control+Left)', selectOnNavigate:true, showAfterMaxDate:false, showBeforeMinDate:false, showFooter:null, showTodayButton:null, specialDates:null, specialDays:null, splitTitle:false, startDay:{$value:Ext.Date.firstDayOfWeek, cached:true}, titleAnimation:null, value:undefined, weekendDays:{$value:Ext.Date.weekendDays, cached:true}, yearPicker:{lazy:true, $value:{}}, yearPickerDefaults:null}, focusable:true, tabIndex:0, border:false, mouseWheelBuffer:500, autoSize:null, 
headerCls:Ext.baseCSSPrefix + 'datepanelheader', titleCls:Ext.baseCSSPrefix + 'datetitle', toolCls:[Ext.baseCSSPrefix + 'paneltool', Ext.baseCSSPrefix + 'datepaneltool'], header:{title:{xtype:'datetitle'}}, tools:{previousMonth:{reference:'navigatePrevMonth', iconCls:'x-fa fa-angle-left', cls:Ext.baseCSSPrefix + 'left-year-tool ', weight:-100, increment:-1, focusable:false, tabIndex:null, forceTabIndex:true, listeners:{click:'onMonthToolClick'}}, previousYear:{reference:'navigatePrevYear', iconCls:'x-fa fa-angle-double-left', 
cls:Ext.baseCSSPrefix + 'left-month-tool', weight:-90, increment:-12, focusable:false, tabIndex:null, forceTabIndex:true, listeners:{click:'onMonthToolClick'}}, nextYear:{reference:'navigateNextYear', iconCls:'x-fa fa-angle-double-right', cls:Ext.baseCSSPrefix + 'right-month-tool', weight:90, increment:12, focusable:false, tabIndex:null, forceTabIndex:true, listeners:{click:'onMonthToolClick'}}, nextMonth:{reference:'navigateNextMonth', iconCls:'x-fa fa-angle-right', cls:Ext.baseCSSPrefix + 'right-year-tool', 
weight:100, increment:1, focusable:false, tabIndex:null, forceTabIndex:true, listeners:{click:'onMonthToolClick'}}}, keyMapTarget:'bodyElement', keyMap:{'*+LEFT':'onLeftArrowKey', '*+RIGHT':'onRightArrowKey', UP:'onUpArrowKey', DOWN:'onDownArrowKey', '*+PAGE_UP':'onPageUpKey', '*+PAGE_DOWN':'onPageDownKey', HOME:'onHomeKey', END:'onEndKey', ENTER:'onEnterKey', SPACE:'onSpaceKey', BACKSPACE:'onBackspaceKey', '*+TAB':'onTabKey', scope:'this'}, paneXtype:'dateview', classCls:Ext.baseCSSPrefix + 'datepanel', 
layout:{type:'carousel', animation:{duration:100}}, defaultListenerScope:true, referenceHolder:true, buttonToolbar:{enableFocusableContainer:false, cls:Ext.baseCSSPrefix + 'datepanel-footer', reference:'footer'}, buttons:{footerTodayButton:{text:'Today', tabIndex:-1, hidden:true, weight:-20, handler:'onTodayButtonClick', reference:'footerTodayButton'}, spacer:{xtype:'component', weight:-10, flex:1}, ok:{tabIndex:-1, handler:'onOkButtonClick'}, cancel:{tabIndex:-1, handler:'onCancelButtonClick'}}, 
initialize:function() {
  var me = this, value = me.getValue();
  me.callParent();
  me.setToolText('navigatePrevMonth', me.getPrevText());
  me.setToolText('navigateNextMonth', me.getNextText());
  me.bodyElement.on({click:{delegate:me.cellSelector, fn:'onDateClick'}, focus:'onBodyFocus', wheel:Ext.Function.createThrottled(me.onMouseWheel, me.mouseWheelBuffer), scope:me});
  me.getShowFooter();
  me.preventAnim = true;
  me.setFocusableDate(value);
  me.preventAnim = false;
  me.setTitleByDate(value);
  Ext.fly(me.getCellByDate(value)).addCls(me.selectedCls);
}, onRender:function() {
  this.callParent();
  this.measurePaneSize();
}, doDestroy:function() {
  var me = this;
  Ext.destroy(me.animTitle, me.animBody);
  me.callParent();
}, focusDate:function(date) {
  var me = this;
  me.doFocus = true;
  me.setFocusableDate(date);
  me.doFocus = false;
}, updateAnimation:function(animate) {
  this.getLayout().setAnimation(animate);
}, updateAutoConfirm:function(autoConfirm) {
  var me = this;
  me.getButtons();
  if (!autoConfirm) {
    me.setShowFooter(true);
  } else {
    me.setShowFooter(me.initialConfig.showFooter);
  }
}, updateCaptionFormat:function(format) {
  this.broadcastConfig('captionFormat', format);
}, updateDateCellFormat:function(format) {
  this.broadcastConfig('dateCellFormat', format);
}, applyDisabledDates:function(dates) {
  if (!dates) {
    return dates;
  }
  var cfg = {dates:{}}, re = [], item, i, len;
  if (dates instanceof RegExp) {
    cfg.re = dates;
  } else {
    if (!Ext.isArray(dates)) {
      dates = [dates];
    }
    for (i = 0, len = dates.length; i < len; i++) {
      item = dates[i];
      if (item instanceof Date) {
        item = Ext.Date.clearTime(item);
        cfg.dates[item.getTime()] = true;
      } else {
        if (item instanceof RegExp) {
          re.push(item.source);
        } else {
          re.push(Ext.String.escapeRegex(item));
        }
      }
    }
    if (re.length) {
      cfg.re = new RegExp('(?:' + re.join('|') + ')');
    }
  }
  return cfg;
}, updateDisabledDates:function() {
  this.refreshPanes();
}, applyDisabledDays:function(days) {
  return days ? Ext.Array.toMap(days) : days;
}, updateDisabledDays:function() {
  this.refreshPanes();
}, updateFormat:function(format) {
  this.broadcastConfig('format', format);
}, updateHeader:function(header, oldHeader) {
  this.callParent([header, oldHeader]);
  header.getTitle().on({scope:this, yeartap:'onYearTitleTap', titletap:'onTitleTap'});
}, applyMaxDate:function(date) {
  if (typeof date === 'string') {
    date = Ext.Date.parse(date, this.getFormat());
  }
  return date;
}, updateMaxDate:function() {
  this.refreshPanes();
}, applyMinDate:function(date) {
  if (typeof date === 'string') {
    date = Ext.Date.parse(date, this.getFormat());
  }
  return date;
}, updateMinDate:function() {
  this.refreshPanes();
}, updateNavigationPosition:function(pos) {
  var me = this, toolList = me.toolList, len = toolList.length, isHeader = pos === 'header', ct = isHeader ? me.toolCt : me.getHeader(), tools, i, c;
  if (isHeader && me.isConfiguring) {
    return;
  }
  me.getTools();
  tools = [];
  for (i = 0; i < len; ++i) {
    c = me.lookup(toolList[i]);
    if (c) {
      tools.push(c);
      ct.remove(c, false);
      c.toggleCls(me.toolCls, isHeader);
    }
  }
  me.toolCt = Ext.destroy(me.toolCt);
  if (pos === 'header') {
    me.getHeader().add(tools);
  } else {
    tools.push({xtype:'component', flex:1, weight:0});
    me.toolCt = me.add({xtype:'container', cls:Ext.baseCSSPrefix + 'navigation-tools', defaultType:'tool', weighted:true, layout:'hbox', bottom:'auto', items:tools});
  }
}, updateNextText:function(text) {
  this.setToolText('navigateNextMonth', text);
}, updatePrevText:function(text) {
  this.setToolText('navigatePrevMonth', text);
}, applyPanes:function(count) {
  if (count < 1) {
    Ext.raise('Cannot configure less than 1 pane for Calendar picker');
  }
  return count;
}, updatePanes:function(count) {
  var me = this;
  me.getLayout().setVisibleChildren(count);
  me.initPanes(0);
  me.singlePane = count === 1;
  me.toggleCls(Ext.baseCSSPrefix + 'single', me.singlePane);
}, updateShowFooter:function(showFooter) {
  this.lookup('footer').setHidden(!showFooter);
  this.getShowTodayButton();
}, updateShowTodayButton:function(showButton) {
  var footerBtn;
  this.getButtons();
  footerBtn = this.lookup('footerTodayButton');
  if (footerBtn) {
    footerBtn.setHidden(!showButton);
  }
}, applySpecialDates:function(dates) {
  return this.applyDisabledDates(dates);
}, updateSpecialDates:function(cfg) {
  this.broadcastConfig('specialDates', cfg);
}, applySpecialDays:function(days) {
  return days ? Ext.Array.toMap(days) : days;
}, updateSpecialDays:function(daysMap) {
  this.broadcastConfig('specialDays', daysMap);
}, updateSplitTitle:function(splitTitle) {
  this.getHeader().getTitle().setSplit(splitTitle);
}, updateStartDay:function(day) {
  this.broadcastConfig('startDay', day);
}, applyValue:function(date) {
  if (typeof date === 'string') {
    date = Ext.Date.parse(date, this.getFormat());
  } else {
    if (!date) {
      date = new Date;
    }
  }
  return Ext.isDate(date) ? Ext.Date.clearTime(date, true) : null;
}, updateValue:function(value, oldValue) {
  var me = this, handler = me.getHandler(), selectedCls = me.selectedCls, cell;
  if (oldValue) {
    cell = me.getCellByDate(oldValue);
    if (cell) {
      Ext.fly(cell).removeCls(selectedCls);
    }
  }
  if (!me.isConfiguring) {
    if (me.hasFocus) {
      me.focusDate(value);
    } else {
      me.setFocusableDate(value);
    }
    cell = me.getCellByDate(value);
    if (cell) {
      Ext.fly(cell).addCls(selectedCls);
    }
    me.setTitleByDate(value);
    me.fireEvent('change', me, value, oldValue);
    if (handler) {
      Ext.callback(handler, me.scope, [me, value, oldValue]);
    }
  }
}, applyWeekendDays:function(days) {
  return Ext.Array.toMap(days);
}, updateWeekendDays:function(daysMap) {
  this.broadcastConfig('weekendDays', daysMap);
}, applyYearPicker:function(yearPicker, oldYearPicker) {
  return Ext.updateWidget(oldYearPicker, yearPicker, this, 'createYearPicker', 'yearPickerDefaults');
}, updateYearPicker:function(yearPicker) {
  if (yearPicker) {
    this.add(yearPicker);
  }
}, replacePanes:function(increment, animate) {
  var me = this, panes, cb, direction, ret;
  if (me.destroying || me.destroyed) {
    return;
  }
  panes = me.getLayout().getVisibleItems();
  cb = function() {
    var pane, offset, j, jlen;
    for (j = 0, jlen = panes.length; j < jlen; j++) {
      pane = panes[j];
      offset = pane.getMonthOffset();
      pane.setMonthOffset(offset + increment);
    }
  };
  if (animate == null) {
    animate = me.getAnimation();
  }
  if (animate) {
    direction = increment < 0 ? 'up' : 'down';
    ret = me.animateVertical(me.carouselElement, direction, 0, cb, 'animBody');
  } else {
    cb();
    ret = Ext.Deferred.getCachedResolved();
  }
  return ret;
}, initPanes:function(offset) {
  var me = this, count = me.getPanes() + 2, panes = [], oldPanes, index, center, i;
  index = count - 1;
  center = !index ? index : index % 2 ? Math.floor(index / 2) + 1 : Math.floor(index / 2);
  for (i = 0; i < count; i++) {
    panes.push(me.getPaneTemplate(i + offset - center));
  }
  oldPanes = me.getInnerItems();
  for (i = 0; i < oldPanes.length; i++) {
    me.remove(oldPanes[i], true);
  }
  me.add(panes);
  me.getLayout().setFrontItem(center, false);
}, getPaneByDate:function(date) {
  var me = this, panes = me.getInnerItems(), month, pane, i, len;
  month = Ext.Date.getFirstDateOfMonth(date);
  for (i = 0, len = panes.length; i < len; i++) {
    pane = panes[i];
    if (Ext.Date.isEqual(pane.getMonth(), month)) {
      return pane;
    }
  }
  return null;
}, getCellByDate:function(date) {
  var pane = this.getPaneByDate(date);
  return pane ? pane.getCellByDate(date) : null;
}, updateCellTabIndex:function(date, tabIndex) {
  var cell = date && this.getCellByDate(date);
  if (cell) {
    Ext.fly(cell).setTabIndex(tabIndex);
  }
  return cell;
}, canSwitchTo:function(date, offset) {
  var me = this, boundary, prevent;
  if (offset < 0) {
    boundary = me.getMinDate();
    prevent = !me.getShowBeforeMinDate();
    if (boundary && prevent) {
      if (date.getTime() < Ext.Date.getFirstDateOfMonth(boundary).getTime()) {
        return false;
      }
    }
  } else {
    if (offset > 0) {
      boundary = me.getMaxDate();
      prevent = !me.getShowAfterMaxDate();
      if (boundary && prevent) {
        if (date.getTime() > Ext.Date.getLastDateOfMonth(boundary).getTime()) {
          return false;
        }
      }
    }
  }
  return true;
}, navigateTo:function(date, animate) {
  var me = this, layout = me.getLayout(), month, increment, boundary, prevent;
  if (date.getTime() < (month = layout.getFirstVisibleItem().getMonth()).getTime()) {
    boundary = month;
  } else {
    if (date.getTime() > (month = layout.getLastVisibleItem().getMonth()).getTime()) {
      boundary = month;
    } else {
      boundary = date;
    }
  }
  increment = date.getFullYear() * 12 + date.getMonth() - (boundary.getFullYear() * 12 + boundary.getMonth());
  if (increment < 0) {
    boundary = me.getMinDate();
    prevent = !me.getShowBeforeMinDate();
    if (boundary && prevent) {
      if (date.getTime() < Ext.Date.getFirstDateOfMonth(boundary).getTime()) {
        increment = 0;
      }
    }
  } else {
    if (increment > 0) {
      boundary = me.getMaxDate();
      prevent = !me.getShowAfterMaxDate();
      if (boundary && prevent) {
        if (date.getTime() > Ext.Date.getLastDateOfMonth(boundary).getTime()) {
          increment = 0;
        }
      }
    }
  }
  return me.navigateByIncrement(increment, animate, 0);
}, switchPanes:function(increment, animate) {
  var me = this, layout = me.getLayout(), edgePane, pane;
  edgePane = increment < 0 ? layout.getFirstVisibleItem() : layout.getLastVisibleItem();
  pane = layout.getEdgeItem(increment);
  pane.setMonthOffset(edgePane.getMonthOffset() + increment);
  return layout.move(increment, animate);
}, onMonthToolClick:function(tool) {
  var me = this, panes = me.getInnerItems(), D = Ext.Date, increment = tool.increment, date = D.add(me.getFocusableDate(), D.MONTH, increment), hasFocus = me.hasFocus, index, pane, month;
  index = me.getCenterIndex();
  pane = panes[index];
  month = D.add(pane.getMonth(), D.MONTH, increment);
  if (!me.canSwitchTo(month, increment)) {
    return;
  }
  me.navIncrement = me.singlePane ? 0 : increment;
  if (hasFocus || me.getSelectOnNavigate()) {
    me.setValue(date);
  } else {
    me.doFocus = hasFocus;
    me.setFocusableDate(date);
    me.doFocus = false;
  }
  me.navIncrement = 0;
}, onDateClick:function(e) {
  var me = this, cell = e.getTarget(me.cellSelector, me.bodyElement), date = cell && cell.date, focus = true, disabled = cell && cell.disabled;
  if (!date || me.getDisabled()) {
    return;
  }
  if (!disabled) {
    me.setValue(date);
    if (me.getAutoConfirm()) {
      if (e.pointerType === 'touch') {
        e.preventDefault();
      }
      focus = false;
      me.fireEvent('select', me, date);
    }
  }
  if (focus) {
    me.focusDate(date);
  }
}, onMouseWheel:function(e) {
  var dy = e.browserEvent.deltaY;
  if (dy && !this.pickerVisible) {
    this.onMonthToolClick({increment:Math.sign(dy)});
  }
}, onOkButtonClick:function() {
  this.setValue(this.getFocusableDate());
}, onCancelButtonClick:function() {
  this.fireEventArgs('tabout', [this]);
}, onTodayButtonClick:function() {
  var me = this, offset;
  offset = me.getLayout().getFrontItem().getMonthOffset();
  if (offset !== 0) {
    if (Math.abs(offset) === 1) {
      me.switchPanes(-offset);
    } else {
      me.replacePanes(-offset);
    }
  }
  me.setValue(Ext.Date.clearTime(new Date));
}, getFocusEl:function() {
  if (!this.initialized) {
    return null;
  }
  return this.getCellByDate(this.getFocusableDate());
}, onLeftArrowKey:function(e) {
  this.walkCells(e.target.date, e.ctrlKey ? Ext.Date.MONTH : Ext.Date.DAY, -1);
  e.preventDefault();
}, onRightArrowKey:function(e) {
  this.walkCells(e.target.date, e.ctrlKey ? Ext.Date.MONTH : Ext.Date.DAY, 1);
  e.preventDefault();
}, onUpArrowKey:function(e) {
  this.walkCells(e.target.date, Ext.Date.DAY, -7);
  e.preventDefault();
}, onDownArrowKey:function(e) {
  this.walkCells(e.target.date, Ext.Date.DAY, 7);
  e.preventDefault();
}, onPageUpKey:function(e) {
  var unit = e.ctrlKey || e.shiftKey ? Ext.Date.YEAR : Ext.Date.MONTH;
  this.walkCells(e.target.date, unit, -1);
  e.preventDefault();
}, onPageDownKey:function(e) {
  var unit = e.ctrlKey || e.shiftKey ? Ext.Date.YEAR : Ext.Date.MONTH;
  this.walkCells(e.target.date, unit, 1);
  e.preventDefault();
}, onHomeKey:function(e) {
  this.walkCells(Ext.Date.getFirstDateOfMonth(e.target.date));
  e.preventDefault();
}, onEndKey:function(e) {
  this.walkCells(Ext.Date.getLastDateOfMonth(e.target.date));
  e.preventDefault();
}, onBackspaceKey:function(e) {
  this.walkCells(new Date);
  e.preventDefault();
}, onEnterKey:function(e) {
  var target = e.target, date = target && target.date;
  if (date && !target.disabled) {
    this.setValue(date);
    this.fireEvent('select', this, target.date);
  }
}, onSpaceKey:function(e) {
  this.onEnterKey(e);
  e.preventDefault();
}, onTabKey:function(e) {
  this.handleTabKey(e);
  return true;
}, handleTabKey:function(e) {
  var me = this, target = e.target, picker = me.pickerField;
  if (!me.getDisabled() && me.getAutoConfirm() && target && target.date && !target.disabled) {
    me.setValue(target.date);
    if (picker && picker.isEditorComponent) {
      e.preventDefault();
    }
  } else {
    me.fireEventArgs('tabout', [me]);
  }
}, walkCells:function(date, unit, increment) {
  var me = this, newDate;
  if (!me.getDisabled()) {
    date = me.getFocusableDate();
    newDate = unit ? Ext.Date.add(date, unit, increment) : date;
    if (me.isDateDisabled(newDate)) {
      me.focusDate(newDate);
    } else {
      me.setValue(newDate);
    }
  }
}, onBodyFocus:function(e) {
  var me = this, date = me.getFocusableDate(), cell = me.getCellByDate(date);
  if (!cell) {
    me.navigateTo(date, false);
  }
  cell = me.updateCellTabIndex(date, me.getTabIndex());
  cell.focus();
}, getTabIndex:function() {
  return this.getConfig('tabIndex', true);
}, getFocusClsEl:function() {
  return this.bodyElement;
}, onFocusEnter:function(e) {
  if (this.bodyElement.contains(e.target)) {
    this.onFocus(e);
  }
  this.callParent([e]);
}, onFocusLeave:function(e) {
  this.onBlur(e);
  this.callParent([e]);
}, privates:{cellSelector:'.' + Ext.baseCSSPrefix + 'cell', clonedCls:Ext.baseCSSPrefix + 'cloned', lastNavigate:0, hideFocusCls:Ext.baseCSSPrefix + 'hide-focus', selectedCls:Ext.baseCSSPrefix + 'selected', toolList:['navigatePrevMonth', 'navigatePrevYear', 'navigateNextYear', 'navigateNextMonth'], paneWidthMap:{}, pickerVisible:false, applyFocusableDate:function(date) {
  var me = this, D = Ext.Date, boundary;
  if (date) {
    date = D.clearTime(date || new Date);
    if ((boundary = me.getMinDate()) && !me.getShowBeforeMinDate() && date.getTime() < boundary.getTime()) {
      date = boundary;
    } else {
      if ((boundary = me.getMaxDate()) && !me.getShowAfterMaxDate() && date.getTime() > boundary.getTime()) {
        date = boundary;
      }
    }
  }
  return date;
}, updateFocusableDate:function(date, oldDate) {
  var me = this, focus = me.doFocus, layout = me.getLayout(), cls = me.hideFocusCls, increment = me.navIncrement, visibleItems, toPane, anim, navigate, oldCell, p;
  if (me.destroying || me.destroyed) {
    return;
  }
  if (oldDate) {
    oldCell = me.getCellByDate(oldDate);
    me.updateCellTabIndex(oldDate, -1);
  }
  if (date) {
    toPane = me.getPaneByDate(date);
    if (!me.preventAnim) {
      anim = me.getAnimation();
    }
    visibleItems = layout.getVisibleItems();
    me.lastNavigate = navigate = Date.now();
    if (!increment && (!anim || visibleItems.indexOf(toPane) > -1)) {
      me.navigateTo(date, false);
      if (focus) {
        me.getCellByDate(date).focus();
      }
    } else {
      if (oldCell) {
        Ext.fly(oldCell).addCls(cls);
      }
      p = increment ? me.navigateByIncrement(increment) : me.navigateTo(date);
      p.then(function() {
        oldCell = me.getCellByDate(oldDate);
        if (oldCell) {
          Ext.fly(oldCell).removeCls(cls);
        }
        if (focus && me.lastNavigate === navigate) {
          me.getCellByDate(date).focus();
        }
      });
    }
    me.updateCellTabIndex(date, me.getTabIndex());
  }
}, animateVertical:function(el, direction, offset, beforeFn, prop) {
  var me = this, clone = el.dom.cloneNode(true), ret = new Ext.Deferred;
  clone.id = '';
  Ext.fly(clone).addCls(me.clonedCls);
  el.parent().appendChild(clone);
  if (beforeFn) {
    beforeFn();
  }
  Ext.destroy(me[prop]);
  me[prop] = Ext.Animator.run([{offset:offset, type:'slide', direction:direction, element:el}, {offset:offset, type:'slideOut', direction:direction, element:clone, callback:function() {
    Ext.fly(clone).destroy();
    me[prop] = null;
    ret.resolve();
  }}]);
  return ret.promise;
}, broadcastConfig:function(config, value) {
  if (this.isConfiguring) {
    return;
  }
  var panes = this.getInnerItems(), setter, pane, i, len;
  setter = Ext.Config.get(config).names.set;
  for (i = 0, len = panes.length; i < len; i++) {
    pane = panes[i];
    if (pane[setter]) {
      pane[setter](value);
    }
  }
}, createYearPicker:function(config) {
  return Ext.apply({xtype:'yearpicker', hidden:true, top:0, right:0, bottom:0, left:0, listeners:{yeartap:'onYearPickerTap'}}, config);
}, getCenterIndex:function() {
  var count = this.getPanes(), index = count - 1;
  return !index ? index : index % 2 ? Math.floor(index / 2) + 1 : Math.floor(index / 2);
}, getPaneTemplate:function(offset) {
  var me = this;
  return {xtype:me.paneXtype, monthOffset:offset, hideOutside:me.getHideOutside(), hideCaption:me.getHideCaptions(), startDay:me.getStartDay(), weekendDays:me.getWeekendDays(), specialDates:me.getSpecialDates(), specialDays:me.getSpecialDays(), format:me.getFormat(), captionFormat:me.getCaptionFormat(), dateCellFormat:me.getDateCellFormat(), headerLength:me.getHeaderLength(), transformCellCls:me.transformCellCls};
}, getPositionedItemTarget:function() {
  return this.bodyElement;
}, isDateDisabled:function(date) {
  var me = this, ms = date.getTime(), minDate = me.getMinDate(), maxDate = me.getMaxDate(), disabled = false, disabledDays, disabledDates, formatted, re;
  disabled = minDate && ms < minDate.getTime() || maxDate && ms > maxDate.getTime();
  if (!disabled) {
    disabledDays = me.getDisabledDays();
    if (disabledDays) {
      disabled = disabledDays[date.getDay()];
    }
  }
  if (!disabled) {
    disabledDates = me.getDisabledDates();
    if (disabledDates) {
      disabled = disabledDates.dates[ms];
      re = disabledDates.re;
      if (!disabled && re) {
        formatted = Ext.Date.format(date, me.getFormat());
        disabled = re.test(formatted);
      }
    }
  }
  return !!disabled;
}, measurePaneSize:function() {
  var me = this, count = me.getPanes(), ui = me.getUi() || 'default', map = me.paneWidthMap, borderWidth;
  if (!map.hasOwnProperty(ui)) {
    map[ui] = this.getLayout().getFrontItem().measurePaneSize();
  }
  borderWidth = me.el.getBorderWidth('lr');
  me.setWidth(borderWidth + count * map[ui]);
}, navigateByIncrement:function(increment, animate) {
  var ret;
  if (Math.abs(increment) === 1) {
    ret = this.switchPanes(increment, animate);
  } else {
    if (increment !== 0) {
      ret = this.replacePanes(increment, animate);
    } else {
      if (!animate) {
        this.getLayout().cancelAnimation();
        ret = Ext.Deferred.getCachedResolved();
      }
    }
  }
  return ret;
}, onTitleTap:function() {
  var visible;
  if (this.getSplitTitle()) {
    visible = false;
  } else {
    visible = !this.pickerVisible;
  }
  this.toggleYearPicker(visible);
}, onYearPickerTap:function(picker, year) {
  this.toggleYearPicker(false);
  var d = Ext.Date.clone(this.getFocusableDate());
  d.setFullYear(year);
  this.setValue(d);
}, onYearTitleTap:function() {
  this.toggleYearPicker(!this.pickerVisible);
}, refreshPanes:function() {
  if (this.isConfiguring) {
    return;
  }
  var panes = this.getPanes(), len = panes.length, i;
  for (i = 0; i < len; ++i) {
    panes[i].refresh();
  }
}, setTitleByDate:function(date) {
  var me = this, prev = me.lastTitleDate, anim;
  if (prev && prev.getTime() === date.getTime()) {
    anim = false;
  }
  me.setTitleText(Ext.Date.format(date, me.getHeaderFormat()), date, prev, anim);
  me.lastTitleDate = date;
}, setTitleText:function(text, date, oldDate, animate) {
  var me = this, title, direction, titleAnim;
  if (me.destroying || me.destroyed) {
    return;
  }
  if (animate === undefined) {
    titleAnim = me.getTitleAnimation();
    if (titleAnim !== null) {
      animate = titleAnim;
    } else {
      animate = me.getAnimation();
    }
  }
  animate = me.rendered ? animate : false;
  title = me.getHeader().getTitle();
  if (animate) {
    if (me.getSplitTitle()) {
      Ext.raise('Animation is not supported with title split');
    }
    direction = (oldDate || date).getTime() < date.getTime() ? 'bottom' : 'top';
    me.animateVertical(title.textElement, direction, '150%', function() {
      title.setText(text);
    }, 'animTitle');
  } else {
    if (me.getSplitTitle()) {
      title.setYear(date.getFullYear());
      title.setText(text);
    } else {
      title.setText(text);
    }
  }
}, setToolText:function(type, text) {
  var tool = this.lookup(type);
  if (tool) {
    tool.setTooltip(text);
  }
}, toggleYearPicker:function(visible) {
  var me = this, picker = me.getYearPicker();
  if (picker) {
    if (me.getSplitTitle()) {
      me.getHeader().getTitle().setTitleActive(!visible);
    }
    picker.setHidden(!visible);
    if (visible) {
      picker.focusYear(me.getFocusableDate().getFullYear());
    }
    me.pickerVisible = visible;
  }
}}});
Ext.define('Ext.theme.neptune.panel.Date', {override:'Ext.panel.Date', border:true});
Ext.define('Ext.theme.material.panel.Date', {override:'Ext.panel.Date', config:{headerFormat:'D, M j', hideCaptions:false, hideOutside:true, navigationPosition:'caption', selectOnNavigate:false, showTodayButton:false, splitTitle:true, titleAnimation:false, tools:{previousYear:null, nextYear:null}}});
Ext.define('Ext.field.Date', {extend:Ext.field.Picker, alternateClassName:['Ext.form.DatePicker', 'Ext.field.DatePicker'], xtype:['datefield', 'datepickerfield'], config:{destroyPickerOnHide:false, dateFormat:'', minDate:null, maxDate:null, triggers:{expand:{type:'date'}}}, classCls:Ext.baseCSSPrefix + 'datepickerfield', matchFieldWidth:false, minDateMessage:'The date in this field must be equal to or after {0}', maxDateMessage:'The date in this field must be equal to or before {0}', floatedPicker:{xtype:'datepanel', 
autoConfirm:true, floated:true, listeners:{tabout:'onTabOut', select:'onPickerChange', scope:'owner'}, keyMap:{ESC:'onTabOut', scope:'owner'}}, edgePicker:{xtype:'datepicker', cover:true}, parseValidator:'date', applyValue:function(value, oldValue) {
  if (!(value || value === 0)) {
    value = null;
  }
  value = this.callParent([value, oldValue]);
  if (value) {
    if (this.isConfiguring) {
      this.originalValue = value;
    }
    if (Ext.isDate(value) && Ext.isDate(oldValue) && value.getTime() === oldValue.getTime()) {
      return;
    }
  }
  return value;
}, updateValue:function(value, oldValue) {
  var picker = this._picker;
  if (picker && picker.isPicker && Ext.isDate(value)) {
    this.updatePickerValue(picker, value);
  }
  this.callParent([value, oldValue]);
}, updatePickerValue:function(picker, value) {
  picker.setValue(value);
}, applyInputValue:function(value, oldValue) {
  if (Ext.isDate(value)) {
    value = Ext.Date.format(value, this.getDateFormat());
  }
  return this.callParent([value, oldValue]);
}, applyDateFormat:function(dateFormat) {
  return dateFormat || Ext.util.Format.defaultDateFormat;
}, updateDateFormat:function() {
  var me = this, value;
  if (!me.isConfiguring && !me.hasFocus) {
    value = me.getValue();
    if (Ext.isDate(value)) {
      me.setInputValue(value);
    }
  }
}, applyMinDate:function(minDate) {
  if (typeof minDate === 'string') {
    minDate = Ext.Date.parse(minDate, this.getDateFormat());
  }
  if (!Ext.isDate(minDate)) {
    Ext.raise('Date object or string in dateFormat required');
  }
  return Ext.Date.clearTime(minDate, true);
}, applyMaxDate:function(maxDate) {
  if (typeof maxDate === 'string') {
    maxDate = Ext.Date.parse(maxDate, this.getDateFormat());
  }
  if (!Ext.isDate(maxDate)) {
    Ext.raise('Date object or string in dateFormat required');
  }
  return Ext.Date.clearTime(maxDate, true);
}, getFormattedValue:function(format) {
  var value = this.getValue();
  return Ext.isDate(value) ? Ext.Date.format(value, format || this.getDateFormat()) : '';
}, applyPicker:function(picker, oldPicker) {
  var me = this;
  picker = me.callParent([picker, oldPicker]);
  if (picker) {
    me.pickerType = picker.xtype === 'datepicker' ? 'edge' : 'floated';
    picker.ownerCmp = me;
  }
  return picker;
}, createFloatedPicker:function() {
  return this.getFloatedPicker();
}, createEdgePicker:function() {
  var me = this, minDate = this.getMinDate(), maxDate = this.getMaxDate();
  return Ext.merge({yearFrom:minDate ? minDate.getFullYear() : (new Date).getFullYear() - 20, yearTo:maxDate ? maxDate.getFullYear() : (new Date).getFullYear() + 20}, me.getEdgePicker());
}, setPickerLocation:function(fromKeyboard) {
  var me = this, pickerType = me.pickerType, picker = me.getPicker(), value = me.getValue(), limit;
  me.$ignorePickerChange = true;
  if (value != null) {
    picker.setValue(value);
  } else {
    if (pickerType === 'edge') {
      picker.setValue(new Date);
    }
  }
  delete me.$ignorePickerChange;
  if (pickerType === 'floated') {
    picker.el.dom.tabIndex = -1;
    limit = me.getMinDate();
    if (limit) {
      picker.setMinDate(limit);
    }
    limit = me.getMaxDate();
    if (limit) {
      picker.setMaxDate(limit);
    }
    value = value || new Date;
    picker.navigateTo(value, false);
    if (fromKeyboard) {
      picker.focusDate(value);
    }
  }
}, doValidate:function(value, errors, skipLazy) {
  var me = this, format = me.getDateFormat(), limit, t;
  me.callParent([value, errors, skipLazy]);
  limit = me.getMinDate();
  t = +value;
  if (limit && t < +limit) {
    limit = Ext.Date.format(limit, format);
    errors.push(Ext.String.format(me.minDateMessage, limit));
  }
  limit = me.getMaxDate();
  if (limit && t > +limit) {
    limit = Ext.Date.format(limit, format);
    errors.push(Ext.String.format(me.maxDateMessage, limit));
  }
}, onPickerChange:function(picker, value) {
  var me = this;
  if (me.$ignorePickerChange) {
    return;
  }
  me.forceInputChange = true;
  me.setValue(value);
  me.forceInputChange = false;
  me.fireEvent('select', me, value);
  me.onTabOut(picker);
}, onTabOut:function() {
  this.collapse();
}, parseValue:function(value, errors) {
  var date;
  if (value) {
    date = Ext.Date.parse(value, this.getDateFormat());
    if (date !== null) {
      return date;
    }
  }
  return this.callParent([value, errors]);
}, transformValue:function(value) {
  if (Ext.isObject(value)) {
    value = new Date(value.year, value.month, value.day);
    if (isNaN(value.getTime())) {
      value = null;
    }
  }
  return value;
}, doDestroy:function() {
  var picker = this._picker;
  if (picker && picker.isPicker) {
    picker.destroy();
  }
  this.callParent();
}, privates:{setShowPickerValue:function(picker) {
  this.updatePickerValue(picker, this.getValue() || new Date);
}}, deprecated:{'6.5':{configs:{format:'dateFormat'}}}});
Ext.define('Ext.theme.material.field.Date', {override:'Ext.field.Date', config:{floatedPicker:{selectOnNavigate:true, header:{hidden:true}}}});
Ext.define('Ext.field.Display', {extend:Ext.field.Field, xtype:'displayfield', alternateClassName:'Ext.form.Display', submitValue:false, validateOnChange:false, focusable:false, readOnly:true, config:{encodeHtml:true, renderer:null}, classCls:Ext.baseCSSPrefix + 'displayfield', initialize:function() {
  this.callParent();
  this.syncDom();
}, getBodyTemplate:function() {
  return [{reference:'inputElement', cls:Ext.baseCSSPrefix + 'input-el'}];
}, updateValue:function(newValue, oldValue) {
  this.callParent([newValue, oldValue]);
  this.syncDom();
}, updateHtmlEncode:function() {
  this.syncDom();
}, updateRenderer:function() {
  this.syncDom();
}, validate:Ext.returnTrue, isValid:Ext.returnTrue, privates:{getDisplayValue:function() {
  var me = this, value = Ext.valueFrom(me.getValue(), ''), renderer = me.getRenderer();
  if (renderer) {
    value = Ext.callback(renderer, me.scope, [value, me], 0, me);
  }
  return value;
}, syncDom:function() {
  var me = this, dom = me.inputElement.dom, value;
  if (!me.isConfiguring) {
    value = me.getDisplayValue();
    if (me.getEncodeHtml()) {
      dom.textContent = value;
    } else {
      dom.innerHTML = value;
    }
  }
}}});
Ext.define('Ext.field.Number', {extend:Ext.field.Text, xtype:'numberfield', alternateClassName:'Ext.form.Number', config:{minValue:null, maxValue:null, decimals:2, trim:true}, inputType:Ext.os.is.Desktop ? 'text' : 'number', minValueText:'The minimum value for this field is {0}', maxValueText:'The maximum value for this field is {0}', decimalsText:'The maximum decimal places is {0}', badFormatMessage:'Value is not a valid number', classCls:Ext.baseCSSPrefix + 'numberfield', parseValidator:'number', 
initialize:function() {
  this.getDecimals();
  this.callParent();
  this.inputElement.dom.setAttribute('inputmode', 'numeric');
  if (this.getInputMask()) {
    Ext.raise('NumberFields cannot use input masks');
  }
}, updateDecimals:function(decimals) {
  var me = this, format = '0', zeroChar = me.getTrim() ? '#' : '0', value;
  if (decimals) {
    format += '.' + Ext.String.repeat(zeroChar, decimals);
  }
  me.numberFormat = format;
  if (!me.isConfiguring) {
    value = me.getValue();
    if (Ext.isDate(value)) {
      me.setInputValue(value);
    }
  }
}, applyInputValue:function(value) {
  this.getDecimals();
  if (typeof value === 'number') {
    value = Ext.util.Format.number(value, this.numberFormat);
  }
  return value;
}, doValidate:function(value, errors, skipLazy) {
  var me = this, String = Ext.String, minValue = me.getMinValue(), maxValue = me.getMaxValue();
  me.callParent([value, errors, skipLazy]);
  if (minValue != null && value < minValue) {
    errors.push(String.format(me.minValueText, minValue));
  } else {
    if (maxValue != null && value > maxValue) {
      errors.push(String.format(me.maxValueText, maxValue));
    }
  }
}, onKeyDown:function(e) {
  var me = this, raw;
  if (me.getInputType() !== 'number') {
    if (!e.ctrlKey && !e.altKey) {
      raw = me.calculateNewValue(e.key());
      if (!me.specialKeys[e.getCharCode()] && !me.isAllowableValue(raw)) {
        e.preventDefault();
        return false;
      }
    }
  }
  me.callParent([e]);
}, transformValue:function(value) {
  if (!(value || value === 0)) {
    value = null;
  }
  return value;
}, privates:{calculateNewValue:function(text) {
  var me = this, textSelection = me.getTextSelection(), raw = me.getInputValue();
  if (textSelection[1]) {
    raw = raw.substr(0, textSelection[0]) + text + raw.substr(textSelection[1]);
  } else {
    raw = Ext.String.insert(raw, text, me.getCaretPos());
  }
  return raw;
}, handlePaste:function(e) {
  var me = this, text;
  if (me.getInputType() !== 'number') {
    text = e.getClipboardData('text/plain');
    if (text) {
      text = me.calculateNewValue(text);
      if (me.isAllowableValue(text)) {
        me.setValue(text);
      }
      e.preventDefault();
      return false;
    }
  }
  me.callParent([e]);
  me.validate();
}, isAllowableValue:function(value) {
  var minValue = this.getMinValue(), allowNegative = minValue == null || minValue < 0;
  if (!allowNegative && Ext.String.startsWith(value, '-')) {
    return false;
  }
  return this.isPartialValue(value) || this.parseValue(value) !== null;
}, isPartialValue:function(value) {
  var me = this, minValue = me.getMinValue(), allowNegative = minValue == null || minValue < 0;
  if (allowNegative && value === '-') {
    return true;
  }
  if (me.getDecimals() && (value === '.' || allowNegative && value === '-.')) {
    return true;
  }
  return false;
}}}, function(C) {
  var E = Ext.event.Event;
  C.prototype.specialKeys = Ext.Array.toMap([E.BACKSPACE, E.TAB, E.RETURN, E.CTRL, E.DELETE, E.LEFT, E.RIGHT, E.UP, E.DOWN, E.HOME, E.END, E.META]);
});
Ext.define('Ext.form.Borders', {mixinId:'formborders', config:{fieldSeparators:null, inputBorders:null}, fieldSeparatorsCls:Ext.baseCSSPrefix + 'form-field-separators', noInputBordersCls:Ext.baseCSSPrefix + 'form-no-input-borders', updateFieldSeparators:function(fieldSeparators, oldFieldSeparators) {
  var bodyElement = this.bodyElement, cls = this.fieldSeparatorsCls;
  if (fieldSeparators) {
    bodyElement.addCls(cls);
  } else {
    if (oldFieldSeparators) {
      bodyElement.removeCls(cls);
    }
  }
}, updateInputBorders:function(inputBorders, oldInputBorders) {
  var bodyElement = this.bodyElement, cls = this.noInputBordersCls;
  if (inputBorders === false) {
    bodyElement.addCls(cls);
  } else {
    if (oldInputBorders === false) {
      bodyElement.removeCls(cls);
    }
  }
}});
Ext.define('Ext.theme.material.form.Borders', {override:'Ext.form.Borders', config:{fieldSeparators:false, inputBorders:true}});
Ext.define('Ext.field.Panel', {extend:Ext.Panel, xtype:'fieldpanel', mixins:[Ext.field.Manager, Ext.form.Borders], scrollable:true, nameable:true, shareableName:true, nameHolder:true, config:{api:null, baseParams:null, paramOrder:null, paramsAsHash:null, timeout:30, url:null}, load:function(options) {
  options = options || {};
  var me = this, api = me.getApi(), url = options.url || me.getUrl(), waitMsg = options.waitMsg, successFn = function(response, data) {
    me.setValues(data.data);
    if (Ext.isFunction(options.success)) {
      options.success.call(options.scope || me, me, response, data);
    }
    me.fireEvent('load', me, response);
  }, failureFn = function(response, data) {
    if (Ext.isFunction(options.failure)) {
      options.failure.call(options.scope, me, response, data);
    }
    me.fireEvent('exception', me, response);
  }, load, args;
  if (options.waitMsg) {
    if (typeof waitMsg === 'string') {
      waitMsg = {xtype:'loadmask', message:waitMsg};
    }
    me.setMasked(waitMsg);
  }
  if (api) {
    api = Ext.direct.Manager.resolveApi(api, me);
    me.setApi(api);
    load = api.load;
    if (!load) {
      Ext.raise('Cannot find Ext Direct API method for load action');
    }
    args = load.$directCfg.method.getArgs({params:me.getParams(options.params), paramOrder:me.getParamOrder(), paramsAsHash:me.getParamsAsHash(), scope:me, callback:function(data, response, success) {
      me.setMasked(false);
      if (success) {
        successFn(response, data);
      } else {
        failureFn(response, data);
      }
    }});
    load.apply(window, args);
  } else {
    if (url) {
      return Ext.Ajax.request({url:url, timeout:(options.timeout || me.getTimeout()) * 1000, method:options.method || 'GET', autoAbort:options.autoAbort, headers:Ext.apply({'Content-Type':'application/x-www-form-urlencoded; charset\x3dUTF-8'}, options.headers || {}), callback:function(callbackOptions, success, response) {
        var responseText = response.responseText, statusResult = Ext.data.request.Ajax.parseStatus(response.status, response);
        me.setMasked(false);
        if (success) {
          if (statusResult && responseText.length === 0) {
            success = true;
          } else {
            response = Ext.decode(responseText);
            success = !!response.success;
          }
          if (success) {
            successFn(response, responseText);
          } else {
            failureFn(response, responseText);
          }
        } else {
          failureFn(response, responseText);
        }
      }});
    }
  }
}, getParams:function(params) {
  return Ext.apply({}, params, this.getBaseParams());
}, updateDisabled:function(newDisabled, oldDisabled) {
  this.mixins.fieldmanager.updateDisabled.call(this, newDisabled, oldDisabled);
  this.callParent([newDisabled, oldDisabled]);
}, updateRecord:function(record) {
  this.consumeRecord(record);
}});
Ext.define('Ext.field.trigger.Reveal', {extend:Ext.field.trigger.Trigger, xtype:'revealtrigger', alias:'trigger.reveal', classCls:Ext.baseCSSPrefix + 'revealtrigger', weight:-1000, hidden:true, handler:'onRevealTap', scope:'this'});
Ext.define('Ext.field.Password', {extend:Ext.field.Text, xtype:'passwordfield', alternateClassName:'Ext.form.Password', config:{autoCapitalize:false, revealable:false, revealed:{$value:false, lazy:true}}, inputType:'password', classCls:Ext.baseCSSPrefix + 'passwordfield', revealedCls:Ext.baseCSSPrefix + 'revealed', isPassword:true, applyTriggers:function(triggers, oldTriggers) {
  if (triggers && this.getRevealable() && !triggers.reveal) {
    triggers = Ext.apply({reveal:{type:'reveal'}}, triggers);
  }
  return this.callParent([triggers, oldTriggers]);
}, updateRevealed:function(newValue, oldValue) {
  var me = this;
  if (newValue) {
    me.element.addCls(me.revealedCls);
    me.setInputType('text');
  } else {
    me.element.removeCls(me.revealedCls);
    me.setInputType('password');
  }
}, updateValue:function(value, oldValue) {
  this.syncRevealTrigger();
  this.callParent([value, oldValue]);
}, doKeyUp:function(me, e) {
  this.callParent([me, e]);
  this.syncRevealTrigger();
}, onRevealTap:function(e) {
  this.fireAction('revealicontap', [this, e], 'doRevealTap');
}, doRevealTap:function(me, e) {
  this.setRevealed(!this.getRevealed());
}, privates:{isValidTextValue:function(value) {
  return value !== undefined && value !== null && value !== '';
}, syncRevealTrigger:function() {
  var me = this, triggers = me.getTriggers(), revealTrigger = triggers && triggers.reveal, visible, value;
  if (revealTrigger) {
    if (me.getRevealable()) {
      value = me.getValue();
      if (value != null && value !== '' && !me.getDisabled() && !me.getReadOnly()) {
        visible = true;
      }
    }
    if (visible) {
      revealTrigger.show();
    } else {
      revealTrigger.hide();
    }
  }
}}});
Ext.define('Ext.field.trigger.Search', {extend:Ext.field.trigger.Trigger, xtype:'searchtrigger', alias:'trigger.search', classCls:Ext.baseCSSPrefix + 'searchtrigger'});
Ext.define('Ext.field.Search', {extend:Ext.field.Text, xtype:'searchfield', alternateClassName:'Ext.form.Search', inputType:'search', triggers:{search:{type:'search', side:'left'}}, classCls:Ext.baseCSSPrefix + 'searchfield'});
Ext.define('Ext.form.Panel', {extend:Ext.field.Panel, xtype:'formpanel', alternateClassName:'Ext.form.FormPanel', classCls:Ext.baseCSSPrefix + 'formpanel', element:{reference:'element', tag:'form', novalidate:'novalidate'}, config:{enableSubmissionForm:true, enctype:null, method:'post', multipartDetection:true, standardSubmit:false, submitOnAction:false, trackResetOnLoad:false}, getTemplate:function() {
  var template = this.callParent();
  template.push({tag:'input', type:'submit', cls:Ext.baseCSSPrefix + 'hidden-submit'});
  return template;
}, initialize:function() {
  this.callParent();
  this.element.on('submit', 'onSubmit', this);
}, applyEnctype:function(newValue) {
  var form = this.element.dom || null;
  if (form) {
    if (newValue) {
      form.setAttribute('enctype', newValue);
    } else {
      form.setAttribute('enctype');
    }
  }
}, onSubmit:function(event) {
  var me = this;
  if (event && !me.getStandardSubmit()) {
    event.stopEvent();
  } else {
    this.submit(null, event);
  }
}, updateSubmitOnAction:function(value) {
  this[value ? 'on' : 'un']({action:'onFieldAction', scope:this});
}, onFieldAction:function(field) {
  if (this.getSubmitOnAction()) {
    field.blur();
    this.submit();
  }
}, submit:function(options, e) {
  options = options || {};
  var me = this, formValues = me.getValues(me.getStandardSubmit() || !options.submitDisabled), form = me.element.dom || {};
  if (this.getEnableSubmissionForm()) {
    form = this.createSubmissionForm(form, formValues);
  }
  options = Ext.apply({url:me.getUrl() || form.action, submit:false, form:form, method:me.getMethod() || form.method || 'post', autoAbort:false, params:null, waitMsg:null, headers:null, success:null, failure:null}, options || {});
  return me.fireAction('beforesubmit', [me, formValues, options, e], 'doBeforeSubmit', null, null, 'after');
}, privates:{applyExtraParams:function(options) {
  var form = options.form, params = Ext.merge(this.getBaseParams() || {}, options.params), name, input;
  for (name in params) {
    input = document.createElement('input');
    input.setAttribute('type', 'text');
    input.setAttribute('name', name);
    input.setAttribute('value', params[name]);
    form.appendChild(input);
  }
}, beforeAjaxSubmit:function(form, options, successFn, failureFn) {
  var me = this, url = options.url || me.getUrl(), request = Ext.merge({}, {url:url, timeout:me.getTimeout() * 1000, form:form, scope:me}, options);
  delete request.success;
  delete request.failure;
  request.params = Ext.merge(me.getBaseParams() || {}, options.params);
  request.header = Ext.apply({'Content-Type':'application/x-www-form-urlencoded; charset\x3dUTF-8'}, options.headers || {});
  request.callback = function(callbackOptions, success, response) {
    var responseText = response.responseText, responseXML = response.responseXML, statusResult = Ext.data.request.Ajax.parseStatus(response.status, response);
    if (form.$fileswap) {
      var original, placeholder;
      Ext.each(form.$fileswap, function(item) {
        original = item.original;
        placeholder = item.placeholder;
        placeholder.parentNode.insertBefore(original, placeholder.nextSibling);
        placeholder.parentNode.removeChild(placeholder);
      });
      form.$fileswap = null;
      delete form.$fileswap;
    }
    me.setMasked(false);
    if (response.success === false) {
      success = false;
    }
    if (success) {
      if (statusResult && responseText && responseText.length === 0) {
        success = true;
      } else {
        if (!Ext.isEmpty(response.responseBytes)) {
          success = statusResult.success;
        } else {
          if (Ext.isString(responseText) && response.request.options.responseType === 'text') {
            response.success = true;
          } else {
            if (Ext.isString(responseText)) {
              try {
                response = Ext.decode(responseText);
              } catch (e$34) {
                response.success = false;
                response.error = e$34;
                response.message = e$34.message;
              }
            } else {
              if (Ext.isSimpleObject(responseText)) {
                response = responseText;
                Ext.applyIf(response, {success:true});
              }
            }
          }
          if (!Ext.isEmpty(responseXML)) {
            response.success = true;
          }
          success = !!response.success;
        }
      }
      if (success) {
        successFn(response, responseText);
      } else {
        failureFn(response, responseText);
      }
    } else {
      failureFn(response, responseText);
    }
  };
  if (Ext.feature.has.XHR2 && request.xhr2) {
    delete request.form;
    var formData = request.data = new FormData(form);
    if (request.params) {
      Ext.iterate(request.params, function(name, value) {
        if (Ext.isArray(value)) {
          Ext.each(value, function(v) {
            formData.append(name, v);
          });
        } else {
          formData.append(name, value);
        }
      });
      delete request.params;
    }
  }
  return Ext.Ajax.request(request);
}, beforeDirectSubmit:function(api, form, options, successFn, failureFn) {
  var me = this, submit;
  me.applyExtraParams(options);
  api = Ext.direct.Manager.resolveApi(api, me);
  me.setApi(api);
  submit = api.submit;
  if (!submit) {
    Ext.raise('Cannot find Ext Direct API method for submit action');
  }
  return submit(form, function(data, response, success) {
    me.setMasked(false);
    if (success) {
      if (data.success) {
        successFn(response, data);
      } else {
        failureFn(response, data);
      }
    } else {
      failureFn(response, data);
    }
  }, me);
}, beforeStandardSubmit:function(form, options) {
  if (options.url && Ext.isEmpty(form.action)) {
    form.action = options.url;
  }
  var fields = this.query('spinnerfield'), ln = fields.length, body = document.body, i, field;
  for (i = 0; i < ln; i++) {
    field = fields[i];
    if (!field.getDisabled()) {
      field.setDisabled(false);
    }
  }
  body.appendChild(form);
  form.method = (options.method || form.method).toLowerCase();
  form.submit();
  body.removeChild(form);
}, createSubmissionForm:function(form, values) {
  var fields = this.getFields(), name, input, field, fileTrigger, inputDom;
  if (form.nodeType === 1) {
    form = form.cloneNode(false);
    for (name in values) {
      input = document.createElement('input');
      input.setAttribute('type', 'text');
      input.setAttribute('name', name);
      input.setAttribute('value', values[name]);
      form.appendChild(input);
    }
  }
  for (name in fields) {
    if (fields.hasOwnProperty(name)) {
      field = fields[name];
      if (field.isFile) {
        fileTrigger = field.getTriggers().file;
        inputDom = fileTrigger && fileTrigger.getComponent().buttonElement.dom;
        if (inputDom) {
          if (!form.$fileswap) {
            form.$fileswap = [];
          }
          input = inputDom.cloneNode(true);
          inputDom.parentNode.insertBefore(input, inputDom.nextSibling);
          form.appendChild(inputDom);
          form.$fileswap.push({original:inputDom, placeholder:input});
        }
      } else {
        if (field.isPassword) {
          if (field.getInputType() !== 'password') {
            field.setRevealed(false);
          }
        }
      }
    }
  }
  return form;
}, doBeforeSubmit:function(me, formValues, options) {
  var form = options.form || {}, multipartDetected = false, ret;
  if (this.getMultipartDetection() === true) {
    this.getFields(false).forEach(function(field) {
      if (field.isFile === true) {
        multipartDetected = true;
        return false;
      }
    });
    if (multipartDetected) {
      form.setAttribute('enctype', 'multipart/form-data');
    }
  }
  if (options.enctype) {
    form.setAttribute('enctype', options.enctype);
  }
  if (me.getStandardSubmit()) {
    ret = me.beforeStandardSubmit(form, options);
  } else {
    var api = me.getApi(), scope = options.scope || me, failureFn = function(response, responseText) {
      if (Ext.isFunction(options.failure)) {
        options.failure.call(scope, me, response, responseText);
      }
      me.fireEvent('exception', me, response);
    }, successFn = function(response, responseText) {
      if (Ext.isFunction(options.success)) {
        options.success.call(options.scope || me, me, response, responseText);
      }
      me.fireEvent('submit', me, response);
    }, waitMsg = options.waitMsg;
    if (options.waitMsg) {
      if (typeof waitMsg === 'string') {
        waitMsg = {xtype:'loadmask', message:waitMsg};
      }
      me.setMasked(waitMsg);
    }
    if (api) {
      ret = me.beforeDirectSubmit(api, form, options, successFn, failureFn);
    } else {
      ret = me.beforeAjaxSubmit(form, options, successFn, failureFn);
    }
  }
  return ret;
}}});
Ext.define('Ext.grid.Location', {extend:Ext.dataview.Location, isGridLocation:true, actionable:false, cell:null, column:null, columnIndex:-1, summary:false, row:null, rowBody:null, isTreeLocation:false, inheritableStatics:{defineProtoProperty:function(propName, getterName) {
  Object.defineProperty(this.prototype, propName, {get:function() {
    var v = this[getterName]();
    Object.defineProperty(this, propName, {value:v, configurable:true});
    return v;
  }});
}}, attach:function(source) {
  var me = this, view = me.view, store = view.store, item, cell, column, columns, sourceRec, sourceCol, first;
  if (source.constructor === Object) {
    sourceRec = source.record;
    if (typeof sourceRec === 'number') {
      sourceRec = store.getAt(Math.max(Math.min(sourceRec, store.getCount() - 1), 0));
    }
    sourceCol = source.column;
    if (typeof sourceCol === 'number') {
      columns = view.getVisibleColumns();
      sourceCol = columns[Math.max(Math.min(sourceCol, columns.length - 1), 0)];
    }
    if (!(sourceRec && sourceCol)) {
      if (sourceRec) {
        sourceCol = view.getFirstVisibleColumn();
      } else {
        sourceRec = store.getAt(0);
      }
    }
    cell = view.mapToCell(sourceRec, sourceCol);
    if (cell) {
      source = cell.element;
    } else {
      me._setColumn(sourceCol);
      source = sourceRec;
    }
  }
  me.callParent([source]);
  item = me.item;
  if (item && item.isGridRow) {
    me.row = item;
    me.summary = item.isSummaryRow;
    if (!cell) {
      cell = view.mapToCell(source);
      if (!cell) {
        columns = view.getVisibleColumns();
        first = columns[0];
        if (first) {
          cell = item.getCellByColumn(first);
        }
      }
    }
    me.cell = cell;
    if (cell) {
      me.column = column = cell.getColumn();
      columns = columns || view.getVisibleColumns();
      me.columnIndex = columns.indexOf(column);
      me.isTreeLocation = !!cell.isTreeCell;
    } else {
      me.rowBody = view.mapToRowBody(source);
    }
  }
}, clone:function(options) {
  var me = this, ret = me.callParent(), record, column, cell;
  if (options) {
    if (options.record !== undefined) {
      record = options.record;
    }
    if (options.column !== undefined) {
      column = options.column;
    }
    delete ret.sourceElement;
  }
  if (record != null) {
    delete me.source;
    me.superclass.attach.call(ret, record);
    ret.row = ret.item;
  } else {
    ret.row = ret.child = me.row;
    ret.summary = me.summary;
    ret.rowBody = me.rowBody;
  }
  if (column != null) {
    ret._setColumn(column);
  } else {
    ret.cell = cell = me.cell;
    ret.column = me.column;
    ret.columnIndex = me.columnIndex;
    me.isTreeLocation = !!(cell && cell.isTreeCell);
  }
  return ret;
}, cloneForColumn:function(column) {
  return this.clone({column:column});
}, equals:function(other) {
  var me = this;
  if (other && other.view === me.view && other.isGridLocation) {
    if (me.actionable !== other.actionable) {
      return false;
    }
    if (me.sourceElement && me.actionable) {
      return other.sourceElement === me.sourceElement;
    }
    if (me.recordIndex !== other.recordIndex || me.record !== other.record) {
      return false;
    }
    return me.column === other.column;
  }
  return false;
}, equalCell:function(other) {
  var me = this;
  return other && other.view === me.view && other.isGridLocation && me.recordIndex === other.recordIndex && me.column === other.column;
}, getFocusEl:function(as) {
  var cell = this.get(), ret;
  if (this.actionable) {
    ret = this.sourceElement;
  } else {
    ret = cell && !cell.destroyed && cell.el.dom;
  }
  return Ext.getBody().contains(ret) ? as === 'dom' || as === true ? ret : Ext.get(ret) : null;
}, getCell:function(as) {
  var result = this.cell, ret = null;
  if (result) {
    ret = as === 'dom' || as === true ? result.el.dom : as === 'cmp' ? result : result.el;
  }
  return ret;
}, get:function() {
  return this.cell;
}, isFirstColumn:function() {
  var column = this.column, ret = false;
  if (column) {
    ret = this.view.isFirstVisibleColumn(column);
  }
  return ret;
}, isLastColumn:function() {
  var column = this.column, ret = false;
  if (column) {
    ret = this.view.isLastVisibleColumn(column);
  }
  return ret;
}, refresh:function() {
  var me = this, column = me.column, oldColumnIndex = me.columnIndex, newColumnIndex = me.view.getHeaderContainer().indexOfLeaf(column), location;
  if (newColumnIndex === -1) {
    newColumnIndex = oldColumnIndex === -1 ? 0 : oldColumnIndex;
  }
  location = me.callParent();
  return location._setColumn(newColumnIndex);
}, next:function(options) {
  var me = this, candidate;
  if (me.actionable) {
    return me.navigate();
  } else {
    for (candidate = me.nextCell(options); candidate && !candidate.get().el.isFocusable(); candidate = candidate.nextCell(options)) {
    }
    return candidate || me;
  }
}, previous:function(options) {
  var me = this, candidate;
  if (me.actionable) {
    return me.navigate(true);
  } else {
    for (candidate = me.previousCell(options); candidate && !candidate.get().el.isFocusable(); candidate = candidate.previousCell(options)) {
    }
    return candidate || me;
  }
}, down:function(options) {
  var me = this, column = options && options.column || me.column, candidate = me.nextItem(options), cell;
  if (candidate) {
    candidate._setColumn(column);
    cell = candidate.get();
    while (candidate && (!cell || !cell.el.isFocusable())) {
      candidate = candidate.nextItem(options);
      if (candidate) {
        candidate._setColumn(column);
        cell = candidate.get();
      }
    }
    if (candidate && !candidate.equals(me)) {
      return candidate;
    }
  }
  return me;
}, up:function(options) {
  var me = this, column = options && options.column || me.column, candidate = me.previousItem(options), cell;
  if (candidate) {
    candidate._setColumn(column);
    cell = candidate.get();
    while (candidate && (!cell || !cell.el.isFocusable())) {
      candidate = candidate.previousItem(options);
      if (candidate) {
        candidate._setColumn(column);
        cell = candidate.get();
      }
    }
  }
  if (candidate && !candidate.equals(me)) {
    return candidate;
  }
  return me;
}, privates:{determineActionable:function() {
  var target = this.sourceElement, cell = this.cell, actionable = false;
  if (target && (!cell || cell.destroyed || cell.element.dom !== target)) {
    actionable = Ext.fly(target).isFocusable(true);
  }
  return actionable;
}, navigate:function(reverse) {
  var me = this, activeEl = me.sourceElement, view = me.view, scrollable = view.getScrollable(), actionables = view.getNavigationModel().actionables, len = actionables && actionables.length, candidate = me.clone(), previousCandidate = me.clone(), testEl, visitOptions = {callback:function(el) {
    testEl = Ext.fly(el);
    if (!testEl.$isFocusTrap && testEl.isFocusable()) {
      component = Ext.Component.from(el);
      if (!component || !component.getDisabled()) {
        focusables.push(el);
      }
    }
  }, reverse:reverse, skipSelf:true}, i, result, component, focusables = [];
  while (candidate && !result && candidate.get()) {
    focusables.length = 0;
    candidate.get().el.visit(visitOptions);
    activeEl = focusables[activeEl ? Ext.Array.indexOf(focusables, activeEl) + 1 : 0];
    if (activeEl) {
      result = candidate;
      result.source = result.sourceElement = activeEl;
      delete result.actionable;
      if (candidate.child) {
        scrollable.ensureVisible(candidate.child.el);
      }
      scrollable.ensureVisible(activeEl);
      activeEl.focus();
    } else {
      candidate = candidate[reverse ? 'previousCell' : 'nextCell']();
      if (candidate.equals(previousCandidate)) {
        return me;
      }
      if (candidate && len) {
        for (i = 0; !result && i < len; i++) {
          result = actionables[i].activateCell(candidate);
        }
      }
    }
    previousCandidate = candidate;
  }
  return result || me;
}, activate:function() {
  var me = this, view = me.view, scrollable = view.getScrollable(), actionables = view.getNavigationModel().actionables, len = actionables && actionables.length, candidate = me.clone(), activeEl, i, result;
  candidate.get().el.visit({callback:function(el) {
    if (Ext.fly(el).isFocusable()) {
      activeEl = el;
      return false;
    }
  }, skipSelf:true});
  if (activeEl) {
    result = candidate;
    result.source = result.sourceElement = activeEl;
    delete result.actionable;
    if (candidate.child) {
      scrollable.ensureVisible(candidate.child.el);
    }
    scrollable.ensureVisible(activeEl);
    activeEl.focus();
  } else {
    for (i = 0; !result && i < len; i++) {
      result = actionables[i].activateCell(candidate);
    }
  }
  return result;
}, getFocusables:function() {
  var focusables = [], element = this.sourceElement;
  if (element) {
    Ext.fly(element).visit({callback:function(el) {
      if (Ext.fly(el).isFocusable()) {
        focusables.push(el);
      }
    }, skipSelf:true});
  }
  return focusables;
}, nextCell:function(options) {
  var me = this, view = me.view, startPoint = me.clone(), result = me.clone(), columns = view.getVisibleColumns(), len = columns.length, wrap;
  if (options) {
    if (typeof options === 'boolean') {
      wrap = options;
    } else {
      wrap = options.wrap;
    }
  }
  do {
    if (result.column === columns[len - 1] || !me.child.isGridRow) {
      result = me.down(Ext.apply({column:columns[0]}, options));
    } else {
      result._setColumn(result.columnIndex + 1);
    }
    if (result && result.equals(startPoint)) {
      break;
    }
  } while (result && !result.sourceElement);
  return result;
}, previousCell:function(options) {
  var me = this, view = me.view, startPoint = me.clone(), result = me.clone(), columns = view.getVisibleColumns(), wrap;
  if (options) {
    if (typeof options === 'boolean') {
      wrap = options;
    } else {
      wrap = options.wrap;
    }
  }
  do {
    if (result.column === columns[0] || !me.child.isGridRow) {
      result = me.up(Ext.apply({column:columns.length - 1}, options));
    } else {
      result._setColumn(result.columnIndex - 1);
    }
    if (result && result.equals(startPoint)) {
      break;
    }
  } while (result && !result.sourceElement);
  return result;
}, _setColumn:function(column) {
  var me = this, columns = me.view.getVisibleColumns(), index;
  if (typeof column === 'number') {
    index = column;
    column = columns[index];
  } else {
    index = columns.indexOf(column);
  }
  delete me.event;
  delete me.actionable;
  me.column = column;
  me.columnIndex = index;
  me.cell = me.row && me.row.getCellByColumn(column);
  if (me.cell) {
    me.isTreeLocation = !!me.cell.isTreeCell;
    me.sourceElement = me.cell.el.dom;
  }
  return me;
}}}, function(Cls) {
  Cls.defineProtoProperty('actionable', 'determineActionable');
});
Ext.define('Ext.grid.NavigationModel', {extend:Ext.dataview.NavigationModel, alias:'navmodel.grid', locationClass:'Ext.grid.Location', statics:{ignoreInputFieldKeys:{PAGE_UP:true, PAGE_DOWN:true, END:true, HOME:true, LEFT:true, UP:true, RIGHT:true, DOWN:true}}, setLocation:function(location, options) {
  var me = this, view = me.getView(), event = options && options.event;
  me.columnIndex = -1;
  if (location != null && !location.isGridLocation) {
    if (Ext.isArray(location)) {
      location = {column:location[0], record:location[1]};
    } else {
      if (typeof location === 'number') {
        location = view.store.getAt(location);
      }
    }
    location = me.createLocation(location);
    if (event) {
      location.event = event;
    }
  }
  return me.callParent([location, options]);
}, clearLocation:function() {
  var me = this, item;
  if (me.location) {
    me.previousLocation = me.location;
    item = me.location.sourceElement;
    if (item) {
      Ext.fly(item).removeCls(me.focusedCls);
    }
    me.location = null;
  }
}, registerActionable:function(actionable) {
  var me = this, view = me.getView(), actionables = me.actionables || (me.actionables = []), triggerEvent, listeners;
  if (!Ext.Array.contains(actionables, actionable)) {
    actionables.push(actionable);
    triggerEvent = actionable.getTriggerEvent();
    if (triggerEvent) {
      listeners = {scope:me, args:[actionable]};
      listeners[triggerEvent] = 'triggerActionable';
      actionable.triggerEventListener = view.bodyElement.on(listeners);
    }
  }
}, unregisterActionable:function(actionable) {
  var actionables = this.actionables;
  if (actionables) {
    Ext.Array.remove(actionables, actionable);
  }
}, privates:{onFocusMove:function(e) {
  var me = this, view = me.getView(), location = me.getLocation();
  if (e.toElement === view.el.dom && location) {
    me.clearLocation();
    return me.setLocation(location);
  }
  location = me.createLocation(e);
  if (!location.equals(me.location)) {
    me.handleLocationChange(location, {event:e, navigate:false});
  }
}, processViewEvent:function(e) {
  var me = this, view = me.getView(), cell = view.mapToCell(e);
  if (Ext.fly(e.target).isInputField() && me.self.ignoreInputFieldKeys[e.getKeyName()]) {
    return false;
  }
  if (cell && cell.row.grid === view) {
    return e;
  }
}, activateCell:function(location) {
  location.clone().activate();
}, triggerActionable:function(actionable, e) {
  var actionLocation;
  actionLocation = actionable.activateCell(this.createLocation(e));
  if (actionLocation) {
    this.setLocation(actionLocation);
  }
}, onChildTouchStart:function(view, location) {
  var e = location.event;
  if (location.header || location.footer) {
    e.preventDefault();
  } else {
    if (this.location && !this.location.equalCell(location)) {
      this.setLocation(location, {event:location.event, navigate:this.getView().getTriggerEvent() === 'childtouchstart'});
    }
  }
}, onKeyUp:function(e) {
  e.preventDefault();
  if (!this.location.actionable) {
    if (this.location) {
      this.moveUp(e);
    } else {
      this.setLocation(0);
    }
  }
}, onKeyDown:function(e) {
  e.preventDefault();
  if (!this.location.actionable) {
    if (this.location) {
      this.moveDown(e);
    } else {
      this.setLocation(0);
    }
  }
}, onKeyLeft:function(e) {
  var location = this.location, isSimpleTree = location.isLastColumn() && location.isFirstColumn();
  if (!location.actionable) {
    e.preventDefault();
    if (location.isTreeLocation && !location.record.isLeaf() && location.record.isExpanded()) {
      if (isSimpleTree === !e.ctrlKey) {
        return location.cell.collapse();
      }
    }
    if (!(e.shiftKey && location.isFirstColumn())) {
      this.movePrevious({event:e});
    }
  } else {
    if (Ext.fly(e.target).isInputField()) {
      return true;
    }
  }
}, onKeyRight:function(e) {
  var location = this.location, isSimpleTree = location.isLastColumn() && location.isFirstColumn();
  if (!location.actionable) {
    e.preventDefault();
    if (location.isTreeLocation && !location.record.isLeaf() && !location.record.isExpanded()) {
      if (isSimpleTree === !e.ctrlKey) {
        return location.cell.expand();
      }
    }
    if (!(e.shiftKey && location.isLastColumn())) {
      this.moveNext({event:e});
    }
  } else {
    if (Ext.fly(e.target).isInputField()) {
      return true;
    }
  }
}, onKeyF2:function(e) {
  if (this.location.actionable) {
    this.onKeyEsc();
  } else {
    this.activateCell(this.location);
  }
}, onKeyEsc:function(e) {
  if (this.location.actionable) {
    this.location.get().el.focus();
  }
}, onKeyTab:function(e) {
  var me = this, view = me.getView(), location = me.location, navigate;
  if (location.actionable) {
    navigate = function() {
      me.location = e.shiftKey ? location.previous() : location.next();
    };
    view.ensureVisible(location.record).then(function() {
      if (view.mapToItem(location.record)) {
        navigate();
      } else {
        Ext.defer(navigate, 100);
      }
    });
  } else {
    return true;
  }
}, onKeyPageDown:function(e) {
  e.preventDefault();
  if (!this.location.actionable) {
    var me = this, view = me.getView(), y = (view.infinite ? view.getItemTop(me.location.child) : me.location.child.el.dom.offsetTop) + view.getVisibleHeight(), candidate = view.getRecordIndexFromPoint(0, y);
    view.ensureVisible(candidate).then(function() {
      candidate = new Ext.grid.Location(view, {record:candidate, column:me.location.column});
      if (!(candidate.sourceElement && Ext.fly(candidate.sourceElement).isFocusable())) {
        candidate = candidate.up();
      }
      me.setLocation(candidate, {event:e});
    });
  }
}, onKeyPageUp:function(e) {
  e.preventDefault();
  if (!this.location.actionable) {
    var me = this, view = me.getView(), y = (view.infinite ? view.getItemTop(me.location.child) : me.location.child.el.dom.offsetTop) - view.getVisibleHeight(), candidate = view.getRecordIndexFromPoint(0, y);
    view.ensureVisible(candidate).then(function() {
      candidate = new Ext.grid.Location(view, {record:candidate, column:me.location.column});
      if (!(candidate.sourceElement && Ext.fly(candidate.sourceElement).isFocusable())) {
        candidate = candidate.down();
      }
      me.setLocation(candidate, {event:e});
    });
  }
}, onKeyHome:function(e) {
  e.preventDefault();
  if (!this.location.actionable) {
    if (e.ctrlKey) {
      this.setLocation({record:this.getView().getStore().first(), column:this.location.column}, {event:e});
    } else {
      this.setLocation({record:this.location.record, column:this.getView().getFirstVisibleColumn()}, {event:e});
    }
  }
}, onKeyEnd:function(e) {
  e.preventDefault();
  if (!this.location.actionable) {
    if (e.ctrlKey) {
      this.setLocation({record:this.getView().getStore().last(), column:this.location.column}, {event:e});
    } else {
      this.setLocation({record:this.location.record, column:this.getView().getLastVisibleColumn()}, {event:e});
    }
  }
}, onKeySpace:function(e) {
  var target = Ext.fly(e.target), events, focusables, result;
  this.onNavigate(e);
  if (!this.location.actionable) {
    focusables = this.location.getFocusables();
    if (focusables.length) {
      events = Ext.get(focusables[0]).events;
    }
  } else {
    if (target.isInputField()) {
      result = true;
    } else {
      events = target.events;
    }
  }
  if (events) {
    if (events.tap) {
      events.tap.fire(e);
    }
    if (events.click) {
      events.click.fire(e);
    }
  }
  return result;
}, onKeyEnter:function(e) {
  var l = this.location;
  e.stopEvent();
  if (!l.actionable) {
    if (l.isTreeLocation && l.record.data.checked != null) {
      l.record.set('checked', !l.record.data.checked);
    } else {
      this.activateCell(l);
    }
  } else {
    this.onKeySpace(e);
  }
}, onSelectAllKeyPress:function(e) {
  if (Ext.fly(e.target).isInputField()) {
    return true;
  } else {
    return this.callParent([e]);
  }
}, moveUp:function(e) {
  var location = this.getLocation();
  if (location) {
    location = location.up();
    if (location) {
      this.setLocation(location, {event:e});
    }
  }
}, moveDown:function(e) {
  var location = this.getLocation();
  if (location) {
    location = location.down();
    if (location) {
      this.setLocation(location, {event:e});
    }
  }
}}});
Ext.define('Ext.grid.cell.Base', {extend:Ext.Widget, xtype:'gridcellbase', isGridCell:true, mixins:[Ext.mixin.Toolable], cachedConfig:{align:null, cls:null, bodyCls:null, bodyStyle:null, cellCls:null, selectable:null}, config:{column:null, hidden:false, record:null, value:null}, classCls:Ext.baseCSSPrefix + 'gridcell', dirtyCls:Ext.baseCSSPrefix + 'dirty', alignCls:{left:Ext.baseCSSPrefix + 'align-left', center:Ext.baseCSSPrefix + 'align-center', right:Ext.baseCSSPrefix + 'align-right'}, inheritUi:true, 
cellSelector:'.' + Ext.baseCSSPrefix + 'gridcell', defaultBindProperty:'value', toolDefaults:{zone:'head', ui:'gridcell'}, getTemplate:function() {
  var template = {reference:'bodyElement', cls:Ext.baseCSSPrefix + 'body-el', uiCls:'body-el'};
  if (!(template.children = this.innerTemplate)) {
    template.html = '';
  }
  return [template];
}, doDestroy:function() {
  this.setColumn(null);
  this.setRecord(null);
  this.mixins.toolable.doDestroy.call(this);
  this.callParent();
}, getComputedWidth:function() {
  return this.getHidden() ? 0 : this.getWidth();
}, updateAlign:function(align, oldAlign) {
  var me = this, alignCls = me.alignCls;
  if (oldAlign) {
    me.removeCls(alignCls[oldAlign]);
  }
  if (align) {
    if (!alignCls[align]) {
      Ext.raise("Invalid value for align: '" + align + "'");
    }
    me.addCls(alignCls[align]);
  }
  me.syncToolableAlign();
}, updateBodyCls:function(cellCls, oldCellCls) {
  if (cellCls || oldCellCls) {
    this.bodyElement.replaceCls(oldCellCls, cellCls);
  }
}, updateBodyStyle:function(style) {
  this.bodyElement.applyStyles(style);
}, updateCellCls:function(cls, oldCls) {
  this.element.replaceCls(oldCls, cls);
}, updateCls:function(cls, oldCls) {
  this.element.replaceCls(oldCls, cls);
}, updateColumn:function(column) {
  var dataIndex = null, row = this.row;
  if (column) {
    dataIndex = row && row.isSummaryRow && column.getSummaryDataIndex() || column.getDataIndex();
  }
  this.dataIndex = dataIndex;
}, updateRecord:function() {
  if (!this.destroyed && !this.destroying) {
    this.refresh();
  }
}, updateSelectable:function(value) {
  this.toggleCls(Ext.baseCSSPrefix + 'item-no-select', value === false);
}, refresh:function(ctx) {
  var me = this, was = me.refreshContext, context, modified, value;
  if (!me.isBound('value')) {
    ctx = ctx || was;
    modified = ctx && ctx.modified;
    if (!modified || me.bound(modified)) {
      me.refreshContext = context = me.beginRefresh(ctx);
      value = me.refreshValue(context);
      if (value !== me.getValue()) {
        me.setValue(value);
      } else {
        if (me.writeValue) {
          me.writeValue();
        }
      }
      me.refreshContext = was;
    }
  }
}, refreshValue:function(context) {
  var me = this, record = context.record, dataIndex = context.dataIndex, value, dirty, modified;
  if (context.summary) {
    value = me.summarize(context);
  } else {
    if (record && dataIndex) {
      value = record.get(dataIndex);
      modified = record.modified;
      dirty = !!(modified && modified.hasOwnProperty(dataIndex));
      if (dirty !== me.$dirty) {
        me.toggleCls(me.dirtyCls, dirty);
        me.$dirty = dirty;
      }
    }
  }
  return value;
}, privates:{refreshCounter:0, $dirty:false, refreshContext:null, storeMethodRe:/^(?:average|max|min|sum)$/, augmentToolHandler:function(tool, args) {
  var info = args[1] = {event:args.pop(), record:this.getRecord(), column:this.getColumn(), cell:args[0], tool:args[1]};
  args[0] = info.grid = info.column.getGrid();
}, beginRefresh:function(context) {
  var me = this, column = me.getColumn(), row = me.row;
  context = context || (row ? row.beginRefresh() : {record:me.getRecord()});
  ++me.refreshCounter;
  context.from = context.from || 'cell';
  context.cell = me;
  context.column = column;
  context.dataIndex = me.dataIndex;
  context.scope = column.getScope();
  return context;
}, bound:function(fields) {
  return !!fields[this.dataIndex];
}, summarize:function(context) {
  var me = this, column = context.column, summaryType = column.getSummaryType(), dataIndex = context.dataIndex, group = context.group, store = context.store, records = context.records, value;
  if (summaryType) {
    if (!column.$warnSummaryType) {
      column.$warnSummaryType = true;
      Ext.log.warn('[column] summaryType is deprecated; use summaryRenderer (' + column.getId() + ')');
    }
    if (Ext.isFunction(summaryType)) {
      value = summaryType.call(store, store.data.items.slice(), dataIndex);
    } else {
      if (summaryType === 'count') {
        value = store.getCount();
      } else {
        if (me.storeMethodRe.test(summaryType)) {
          value = store[summaryType](dataIndex);
        } else {
          value = Ext.callback(summaryType, null, [store.data.items.slice(), dataIndex, store], 0, me);
        }
      }
    }
  } else {
    if (!(summaryType = column.getSummary())) {
      if (dataIndex) {
        value = context.record.get(dataIndex);
      }
    } else {
      if (!dataIndex) {
        Ext.raise('Cannot use summary config w/o summaryDataIndex or dataIndex (' + context.grid.getId() + ')');
      } else {
        if (group) {
          if (group.isVirtualGroup) {
            Ext.raise('Cannot calculate a group summary on a virtual store (' + context.grid.getId() + ')');
          }
        } else {
          if (store.getRemoteSort()) {
            Ext.raise('Cannot calculate a summary on a remoteSort store (' + context.grid.getId() + ')');
          }
        }
        value = summaryType.calculate(records, dataIndex, 'data', 0, records.length);
      }
    }
  }
  return value;
}}, deprecated:{'6.5':{configs:{innerStyle:'bodyStyle', innerCls:'bodyCls'}}}});
Ext.define('Ext.grid.cell.Text', {extend:Ext.grid.cell.Base, xtype:'textcell', config:{encodeHtml:true, rawValue:null, zeroValue:null}, getTemplate:function() {
  var template = this.callParent();
  template[0]['data-qoverflow'] = true;
  return template;
}, formatValue:function(v) {
  var me = this, context = me.refreshContext, column = context.column, zeroValue = me.getZeroValue(), format = column.getFormatter(), renderer, scope;
  if (context.summary) {
    renderer = column.getSummaryRenderer();
    if (renderer) {
      format = null;
      scope = context.scope;
      if (typeof renderer === 'string') {
        v = Ext.callback(renderer, scope, [v, context], 0, column);
      } else {
        v = renderer.call(scope || me, v, context);
      }
    }
    format = column.getSummaryFormatter() || format;
  } else {
    if (v === 0 && zeroValue !== null) {
      v = zeroValue;
      format = null;
    }
  }
  if (format) {
    v = format(v);
  }
  if (v != null) {
    v = String(v);
  } else {
    v = '';
  }
  return v;
}, printValue:function(v) {
  var me = this, was = me.refreshContext, s;
  me.refreshContext = me.beginRefresh(was);
  s = me.formatValue(v);
  if (me.getEncodeHtml()) {
    s = Ext.htmlEncode(s);
  }
  me.refreshContext = was;
  return s;
}, updateRawValue:function(rawValue) {
  var dom = this.bodyElement.dom, value = rawValue == null ? '' : rawValue;
  if (this.getEncodeHtml()) {
    dom.textContent = value;
  } else {
    dom.innerHTML = value;
  }
}, updateValue:function() {
  var me = this, was = me.refreshContext, row = me.row;
  if (row && row.parent) {
    if (!was) {
      me.refreshContext = me.beginRefresh();
    }
    me.writeValue();
    me.refreshContext = was;
  }
}, updateZeroValue:function() {
  if (!this.isConfiguring) {
    this.refresh();
  }
}, writeValue:function() {
  var me = this, value = me.getValue();
  if (!(value = me.formatValue(value))) {
    value = me.getColumn().getEmptyText();
  }
  me.setRawValue(value);
}});
Ext.define('Ext.grid.cell.Cell', {extend:Ext.grid.cell.Text, xtype:'gridcell', config:{tpl:null, renderer:null, formatter:null, scope:null}, friendly:null, updateColumn:function(column, oldColumn) {
  var me = this, friendly = true, tpl, renderer, formatter;
  me.callParent([column, oldColumn]);
  if (column) {
    tpl = column.getTpl();
    renderer = column.getRenderer();
    formatter = column.getFormatter();
    if (renderer !== null) {
      me.setRenderer(renderer);
      friendly = typeof renderer === 'function' && renderer.length === 1;
    }
    if (tpl !== null) {
      me.setTpl(tpl);
      friendly = false;
    }
    if (formatter !== null) {
      me.setFormatter(formatter);
    }
    me.friendly = friendly;
  }
}, applyTpl:function(tpl) {
  return Ext.XTemplate.get(tpl);
}, applyFormatter:function(format) {
  var me = this, fmt = format, parser;
  if (typeof fmt === 'string') {
    parser = Ext.app.bind.Parser.fly(fmt);
    fmt = parser.compileFormat();
    parser.release();
    return function(v) {
      return fmt(v, me.getScope() || me.resolveListenerScope());
    };
  } else {
    if (typeof fmt !== 'function') {
      Ext.raise('Invalid formatter');
    }
  }
  return fmt;
}, updateTpl:function() {
  if (!this.isConfiguring) {
    this.refresh();
  }
}, updateRenderer:function() {
  if (!this.isConfiguring) {
    this.refresh();
  }
}, updateFormatter:function() {
  if (!this.isConfiguring) {
    this.refresh();
  }
}, formatValue:function(v) {
  var me = this, context = me.refreshContext, dataIndex = context.dataIndex, column = context.column, record = context.record, zeroValue = me.getZeroValue(), raw = v, summary = context.summary, args, data, format, renderer, scope, tpl;
  if (!context.summary && v === 0 && zeroValue !== null) {
    raw = zeroValue;
  } else {
    if (!(tpl = me.getTpl(context))) {
      format = me.getFormatter();
      if (summary) {
        renderer = column.getSummaryRenderer();
        if (renderer) {
          format = null;
          scope = context.scope;
          if (typeof renderer === 'string') {
            raw = Ext.callback(renderer, scope, [v, context], 0, column);
            me.friendly = false;
          } else {
            raw = renderer.call(scope || me, v, context);
            if (renderer.length > 1) {
              me.friendly = false;
            }
          }
        }
        format = column.getSummaryFormatter() || format;
      } else {
        renderer = me.getRenderer();
        if (renderer) {
          args = [v, record, dataIndex, me, column];
          scope = me.getScope() || context.scope;
          if (typeof renderer === 'function') {
            raw = renderer.apply(scope || column, args);
          } else {
            raw = Ext.callback(renderer, scope, args, 0, me);
          }
        }
      }
      if (format) {
        raw = format(raw);
      }
    } else {
      if (!(data = context.data)) {
        context.data = data = context.summary ? context.record.getData() : context.grid.gatherData(context.record);
      }
      raw = tpl.apply(data);
    }
  }
  if (raw != null) {
    raw = String(raw);
  } else {
    raw = '';
  }
  return raw;
}, privates:{bound:function(fields) {
  var me = this, bound = !!fields[me.dataIndex], column, depends, i;
  if (!bound) {
    column = me.getColumn();
    depends = column && column.getDepends();
    if (depends) {
      for (i = depends.length; !bound && i-- > 0;) {
        bound = !!fields[depends[i]];
      }
    } else {
      if (!me.friendly) {
        bound = true;
      }
    }
  }
  return bound;
}}});
Ext.define('Ext.grid.RowBody', {extend:Ext.Component, xtype:'rowbody', config:{widget:null}, classCls:Ext.baseCSSPrefix + 'rowbody', inheritUi:true, template:[{reference:'spacerElement', cls:Ext.baseCSSPrefix + 'spacer-el'}, {reference:'contentElement', cls:Ext.baseCSSPrefix + 'content-el'}], initialize:function() {
  var me = this, grid, rowExpander;
  me.callParent();
  grid = me.row.getGrid();
  if (grid && grid.hasRowExpander) {
    rowExpander = grid.findPlugin('rowexpander');
    if (rowExpander) {
      me.spacerElement.setWidth(rowExpander.getColumn().getWidth());
    }
  }
}, applyWidget:function(widget) {
  var row = this.row;
  if (widget) {
    widget = Ext.apply({ownerCmp:row}, widget);
    widget = Ext.widget(widget);
  }
  return widget;
}, updateWidget:function(widget, oldWidget) {
  if (oldWidget) {
    oldWidget.destroy();
  }
  if (widget) {
    this.contentElement.appendChild(widget.element);
  }
}, updateRecord:function(record, oldRecord) {
  var tpl = this.getTpl();
  if (tpl) {
    this.callParent([record, oldRecord]);
  }
}, getInnerHtmlElement:function() {
  return this.contentElement;
}, doDestroy:function() {
  this.setWidget(null);
  this.callParent();
}});
Ext.define('Ext.grid.Row', {extend:Ext.Component, xtype:'gridrow', mixins:[Ext.mixin.Queryable, Ext.dataview.GenericItem, Ext.dataview.Pinnable], isGridRow:true, isRecordRefreshable:true, cachedConfig:{collapsed:true}, config:{body:null, expandedField:null, defaultCellUI:null, stickyVisibility:null}, classCls:[Ext.baseCSSPrefix + 'listitem', Ext.baseCSSPrefix + 'gridrow'], inheritUi:true, expandedCls:Ext.baseCSSPrefix + 'expanded', element:{reference:'element', children:[{reference:'cellsElement', 
className:Ext.baseCSSPrefix + 'cells-el'}]}, constructor:function(config) {
  this.cells = [];
  this.columnMap = {};
  this.callParent([config]);
}, doDestroy:function() {
  var me = this;
  me.setRecord(null);
  me.setBody(null);
  me.cells = Ext.destroy(me.cells);
  me.callParent();
}, collapse:function() {
  this.setCollapsed(true);
}, expand:function() {
  this.setCollapsed(false);
}, toggleCollapsed:function() {
  this.setCollapsed(!this.getCollapsed());
}, updateCollapsed:function(collapsed) {
  var me = this, body = me.getBody(), grid = me.getParent(), record = me.getRecord(), expandField = me.getExpandedField(), expandedCls = me.expandedCls, expanderCell = me.expanderCell, recordsExpanded;
  if (record) {
    if (expandField) {
      record.set(expandField, !collapsed);
    } else {
      recordsExpanded = grid.$recordsExpanded || (grid.$recordsExpanded = {});
      if (collapsed) {
        delete recordsExpanded[record.internalId];
      } else {
        recordsExpanded[record.internalId] = true;
      }
    }
  }
  if (expanderCell) {
    expanderCell.setCollapsed(collapsed);
  }
  if (body) {
    if (collapsed) {
      body.hide();
      me.removeCls(expandedCls);
    } else {
      body.show();
      me.addCls(expandedCls);
    }
  }
}, applyBody:function(config, existing) {
  return Ext.updateWidget(existing, config, this, 'createBody');
}, createBody:function(body) {
  return Ext.merge({xtype:'rowbody', ownerCmp:this, row:this, hidden:true}, body);
}, updateBody:function(body) {
  var me = this, grid = me.getParent();
  if (body) {
    me.bodyElement.appendChild(body.element);
    if (me.rendered && !body.rendered) {
      body.setRendered(true);
    }
  }
  if (grid) {
    grid.setVariableHeights(true);
    if (!grid.hasRowExpander) {
      me.expand();
    }
  }
}, onAdded:function(grid) {
  var me = this, cells = me.cells, cell, col, columns, i, k, n;
  me.callParent(arguments);
  if (grid) {
    columns = grid.getColumns();
    for (i = 0, n = columns.length; i < n; i++) {
      cell = cells[i];
      col = columns[i];
      if (cell) {
        if (cell.getColumn() === col) {
          continue;
        }
        for (k = cells.length; k-- > i;) {
          cell = cells[k];
          me.removeColumn(cell.getColumn());
        }
      }
      me.addColumn(columns[i]);
    }
  }
}, addColumn:function(column) {
  this.insertColumn(this.cells.length, column);
}, getCells:function(selector) {
  return selector ? Ext.ComponentQuery.query(selector, this.cells) : this.cells;
}, getRefItems:function(deep) {
  var result = [], body = this.getConfig('body', false, true), cells = this.cells, len = cells && cells.length, i, cell;
  for (i = 0; i < len; i++) {
    cell = cells[i];
    result.push(cell);
    if (deep && cell.getRefItems) {
      result.push.apply(result, cell.getRefItems());
    }
  }
  if (body) {
    result.push(body);
    if (deep && body.getRefItems) {
      result.push.apply(result, body.getRefItems());
    }
  }
  return result;
}, insertColumn:function(index, column) {
  var me = this, cells = me.cells, cell;
  if (column.isHeaderGroup) {
    return;
  }
  cell = me.createCell(column);
  if (index >= cells.length) {
    me.cellsElement.appendChild(cell.element);
    cells.push(cell);
  } else {
    cell.element.insertBefore(cells[index].element);
    cells.splice(index, 0, cell);
  }
  me.columnMap[column.getId()] = cell;
  if (cell.isExpanderCell) {
    me.expanderCell = cell;
  }
  if (me.rendered) {
    cell.setRendered(true);
  }
}, insertColumnBefore:function(column, ref) {
  var me = this, map = me.columnMap, id = column.getId(), cell = map[id], cells = me.cells, refCell, refIndex, index;
  if (ref) {
    refCell = me.getCellByColumn(ref);
    refIndex = cells.indexOf(refCell);
  } else {
    refIndex = cells.length;
  }
  if (cell) {
    index = cells.indexOf(cell);
    Ext.Array.move(cells, index, refIndex);
    if (refCell) {
      cell.element.insertBefore(refCell.element);
    } else {
      me.cellsElement.appendChild(cell.element);
    }
  } else {
    me.insertColumn(refIndex, column);
  }
}, removeColumn:function(column) {
  var me = this, columnMap = me.columnMap, columnId = column.getId(), cell = columnMap[columnId];
  if (cell) {
    Ext.Array.remove(me.cells, cell);
    delete columnMap[columnId];
    cell.destroy();
  }
}, updateRecord:function(record) {
  if (!this.destroyed && !this.destroying) {
    this.refresh();
  }
}, setColumnWidth:function(column) {
  var cell = this.getCellByColumn(column);
  if (cell) {
    cell.setWidth(column.getComputedWidth());
  }
}, showColumn:function(column) {
  this.setCellHidden(column, false);
}, hideColumn:function(column) {
  this.setCellHidden(column, true);
}, getCellByColumn:function(column) {
  return this.columnMap[column.getId()];
}, getColumnByCell:function(cell) {
  return cell.getColumn();
}, updateStickyVisibility:function(value) {
  this.fireEvent('stickyvisiblitychange', value);
}, refresh:function(context) {
  var me = this, cells = me.cells, body = me.getBody(), len = cells.length, expandField = me.getExpandedField(), grid = me.getParent(), sm = grid.getSelectable(), selection = sm.getSelection(), isCellSelection = selection.isCells || selection.isColumns, i, visibleIndex, cell, record, recordsExpanded;
  me.refreshContext = context = me.beginRefresh(context);
  record = context.record;
  me.syncDirty(record);
  for (i = 0, visibleIndex = 0; i < len; ++i) {
    cell = cells[i];
    if (!context.summary || !cell.getColumn().getIgnore()) {
      if (cell.getRecord() === record) {
        cell.refresh(context);
      } else {
        cell.refreshContext = context;
        cell.setRecord(record);
        cell.refreshContext = null;
      }
      if (isCellSelection) {
        cell.toggleCls(grid.selectedCls, sm.isCellSelected(me._recordIndex, visibleIndex));
      }
    }
    if (!cell.isHidden()) {
      visibleIndex++;
    }
  }
  context.cell = context.column = context.dataIndex = context.scope = null;
  if (body) {
    body.refreshContext = context;
    if (body.getRecord() === record) {
      body.updateRecord(record);
    } else {
      body.setRecord(record);
    }
    body.refreshContext = null;
    if (expandField) {
      me.setCollapsed(!record.get(expandField));
    } else {
      recordsExpanded = grid.$recordsExpanded || (grid.$recordsExpanded = {});
      if (grid.hasRowExpander) {
        me.setCollapsed(!recordsExpanded[record.internalId]);
      }
    }
  }
  me.refreshContext = null;
}, privates:{refreshContext:null, beginRefresh:function(context) {
  var me = this, grid = me.getParent();
  context = context || {};
  context.from = context.from || 'row';
  context.grid = grid;
  context.record = me.getRecord();
  context.row = me;
  context.store = grid.store;
  return context;
}, createCell:function(column) {
  var cell = column.createCell(this);
  cell = Ext.create(cell);
  delete cell.$initParent;
  if (cell.inheritUi) {
    cell.doInheritUi();
  }
  cell.el.setTabIndex(-1);
  return cell;
}, setCellHidden:function(column, hidden) {
  var cell = this.getCellByColumn(column);
  if (cell) {
    cell.setHidden(hidden);
  }
}, getGrid:function() {
  return this.getParent();
}}});
Ext.define('Ext.grid.HeaderContainer', {extend:Ext.Container, xtype:'headercontainer', isHeaderContainer:true, config:{docked:'top', defaultColumnUI:null, columns:null, defaultType:'column', layout:{type:'hbox', align:'stretch'}, sortable:true, scrollable:{x:false, y:false}, grid:null, verticalOverflow:null, reserveScrollbar:null}, inheritUi:true, weighted:true, autoSize:null, constructor:function(config) {
  this.isRootHeader = !this.isGridColumn;
  if (this.isRootHeader) {
    config.grid._headerContainer = this;
  }
  this.columns = [];
  this.callParent([config]);
  if (this.isRootHeader) {
    config.grid._headerContainer = null;
  }
}, initialize:function() {
  var me = this;
  me.callParent();
  if (me.isRootHeader) {
    me.setInstanceCls(Ext.baseCSSPrefix + 'headercontainer');
    me.on({tap:'onHeaderTap', triggertap:'onHeaderTriggerTap', columnresize:'onColumnResize', show:'onColumnShow', hide:'onColumnHide', sort:'onColumnSort', scope:me, delegate:'[isLeafHeader]'});
    me.on({tap:'onGroupTap', triggertap:'onGroupTriggerTap', show:'onGroupShow', hide:'onGroupHide', add:'onColumnAdd', move:'onColumnMove', remove:'onColumnRemove', scope:me, delegate:'[isHeaderGroup]'});
    me.on({add:'onColumnAdd', move:'onColumnMove', remove:'onColumnRemove', scope:me});
  }
}, getRootHeaderCt:function() {
  var grid = this.getGrid();
  return grid && grid.getHeaderContainer();
}, getColumnForField:function(fieldName) {
  var columns = this.columns, n = columns.length, c, i;
  for (i = 0; i < n; ++i) {
    c = columns[i].getColumnForField(fieldName);
    if (c) {
      return c;
    }
  }
  return null;
}, getColumns:function(selector) {
  var result = this.columns;
  if (selector) {
    if (typeof selector === 'string') {
      result = Ext.ComponentQuery.query(selector, result);
    } else {
      if (Ext.isFunction(selector)) {
        return result.filter(selector);
      }
    }
  }
  return result;
}, getVisibleColumns:function() {
  var me = this, result = me.visibleColumns;
  if (!result) {
    result = me.visibleColumns = me.columns.filter(me.visibleLeafFilter);
  }
  return result;
}, getClosestVisibleHeader:function(index) {
  var result = typeof index === 'number' ? this.getVisibleColumns()[index] : index;
  if (result && result.hidden) {
    result = result.next(':visible') || result.prev(':visible');
  }
  return result;
}, indexOfLeaf:function(column) {
  return this.getVisibleColumns().indexOf(column);
}, factoryItem:function(item) {
  var grid = this.getGrid();
  if (item.isComponent) {
    if (item.isGridColumn) {
      item.setGrid(grid);
    }
  } else {
    item = Ext.apply({grid:grid}, item);
  }
  return this.callParent([item]);
}, updateColumns:function(columns) {
  var me = this;
  if (me.isRootHeader) {
    me.columns = [];
    me.visibleColumns = null;
    me.add(columns);
  }
}, beginColumnUpdate:function() {
  var me = this;
  if (!me.isRootHeader) {
    return;
  }
  me.hasBulkUpdate = me.hasBulkUpdate || 0;
  me.hasBulkUpdate++;
  if (me.hasBulkUpdate === 1) {
    me.bulkAdd = [];
    me.updateMenuDisabledState = Ext.emptyFn;
  }
}, endColumnUpdate:function() {
  var me = this, length, i, columns, item;
  if (!me.isRootHeader || !me.hasBulkUpdate) {
    return;
  }
  me.hasBulkUpdate--;
  if (me.hasBulkUpdate === 0) {
    columns = me.bulkAdd;
    length = columns && columns.length;
    if (length) {
      me.visibleColumns = null;
      me.columns = me.query('[isLeafHeader]');
      for (i = 0; i < length; i++) {
        item = columns[i];
        item.columnIndex = me.columns.indexOf(item.column);
      }
      Ext.Array.sort(columns, me.sortByColumnIndex);
      for (i = 0; i < length; i++) {
        item = columns[i];
        me.fireEvent('columnadd', me, item.column, item.columnIndex);
      }
    }
    me.getGrid().refreshInnerWidth();
    me.bulkAdd = null;
    delete me.updateMenuDisabledState;
    me.updateMenuDisabledState();
  }
}, sortByColumnIndex:function(a, b) {
  return a.columnIndex - b.columnIndex;
}, add:function(items) {
  var ret, rootHeaders = this.getRootHeaderCt();
  if (rootHeaders) {
    rootHeaders.beginColumnUpdate();
  }
  ret = this.callParent([items]);
  if (rootHeaders) {
    rootHeaders.endColumnUpdate();
  }
  return ret;
}, insert:function(index, item) {
  var ret, rootHeaders = this.getRootHeaderCt();
  if (rootHeaders) {
    rootHeaders.beginColumnUpdate();
  }
  ret = this.callParent([index, item]);
  if (rootHeaders) {
    rootHeaders.endColumnUpdate();
  }
  return ret;
}, remove:function(which, destroy) {
  var ret, rootHeaders = this.getRootHeaderCt();
  if (rootHeaders) {
    rootHeaders.beginColumnUpdate();
  }
  ret = this.callParent([which, destroy]);
  if (rootHeaders) {
    rootHeaders.endColumnUpdate();
  }
  return ret;
}, onColumnAdd:function(container, column) {
  var me = this, grid = me.getGrid(), groupColumns, ln, i, ui;
  if (column.isHeaderGroup) {
    groupColumns = column.getItems().items;
    for (i = 0, ln = groupColumns.length; i < ln; i++) {
      me.onColumnAdd(column, groupColumns[i]);
    }
  } else {
    ui = column.getUi();
    if (ui == null) {
      column.setUi(me.getDefaultColumnUI());
    }
    column.setGrid(grid);
    me.bulkAdd.push({column:column});
  }
  me.updateMenuDisabledState();
}, onColumnMove:function(parent, column, toIdx, fromIdx) {
  var me = this, columns = me.columns, group = null, cols;
  me.visibleColumns = null;
  if (column.isHeaderGroup) {
    cols = column.getItems().items;
    group = column;
  } else {
    cols = [column];
  }
  fromIdx = columns.indexOf(cols[0]);
  me.columns = me.getLeaves();
  me.fireEvent('columnmove', me, cols, group, fromIdx);
}, onColumnRemove:function(parent, column) {
  var me = this;
  me.visibleColumns = null;
  if (column.isHeaderGroup) {
    if (!column.destroying) {
      var columns = column.getItems().items, ln = columns.length, i;
      for (i = 0; i < ln; i++) {
        me.onColumnRemove(column, columns[i]);
      }
    }
  } else {
    Ext.Array.remove(me.columns, column);
    me.fireEvent('columnremove', me, column);
  }
  me.updateMenuDisabledState();
}, onHeaderTap:function(column, e) {
  var selModel = this.getGrid().getSelectable(), ret = this.fireEvent('columntap', this, column, e);
  if (ret !== false) {
    if (selModel.onHeaderTap) {
      selModel.onHeaderTap(this, column, e);
    }
  }
}, onGroupTriggerTap:function(column) {
  column.showMenu();
}, onHeaderTriggerTap:function(column) {
  column.showMenu();
}, onColumnShow:function(column) {
  var me = this;
  me.visibleColumns = null;
  me.fireEvent('columnshow', me, column);
  me.updateMenuDisabledState();
}, onColumnHide:function(column) {
  var me = this;
  me.visibleColumns = null;
  me.fireEvent('columnhide', me, column);
  me.updateMenuDisabledState();
}, onGroupShow:function(group) {
  var columns = group.getInnerItems(), ln = columns.length, i, column;
  this.visibleColumns = null;
  for (i = 0; i < ln; i++) {
    column = columns[i];
    if (!column.isHidden()) {
      this.fireEvent('columnshow', this, column);
    }
  }
  this.updateMenuDisabledState();
}, onGroupHide:function(group) {
  var columns = group.getInnerItems(), ln = columns.length, i, column;
  this.visibleColumns = null;
  for (i = 0; i < ln; i++) {
    column = columns[i];
    this.fireEvent('columnhide', this, column);
  }
  this.updateMenuDisabledState();
}, onGroupTap:function(column, e) {
  return this.fireEvent('headergrouptap', this, column, e);
}, onColumnResize:function(column, width, oldWidth) {
  this.fireEvent('columnresize', this, column, width, oldWidth);
}, onColumnSort:function(column, direction, newDirection) {
  if (direction !== null) {
    this.fireEvent('columnsort', this, column, direction, newDirection);
  }
}, scrollTo:function(x) {
  this.getScrollable().scrollTo(x);
}, updateGrid:function(grid) {
  if (this.isRootHeader) {
    this.parent = grid;
  }
}, doDestroy:function() {
  var me = this, task = me.spacerTask;
  if (task) {
    task.cancel();
    me.spacerTask = null;
  }
  me.setGrid(null);
  me.callParent();
}, afterRender:function() {
  this.callParent();
  if (this.isRootHeader) {
    this.onColumnComputedWidthChange();
  }
}, privates:{columnsResizing:null, updateVerticalOverflow:function() {
  this.syncReserveSpace();
}, updateReserveScrollbar:function() {
  this.syncReserveSpace();
}, updateMenuDisabledState:function() {
  if (this.rendered) {
    var me = this.isRootHeader ? this : this.getRootHeaderCt(), columns = [], menuOfferingColumns = [], len, i, column, columnIsHideable, checkItem;
    me.visitPreOrder('gridcolumn:not([hidden])', function(col) {
      columns.push(col);
      if (!col.isHidden(true) && !col.getMenuDisabled() && col.getConfig('menu', true)) {
        menuOfferingColumns.push(col);
      }
    });
    len = columns.length;
    for (i = 0; i < len; ++i) {
      column = columns[i];
      checkItem = column.getHideShowMenuItem(false);
      if (checkItem) {
        columnIsHideable = menuOfferingColumns.length > 1 || menuOfferingColumns[0] !== column;
        checkItem['set' + (checkItem.getMenu() ? 'CheckChange' : '') + 'Disabled'](!columnIsHideable);
      }
    }
  }
}, getLeaves:function() {
  return this.query('[isLeafHeader]');
}, onColumnComputedWidthChange:function(column, computedWidth) {
  var me = this, totalColumnWidth = 0, changedColumns = me.columnsResizing, columns, len, i, c, width;
  if (me.destroying) {
    return;
  }
  if (changedColumns) {
    changedColumns.push(column);
    return;
  }
  me.columnsResizing = changedColumns = [];
  columns = me.getColumns();
  len = columns.length;
  for (i = 0; i < len; i++) {
    c = columns[i];
    if (c === column) {
      changedColumns.push(c);
      width = computedWidth;
    } else {
      width = c.isHidden(true) ? 0 : c.measureWidth();
    }
    totalColumnWidth += width;
  }
  totalColumnWidth = Math.floor(totalColumnWidth);
  me.getGrid().onColumnComputedWidthChange(changedColumns, totalColumnWidth);
  me.columnsResizing = null;
}, setRendered:function(rendered) {
  this.visibleColumns = null;
  this.callParent([rendered]);
}, setSortState:function() {
  var grid = this.getGrid(), store = grid.getStore(), columns = grid.getColumns(), isGrouped = store.isGrouped(), len = columns && columns.length, sorters = store.getSorters(), grouper = store.getGrouper(), i, header, isGroupedHeader, sorter;
  for (i = 0; i < len; i++) {
    header = columns[i];
    sorter = header.sorter;
    isGroupedHeader = store.getGroupField() === header.getDataIndex();
    if (sorter) {
      if (isGrouped && !isGroupedHeader) {
        sorter = null;
      } else {
        if (isGrouped && isGroupedHeader) {
          sorter = grouper;
        } else {
          if (!(sorters.contains(sorter) || grouper === sorter)) {
            sorter = null;
          }
        }
      }
    }
    header.setSortState(sorter);
  }
}, syncReserveSpace:function() {
  var reserve = this.getVerticalOverflow() || this.getReserveScrollbar();
  this.el.setStyle('padding-right', reserve ? Ext.getScrollbarSize().width + 'px' : 0);
}, visibleLeafFilter:function(c) {
  return c.isLeafHeader && !c.isHidden();
}}});
Ext.define('Ext.menu.CheckItem', {extend:Ext.menu.Item, xtype:'menucheckitem', isMenuCheckItem:true, hideOnClick:false, config:{checked:false, checkHandler:null, checkChangeDisabled:false, value:null, showCheckbox:null}, classCls:Ext.baseCSSPrefix + 'menucheckitem', checkedCls:Ext.baseCSSPrefix + 'checked', checkboxIconElCls:Ext.baseCSSPrefix + 'checkbox-icon-el', ariaRole:'menuitemcheckbox', defaultBindProperty:'checked', submenuText:'{0} submenu', href:null, target:null, element:{reference:'element', 
tabindex:Ext.is.iOS ? -1 : null, cls:Ext.baseCSSPrefix + 'unselectable ' + Ext.baseCSSPrefix + 'has-left-icon'}, focusEl:'checkboxElement', ariaEl:'checkboxElement', getTemplate:function() {
  var template = this.callParent(), body = template[0];
  body.tag = 'div';
  body.href = null;
  body.children.push({tag:'input', type:'checkbox', reference:'checkboxElement', cls:Ext.baseCSSPrefix + 'checkbox-el'});
  return template;
}, initialize:function() {
  var me = this;
  me.callParent();
  me.element.on({mousedown:'onCheckboxMousedown', translate:false, scope:me});
  me.checkboxElement.on({change:'onCheckboxChange', delegated:false, scope:me});
  this.syncCheckboxCls();
}, enableFocusable:function() {
  this.mixins.focusable.enableFocusable();
  this.checkboxElement.dom.readOnly = '';
}, disableFocusable:function() {
  this.mixins.focusable.disableFocusable();
  this.checkboxElement.dom.readOnly = 'readonly';
}, setChecked:function(checked, suppressEvents) {
  var me = this, isConfiguring = me.isConfiguring;
  if (suppressEvents) {
    me.isConfiguring = true;
  }
  me.callParent([checked]);
  if (suppressEvents) {
    me.isConfiguring = isConfiguring;
  }
}, updateChecked:function(checked) {
  this.checkboxElement.dom.checked = checked;
  this.onCheckChange();
}, updateCheckChangeDisabled:function(checkChangeDisabled) {
  this.checkboxElement.dom.readOnly = checkChangeDisabled;
}, updateValue:function(value) {
  this.checkboxElement.dom.value = value;
}, updateText:function(text) {
  var me = this, ariaDom = me.ariaEl.dom;
  me.callParent([text]);
  if (me.getValue() === null) {
    me.setValue(text);
  }
  if (ariaDom && me.getMenu()) {
    ariaDom.setAttribute('aria-label', Ext.String.formatEncode(me.submenuText, text));
  }
}, applyShowCheckbox:function(showCheckbox) {
  return !!showCheckbox;
}, updateShowCheckbox:function(showCheckbox) {
  this.checkboxElement.setDisplayed(showCheckbox);
}, updateIcon:function(icon, oldIcon) {
  this.callParent([icon, oldIcon]);
  if (!this.isConfiguring) {
    this.syncCheckboxCls();
  }
}, updateIconCls:function(iconCls, oldIconCls) {
  this.callParent([iconCls, oldIconCls]);
  if (!this.isConfiguring) {
    this.syncCheckboxCls();
  }
}, updateIconAlign:function(iconAlign, oldIconAlign) {
  this.callParent([iconAlign, oldIconAlign]);
  if (!this.isConfiguring) {
    this.syncCheckboxCls();
  }
}, privates:{onSpace:function(e) {
  if (this.getDisabled()) {
    e.preventDefault();
  }
}, onClick:function(e) {
  var me = this, arrowElement = me.arrowElement, result, parentResult, region;
  if (me.getDisabled()) {
    e.preventDefault();
  }
  if (e.pointerType !== 'mouse') {
    region = me.bodyElement.getRegion();
    if (me.getMenu()) {
      region.setWidth(region.getWidth() - arrowElement.getWidth() - arrowElement.getMargin('lr'));
    }
    if (region.contains(e.getPoint())) {
      result = false;
    } else {
      e.preventDefault();
    }
  }
  parentResult = me.callParent([e]);
  return result === false ? result : parentResult;
}, onCheckboxMousedown:function(e) {
  if (Ext.isApple && !Ext.isChrome || !this.checkboxElement.contains(e.target)) {
    e.preventDefault();
  }
}, onCheckboxChange:function() {
  var me = this, checkboxElement = me.checkboxElement.dom, meChecked = me.getChecked(), isChecked = checkboxElement.checked;
  if (me.getCheckChangeDisabled()) {
    checkboxElement.checked = meChecked;
    return false;
  }
  if (isChecked === meChecked || me.getDisabled()) {
    return;
  }
  if (me.fireEvent('beforecheckchange', me, isChecked) === false) {
    checkboxElement.checked = !isChecked;
  } else {
    me.setChecked(isChecked);
  }
}, onCheckChange:function() {
  var me = this, checked = me.checkboxElement.dom.checked, el = me.el, ariaDom = me.ariaEl.dom;
  el.toggleCls(me.checkedCls, !!checked);
  if (ariaDom) {
    ariaDom.setAttribute('aria-checked', me.getMenu() ? 'mixed' : checked);
  }
  me.publishState('checked', checked);
  if (!me.isConfiguring) {
    Ext.callback(me.getCheckHandler(), me.scope, [me, checked], 0, me);
    me.fireEvent('checkchange', me, checked);
  }
}, syncHasIconCls:function() {
  var me = this;
  me.toggleCls(me.hasRightIconCls, me.hasIcon());
}, syncCheckboxCls:function() {
  var me = this, leftIconElement = me.leftIconElement, rightIconElement = me.rightIconElement, checkboxIconElCls = me.checkboxIconElCls, checkboxIconElement, oldCheckboxIconElement;
  if (me.hasIcon() && me.getIconAlign() === 'left') {
    checkboxIconElement = rightIconElement;
    oldCheckboxIconElement = leftIconElement;
  } else {
    checkboxIconElement = leftIconElement;
    oldCheckboxIconElement = rightIconElement;
  }
  checkboxIconElement.addCls(checkboxIconElCls);
  oldCheckboxIconElement.removeCls(checkboxIconElCls);
}}});
Ext.define('Ext.grid.column.Column', {extend:Ext.grid.HeaderContainer, alternateClassName:'Ext.grid.column.Template', xtype:['gridcolumn', 'column', 'templatecolumn'], isGridColumn:true, mixins:[Ext.mixin.StyleCacher, Ext.mixin.Toolable], config:{align:undefined, cell:{xtype:'gridcell'}, dataIndex:null, defaultWidth:100, depends:null, emptyText:{cached:true, $value:''}, text:'', sortable:true, groupable:true, resizable:true, hideable:true, renderer:null, formatter:null, scope:null, editable:null, 
editor:null, defaultEditor:{lazy:true, $value:{}}, ignore:false, ignoreExport:false, exportStyle:null, exportRenderer:false, summary:null, summaryCell:null, summaryDataIndex:null, summaryFormatter:null, summaryRenderer:null, summaryType:null, exportSummaryRenderer:false, minWidth:40, tpl:null, computedWidth:null, grouper:{lazy:true, $value:null}, groupHeaderTpl:null, sorter:{lazy:true, $value:true}, scratchCell:{lazy:true, $value:true}, menu:{lazy:true, $value:{}}, menuDisabled:null, hideShowMenuItem:{lazy:true, 
$value:{xtype:'menucheckitem'}}}, toolDefaults:{ui:'gridcolumn', zone:'tail'}, toolAnchorName:'titleWrapElement', dockTools:false, scrollable:false, docked:null, sortState:null, ariaSortStates:{ASC:'ascending', DESC:'descending'}, inheritUi:true, classCls:Ext.baseCSSPrefix + 'gridcolumn', sortedCls:Ext.baseCSSPrefix + 'sorted', secondarySortCls:Ext.baseCSSPrefix + 'secondary-sort', auxSortCls:Ext.baseCSSPrefix + 'aux-sort', resizableCls:Ext.baseCSSPrefix + 'resizable', groupCls:Ext.baseCSSPrefix + 
'group', leafCls:Ext.baseCSSPrefix + 'leaf', menuOpenCls:Ext.baseCSSPrefix + 'menu-open', alignCls:{left:Ext.baseCSSPrefix + 'align-left', center:Ext.baseCSSPrefix + 'align-center', right:Ext.baseCSSPrefix + 'align-right'}, constructor:function(config) {
  var me = this, isHeaderGroup, menu;
  if (config.columns || me.columns) {
    isHeaderGroup = me.isHeaderGroup = true;
  } else {
    me.isLeafHeader = true;
  }
  me.callParent([config]);
  me.addCls(isHeaderGroup ? me.groupCls : me.leafCls);
  menu = me.getConfig('menu', true);
  if (!menu && me.getMenuDisabled() === null) {
    me.setMenuDisabled(true);
  }
}, getTemplate:function() {
  var me = this, beforeTitleTemplate = me.beforeTitleTemplate, afterTitleTemplate = me.afterTitleTemplate, titleTpl = [];
  if (beforeTitleTemplate) {
    titleTpl.push.apply(titleTpl, beforeTitleTemplate);
  }
  titleTpl.push({reference:'titleElement', className:Ext.baseCSSPrefix + 'title-el', children:[{reference:'textElement', className:Ext.baseCSSPrefix + 'text-el', 'data-qoverflow':true}, {reference:'sortIconElement', cls:Ext.baseCSSPrefix + 'sort-icon-el ' + Ext.baseCSSPrefix + 'font-icon'}]});
  if (afterTitleTemplate) {
    titleTpl.push.apply(titleTpl, afterTitleTemplate);
  }
  return [{reference:'headerElement', cls:Ext.baseCSSPrefix + 'header-el', children:[{reference:'titleWrapElement', cls:Ext.baseCSSPrefix + 'title-wrap-el', uiCls:'title-wrap-el', children:titleTpl}, {reference:'resizerElement', cls:Ext.baseCSSPrefix + 'resizer-el ' + Ext.baseCSSPrefix + 'item-no-tap'}, {reference:'triggerElement', cls:Ext.baseCSSPrefix + 'trigger-el ' + Ext.baseCSSPrefix + 'font-icon ' + Ext.baseCSSPrefix + 'item-no-tap'}]}, {reference:'bodyElement', cls:Ext.baseCSSPrefix + 'body-el', 
  uiCls:'body-el'}];
}, initialize:function() {
  var me = this;
  if (me.isLeafHeader && !me.getWidth() && me.getFlex() == null) {
    me.setWidth(me.getDefaultWidth());
  }
  me.callParent();
  me.element.on({tap:'onColumnTap', longpress:'onColumnLongPress', scope:this});
  me.triggerElement.on({tap:'onTriggerTap', scope:this});
  me.resizerElement.on({tap:'onResizerTap', scope:this});
  if (me.isHeaderGroup) {
    me.on({add:'doVisibilityCheck', remove:'doVisibilityCheck', show:'onColumnShow', hide:'onColumnHide', move:'onColumnMove', delegate:'\x3e column', scope:me});
    me.on({show:'onShow', scope:me});
  }
}, doDestroy:function() {
  var me = this;
  me.destroyMembers('editor', 'resizeListener', 'menu', 'hideShowMenuItem', 'childColumnsMenu');
  me.setScratchCell(null);
  me.mixins.toolable.doDestroy.call(me);
  me.callParent();
}, onAdded:function(parent, instanced) {
  this.visibleIndex = null;
  this.callParent([parent, instanced]);
}, getVisibleIndex:function() {
  var visibleIndex = this.visibleIndex, rootHeaders;
  if (visibleIndex == null) {
    if (this.isHeaderGroup) {
      visibleIndex = false;
    } else {
      rootHeaders = this.getRootHeaderCt();
      if (rootHeaders) {
        visibleIndex = rootHeaders.indexOfLeaf(this);
      }
    }
    this.visibleIndex = visibleIndex;
  }
  return visibleIndex;
}, _columnScopeRe:/^column\./, _gridScopeRe:/^grid\./, applyMenu:function(menu) {
  var me = this, grid = me.getGrid(), columnScopeRe = me._columnScopeRe, gridScopeRe = me._gridScopeRe, extraItems, gridColumnMenu, i, item, items, s;
  Ext.destroy(me.sortChangeListener);
  if (menu && !menu.isMenu) {
    if (Ext.isArray(menu)) {
      extraItems = menu;
      menu = null;
    } else {
      if (!menu.items) {
        menu = {items:menu};
      }
    }
    if (!(gridColumnMenu = grid.getColumnMenu())) {
      menu = menu ? Ext.clone(menu) : {};
    } else {
      gridColumnMenu = Ext.clone(gridColumnMenu);
      menu = menu ? Ext.merge(gridColumnMenu, menu) : gridColumnMenu;
    }
    menu.ownerCmp = me;
    menu = Ext.create(menu);
    me.sortChangeListener = menu.on({groupchange:'onColumnMenuGroupChange', scope:me});
    for (items = menu.getItems().items, i = items && items.length; i-- > 0;) {
      item = items[i];
      if (columnScopeRe.test(s = item.getHandler() || '')) {
        item.setHandler(s.substr(7));
        item.scope = me;
      } else {
        if (gridScopeRe.test(s)) {
          item.setHandler(s.substr(5));
          item.scope = grid;
        } else {
          if (item.isMenuCheckItem) {
            if (columnScopeRe.test(s = item.getCheckHandler() || '')) {
              item.setCheckHandler(s.substr(7));
              item.scope = me;
            } else {
              if (gridScopeRe.test(s)) {
                item.setCheckHandler(s.substr(5));
                item.scope = grid;
              }
            }
          }
        }
      }
    }
    if (extraItems) {
      menu.add(extraItems);
    }
    grid.fireEvent('columnmenucreated', grid, me, menu);
  }
  return menu;
}, updateMenu:function(menu, oldMenu) {
  if (oldMenu) {
    oldMenu.destroy();
  }
}, beforeShowMenu:function(menu) {
  var me = this, store = me.getGrid().getStore(), isGrouped = store && !!store.getGrouper(), groupByThis = menu.getComponent('groupByThis'), showInGroups = menu.getComponent('showInGroups'), sortAsc = menu.getComponent('sortAsc'), sortDesc = menu.getComponent('sortDesc');
  sortAsc.setDisabled(!store);
  sortDesc.setDisabled(!store);
  if (!store) {
    groupByThis.setHidden(true);
    showInGroups.setHidden(true);
    return;
  }
  menu.suspendEvent('groupchange');
  if (sortAsc) {
    me.syncMenuItemState(sortAsc);
  }
  if (sortDesc) {
    me.syncMenuItemState(sortDesc);
  }
  if (groupByThis) {
    groupByThis.setHidden(!(me.canGroup() && !store.isTreeStore));
  }
  menu.resumeEvent('groupchange');
  if (showInGroups) {
    showInGroups.setHidden(store.isTreeStore);
    showInGroups.setChecked(isGrouped);
    showInGroups.setDisabled(!isGrouped);
  }
}, showMenu:function() {
  var me = this, menu = !me.getMenuDisabled() && me.getMenu(), menuOpenCls = me.menuOpenCls, columnsMenu, grid;
  if (menu) {
    grid = me.getGrid();
    columnsMenu = grid.getColumnsMenuItem();
    menu.add(columnsMenu);
    if (me.beforeShowMenu(menu) !== false && grid.beforeShowColumnMenu(me, menu) !== false) {
      menu.showBy(me.triggerElement);
      me.addCls(menuOpenCls);
      menu.on({single:true, hide:function() {
        if (!(me.destroyed || me.destroying)) {
          me.removeCls(menuOpenCls);
          menu.remove(columnsMenu, false);
        }
      }});
    }
  }
}, getCells:function() {
  var cells = [], rows = this.getGrid().items.items, len = rows.length, i, row;
  for (i = 0; i < len; ++i) {
    row = rows[i];
    if (row.isGridRow) {
      cells.push(row.getCellByColumn(this));
    }
  }
  return cells;
}, getColumnForField:function(fieldName) {
  if (fieldName === this.getDataIndex()) {
    return this;
  }
  return this.callParent([fieldName]);
}, isHideable:function() {
  var menuOfferingColumns = [];
  this.getRootHeaderCt().visitPreOrder('gridcolumn:not([hidden])', function(col) {
    if (!col.getMenuDisabled() && col.getConfig('menu', true)) {
      menuOfferingColumns.push(col);
    }
  });
  return menuOfferingColumns.length > 1 || menuOfferingColumns[0] !== this;
}, applyTpl:function(tpl) {
  return Ext.XTemplate.get(tpl);
}, applyAlign:function(align, oldAlign) {
  if (align == null) {
    align = this.isHeaderGroup ? 'center' : 'left';
  }
  return align;
}, updateAlign:function(align, oldAlign) {
  var me = this, alignCls = me.alignCls;
  if (oldAlign) {
    me.removeCls(alignCls[oldAlign]);
  }
  if (align) {
    if (!alignCls[align]) {
      Ext.raise("Invalid value for align: '" + align + "'");
    }
    me.addCls(alignCls[align]);
  }
  me.syncToolableAlign();
}, updateMenuDisabled:function(menuDisabled) {
  if (this.triggerElement) {
    this.triggerElement.setVisible(!menuDisabled);
  }
}, onColumnTap:function(e) {
  var me = this, grid = me.getGrid(), selModel = grid.getSelectable(), store = grid.getStore(), sorters = store && store.getSorters(true), sorter = store && me.pickSorter(), sorterIndex = sorter ? sorters.indexOf(sorter) : -1, isSorted = sorter && (sorterIndex !== -1 || sorter === store.getGrouper());
  if (Ext.Component.from(e) !== me || e.getTarget('.' + Ext.baseCSSPrefix + 'item-no-tap', me)) {
    return;
  }
  if (store && me.isSortable() && (!selModel || !selModel.getColumns())) {
    if (sorter.isGrouper) {
      sorter.toggle();
      store.group(sorter);
    } else {
      if (sorterIndex === 0) {
        me.toggleSortState();
      } else {
        if (isSorted) {
          store.sort(sorter, 'prepend');
        } else {
          me.sort('ASC');
        }
      }
    }
  }
  return me.fireEvent('tap', me, e);
}, onTriggerTap:function(e) {
  this.fireEvent('triggertap', this, e);
}, onResizerTap:function(e) {
  if (e.getPoint().isContainedBy(this.triggerElement.getRegion())) {
    this.fireEvent('triggertap', this, e);
  }
}, onColumnLongPress:function(e) {
  this.fireEvent('longpress', this, e);
}, onGroupByThis:function() {
  var me = this, grid = me.getGrid(), grouper = me.getGrouper(), store = grid.getStore(), dataIndex;
  if (!grouper) {
    dataIndex = me.getDataIndex();
    if (dataIndex != null) {
      me.setGrouper({property:dataIndex});
      grouper = me.getGrouper();
    }
  }
  if (grouper) {
    store.setGrouper(grouper);
  }
}, onColumnMenuGroupChange:function(menu, groupName, value) {
  if (groupName === 'sortDir') {
    this.setSortDirection(value);
  }
}, getSortDirection:function() {
  var sorter = this.pickSorter();
  return sorter && sorter.getDirection();
}, setSortDirection:function(direction) {
  var me = this, grid = me.getGrid(), store = grid.getStore(), sorter = me.pickSorter(), sorters = store.getSorters(true), isSorted = sorter && (sorters.contains(sorter) || sorter.isGrouper);
  if (direction) {
    if (isSorted) {
      if (sorter.getDirection() !== direction) {
        sorter.setDirection(direction);
        if (sorter.isGrouper) {
          store.group(sorter);
        } else {
          sorters.beginUpdate();
          sorters.endUpdate();
        }
      }
    } else {
      return me.sort(direction);
    }
  } else {
    if (sorter) {
      sorters.remove(sorter);
    }
  }
  if (!store.getRemoteSort()) {
    me.getRootHeaderCt().setSortState();
  }
}, syncMenuItemState:function(menuItem) {
  if (menuItem) {
    var me = this, sortable = me.isSortable(), store = me.getGrid().getStore(), sorter = me.pickSorter(), isSorted = sorter && (store.getSorters().contains(sorter) || sorter.isGrouper);
    menuItem.setDisabled(!sortable);
    menuItem.setChecked(sortable && isSorted && sorter.getDirection() === menuItem.getValue());
  }
}, onToggleShowInGroups:function(menuItem) {
  var grid = this.getGrid(), store = grid.getStore();
  store.setGrouper(null);
}, updateResizable:function(resizable) {
  var me = this, widthed = me.getWidth() != null, flexed = me.getFlex() != null;
  me.toggleCls(me.resizableCls, !!(me.getResizable() && (widthed || flexed || me.isLeafHeader)));
}, updateText:function(text) {
  this.setHtml(text || '');
}, onResize:function() {
  if (!this.isHidden(true)) {
    this.updateResizable(this.getResizable());
    this.measureWidth();
  }
}, getComputedWidth:function() {
  return this.isVisible(true) ? this._computedWidth : 0;
}, updateColumns:function(columns) {
  this.getItems();
  this.add(columns);
}, measureWidth:function() {
  var width = this.el.measure('w');
  this.setComputedWidth(width);
  return width;
}, updateComputedWidth:function(value, oldValue) {
  var me = this, rootHeaderCt = !me.isConfiguring && me.getRootHeaderCt();
  if (rootHeaderCt) {
    rootHeaderCt.onColumnComputedWidthChange(me, value);
    me.fireEvent('columnresize', me, value, oldValue);
  }
}, updateDataIndex:function(dataIndex) {
  var sorter;
  if (!this.isConfiguring) {
    sorter = this.pickSorter();
    if (sorter) {
      this.setSorter(null);
    }
  }
}, applyGroupHeaderTpl:function(tpl) {
  return Ext.XTemplate.get(tpl);
}, updateGroupHeaderTpl:function(tpl) {
  var grouper = this.grouper;
  if (grouper) {
    grouper.headerTpl = tpl;
  }
}, isSortable:function() {
  var me = this;
  return me.isLeafHeader && me.getSortable() && (me.pickSorter() || me.getDataIndex()) && me.getRootHeaderCt().getSortable() && me.getGrid().sortableColumns !== false;
}, applyEditor:function(value) {
  if (value && !value.isInstance) {
    if (typeof value === 'string') {
      value = {xtype:value};
    }
    if (!value.xtype) {
      value = Ext.apply({xtype:value.field ? 'celleditor' : 'textfield'}, value);
    }
    return Ext.create(value);
  }
  return value;
}, applyDefaultEditor:function(editor) {
  var dataIndex = this.getDataIndex(), model, field;
  if (dataIndex && !editor.isInstance) {
    editor = Ext.clone(editor);
    if (!editor.isInstance && !editor.xtype) {
      model = this.getGrid().getStore().getModel();
      field = model.getField(dataIndex);
      if (field) {
        switch(field.type) {
          case 'date':
            editor.xtype = 'datefield';
            break;
          case 'int':
          case 'integer':
            editor.xtype = 'numberfield';
            editor.decimals = 0;
            break;
          case 'float':
          case 'number':
            editor.xtype = 'numberfield';
            break;
          case 'boolean':
          case 'bool':
            editor.xtype = 'checkboxfield';
            break;
          default:
            editor.xtype = 'textfield';
        }
      } else {
        editor.xtype = 'textfield';
      }
    }
  }
  return editor;
}, updateEditor:function(editor, oldEditor) {
  if (oldEditor && (!editor || editor.isCellEditor && editor.getField() !== oldEditor)) {
    oldEditor.destroy();
  }
}, applyFormatter:function(format) {
  var me = this, fmt = format, parser;
  if (fmt) {
    parser = Ext.app.bind.Parser.fly(fmt);
    fmt = parser.compileFormat();
    parser.release();
    return function(v) {
      return fmt(v, me.getScope() || me.resolveListenerScope());
    };
  }
  return fmt;
}, applySummaryFormatter:function(format) {
  var me = this, fmt = format, parser;
  if (fmt) {
    parser = Ext.app.bind.Parser.fly(fmt);
    fmt = parser.compileFormat();
    parser.release();
    return function(v) {
      return fmt(v, me.getScope() || me.resolveListenerScope());
    };
  }
  return fmt;
}, applyGrouper:function(grouper) {
  var me = this, cfg = grouper;
  if (cfg && !cfg.isInstance) {
    if (typeof cfg === 'string') {
      cfg = {groupFn:cfg};
    } else {
      cfg = Ext.apply({}, cfg);
    }
    if (typeof cfg.groupFn === 'string') {
      cfg = me.scopeReplacer(cfg, grouper, 'groupFn', 'setGroupFn');
    }
    if (typeof cfg.sorterFn === 'string') {
      cfg = me.scopeReplacer(cfg, grouper, 'sorterFn', 'setSorterFn');
    }
    grouper = new Ext.util.Grouper(cfg);
  }
  if (grouper) {
    grouper.owner = me.getGrid();
    grouper.headerTpl = me.getGroupHeaderTpl();
  }
  return grouper;
}, updateGrouper:function(grouper, oldGrouper) {
  var store = this.getGrid().getStore();
  if (store && oldGrouper) {
    if (oldGrouper === store.getGrouper()) {
      store.setGrouper(grouper);
    }
  }
  this.grouper = grouper;
}, applySorter:function(sorter) {
  var me = this, cfg = sorter, sortProperty;
  if (cfg && !cfg.isInstance) {
    if (cfg === true) {
      sortProperty = me.getSortParam();
      if (!sortProperty) {
        return null;
      }
      cfg = {property:sortProperty, direction:'ASC'};
    } else {
      if (typeof cfg === 'string') {
        cfg = {sorterFn:cfg};
      }
      if (typeof cfg.sorterFn === 'string') {
        cfg = me.scopeReplacer(cfg, sorter, 'sorterFn', 'setSorterFn');
      }
    }
    sorter = new Ext.util.Sorter(cfg);
  }
  if (sorter) {
    sorter.owner = me.getGrid();
  }
  return sorter;
}, updateSorter:function(sorter, oldSorter) {
  var store = this.getGrid().getStore(), sorters = store ? store.getSorters() : null, at;
  if (sorters) {
    if (oldSorter && (at = sorters.indexOf(oldSorter)) > -1) {
      if (sorter) {
        sorters.splice(at, 1, sorter);
      } else {
        sorters.remove(oldSorter);
      }
    }
  }
  this.sorter = sorter;
}, pickSorter:function() {
  var me = this, store = me.getGrid().getStore(), result;
  if (store.isGrouped() && store.getGroupField() === me.getDataIndex()) {
    result = me.getGrouper() || store.getGrouper();
    me.sortState = result.getDirection();
  } else {
    result = me.getSorter();
  }
  return result;
}, applyHideShowMenuItem:function(config, existing) {
  return Ext.updateWidget(existing, config, this, 'createHideShowMenuItem');
}, createHideShowMenuItem:function(defaults) {
  return Ext.apply({text:this.getText(), checked:!this.getHidden(), column:this}, defaults);
}, getHideShowMenuItem:function(deep) {
  var me = this, result = me.callParent(), items = me.items.items, len = items.length, childItems = [], childColumnsMenu = me.childColumnsMenu, i;
  if (me.isHeaderGroup && deep !== false) {
    if (!childColumnsMenu) {
      result.setMenu({});
      me.childColumnsMenu = childColumnsMenu = result.getMenu();
    }
    if (!childColumnsMenu.items.length || me.rebuildChildColumnsMenu) {
      for (i = 0; i < len; i++) {
        if (items[i].getHideable()) {
          childItems.push(items[i].getHideShowMenuItem());
        }
      }
      childColumnsMenu.removeAll(false);
      childColumnsMenu.add(childItems);
    }
  }
  result['set' + (result.getMenu() ? 'CheckChange' : '') + 'Disabled'](!me.isHideable());
  return result;
}, getInnerHtmlElement:function() {
  return this.textElement;
}, getSortParam:function() {
  return this.getDataIndex();
}, applyCell:function(cell, oldCell) {
  if (oldCell) {
    cell = Ext.apply(oldCell, cell);
  }
  return cell;
}, createCell:function(row) {
  var me = this, cfg = {row:row, ownerCmp:row || me, column:me, width:me.rendered ? me.getComputedWidth() || me.measureWidth() : me.getWidth(), minWidth:me.getMinWidth()}, align = me.getAlign(), cellCfg;
  if (row && row.isSummaryRow) {
    cellCfg = me.getSummaryCell();
    if (!cellCfg) {
      cellCfg = me.getCell();
      if (cellCfg.xtype === 'widgetcell') {
        cellCfg = Ext.apply({}, cellCfg);
        cellCfg.xtype = 'gridcell';
        delete cellCfg.widget;
      }
    }
  } else {
    cellCfg = me.getCell();
  }
  if (align) {
    cfg.align = align;
  }
  if (row) {
    cfg.hidden = me.isHidden(row.getGrid().getHeaderContainer());
    cfg.record = row.getRecord();
    if (!(cfg.ui = row.getDefaultCellUI())) {
      delete cfg.ui;
    }
  }
  if (typeof cellCfg === 'string') {
    cfg.xtype = cellCfg;
  } else {
    Ext.apply(cfg, cellCfg);
  }
  return cfg;
}, applyScratchCell:function(cell, oldCell) {
  var me = this;
  if (cell) {
    cell = Ext.create(me.createCell());
    if (!cell.printValue) {
      Ext.destroy(cell);
      cell = me.createCell();
      cell.xtype = 'gridcell';
      cell = Ext.create(cell);
    }
    cell.addCls(me.floatingCls);
  }
  if (oldCell) {
    oldCell.destroy();
  }
  return cell;
}, printValue:function(value) {
  var me = this, rows = me.getGrid().dataItems, cell;
  if (rows.length) {
    cell = rows[0].getCellByColumn(me);
  }
  cell = cell && cell.printValue ? cell : me.getScratchCell();
  return cell.printValue(value);
}, privates:{directionSequence:{'null':'ASC', 'ASC':'DESC', 'DESC':null}, applySummary:function(summary) {
  if (summary) {
    summary = Ext.Factory.dataSummary(summary);
  }
  return summary;
}, beginRefresh:function(context) {
  var me = this, grid = me.getGrid();
  context = context || {};
  context.column = me;
  context.grid = grid;
  context.store = grid.store;
  return context;
}, canGroup:function() {
  return this.getGroupable() && (this.getDataIndex() || this.getGrouper());
}, sort:function(direction, mode) {
  var me = this, sorter = me.pickSorter(), grid = me.getGrid(), store = grid.getStore(), sorters = store.getSorters();
  if (!me.isSortable()) {
    return;
  }
  if (sorter.isGrouper) {
    if (sorter.getDirection() !== direction) {
      sorter.toggle();
      store.group(sorter);
    }
  } else {
    if (direction) {
      if (sorter) {
        if (sorters.indexOf(sorter) !== 0) {
          sorter.setDirection(direction);
        }
      } else {
        me.setSorter({property:me.getSortParam(), direction:'ASC'});
        sorter = me.getSorter();
      }
      store.sort(sorter, mode || grid.getMultiColumnSort() ? 'multi' : 'replace');
    } else {
      if (sorter) {
        sorters.remove(sorter);
        if (!store.getRemoteSort()) {
          me.getRootHeaderCt().setSortState();
        }
      }
    }
  }
}, toggleSortState:function() {
  this.sort(this.directionSequence[this.sortState]);
}, setSortState:function(sorter) {
  var me = this, store = me.getGrid().getStore(), grouper = store.isGrouped() && store.getGrouper(), oldDirection = me.sortState, direction = null, sortedCls = me.sortedCls, secondarySortCls = me.secondarySortCls, auxSortCls = me.auxSortCls, ascCls = sortedCls + '-asc', descCls = sortedCls + '-desc', ariaDom = me.ariaEl.dom, sortPrioClass = '', changed, index, remove = [secondarySortCls, auxSortCls], add;
  if (sorter) {
    if (typeof sorter === 'string') {
      direction = sorter;
    } else {
      if (!sorter.isSorter) {
        Ext.raise('Must pass a sorter instance into HeaderContainer#saveState');
      }
      if (sorter === grouper) {
        index = 0;
      } else {
        index = store.getSorters().indexOf(sorter);
      }
      if (index === -1) {
        Ext.raise("Sorter passed into HeaderContainer#saveState is not used by the grid's store");
      }
      direction = sorter.getDirection();
      sortPrioClass = index === 1 ? secondarySortCls : index > 1 ? auxSortCls : '';
    }
  }
  changed = direction !== oldDirection;
  me.sortState = direction;
  switch(direction) {
    case 'DESC':
      add = [sortedCls, descCls, sortPrioClass];
      remove.push(ascCls);
      break;
    case 'ASC':
      add = [sortedCls, ascCls, sortPrioClass];
      remove.push(descCls);
      break;
    default:
      remove.push(sortedCls, ascCls, descCls);
      break;
  }
  me.replaceCls(remove, add);
  if (ariaDom) {
    if (direction) {
      ariaDom.setAttribute('aria-sort', me.ariaSortStates[direction]);
    } else {
      ariaDom.removeAttribute('aria-sort');
    }
  }
  if (changed) {
    me.fireEvent('sort', me, direction, oldDirection);
  }
}, getVisibleCount:function() {
  var columns = this.getInnerItems(), len = columns.length, count = 0, i;
  for (i = 0; i < len; ++i) {
    if (columns[i].isHeaderGroup) {
      count += columns[i].getVisibleCount();
    } else {
      count += columns[i].isHidden() ? 0 : 1;
    }
  }
  return count;
}, onShow:function() {
  var toShow;
  if (!this.getVisibleCount()) {
    toShow = this.getComponent(0);
    if (toShow) {
      toShow.show();
    }
  }
}, doVisibilityCheck:function() {
  var me = this, columns = me.getInnerItems(), ln = columns.length, i, column;
  for (i = 0; i < ln; i++) {
    column = columns[i];
    if (!column.isHidden()) {
      if (me.isHidden()) {
        if (me.initialized) {
          me.show();
        } else {
          me.setHidden(false);
        }
      }
      return;
    }
  }
  me.hide();
  me.rebuildChildColumnsMenu = true;
  me.updateMenuDisabledState();
}, onColumnShow:function() {
  var me = this, hideShowItem;
  if (me.getVisibleCount() > 0) {
    me.show();
    hideShowItem = me.getHideShowMenuItem(false);
    hideShowItem.setChecked(true);
    hideShowItem.setCheckChangeDisabled(false);
  }
  me.rebuildChildColumnsMenu = true;
  me.updateMenuDisabledState();
}, onColumnHide:function(column) {
  var me = this, hideShowItem;
  if (me.getVisibleCount() === 0) {
    me.hide();
    hideShowItem = me.getHideShowMenuItem(false);
    hideShowItem.setChecked(false);
    hideShowItem.setCheckChangeDisabled(true);
  }
  me.rebuildChildColumnsMenu = true;
  me.updateMenuDisabledState();
}, onColumnMove:function(column) {
  this.rebuildChildColumnsMenu = true;
}, scopeReplacer:function(config, original, prop, setter) {
  var me = this, name = config[prop];
  if (typeof name === 'string') {
    prop = prop || 'sorterFn';
    setter = setter || 'setSorterFn';
    if (original === config) {
      config = Ext.apply({}, config);
    }
    config[prop] = function() {
      var scope = me.resolveListenerScope(), fn = scope && scope[name], ret = 0;
      if (fn) {
        this[setter](fn.bind(scope));
        ret = fn.apply(scope, arguments);
      } else {
        if (!scope) {
          Ext.raise('Cannot resolve scope for column ' + me.id);
        } else {
          Ext.raise('No such method "' + name + '" on ' + scope.$className);
        }
      }
      return ret;
    };
  }
  return config;
}}});
Ext.define('Ext.grid.cell.Date', {extend:Ext.grid.cell.Text, xtype:'datecell', isDateCell:true, config:{format:''}, updateColumn:function(column, oldColumn) {
  var format;
  this.callParent([column, oldColumn]);
  if (column && column.isDateColumn) {
    format = column.getFormat();
    if (format !== null) {
      this.setFormat(format);
    }
  }
}, applyFormat:function(format) {
  return format || Ext.Date.defaultFormat;
}, updateFormat:function(format) {
  if (!this.isConfiguring) {
    this.writeValue();
  }
}, formatValue:function(value) {
  return value ? Ext.Date.format(value, this.getFormat()) : '';
}});
Ext.define('Ext.grid.column.Date', {extend:Ext.grid.column.Column, xtype:'datecolumn', isDateColumn:true, config:{format:null, defaultEditor:{xtype:'datepickerfield'}, cell:{xtype:'datecell'}}});
Ext.define('Ext.grid.menu.Columns', {extend:Ext.menu.Item, xtype:'gridcolumnsmenu', iconCls:Ext.baseCSSPrefix + 'headermenu-columns-icon', text:'Columns', menu:{}, updateMenu:function(menu, oldMenu) {
  this.callParent([menu, oldMenu]);
  if (menu) {
    this.menuListeners = menu.on({beforeshow:'onBeforeShowColumnsMenu', checkchange:{fn:'onCheckItem', delegate:'menucheckitem'}, scope:this, destroyable:true});
  } else {
    Ext.destroy(this.menuListeners);
  }
}, onBeforeShowColumnsMenu:function(menu) {
  var me = this, grid = me.grid, columns = grid.getHeaderContainer().items.items, items = [], len = columns.length, i, column;
  for (i = 0; i < len; ++i) {
    column = columns[i];
    if (column.getHideable()) {
      items.push(column.getHideShowMenuItem());
    }
  }
  menu.removeAll(false);
  menu.add(items);
}, onCheckItem:function(menuItem, checked) {
  menuItem.column.setHidden(!checked);
}});
Ext.define('Ext.grid.menu.GroupByThis', {extend:Ext.menu.Item, xtype:'gridgroupbythismenuitem', iconCls:Ext.baseCSSPrefix + 'headermenu-group-by-this', text:'Group by this field'});
Ext.define('Ext.grid.menu.ShowInGroups', {extend:Ext.menu.CheckItem, xtype:'gridshowingroupsmenuitem', hideOnClick:true, text:'Show in groups'});
Ext.define('Ext.menu.RadioItem', {extend:Ext.menu.CheckItem, alias:'widget.menuradioitem', classCls:Ext.baseCSSPrefix + 'menuradioitem', nameable:true, shareableName:true, ariaRole:'menuitemradio', config:{group:null, allowUncheck:null}, initialize:function() {
  if (!this.getGroup()) {
    Ext.raise('Menu RadioItems must be configured with a group');
  }
  this.callParent();
}, privates:{onSpace:function(e) {
  if (this.checkboxElement.dom.checked) {
    e.preventDefault();
  }
}, updateGroup:function(group) {
  this.name = group;
}, onCheckboxChange:function() {
  var checkboxElement = this.checkboxElement.dom, isChecked = checkboxElement.checked;
  if (isChecked === this.getChecked() || this.getDisabled()) {
    return;
  }
  if (!isChecked && !this.getAllowUncheck()) {
    checkboxElement.checked = true;
  } else {
    this.callParent();
  }
}, onCheckChange:function() {
  var me = this, checkboxElement = me.checkboxElement.dom, parentMenu = me.getParent(), name, groups, siblings, len, i;
  me.getGroup();
  name = me.name;
  if (parentMenu && name) {
    groups = {};
    if (checkboxElement.checked) {
      groups[name] = me.getValue();
      parentMenu.setGroups(groups);
    } else {
      siblings = parentMenu.lookupName(name);
      len = siblings && siblings.length;
      for (i = 0; i < len && !siblings[i].checkboxElement.dom.checked; i++) {
      }
      if (i === len) {
        groups[name] = null;
        parentMenu.setGroups(groups);
      }
    }
  }
  me.callParent();
}}});
Ext.define('Ext.grid.menu.SortAsc', {extend:Ext.menu.RadioItem, xtype:'gridsortascmenuitem', iconCls:Ext.baseCSSPrefix + 'headermenu-sort-asc', text:'Sort Ascending', value:'ASC', allowUncheck:true, group:'grid-sorters'});
Ext.define('Ext.grid.menu.SortDesc', {extend:Ext.menu.RadioItem, xtype:'gridsortdescmenuitem', iconCls:Ext.baseCSSPrefix + 'headermenu-sort-desc', text:'Sort Descending', value:'DESC', allowUncheck:true, group:'grid-sorters'});
Ext.define('Ext.grid.selection.Cells', {extend:Ext.dataview.selection.Selection, alias:'selection.cells', isCells:true, clone:function() {
  var me = this, result = new me.self(me.view);
  if (me.startCell) {
    result.startCell = me.startCell.clone();
    result.endCell = me.endCell.clone();
  }
  return result;
}, isSelected:function(recordIndex, columnIndex) {
  var range;
  if (this.startCell) {
    if (recordIndex.isGridLocation) {
      columnIndex = recordIndex.columnIndex;
      recordIndex = recordIndex.recordIndex;
    }
    if (!(Ext.isNumber(recordIndex) && Ext.isNumber(columnIndex))) {
      Ext.raise('Cells#isSelected must be passed either a GridLocation of a row and column index');
    }
    range = this.getRowRange();
    if (recordIndex >= range[0] && recordIndex <= range[1]) {
      range = this.getColumnRange();
      return columnIndex >= range[0] && columnIndex <= range[1];
    }
  }
  return false;
}, eachRow:function(fn, scope) {
  var me = this, rowRange = me.getRowRange(), store = me.view.store, rowIdx;
  for (rowIdx = rowRange[0]; rowIdx <= rowRange[1]; rowIdx++) {
    if (fn.call(scope || me, store.getAt(rowIdx)) === false) {
      return;
    }
  }
}, eachColumn:function(fn, scope) {
  var colRange = this.getColumnRange(), columns = this.view.getVisibleColumns(), i;
  for (i = colRange[0]; i <= colRange[1]; i++) {
    if (fn.call(scope || this, columns[i], i) === false) {
      return;
    }
  }
}, eachCell:function(fn, scope) {
  var me = this, view = me.view, store = view.store, rowRange = me.getRowRange(), colRange = me.getColumnRange(), baseLocation, location, rowIdx, colIdx;
  for (rowIdx = rowRange[0]; rowIdx <= rowRange[1]; rowIdx++) {
    baseLocation = new Ext.grid.Location(view, store.getAt(rowIdx));
    for (colIdx = colRange[0]; colIdx <= colRange[1]; colIdx++) {
      location = baseLocation.cloneForColumn(colIdx);
      if (fn.call(scope || me, location, colIdx, rowIdx) === false) {
        return;
      }
    }
  }
}, getFirstRowIndex:function() {
  return this.startCell ? Math.min(this.startCell.recordIndex, this.endCell.recordIndex) : 0;
}, getLastRowIndex:function() {
  return this.startCell ? Math.max(this.startCell.recordIndex, this.endCell.recordIndex) : -1;
}, getFirstColumnIndex:function() {
  return this.startCell ? Math.min(this.startCell.columnIndex, this.endCell.columnIndex) : 0;
}, getLastColumnIndex:function() {
  return this.startCell ? Math.max(this.startCell.columnIndex, this.endCell.columnIndex) : -1;
}, privates:{clear:function(suppressEvent) {
  var me = this, view = me.view, changed;
  if (view.getVisibleColumns().length) {
    me.eachCell(function(location) {
      view.onCellDeselect(location);
      changed = true;
    });
  }
  me.startCell = me.endCell = null;
  if (changed && !suppressEvent) {
    this.getSelectionModel().fireSelectionChange();
  }
}, setRangeStart:function(startCell) {
  this.startCell = (this.endCell = startCell.clone()).clone();
  this.view.onCellSelect(startCell);
  this.fireCellSelection();
}, setRangeEnd:function(endCell) {
  var me = this, view = me.view, store = view.store, renderInfo = view.renderInfo, maxColIdx = view.getVisibleColumns().length - 1, range, lastRange, rowStart, rowEnd, colStart, colEnd, rowIdx, colIdx, location, baseLocation;
  me.endCell = endCell.clone();
  range = me.getRange();
  lastRange = me.lastRange || range;
  rowStart = Math.max(Math.min(range[0][1], lastRange[0][1]), renderInfo.indexTop);
  rowEnd = Math.min(Math.max(range[1][1], lastRange[1][1]), renderInfo.indexBottom - 1);
  colStart = Math.min(range[0][0], lastRange[0][0]);
  colEnd = Math.min(Math.max(range[1][0], lastRange[1][0]), maxColIdx);
  for (rowIdx = rowStart; rowIdx <= rowEnd; rowIdx++) {
    baseLocation = new Ext.grid.Location(view, store.getAt(rowIdx));
    for (colIdx = colStart; colIdx <= colEnd; colIdx++) {
      location = baseLocation.cloneForColumn(colIdx);
      if (rowIdx < range[0][1] || rowIdx > range[1][1] || colIdx < range[0][0] || colIdx > range[1][0]) {
        view.onCellDeselect(location);
      } else {
        view.onCellSelect(location);
      }
    }
  }
  me.lastRange = range;
  me.fireCellSelection();
}, extendRange:function(extensionVector) {
  var me = this, view = me.view, newEndCell;
  if (extensionVector[extensionVector.type] < 0) {
    newEndCell = new Ext.grid.Location(view, {record:me.getLastRowIndex(), column:me.getLastColumnIndex()});
    me.startCell = extensionVector.start.clone();
    me.setRangeEnd(newEndCell);
    view.getNavigationModel().setLocation({column:extensionVector.start.columnIndex, record:extensionVector.start.record});
  } else {
    me.startCell = new Ext.grid.Location(view, {record:me.getFirstRowIndex(), column:me.getFirstColumnIndex()});
    me.setRangeEnd(extensionVector.end);
    view.getNavigationModel().setLocation({column:extensionVector.end.columnIndex, record:extensionVector.end.record});
  }
}, reduceRange:function(extensionVector) {
  var me = this, view = me.view, newEndCell;
  if (extensionVector.type === 'rows') {
    newEndCell = new Ext.grid.Location(view, {record:extensionVector.end.recordIndex - 1, column:extensionVector.end.columnIndex});
    me.setRangeEnd(newEndCell);
    view.getNavigationModel().setLocation({column:extensionVector.end.columnIndex, record:me.view.getStore().getAt(extensionVector.end.recordIndex - 1)});
  } else {
    newEndCell = new Ext.grid.Location(view, {record:extensionVector.end.recordIndex, column:extensionVector.end.columnIndex});
    me.setRangeEnd(newEndCell);
    view.getNavigationModel().setLocation({column:extensionVector.end.columnIndex, record:me.view.getStore().getAt(extensionVector.end.recordIndex)});
  }
}, getRange:function() {
  return [[this.getFirstColumnIndex(), this.getFirstRowIndex()], [this.getLastColumnIndex(), this.getLastRowIndex()]];
}, getRangeSize:function() {
  return this.getCount();
}, getRecords:function() {
  var rowRange = this.getRowRange();
  return this.getSelectionModel().getStore().getRange(rowRange[0], rowRange[1]);
}, getCount:function() {
  var range = this.getRange();
  return (range[1][0] - range[0][0] + 1) * (range[1][1] - range[0][1] + 1);
}, fireCellSelection:function() {
  var me = this, selModel = me.getSelectionModel(), view = selModel.getView();
  view.fireEvent('cellselection', view, me.getRange());
}, selectAll:function() {
  var me = this, view = me.view, columns = view.getVisibleColumns();
  me.clear();
  me.setRangeStart(new Ext.grid.Location(view, {record:0, column:0}));
  me.setRangeEnd(new Ext.grid.Location(view, {record:view.store.last(), column:columns[columns.length - 1]}));
}, isAllSelected:function() {
  var start = this.startCell, end = this.endCell;
  if (start) {
    if (!start.columnIndex && !start.recordIndex) {
      return end.columnIndex === end.view.getVisibleColumns().length - 1 && end.recordIndex === end.view.store.getCount() - 1;
    }
  }
  return false;
}, getColumnRange:function() {
  return [this.getFirstColumnIndex(), this.getLastColumnIndex()];
}, getLastSelected:function() {
  return this.view.getStore().getAt(this.endCell.recordIndex);
}, getRowRange:function() {
  return [this.getFirstRowIndex(), this.getLastRowIndex()];
}, onSelectionFinish:function() {
  var me = this, view = me.view;
  if (me.getCount()) {
    me.getSelectionModel().onSelectionFinish(me, new Ext.grid.Location(view, {record:me.getFirstRowIndex(), column:me.getFirstColumnIndex()}), new Ext.grid.Location(view, {record:me.getLastRowIndex(), column:me.getLastColumnIndex()}));
  } else {
    me.getSelectionModel().onSelectionFinish(me);
  }
}}});
Ext.define('Ext.grid.selection.Columns', {extend:Ext.dataview.selection.Selection, alias:'selection.columns', isColumns:true, clone:function() {
  var me = this, result = new me.self(me.view), columns = me.selectedColumns;
  if (columns) {
    result.selectedColumns = Ext.Array.slice(columns);
  }
  return result;
}, eachRow:function(fn, scope) {
  var columns = this.selectedColumns;
  if (columns && columns.length) {
    this.view.getStore().each(fn, scope || this);
  }
}, eachColumn:function(fn, scope) {
  var me = this, columns = me.selectedColumns, len, i;
  if (columns) {
    len = columns.length;
    for (i = 0; i < len; i++) {
      if (fn.call(scope || me, columns[i], i) === false) {
        return false;
      }
    }
  }
}, eachCell:function(fn, scope) {
  var me = this, view = me.view, columns = me.selectedColumns, context = new Ext.grid.Location(view), len, i;
  if (columns) {
    len = columns.length;
    view.getStore().each(function(record) {
      context = context.clone({record:record});
      for (i = 0; i < len; i++) {
        context = context.clone({column:columns[i]});
        if (fn.call(scope || me, context, context.columnIndex, context.recordIndex) === false) {
          return false;
        }
      }
    });
  }
}, isSelected:function(column) {
  var selectedColumns = this.selectedColumns;
  if (column && column.isGridColumn && selectedColumns && selectedColumns.length) {
    return Ext.Array.contains(selectedColumns, column);
  }
  return false;
}, getCount:function() {
  var selectedColumns = this.selectedColumns;
  return selectedColumns ? selectedColumns.length : 0;
}, getColumns:function() {
  return this.selectedColumns || [];
}, privates:{add:function(column, suppressEvent) {
  if (!column.isGridColumn) {
    Ext.raise('Column selection must be passed a grid Column header object');
  }
  var me = this, selModel = me.getSelectionModel();
  Ext.Array.include(me.selectedColumns || (me.selectedColumns = []), column);
  me.refreshColumns(column);
  selModel.updateHeaderState();
  if (!suppressEvent) {
    selModel.fireSelectionChange();
    me.fireColumnSelection();
  }
}, clear:function(suppressEvent) {
  var me = this, selModel = me.getSelectionModel(), prevSelection = me.selectedColumns;
  if (prevSelection && prevSelection.length) {
    me.selectedColumns = [];
    me.refreshColumns.apply(me, prevSelection);
    selModel.updateHeaderState();
    if (!suppressEvent) {
      selModel.fireSelectionChange();
      me.fireColumnSelection();
    }
  }
}, setRangeStart:function(startColumn) {
  var me = this, prevSelection = me.getColumns();
  prevSelection.push(startColumn);
  me.clear(true);
  me.startColumn = startColumn;
  me.add(startColumn);
}, setRangeEnd:function(endColumn) {
  var me = this, prevSelection = me.getColumns(), headerCt = this.view.ownerGrid.getHeaderContainer(), columns = headerCt.getVisibleColumns(), start = headerCt.indexOfLeaf(me.startColumn), end = headerCt.indexOfLeaf(endColumn), i;
  if (end < start) {
    i = start;
    start = end;
    end = i;
  }
  me.selectedColumns = [];
  for (i = start; i <= end; i++) {
    me.selectedColumns.push(columns[i]);
    prevSelection.push(columns[i]);
  }
  me.refreshColumns.apply(me, prevSelection);
  me.fireColumnSelection();
}, isAllSelected:function() {
  var selectedColumns = this.selectedColumns;
  return selectedColumns && selectedColumns.length === this.view.getHeaderContainer().getVisibleColumns().length;
}, refreshColumns:function(column) {
  var me = this, view = me.view, store = view.store, renderInfo = view.renderInfo, columns = arguments, len = columns.length, selected = [], location, rowIdx, colIdx;
  if (view.rendered) {
    for (colIdx = 0; colIdx < len; colIdx++) {
      selected[colIdx] = me.isSelected(columns[colIdx]);
    }
    for (rowIdx = renderInfo.indexTop; rowIdx < renderInfo.indexBottom; rowIdx++) {
      location = new Ext.grid.Location(view, store.getAt(rowIdx));
      for (colIdx = 0; colIdx < len; colIdx++) {
        location = location.cloneForColumn(columns[colIdx]);
        if (selected[colIdx]) {
          view.onCellSelect(location);
        } else {
          view.onCellDeselect(location);
        }
      }
    }
  }
}, remove:function(column, suppressEvent) {
  var me = this, selModel = me.getSelectionModel();
  if (!column.isGridColumn) {
    Ext.raise('Column selection must be passed a grid Column header object');
  }
  if (me.selectedColumns) {
    Ext.Array.remove(me.selectedColumns, column);
    if (column.getGrid() && column.isVisible()) {
      me.refreshColumns(column);
      selModel.updateHeaderState();
      if (!suppressEvent) {
        selModel.fireSelectionChange();
        me.fireColumnSelection();
      }
    }
  }
}, fireColumnSelection:function() {
  var me = this, selModel = me.getSelectionModel(), view = selModel.getView();
  view.fireEvent('columnselection', view, me.selectedColumns);
}, selectAll:function() {
  var me = this;
  me.clear();
  me.selectedColumns = me.getSelectionModel().lastContiguousColumnRange = me.view.getHeaderContainer().getVisibleColumns();
  me.refreshColumns.apply(me, me.selectedColumns);
}, extendRange:function(extensionVector) {
  var me = this, columns = me.view.getHeaderContainer().getVisibleColumns(), i;
  for (i = extensionVector.start.columnIndex; i <= extensionVector.end.columnIndex; i++) {
    me.add(columns[i]);
  }
}, reduceRange:function(extensionVector) {
  var me = this, columns = me.view.getHeaderContainer().getVisibleColumns(), startIdx = extensionVector.start.columnIndex, endIdx = extensionVector.end.columnIndex, reduceTo = Math.abs(startIdx - endIdx) + 1, diff = me.selectedColumns.length - reduceTo, i;
  for (i = diff; i > 0; i--) {
    me.remove(columns[endIdx + i]);
  }
}, onSelectionFinish:function() {
  var me = this, range = me.getContiguousSelection(), start, end;
  if (range) {
    start = new Ext.grid.Location(me.view, {record:0, column:range[0]});
    end = new Ext.grid.Location(me.view, {record:me.view.getStore().getCount() - 1, column:range[1]});
    me.getSelectionModel().onSelectionFinish(me, start, end);
  } else {
    me.getSelectionModel().onSelectionFinish(me);
  }
}, getContiguousSelection:function() {
  var selection = Ext.Array.sort(this.getColumns(), function(c1, c2) {
    return c1.getGrid().ownerGrid.getHeaderContainer().indexOfLeaf(c1) - c2.getGrid().ownerGrid.getHeaderContainer().indexOfLeaf(c2);
  }), len = selection.length, i;
  if (len) {
    for (i = 1; i < len; i++) {
      if (selection[i].getVisibleIndex() !== selection[i - 1].getVisibleIndex() + 1) {
        return false;
      }
    }
    return [selection[0], selection[len - 1]];
  }
}}});
Ext.define('Ext.grid.selection.Replicator', {extend:Ext.plugin.Abstract, alias:'plugin.selectionreplicator', init:function(grid) {
  this.gridListeners = grid.on({beforeselectionextend:this.onBeforeSelectionExtend, scope:this, destroyable:true});
}, onBeforeSelectionExtend:function(ownerGrid, sel, extension) {
  var columns = this.columns = [];
  sel.eachColumn(function(column) {
    columns.push(column);
  });
  return this.replicateSelection(ownerGrid, sel, extension);
}, replicateSelection:function(ownerGrid, sel, extension) {
  if (extension.columns || sel.isColumns) {
    return;
  }
  var me = this, columns = me.columns, colCount, j, column, values, startIdx, endIdx, i, increment, store, record, prevValues, prevValue, selFirstRowIdx = sel.getFirstRowIndex(), selLastRowIdx = sel.getLastRowIndex(), selectedRowCount = selLastRowIdx - selFirstRowIdx + 1, lastTwoRecords = [], x, y;
  colCount = columns.length;
  store = columns[0].getGrid().getStore();
  if (selectedRowCount === 1) {
    values = me.getColumnValues(sel.view.getStore().getAt(selFirstRowIdx));
  } else {
    values = new Array(colCount);
    if (extension.rows < 0) {
      lastTwoRecords = [store.getAt(selFirstRowIdx + 1), store.getAt(selFirstRowIdx)];
    } else {
      lastTwoRecords = [store.getAt(selLastRowIdx - 1), store.getAt(selLastRowIdx)];
    }
    lastTwoRecords[0] = me.getColumnValues(lastTwoRecords[0]);
    lastTwoRecords[1] = me.getColumnValues(lastTwoRecords[1]);
    for (j = 0; j < colCount; j++) {
      x = lastTwoRecords[1][j];
      y = lastTwoRecords[0][j];
      if (!isNaN(x) && !isNaN(y)) {
        values[j] = Number(x) - Number(y);
      }
    }
  }
  if (extension.rows < 0) {
    startIdx = extension.end.recordIndex;
    endIdx = extension.start.recordIndex - 1;
    increment = -1;
  } else {
    startIdx = extension.start.recordIndex;
    endIdx = extension.end.recordIndex + 1;
    increment = 1;
  }
  if (selectedRowCount === 1) {
    for (i = startIdx; i !== endIdx; i += increment) {
      record = store.getAt(i);
      for (j = 0; j < colCount; j++) {
        column = columns[j];
        if (column.getDataIndex()) {
          record.set(column.getDataIndex(), values[j]);
        }
      }
    }
  } else {
    for (i = startIdx; i !== endIdx; i += increment) {
      record = store.getAt(i);
      prevValues = me.getColumnValues(store.getAt(i - increment));
      for (j = 0; j < colCount; j++) {
        column = columns[j];
        if (column.getDataIndex()) {
          prevValue = prevValues[j];
          if (!isNaN(prevValue)) {
            record.set(column.getDataIndex(), Ext.coerce(Number(prevValue) + values[j], prevValue));
          }
        }
      }
    }
  }
}, getColumnValues:function(record) {
  var columns = this.columns, len = columns.length, i, column, result = new Array(columns.length);
  for (i = 0; i < len; i++) {
    column = columns[i];
    if (column.getDataIndex()) {
      result[i] = record.get(column.getDataIndex());
    }
  }
  return result;
}, destroy:function() {
  this.gridListeners = Ext.destroy(this.gridListeners);
  this.callParent();
}});
Ext.define('Ext.grid.selection.SelectionExtender', {maskBox:{}, constructor:function(config) {
  var me = this, view = config.view, handleListeners = {dragstart:'onDragStart', dragend:'onDragEnd', scope:me};
  Ext.apply(me, config);
  me.el = view.outerCt;
  me.handle = view.bodyElement.createChild({cls:Ext.baseCSSPrefix + 'selmodel-extender-drag-handle'}).hide();
  if (Ext.supports.Touch) {
    handleListeners.longpress = 'onHandleLongpress';
  }
  me.handle.on(handleListeners);
  me.mask = view.outerCt.createChild({cls:Ext.baseCSSPrefix + 'selmodel-extender-mask'}).hide();
  me.scrollListener = view.getScrollable().on({scroll:me.onViewScroll, scope:me, destroyable:true});
  me.viewListener = view.on({columnresize:'alignHandle', columnhide:'alignHandle', columnshow:'alignHandle', columnmove:'alignHandle', scope:me, destroyable:true});
  if (config && config.axes) {
    me.setAxes(config.axes);
  }
}, setAxes:function(axes) {
  var me = this;
  me.axes = axes;
  me.extendX = !!(axes & 1);
  me.extendY = !!(axes & 2);
}, setHandle:function(firstPos, endPos) {
  var me = this;
  me.firstPos = firstPos;
  me.endPos = endPos;
  if (firstPos && endPos && endPos.getCell(true)) {
    me.curPos = endPos;
    me.alignHandle();
  } else {
    me.disable();
  }
}, alignHandle:function() {
  var me = this, lastCell = me.endPos;
  if (me.firstPos && lastCell && me.view.isRecordRendered(lastCell.recordIndex)) {
    lastCell = lastCell.clone({record:lastCell.record, column:lastCell.column}).getCell();
    if (lastCell && lastCell.isVisible()) {
      me.enable();
    } else {
      me.disable();
    }
    me.handle.alignTo(lastCell, 'c-br');
  } else {
    me.disable();
  }
}, enable:function() {
  this.handle.show();
}, disable:function() {
  this.handle.hide();
  this.mask.hide();
}, onHandleLongpress:function(e) {
  e.startDrag();
}, onDragStart:function(e) {
  if (e.pointerType !== 'touch' || e.longpress) {
    e.claimGesture();
    this.handle.on('drag', this.onDrag, this);
  }
}, onDrag:function(e) {
  if (e.changedTouches) {
    var touch = e.changedTouches[0], realTarget;
    if (touch && !Ext.fly(touch.target).getRegion().contains(touch.point)) {
      realTarget = Ext.event.Event.resolveTextNode(Ext.Element.fromPagePoint(touch.pageX, touch.pageY, true));
      if (realTarget) {
        e.target = realTarget;
      }
    }
  }
  var me = this, target = e.target, view = me.view, scrollClientRegion = view.getScrollable().getElement().getClientRegion(), overCell = new Ext.grid.Location(view, target), scrollTask = me.scrollTask || (me.scrollTask = Ext.util.TaskManager.newTask({run:me.doAutoScroll, scope:me, interval:10})), thresh = 25 * (window.devicePixelRatio || 1), scrollDelta = 3 * (window.devicePixelRatio || 1), scrollBy = me.scrollBy || (me.scrollBy = []);
  e.claimGesture();
  me.lastXY = [e.pageX, e.pageY];
  if (!me.el.contains(target)) {
    scrollBy[0] = scrollBy[1] = 0;
    return scrollTask.stop();
  }
  if (me.lastXY[1] > scrollClientRegion.bottom - thresh) {
    if (me.extendY) {
      scrollBy[1] = scrollDelta;
      scrollTask.start();
    }
  } else {
    if (me.lastXY[1] < scrollClientRegion.top + thresh) {
      if (me.extendY) {
        scrollBy[1] = -scrollDelta;
        scrollTask.start();
      }
    } else {
      if (me.lastXY[0] > scrollClientRegion.right - thresh) {
        if (me.extendX) {
          scrollBy[0] = scrollDelta;
          scrollTask.start();
        }
      } else {
        if (me.lastXY[0] < scrollClientRegion.left + thresh) {
          if (me.extendX) {
            scrollBy[0] = -scrollDelta;
            scrollTask.start();
          }
        } else {
          scrollBy[0] = scrollBy[1] = 0;
          scrollTask.stop();
        }
      }
    }
  }
  if (overCell && overCell.getCell() && !overCell.equals(me.lastOverCell)) {
    me.lastOverCell = overCell;
    me.syncMaskOnCell(overCell);
  }
}, doAutoScroll:function() {
  var me = this, view = me.view, scroller = view.getScrollable(), scrollOverCell;
  scroller.scrollBy.apply(scroller, me.scrollBy);
  scrollOverCell = document.elementFromPoint.apply(document, me.lastXY);
  if (scrollOverCell) {
    scrollOverCell = new Ext.grid.Location(me.view, scrollOverCell);
    if (scrollOverCell && scrollOverCell.getCell() && !scrollOverCell.equals(me.lastOverCell)) {
      me.lastOverCell = scrollOverCell;
      me.syncMaskOnCell(scrollOverCell);
    }
  }
}, onDragEnd:function(e) {
  var me = this, selectable = me.view.getSelectable(), selection = selectable && selectable.getSelection();
  me.handle.un('drag', me.onDrag, me);
  if (me.scrollTask) {
    me.scrollTask.stop();
  }
  if (me.extensionDescriptor) {
    me.disable();
    if (selection.isColumns && e.direction.y < 0 || selection.isRows && e.direction.x < 0) {
      me.alignHandle();
      return;
    }
    selectable.extendSelection(me.extensionDescriptor);
  }
}, onViewScroll:function() {
  var me = this;
  if (me.active && me.lastOverCell || me.firstPos) {
    me.endPos = me.endPos.clone({record:me.endPos.recordIndex});
    me.alignHandle();
  }
}, stopEvent:function(e) {
  e.stopEvent();
}, syncMaskOnCell:function(overCell) {
  var me = this, view = me.view, renderInfo = view.renderInfo, maskBox = me.maskBox, startRecordIndex = me.firstPos.recordIndex, endRecordIndex = me.endPos.recordIndex, extensionStart = me.firstPos.clone({record:startRecordIndex}), extensionEnd = me.endPos.clone({record:endRecordIndex}), preventReduce = !me.allowReduceSelection, selRegion, firstCell, endCell, curPos;
  firstCell = me.firstPos.clone({record:Ext.Number.constrain(Math.min(startRecordIndex, endRecordIndex), renderInfo.indexTop, renderInfo.indexBottom - 1), column:me.firstPos.column});
  endCell = me.endPos.clone({record:Ext.Number.constrain(Math.max(firstCell.recordIndex, endRecordIndex), renderInfo.indexTop, renderInfo.indexBottom - 1)});
  me.selectionRegion = selRegion = firstCell.getCell().getRegion().union(endCell.getCell().getRegion());
  me.curPos = curPos = overCell;
  overCell = overCell.getCell('el');
  me.mask.dom.style.borderTopWidth = me.mask.dom.style.borderRightWidth = me.mask.dom.style.borderBottomWidth = me.mask.dom.style.borderLeftWidth = '';
  if (curPos.recordIndex < me.firstPos.recordIndex && me.extendY) {
    me.extensionDescriptor = {type:'rows', start:extensionStart.clone({record:curPos.recordIndex}), end:extensionEnd.clone({record:me.firstPos.recordIndex - 1}), rows:curPos.recordIndex - me.firstPos.recordIndex, mousePosition:me.lastXY};
    me.mask.dom.style.borderBottomWidth = '0';
    maskBox.x = selRegion.x;
    maskBox.y = overCell.getY();
    maskBox.width = selRegion.right - selRegion.left;
    maskBox.height = selRegion.top - overCell.getY();
  } else {
    if (curPos.recordIndex > me.endPos.recordIndex && me.extendY) {
      me.extensionDescriptor = {type:'rows', start:extensionStart.clone({record:me.endPos.recordIndex + 1}), end:extensionEnd.clone({record:curPos.recordIndex}), rows:curPos.recordIndex - me.endPos.recordIndex, mousePosition:me.lastXY};
      me.mask.dom.style.borderTopWidth = '0';
      maskBox.x = selRegion.x;
      maskBox.y = selRegion.bottom;
      maskBox.width = selRegion.right - selRegion.left;
      maskBox.height = overCell.getRegion().bottom - selRegion.bottom;
    } else {
      if (!preventReduce && curPos.recordIndex < me.endPos.recordIndex && me.extendY && curPos.columnIndex === me.endPos.columnIndex) {
        me.extensionDescriptor = {type:'rows', start:extensionStart.clone({record:me.endPos.recordIndex}), end:extensionEnd.clone({record:curPos.recordIndex + 1}), rows:-1, mousePosition:me.lastXY, reduce:true};
        me.mask.dom.style.borderTopWidth = '0';
        maskBox.x = selRegion.x;
        maskBox.y = selRegion.top;
        maskBox.width = selRegion.right - selRegion.left;
        maskBox.height = overCell.getRegion().bottom - selRegion.top;
      } else {
        if (curPos.columnIndex < me.firstPos.columnIndex && me.extendX) {
          me.extensionDescriptor = {type:'columns', start:extensionStart.clone({column:curPos.columnIndex}), end:extensionEnd.clone({column:me.firstPos.columnIndex - 1}), columns:curPos.columnIndex - me.firstPos.columnIndex, mousePosition:me.lastXY};
          me.mask.dom.style.borderRightWidth = '0';
          maskBox.x = overCell.getX();
          maskBox.y = selRegion.top;
          maskBox.width = selRegion.left - overCell.getX();
          maskBox.height = selRegion.bottom - selRegion.top;
        } else {
          if (curPos.columnIndex > me.endPos.columnIndex && me.extendX) {
            me.extensionDescriptor = {type:'columns', start:extensionStart.clone({column:me.endPos.columnIndex + 1}), end:extensionEnd.clone({column:curPos.columnIndex}), columns:curPos.columnIndex - me.endPos.columnIndex, mousePosition:me.lastXY};
            me.mask.dom.style.borderLeftWidth = '0';
            maskBox.x = selRegion.right;
            maskBox.y = selRegion.top;
            maskBox.width = overCell.getRegion().right - selRegion.right;
            maskBox.height = selRegion.bottom - selRegion.top;
          } else {
            if (!preventReduce && curPos.columnIndex < me.endPos.columnIndex && me.extendX) {
              me.extensionDescriptor = {type:'columns', start:extensionStart.clone({column:me.firstPos.columnIndex}), end:extensionEnd.clone({column:curPos.columnIndex}), columns:-1, mousePosition:me.lastXY, reduce:true};
              me.mask.dom.style.borderLeftWidth = '0';
              maskBox.x = selRegion.left;
              maskBox.y = selRegion.top;
              maskBox.width = overCell.getRegion().right - selRegion.left;
              maskBox.height = selRegion.bottom - selRegion.top;
            } else {
              me.extensionDescriptor = null;
            }
          }
        }
      }
    }
  }
  if (view.hasListeners.selectionextenderdrag) {
    view.fireEvent('selectionextenderdrag', view, view.getSelectable().getSelection(), me.extensionDescriptor);
  }
  if (me.extensionDescriptor) {
    me.mask.show();
    me.mask.setBox(maskBox);
  } else {
    me.mask.hide();
  }
}, destroy:function() {
  this.destroyMembers('viewListener', 'scrollListener', 'mask', 'handle');
}});
Ext.define('Ext.grid.cell.Number', {extend:Ext.grid.cell.Text, xtype:'numbercell', isNumberCell:true, config:{format:'0,000.00'}, classCls:Ext.baseCSSPrefix + 'numbercell', zeroValue:null, updateColumn:function(column, oldColumn) {
  this.callParent([column, oldColumn]);
  if (column && column.isNumberColumn) {
    var format = column.getFormat();
    if (format !== null) {
      this.setFormat(format);
    }
  }
}, updateFormat:function(format) {
  if (!this.isConfiguring) {
    this.writeValue();
  }
}, formatValue:function(value) {
  var hasValue = value || value === 0, zeroValue;
  if (value === 0 && (zeroValue = this.getZeroValue()) !== null) {
    value = zeroValue || '';
  } else {
    value = hasValue ? Ext.util.Format.number(value, this.getFormat()) : '';
  }
  return value;
}});
Ext.define('Ext.grid.cell.Check', {extend:Ext.grid.cell.Base, xtype:'checkcell', config:{disabled:null}, innerTemplate:[{reference:'checkboxElement', tabIndex:-1, cls:Ext.baseCSSPrefix + 'checkbox-el ' + Ext.baseCSSPrefix + 'font-icon'}], classCls:Ext.baseCSSPrefix + 'checkcell', disabledCls:Ext.baseCSSPrefix + 'disabled', checkedCls:Ext.baseCSSPrefix + 'checked', constructor:function(config) {
  this.callParent([config]);
  this.checkboxElement.on('tap', 'onTap', this);
}, applyValue:function(value) {
  return !!value;
}, updateValue:function(value, oldValue) {
  var me = this, column = me.getColumn();
  me.el.toggleCls(me.checkedCls, !!value);
  if (value) {
    column.updateHeaderState();
  } else {
    column.setHeaderStatus(value);
  }
}, updateColumn:function(column, oldColumn) {
  this.callParent([column, oldColumn]);
  if (column) {
    this.setDisabled(column.getDisabled());
  }
}, applyDisabled:function(disabled) {
  return Boolean(disabled);
}, updateDisabled:function(disabled) {
  this.element.toggleCls(this.disabledCls, disabled);
}, disable:function() {
  this.setDisabled(true);
}, enable:function() {
  this.setDisabled(false);
}, onTap:function(e) {
  var me = this, record = me.getRecord(), column = me.getColumn(), recordIndex = column.up('grid').getStore().indexOf(record), checked;
  if (record) {
    checked = !column.isRecordChecked(record);
    if (me.getDisabled()) {
      return;
    }
    if (column.fireEvent('beforecheckchange', me, recordIndex, checked, record, e) !== false) {
      if (me.getColumn().getStopSelection()) {
        e.stopSelection = true;
      }
      if (record) {
        column.setRecordChecked(record, checked, e);
      }
      if (column.hasListeners.checkchange) {
        column.fireEvent('checkchange', me, recordIndex, checked, record, e);
      }
    }
  }
}});
Ext.define('Ext.theme.material.grid.cell.Check', {override:'Ext.grid.cell.Check', config:{ripple:{delegate:'.' + Ext.baseCSSPrefix + 'checkbox-el', bound:false, color:'default', centered:true}}});
Ext.define('Ext.grid.column.Check', {extend:Ext.grid.column.Column, isCheckColumn:true, xtype:'checkcolumn', cachedConfig:{headerCheckboxAlign:'bottom'}, config:{stopSelection:true, headerCheckbox:false}, align:'center', classCls:Ext.baseCSSPrefix + 'checkcolumn', noHeaderCheckboxCls:Ext.baseCSSPrefix + 'no-header-checkbox', checkedCls:Ext.baseCSSPrefix + 'checked', hasTextCls:Ext.baseCSSPrefix + 'has-text', checkboxAlignCls:{top:Ext.baseCSSPrefix + 'checkbox-align-top', right:Ext.baseCSSPrefix + 
'checkbox-align-right', bottom:Ext.baseCSSPrefix + 'checkbox-align-bottom', left:Ext.baseCSSPrefix + 'checkbox-align-left'}, text:'', ignoreExport:true, cell:{xtype:'checkcell'}, afterTitleTemplate:[{reference:'checkboxElement', classList:[Ext.baseCSSPrefix + 'checkbox-el', Ext.baseCSSPrefix + 'font-icon']}], onColumnTap:function(e) {
  var me = this;
  if (e.target === me.checkboxElement.dom && !me.getDisabled()) {
    me.toggleAll(e);
  }
  me.callParent([e]);
}, toggleAll:function(e) {
  var me = this, checked = !me.allChecked;
  if (me.fireEvent('beforeheadercheckchange', me, checked, e) !== false) {
    me.doToggleAll(checked);
    me.setHeaderStatus(checked);
    me.fireEvent('headercheckchange', me, checked, e);
  }
}, doToggleAll:function(checked) {
  var me = this, store = me.getGrid().getStore();
  store.each(function(record) {
    me.setRecordChecked(record, checked);
  });
}, setRecordChecked:function(record, checked, e) {
  checked = !!checked;
  this.doSetRecordChecked(record, checked);
  if (checked) {
    this.updateHeaderState();
  } else {
    this.setHeaderStatus(checked);
  }
}, doSetRecordChecked:function(record, checked) {
  var dataIndex = this.getDataIndex();
  if (record.get(dataIndex) != checked) {
    record.set(dataIndex, checked);
  }
}, areAllChecked:function() {
  var me = this, store = me.getGrid().getStore(), records, len, i;
  if (store && !store.isVirtualStore && store.getCount() > 0) {
    records = store.getData().items;
    len = records.length;
    for (i = 0; i < len; ++i) {
      if (!me.isRecordChecked(records[i])) {
        return false;
      }
    }
    return true;
  }
}, isRecordChecked:function(record) {
  return record.get(this.getDataIndex());
}, updateHeaderState:function() {
  if (!this.destroyed && this.getHeaderCheckbox() !== false) {
    this.setHeaderStatus(this.areAllChecked());
  }
}, setHeaderStatus:function(checked) {
  var me = this;
  if (me.allChecked !== checked) {
    me.allChecked = checked;
    me.el.toggleCls(me.checkedCls, checked);
  }
}, updateDisabled:function(disabled, oldDisabled) {
  var me = this, grid = me.getGrid(), rows, len, i;
  me.callParent([disabled, oldDisabled]);
  if (grid) {
    rows = grid.getViewItems();
    len = rows.length;
    for (i = 0; i < len; i++) {
      rows[i].getCellByColumn(me).setDisabled(disabled);
    }
  }
}, updateHeaderCheckboxAlign:function(align, oldAlign) {
  var me = this, checkboxAlignCls = me.checkboxAlignCls;
  if (oldAlign) {
    me.removeCls(checkboxAlignCls[oldAlign]);
  }
  if (align) {
    if (!checkboxAlignCls[align]) {
      Ext.raise("Invalid value for checkboxAlign: '" + align + "'");
    }
    me.addCls(checkboxAlignCls[align]);
  }
}, updateHeaderCheckbox:function(headerCheckbox) {
  var me = this, grid = me.getGrid();
  me.el.toggleCls(me.noHeaderCheckboxCls, !headerCheckbox);
  me.setSortable(me.getSortable() && !headerCheckbox);
  if (grid) {
    me.updateHeaderState();
  }
}, updateText:function(text) {
  this.setHtml(text);
  this.toggleCls(this.hasTextCls, !!text);
}});
Ext.define('Ext.grid.column.Selection', {extend:Ext.grid.column.Check, xtype:'selectioncolumn', classCls:Ext.baseCSSPrefix + 'selectioncolumn', cell:{cls:Ext.baseCSSPrefix + 'selection-cell'}, weight:-900, menu:null, sortable:false, draggable:false, resizable:false, hideable:false, ignore:true, stopSelection:false, updateHeaderState:function() {
  if (!this.isConfiguring) {
    this.getGrid().getSelectable().updateHeaderState();
  }
}, toggleAll:function(e) {
  this.getGrid().getSelectable().toggleAll(this, e);
}, setRecordChecked:function(record, checked, e) {
  var selectionModel = this.getGrid().getSelectable();
  if (checked) {
    selectionModel.select(record, selectionModel.getMode() !== 'single');
  } else {
    selectionModel.deselect(record);
  }
}, isRecordChecked:function(record) {
  return this.getGrid().getSelectable().isRowSelected(record);
}});
Ext.define('Ext.grid.column.Number', {extend:Ext.grid.column.Column, xtype:'numbercolumn', isNumberColumn:true, config:{format:null}, cell:{xtype:'numbercell'}, defaultEditor:{xtype:'numberfield'}});
Ext.define('Ext.grid.cell.RowNumberer', {extend:Ext.grid.cell.Number, xtype:'rownumberercell', classCls:Ext.baseCSSPrefix + 'rownumberercell', format:'0,000', refreshValue:function(context) {
  var row = context.row, ret;
  if (context.summary) {
    ret = '';
  } else {
    ret = row ? row.$datasetIndex + 1 : null;
  }
  return ret;
}});
Ext.define('Ext.grid.column.RowNumberer', {extend:Ext.grid.column.Number, xtype:'rownumberer', isRowNumberer:true, cell:{xtype:'rownumberercell'}, menu:null, align:'right', hideable:false, ignore:true, ignoreExport:true, sortable:false, text:'', width:'auto', minWidth:null, onAdded:function(parent, instanced) {
  var me = this, grid;
  me.callParent([parent, instanced]);
  me.checkWidth();
  grid = me.getGrid();
  me.gridListeners = grid.on({storechange:'attachStoreListeners', scope:me, destroyable:true});
  me.attachStoreListeners(grid.getStore());
}, onRemoved:function(destroying) {
  Ext.destroy(this.gridListeners, this.storeListeners);
  this.callParent([destroying]);
}, privates:{attachStoreListeners:function(store) {
  Ext.destroy(this.storeListeners);
  if (store) {
    this.storeListeners = store.on({datachanged:'checkWidth', totalcountchange:'checkWidth', scope:this, destroyable:true});
  }
}, getCharWidth:function() {
  var me = this, charWidth = me._charWidth, text, cell, cellUi, gridUi, textWidth;
  if (!charWidth) {
    text = '0000000000';
    cell = me.getScratchCell();
    cellUi = me.getCell().ui;
    if (cellUi) {
      cell.addUi(cellUi);
    }
    gridUi = me.getGrid().getUi();
    if (gridUi) {
      cell.addUi(gridUi);
    }
    document.body.appendChild(cell.el.dom);
    textWidth = Ext.util.TextMetrics.measure(cell.bodyElement, text).width;
    document.body.removeChild(cell.el.dom);
    me._charWidth = charWidth = textWidth / text.length;
  }
  return charWidth;
}, checkWidth:function() {
  var me = this;
  if (document.fonts) {
    document.fonts.ready.then(function() {
      if (!me.destroyed) {
        me.doCheckWidth();
      }
    });
  } else {
    me.doCheckWidth();
  }
}, doCheckWidth:function() {
  var me = this, store = me.getGrid().getStore(), charLen = 1, charWidth = me.getCharWidth();
  if (store && store.getTotalCount()) {
    charLen = me.getScratchCell().printValue(store.getTotalCount()).length;
  }
  me.textElement.setStyle('min-width', Math.ceil(charLen * charWidth) + 'px');
}}});
Ext.define('Ext.grid.selection.Model', {extend:Ext.dataview.selection.Model, alias:'selmodel.grid', isGridSelectionModel:true, config:{columns:{$value:false, lazy:true}, cells:{$value:false, lazy:true}, rows:{$value:true, lazy:true}, drag:false, extensible:{$value:false, lazy:true}, reducible:true, checkbox:false, headerCheckbox:true, checkboxDefaults:{xtype:'selectioncolumn', text:null, width:30}, showNumbererColumn:false}, checkboxSelect:false, checkboxColumnIndex:0, mode:'multi', columnSelectCls:Ext.baseCSSPrefix + 
'selmodel-column-select', rowNumbererHeaderCls:Ext.baseCSSPrefix + 'selmodel-row-numberer-hd', updateView:function(view, oldView) {
  var me = this, rowNumberer = me.numbererColumn = view.getRowNumbers(), checkbox = me.getCheckbox();
  me.callParent([view, oldView]);
  if (oldView) {
    me.navigationModel = null;
    Ext.destroy(me.viewListeners);
  }
  if (view) {
    if (rowNumberer) {
      rowNumberer.setCell({cls:me.rowNumbererCellCls});
      rowNumberer.setCls(me.rowNumbererHeaderCls);
    }
    if (checkbox) {
      view.registerColumn(checkbox);
    }
    me.viewListeners = view.on(me.getViewListeners());
  }
}, onViewCreated:function(view) {
  if (this.getColumns()) {
    view.addCls(this.columnSelectCls);
  }
  this.updateHeaderState();
}, updateDrag:function(drag) {
  var view = this.getView(), viewListeners = {dragstart:'onViewDragStart', delegate:view.eventDelegate, scope:this};
  if (Ext.supports.Touch) {
    viewListeners.longpress = 'onViewLongpress';
  }
  view.innerCt[drag ? 'on' : 'un'](viewListeners);
}, getSelection:function(what, reset) {
  if (what === 'rows' || what === 'records') {
    what = this.getStore().isVirtualStore ? 'rows' : 'records';
  }
  var result = this.callParent(), config;
  if (what) {
    what = what.toLowerCase();
    if (!result || result.type !== what) {
      config = {type:what};
      if (what === 'records') {
        config.selected = this.getSelected();
      }
      this.setSelection(config);
      result = this.callParent();
    } else {
      if (reset) {
        result.clear(true);
      }
    }
  }
  return result;
}, createCheckboxColumn:function(checkboxDefaults) {
  var me = this;
  return Ext.apply({headerCheckbox:me.getHeaderCheckbox() !== false}, checkboxDefaults);
}, onHeaderTap:function(headerCt, header, e) {
  var me = this, sel = me.getSelection(), isSelected = false, range, columns, i;
  if (header === this.numbererColumn) {
    me.toggleAll(header, e);
  } else {
    if (me.getColumns() && header !== me.getCheckbox()) {
      if (e.shiftKey && sel && sel.lastColumnSelected) {
        if (!e.ctrlKey) {
          sel.clear();
        }
        headerCt = me.getView().getHeaderContainer();
        columns = headerCt.getColumns();
        range = Ext.Array.sort([headerCt.indexOfLeaf(sel.lastColumnSelected), headerCt.indexOf(header)], Ext.Array.numericSortFn);
        for (i = range[0]; i <= range[1]; i++) {
          me.selectColumn(columns[i], true);
        }
      } else {
        isSelected = me.isColumnSelected(header);
        if (!e.ctrlKey) {
          sel.clear();
        } else {
          if (isSelected) {
            me.deselectColumn(header);
            me.getSelection().lastColumnSelected = null;
          }
        }
        if (!isSelected || !e.ctrlKey && e.pointerType !== 'touch') {
          me.selectColumn(header, e.ctrlKey);
          me.getSelection().lastColumnSelected = header;
        }
        me.updateSelectionExtender();
      }
    }
  }
}, toggleAll:function(header, e) {
  var me = this, sel = me.getSelection();
  e.stopEvent();
  if (!sel || !sel.isAllSelected()) {
    me.selectAll();
  } else {
    me.deselectAll();
  }
  me.updateHeaderState();
  me.lastColumnSelected = null;
}, selectByLocation:function(location) {
  if (!location.isGridLocation) {
    Ext.raise('selectByLocation MUST be passed an Ext.grid.Location');
  }
  var me = this, record = location.record, column = location.column;
  if (me.getCells()) {
    me.selectCells(location, location);
  } else {
    if (me.getRows() && record) {
      this.select(record);
    } else {
      if (me.getColumns() && column) {
        me.selectColumn(column);
      }
    }
  }
}, updateHeaderState:function() {
  var me = this, store = me.getStore(), sel = me.getSelection(), isChecked = false, checkHd = me.getCheckbox(), storeCount;
  if (store && sel && sel.isRows) {
    storeCount = store.getCount();
    if (store.isBufferedStore) {
      isChecked = sel.allSelected;
    } else {
      isChecked = storeCount > 0 && storeCount === sel.getCount();
    }
  }
  if (checkHd) {
    checkHd.setHeaderStatus(isChecked);
  }
}, onColumnUpdate:function(headerCt, columns) {
  var me = this, checkColumn = me.getCheckbox();
  if (checkColumn) {
    if (headerCt) {
      headerCt.remove(checkColumn, false);
    }
    columns.push(checkColumn);
  }
}, select:function(records, keepExisting, suppressEvent) {
  var me = this, sel = me.getSelection('records'), store = me.getStore(), len, i, record;
  if (!Ext.isArray(records)) {
    records = [records];
  }
  len = records.length;
  for (i = 0; i < len; i++) {
    record = records[i];
    if (typeof record === 'number') {
      records[i] = record = store.getAt(record);
    }
  }
  sel.add(records, keepExisting, suppressEvent);
}, deselect:function(records, suppressEvent) {
  var me = this, sel = me.getSelection('records'), store = me.getView().getStore(), len, i, record;
  if (sel && sel.isRecords) {
    if (!Ext.isArray(records)) {
      records = [records];
    }
    len = records.length;
    for (i = 0; i < len; i++) {
      record = records[i];
      if (typeof record === 'number') {
        records[i] = record = store.getAt(record);
      }
    }
  }
  sel.remove(records, suppressEvent);
}, onCollectionRemove:function(selectedCollection, chunk) {
  this.updateHeaderState();
  this.callParent([selectedCollection, chunk]);
}, onCollectionAdd:function(selectedCollection, adds) {
  this.updateHeaderState();
  this.callParent([selectedCollection, adds]);
}, selectCells:function(rangeStart, rangeEnd, suppressEvent) {
  var me = this, view = me.getView(), sel;
  rangeStart = rangeStart.isGridLocation ? rangeStart.clone() : new Ext.grid.Location(view, {record:rangeStart[0], column:rangeStart[1]});
  rangeEnd = rangeEnd.isGridLocation ? rangeEnd.clone() : new Ext.grid.Location(view, {record:rangeEnd[0], column:rangeEnd[1]});
  me.resetSelection(true);
  sel = me.getSelection('cells');
  sel.setRangeStart(rangeStart);
  sel.setRangeEnd(rangeEnd);
  if (!suppressEvent) {
    me.fireSelectionChange();
  }
}, selectAll:function(suppressEvent) {
  var me = this, sel = me.getSelection(), doSelect;
  if (me.getRows()) {
    sel = me.getSelection('records');
    doSelect = true;
  } else {
    if (me.getCells()) {
      sel = me.getSelection('cells');
      doSelect = true;
    } else {
      if (me.getColumns()) {
        sel = me.getSelection('columns');
        doSelect = true;
      }
    }
  }
  if (doSelect) {
    sel.selectAll(suppressEvent);
  }
}, deselectAll:function(suppressEvent) {
  var sel = this.getSelection();
  if (sel && sel.getCount()) {
    sel.clear(suppressEvent);
  }
}, selectRows:function(rows, keepSelection, suppressEvent) {
  var sel = this.getSelection('records');
  if (!keepSelection) {
    this.resetSelection(true);
  }
  sel.add(rows, keepSelection, suppressEvent);
}, isSelected:function(record) {
  return this.isRowSelected(record);
}, selectColumn:function(column, keepSelection, suppressEvent) {
  var selData = this.getSelection('columns');
  if (!selData.isSelected(column)) {
    if (!keepSelection) {
      selData.clear(suppressEvent);
      selData.setRangeStart(column);
    } else {
      selData.add(column);
    }
  }
}, deselectColumn:function(column, suppressEvent) {
  var selData = this.getSelection();
  if (selData && selData.isColumns && selData.isSelected(column)) {
    selData.remove(column, suppressEvent);
  }
}, destroy:function() {
  var me = this, view = me.getView(), checkbox = me.checkbox;
  if (view && !view.destroying && checkbox) {
    view.unregisterColumn(checkbox, true);
  }
  Ext.destroy(me.viewListeners, me.getConfig('extensible', null, true));
  me.callParent();
}, privates:{axesConfigs:{x:1, y:2, xy:3, both:3, 'true':3}, getViewListeners:function() {
  return {columnschanged:'onColumnsChanged', columnmove:'onColumnMove', scope:this, destroyable:true};
}, refreshSelection:function() {
  if (this.getSelection().isRecords) {
    this.callParent();
  } else {
    this.resetSelection();
  }
}, onColumnsChanged:function() {
  var me = this, selData = me.getSelection(), view, selectionChanged;
  if (selData) {
    view = selData.view;
    if (selData.isCells) {
      if (view.visibleColumns().length) {
        selData.eachCell(function(location) {
          view.onCellDeselect(location);
        });
      } else {
        me.clearSelections();
      }
    } else {
      if (selData.isColumns) {
        selectionChanged = false;
        selData.eachColumn(function(column) {
          if (!column.isVisible() || !view.isAncestor(column)) {
            me.remove(column);
            selectionChanged = true;
          }
        });
      }
    }
  }
  Ext.on('idle', selectionChanged ? me.fireSelectionChange : me.updateSelectionExtender, me, {single:true});
}, onColumnMove:function() {
  this.updateSelectionExtender();
}, resetSelection:function(suppressEvent) {
  var sel = this.getSelection();
  if (sel) {
    sel.clear(suppressEvent);
  }
}, onViewLongpress:function(e) {
  if (e.pointerType === 'touch') {
    e.startDrag();
  }
}, onViewDragStart:function(e) {
  if (e.pointerType === 'touch' && !e.longpress) {
    return;
  }
  var me = this, view = me.getView(), location = new Ext.grid.Location(view, e), header = location.column, viewLocation = view.getNavigationModel().getLocation(), isCheckClick = header === me.getCheckbox(), resumingSelection = false, sel;
  if (!location.cell) {
    return;
  }
  if (e.claimed || e.button > 0 || e.altKey || viewLocation && viewLocation.actionable || !view.shouldSelectItem(e)) {
    return;
  }
  if (header) {
    e.claimGesture();
    me.mousedownPosition = location.clone();
    if (isCheckClick) {
      me.checkCellClicked = location.cell.element.dom;
    }
    if (header === me.numbererColumn || isCheckClick || !me.getCells()) {
      if (me.getRows()) {
        if (e.shiftKey && me.isSelected(location.record)) {
          resumingSelection = true;
        } else {
          if (!e.shiftKey && !isCheckClick && me.checkboxOnly) {
            return;
          }
        }
        sel = me.getSelection('records');
        if (!e.shiftKey && !e.ctrlKey && !isCheckClick) {
          sel.clear();
        }
      } else {
        if (me.getColumns()) {
          sel = me.getSelection('columns');
          if (e.shiftKey && me.isColumnSelected(location.column)) {
            resumingSelection = true;
          } else {
            if (!e.shiftKey && !e.ctrlKey && !isCheckClick) {
              sel.clear();
            }
          }
        } else {
          return false;
        }
      }
    } else {
      sel = me.getSelection('cells');
      if (e.shiftKey && me.isCellSelected(location.recordIndex, location.columnIndex)) {
        resumingSelection = true;
      } else {
        if (!e.shiftKey) {
          sel.clear();
        }
      }
    }
    if (!resumingSelection) {
      me.lastDragLocation = null;
    }
    if (e.longpress) {
      location.row.removeCls(view.pressedCls);
      me.onViewSelectionDrag(e);
    }
    if (sel) {
      view.innerCt.on('dragend', me.onViewDragEnd, me, {single:true});
      me.mousemoveListener = view.innerCt.on({drag:'onViewSelectionDrag', scope:me, delegate:view.eventDelegate, destroyable:true});
    }
  }
}, onViewSelectionDrag:function(e) {
  var me = this, view = me.getView(), newLocation, touch, realTarget;
  if (e.changedTouches) {
    touch = e.changedTouches[0];
    if (touch && !Ext.fly(touch.target).getRegion().contains(touch.point)) {
      realTarget = Ext.event.Event.resolveTextNode(Ext.Element.fromPagePoint(touch.pageX, touch.pageY, true));
      if (realTarget) {
        e.target = realTarget;
      }
    }
  }
  me.stopAutoScroller();
  if (!Ext.fly(e.target).up(view.eventDelegate)) {
    me.scrollTowardsPointer(e, view);
    return;
  }
  newLocation = me.dragLocation = new Ext.grid.Location(view, e);
  me.changeSelectionRange(view, newLocation, e);
}, changeSelectionRange:function(view, location, e) {
  var me = this, overColumn = location.column, overRecord = location.record, overRowIdx = location.recordIndex, lastDragLocation = me.lastDragLocation, selData, lastOverRecord, lastOverColumn, recChange, colChange;
  e.claimGesture();
  if (lastDragLocation) {
    lastOverRecord = lastDragLocation.record;
    lastOverColumn = lastDragLocation.column;
  }
  if (me.checkCellClicked) {
    selData = me.getSelection('rows');
    selData.setRangeStart(me.getStore().indexOf(overRecord));
    me.checkCellClicked = null;
    return;
  } else {
    selData = me.getSelection();
  }
  if (me.getExtensible()) {
    me.getExtensible().disable();
  }
  if (overColumn) {
    recChange = overRecord !== lastOverRecord;
    colChange = overColumn !== lastOverColumn;
    if (selData.isRows || selData.isRecords) {
      if (recChange) {
        if (lastOverRecord) {
          selData.setRangeEnd(overRowIdx);
        } else {
          selData.setRangeStart(overRowIdx);
        }
      }
    } else {
      if (selData.isCells) {
        if (recChange || colChange) {
          if (lastOverRecord) {
            selData.setRangeEnd(location);
          } else {
            selData.setRangeStart(location);
          }
        }
      } else {
        if (selData.isColumns) {
          if (colChange) {
            if (lastOverColumn) {
              selData.setRangeEnd(location.column);
            } else {
              selData.setRangeStart(location.column);
            }
          }
        }
      }
    }
    if (recChange || colChange) {
      view.getNavigationModel().setLocation(location);
    }
    me.lastDragLocation = location;
  }
}, scrollTowardsPointer:function(e, view) {
  var me = this, scrollClientRegion = view.getScrollable().getElement().getClientRegion(), point = e.getXY(), scrollTask = me.scrollTask || (me.scrollTask = Ext.util.TaskManager.newTask({run:me.doAutoScroll, args:[e, view], scope:me, interval:10})), thresh = 25 * (window.devicePixelRatio || 1), scrollDelta = 3 * (window.devicePixelRatio || 1), scrollBy = me.scrollBy || (me.scrollBy = []);
  e.claimGesture();
  if (point[1] > scrollClientRegion.bottom - thresh) {
    scrollBy[0] = 0;
    scrollBy[1] = scrollDelta;
    scrollTask.start();
  } else {
    if (point[1] < scrollClientRegion.top + thresh) {
      scrollBy[0] = 0;
      scrollBy[1] = -scrollDelta;
      scrollTask.start();
    } else {
      if (point[0] > scrollClientRegion.right - thresh) {
        scrollBy[0] = scrollDelta;
        scrollBy[1] = 0;
        scrollTask.start();
      } else {
        if (point[0] < scrollClientRegion.left + thresh) {
          scrollBy[0] = -scrollDelta;
          scrollBy[1] = 0;
          scrollTask.start();
        }
      }
    }
  }
}, doAutoScroll:function(e, view) {
  var me = this, scrollClientRegion = view.getScrollable().getElement().getClientRegion(), scroller = view.getScrollable(), xy = [], cell, location;
  scroller.scrollBy.apply(scroller, me.scrollBy);
  if (me.scrollBy[0]) {
    xy[0] = me.scrollBy[0] > 0 ? scrollClientRegion.right - 5 : scrollClientRegion.left + 5;
  } else {
    xy[0] = e.getX();
  }
  if (me.scrollBy[1]) {
    xy[1] = me.scrollBy[1] > 0 ? scrollClientRegion.bottom - 5 : scrollClientRegion.top + 5;
  } else {
    xy[1] = e.getY();
  }
  cell = document.elementFromPoint.apply(document, xy);
  if (cell) {
    cell = Ext.fly(cell).up(view.cellSelector);
    if (!cell) {
      me.stopAutoScroller();
      return;
    }
    location = new Ext.grid.Location(view, cell);
    if (cell && !location.equals(me.lastDragLocation)) {
      me.changeSelectionRange(view, location, e);
    }
  }
}, stopAutoScroller:function() {
  var me = this;
  if (me.scrollTask) {
    me.scrollBy[0] = me.scrollBy[1] = 0;
    me.scrollTask.stop();
    me.scrollTask = null;
  }
}, onViewDragEnd:function(e) {
  var me = this, view = me.getView(), dragLocation = me.dragLocation, changedCell = !dragLocation || !dragLocation.equals(me.mousedownPosition), location = e.location, sel;
  me.checkCellClicked = null;
  me.stopAutoScroller();
  if (view && !view.destroyed) {
    if (!location) {
      e.location = new Ext.grid.Location(view, e);
    }
    if (me.getExtensible() && changedCell) {
      me.getExtensible().disable();
    }
    me.mousemoveListener.destroy();
    if ((sel = me.getSelection()) && sel.isRows) {
      sel.addRange(true);
    } else {
      if (changedCell) {
        me.fireSelectionChange();
      }
    }
  }
}, onNavigate:function(navigateEvent) {
  var me = this, store = me.getStore(), selectingRows = me.getRows(), selectingCells = me.getCells(), selectingColumns = me.getColumns(), checkbox = me.getCheckbox(), checkboxOnly = me.checkboxOnly, mode = me.getMode(), location = navigateEvent.to, toColumn = location.column, record = location.record, sel = me.getSelection(), ctrlKey = navigateEvent.ctrlKey, shiftKey = navigateEvent.shiftKey, adding = true, count, changedRow, selectionChanged, selected;
  if (navigateEvent.stopSelection || toColumn === me.checkboxColumn) {
    return;
  }
  if (!navigateEvent.pointerType && navigateEvent.getKey() !== navigateEvent.SPACE) {
    if (ctrlKey) {
      return;
    }
    changedRow = !navigateEvent.from || location.recordIndex !== navigateEvent.from.recordIndex;
    if (!changedRow && !(selectingCells || selectingColumns)) {
      return;
    }
  }
  if (sel && (sel.isCells || sel.isColumns && selectingRows && !(ctrlKey || shiftKey)) && sel.getCount() > 1 && !shiftKey && navigateEvent.type === 'click') {
    return;
  }
  if (!(selectingCells || selectingColumns || selectingRows) || !record || navigateEvent.type === 'mousedown') {
    return;
  }
  if (ctrlKey && navigateEvent.keyCode === navigateEvent.A && mode === 'multi') {
    if (!sel || sel.getCount() < 2) {
      me.selectAll();
    } else {
      me.deselectAll();
    }
    me.updateHeaderState();
    return;
  }
  if (shiftKey && mode === 'multi') {
    if (toColumn === me.numbererColumn || toColumn === me.checkColumn || !(selectingCells || selectingColumns) || sel && (sel.isRows || sel.isRecords)) {
      if (selectingRows) {
        if (toColumn !== checkbox && checkboxOnly) {
          return;
        }
        sel = me.getSelection('records');
        if (!sel.getRangeSize()) {
          if (me.selectionStart == null) {
            me.selectionStart = location.recordIndex;
          }
          sel.setRangeStart(me.selectionStart);
        }
        sel.setRangeEnd(location.recordIndex);
        selectionChanged = true;
      }
    } else {
      if (selectingCells) {
        sel = me.getSelection('cells');
        count = sel.getCount();
        if (!sel.getRangeSize()) {
          sel.setRangeStart(navigateEvent.from || new Ext.grid.Location(me.getView(), {record:0, column:0}));
        }
        sel.setRangeEnd(location);
        adding = count < sel.getCount();
        selectionChanged = true;
      } else {
        if (selectingColumns) {
          sel = me.getSelection('columns');
          if (!sel.getCount()) {
            sel.setRangeStart(toColumn);
          }
          sel.setRangeEnd(toColumn);
          selectionChanged = true;
        }
      }
    }
  } else {
    me.selectionStart = null;
    if (sel) {
      if (mode !== 'multi' || !ctrlKey) {
        sel.clear(true);
      }
    }
    if (selectingRows && (toColumn === me.numbererColumn || toColumn === checkbox || !selectingCells)) {
      if (toColumn !== checkbox && checkboxOnly || navigateEvent.keyCode && navigateEvent.from && record === navigateEvent.from.record) {
        return;
      }
      sel = me.getSelection('records');
      if (sel.isSelected(record)) {
        if (ctrlKey || toColumn === checkbox || me.getDeselectable()) {
          sel.remove(record);
          selectionChanged = true;
        }
      } else {
        sel.add(record, ctrlKey || toColumn === checkbox);
        selectionChanged = true;
      }
      if (selectionChanged && (selected = sel.getSelected()) && selected.length) {
        me.selectionStart = store.indexOf(selected.first());
        sel.setRangeStart(me.selectionStart);
      }
    } else {
      if (selectingCells) {
        sel = me.getSelection('cells', true);
        sel.setRangeStart(location);
        selectionChanged = true;
      } else {
        if (selectingColumns) {
          sel = me.getSelection('columns');
          if (ctrlKey) {
            if (sel.isSelected(toColumn)) {
              sel.remove(toColumn);
            } else {
              sel.add(toColumn);
            }
          } else {
            sel.setRangeStart(toColumn);
          }
          selectionChanged = true;
        }
      }
    }
  }
  if (selectionChanged) {
    if (!sel.isRecords) {
      me.fireSelectionChange(null, adding);
    }
  }
  me.lastDragLocation = location;
}, isColumnSelected:function(column) {
  var me = this, sel = me.getSelection(), ret = false;
  if (sel && sel.isColumns) {
    ret = sel.isSelected(column);
  }
  return ret;
}, isCellSelected:function(row, column) {
  var sel = this.getSelection();
  if (sel) {
    if (sel.isColumns) {
      if (typeof column === 'number') {
        column = this.getView().getVisibleColumns()[column];
      }
      return sel.isSelected(column);
    }
    if (sel.isCells) {
      return sel.isSelected(row, column);
    }
    return sel.isSelected(row);
  }
  return false;
}, updateSelection:function(selection, oldSelection) {
  var view = this.getView();
  Ext.destroy(oldSelection);
  if (selection && selection.getCount()) {
    view = selection.view;
    if (selection.isRows) {
      selection.eachRow(view.onRowSelect, view);
    } else {
      if (selection.isColumns) {
        selection.eachCell(view.onCellSelect, view);
      } else {
        if (selection.isCells) {
          selection.eachCell(view.onCellSelect, view);
        }
      }
    }
  }
}, updateRows:function(rows) {
  var sel;
  if (!rows) {
    this.setCheckbox(false);
    sel = this.getSelection();
    if (sel && sel.isRows) {
      sel.clear();
    }
  }
}, updateColumns:function(columns) {
  var me = this, view = me.getView(), sel = me.getSelection();
  if (!columns && sel && sel.isColumns) {
    sel.clear();
    me.fireSelectionChange();
  }
  view.toggleCls(me.columnSelectCls, !!columns);
}, updateCells:function(cells) {
  var me = this, sel = me.getSelection();
  if (!cells && sel && sel.isCells) {
    sel.clear();
    me.fireSelectionChange();
  }
}, updateMode:function(mode) {
  if (mode === 'multi') {
    this.setDrag(this.getInitialConfig().drag);
  } else {
    if (!this.isConfiguring) {
      this.setDrag(false);
    }
  }
}, fireSelectionChange:function(records, selecting) {
  var me = this, view = me.getView(), sel = me.getSelection();
  me.updateSelectionExtender();
  me.fireEvent('selectionchange', view, me.getSelection());
  if (sel.isCells) {
    view.fireEvent('selectionchange', view, sel.getRange(), selecting, sel);
  } else {
    view.fireEvent('selectionchange', view, sel.isRecords ? records : sel.isCells ? sel.getRecords() : null, selecting, me.getSelection());
  }
}, updateSelectionExtender:function() {
  var sel = this.getSelection();
  if (sel) {
    sel.onSelectionFinish();
  }
}, onSelectionFinish:function(sel, firstCell, lastCell) {
  var extensible = this.getExtensible();
  if (extensible) {
    extensible.setHandle(firstCell, lastCell);
  }
}, applyExtensible:function(extensible, oldExtensible) {
  var me = this, axes;
  if (!extensible) {
    return undefined;
  }
  if (extensible === true || typeof extensible === 'string') {
    axes = me.axesConfigs[extensible];
    if (oldExtensible) {
      oldExtensible.setAxes(axes);
      return oldExtensible;
    }
    extensible = {axes:axes};
  } else {
    extensible = Ext.Object.chain(extensible);
  }
  extensible.allowReduceSelection = me.getReducible();
  extensible.view = me.getView();
  if (oldExtensible) {
    oldExtensible.destroy();
  }
  return new Ext.grid.selection.SelectionExtender(extensible);
}, applyReducible:function(reducible) {
  return !!reducible;
}, updateReducible:function(reducible) {
  var extensible;
  extensible = this.getConfig('extensible', null, true);
  if (extensible) {
    extensible.allowReduceSelection = reducible;
  }
}, applyCheckbox:function(checkbox) {
  var me = this;
  if (checkbox) {
    me.checkboxOnly = checkbox === 'only';
    me.checkboxColumn = checkbox = Ext.create(me.createCheckboxColumn(me.getCheckboxDefaults()));
  }
  return checkbox;
}, updateCheckbox:function(checkbox, oldCheckbox) {
  var me = this, view;
  if (!me.isConfiguring) {
    view = me.getView();
    if (oldCheckbox) {
      view.unregisterColumn(oldCheckbox, true);
    }
    if (checkbox) {
      view.registerColumn(checkbox);
      me.setRows(true);
    }
  }
}, applyView:function(view) {
  return view.ownerGrid;
}, extendSelection:function(extension) {
  var me = this, view = me.getView(), sel = me.getSelection(), action = extension.reduce ? 'reduce' : 'extend';
  if (view.fireEvent('beforeselectionextend', view, sel, extension) !== false) {
    sel[action + 'Range'](extension);
    if (!sel.isRows) {
      me.fireSelectionChange();
    }
  }
}, onIdChanged:function(store, rec, oldId, newId) {
  var sel = this.getSelection();
  if (sel && sel.isRecords) {
    sel.getSelected().updateKey(rec, oldId);
  }
}, onSelectionStoreAdd:function() {
  this.callParent(arguments);
  this.updateHeaderState();
}, onSelectionStoreClear:function() {
  this.callParent(arguments);
  this.updateHeaderState();
}, onSelectionStoreLoad:function() {
  this.callParent(arguments);
  this.updateHeaderState();
}}}, function(GridModel) {
  var RowNumberer = Ext.ClassManager.get('Ext.grid.column.RowNumberer'), cellCls;
  if (RowNumberer) {
    cellCls = Ext.grid.column.RowNumberer.prototype.cellCls;
    GridModel.prototype.rowNumbererCellCls = (cellCls ? cellCls + ' ' : '') + Ext.baseCSSPrefix + 'selmodel-row-numberer-cell';
  }
});
Ext.define('Ext.grid.plugin.ColumnResizing', {extend:Ext.Component, alias:['plugin.columnresizing', 'plugin.gridcolumnresizing'], config:{grid:null, realtime:false}, hasResizingCls:Ext.baseCSSPrefix + 'has-columnresizing', resizingCls:Ext.baseCSSPrefix + 'resizing', columnSelector:'.' + Ext.baseCSSPrefix + 'gridcolumn', resizerSelector:'.' + Ext.baseCSSPrefix + 'gridcolumn .' + Ext.baseCSSPrefix + 'resizer-el', init:function(grid) {
  this.setGrid(grid);
  grid.getHeaderContainer().setTouchAction({panX:false});
}, updateGrid:function(grid, oldGrid) {
  var me = this, cls = me.hasResizingCls, headerContainer, resizeMarker;
  if (oldGrid) {
    headerContainer = oldGrid.getHeaderContainer();
    headerContainer.renderElement.un({touchstart:'onContainerTouchStart', scope:me, priority:100});
    oldGrid.removeCls(cls);
  }
  if (grid) {
    me._resizeMarker = resizeMarker = grid.resizeMarkerElement;
    me._resizeMarkerParent = resizeMarker.parent();
    headerContainer = grid.getHeaderContainer();
    headerContainer.renderElement.on({touchstart:'onContainerTouchStart', scope:me});
    grid.addCls(cls);
  }
}, onContainerTouchStart:function(e) {
  var me = this, target = e.getTarget(me.columnSelector), resizer = e.getTarget(me.resizerSelector), column;
  if (resizer && !e.multitouch && target && !me._resizeColumn) {
    column = Ext.Component.from(target);
    if (column && column.getResizable()) {
      me._startColumnWidth = column.getComputedWidth();
      me._minColumnWidth = column.getMinWidth();
      me._maxColumnWidth = column.getMaxWidth();
      me._resizeColumn = column;
      me._startX = e.getX();
      column.addCls(me.resizingCls);
      e.claimGesture();
      if (!this.getRealtime()) {
        me._resizeMarker.show();
        me._resizeMarker.setLeft(column.el.getOffsetsTo(me._resizeMarkerParent)[0] + me._startColumnWidth);
      } else {
        column.setWidth(me._startColumnWidth);
      }
      me.touchListeners = Ext.getBody().on({touchEnd:'onTouchEnd', touchMove:'onTouchMove', scope:me, destroyable:true});
    }
  } else {
    if (e.multitouch && me._resizeColumn) {
      me.endResize();
    }
  }
}, onTouchMove:function(e) {
  if (e.isMultitouch) {
    this.endResize();
    return;
  }
  if (this._resizeColumn) {
    var column = this._resizeColumn, resizeAmount = e.getX() - this._startX;
    if (column) {
      this.currentColumnWidth = Math.max(Math.ceil(this._startColumnWidth + resizeAmount), this._minColumnWidth);
      if (this._maxColumnWidth) {
        this.currentColumnWidth = Math.min(this.currentColumnWidth, this._maxColumnWidth);
      }
      if (this.getRealtime()) {
        column.setWidth(this.currentColumnWidth);
        column.renderElement.setWidth(this.currentColumnWidth);
      } else {
        this._resizeMarker.setLeft(column.el.getOffsetsTo(this._resizeMarkerParent)[0] + this.currentColumnWidth);
      }
      e.claimGesture();
    }
  }
}, onTouchEnd:function(e) {
  var column = this._resizeColumn, hasResized = e.getX() !== this._startX;
  Ext.destroy(this.touchListeners);
  if (column) {
    this.endResize();
    if (!hasResized) {
      column.onResizerTap(e);
    }
  }
}, endResize:function() {
  var me = this, column = me._resizeColumn, grid = me.getGrid();
  if (column) {
    if (!me.getRealtime()) {
      grid.resizeMarkerElement.hide();
    }
    if (me.currentColumnWidth) {
      column.setFlex(null);
      column.setWidth(me.currentColumnWidth);
    }
    column.removeCls(me.resizingCls);
    me._resizeColumn = null;
  }
}});
Ext.define('Ext.grid.RowHeader', {extend:Ext.dataview.ItemHeader, xtype:'rowheader', classCls:Ext.baseCSSPrefix + 'rowheader', isRowHeader:true, toolDefaults:{ui:'itemheader rowheader'}, privates:{augmentToolHandler:function(tool, args) {
  this.callParent([tool, args]);
  var info = args[1];
  info.grid = info.list;
}, getGroupHeaderTplData:function() {
  var data = this.callParent([true]), grid = this.parent, column = data && grid.getColumnForField(data.groupField);
  if (column) {
    data.columnName = column.getText();
    if (column.printValue) {
      data.html = column.printValue(data.value);
    }
  } else {
    if (data) {
      data.html = Ext.htmlEncode(data.name);
    }
  }
  return data;
}}});
Ext.define('Ext.grid.Grid', {extend:Ext.dataview.List, xtype:'grid', isGrid:true, mixins:[Ext.mixin.ConfigProxy], storeEventListeners:{sort:'onStoreSort'}, config:{columns:null, columnMenu:{xtype:'menu', weighted:true, align:'tl-bl?', hideOnParentHide:false, items:{sortAsc:{xtype:'gridsortascmenuitem', group:'sortDir', weight:-100}, sortDesc:{xtype:'gridsortdescmenuitem', group:'sortDir', weight:-90}, groupByThis:{xtype:'gridgroupbythismenuitem', handler:'column.onGroupByThis', separator:true, weight:-70}, 
showInGroups:{xtype:'gridshowingroupsmenuitem', handler:'column.onToggleShowInGroups', weight:-60}}}, columnResize:true, headerContainer:{xtype:'headercontainer'}, hideHeaders:false, itemsFocusable:false, title:'', titleBar:{xtype:'titlebar', docked:'top'}, sortable:true, multiColumnSort:false, columnsMenuItem:{lazy:true, $value:{xtype:'gridcolumnsmenu', weight:-80, separator:true}}, columnLines:null, rowNumbers:null}, itemConfig:{xtype:'gridrow'}, groupHeader:{xtype:'rowheader'}, infinite:true, 
navigationModel:'grid', pinnedHeader:{xtype:'rowheader'}, scrollable:true, scrollToTopOnRefresh:false, striped:true, proxyConfig:{headerContainer:['reserveScrollbar']}, selectionModel:'grid', classCls:Ext.baseCSSPrefix + 'grid', columnLinesCls:Ext.baseCSSPrefix + 'column-lines', getTemplate:function() {
  var template = this.callParent();
  template.push({reference:'resizeMarkerElement', className:Ext.baseCSSPrefix + 'resize-marker-el', hidden:true});
  return template;
}, beforeInitialize:function() {
  this.ownerGrid = this;
  this.callParent();
}, initialize:function() {
  var me = this, titleBar = me.getTitleBar(), headerContainer = me.getHeaderContainer(), scroller = me.getScrollable(), selectable = me.getSelectable();
  me.callParent();
  if (scroller) {
    headerContainer.getScrollable().addPartner(scroller, 'x');
  }
  if (titleBar) {
    me.insert(0, titleBar);
  }
  me.add(headerContainer);
  if (selectable) {
    selectable.onViewCreated(me);
  }
}, addColumn:function(column) {
  return this.getHeaderContainer().add([column])[0];
}, beforeShowColumnMenu:function(column, menu) {
  return this.fireEvent('beforeshowcolumnmenu', this, column, menu);
}, doDestroy:function() {
  this.destroyMembers('columnsMenu', 'columnsMenuItem', 'rowNumbererColumn');
  this.callParent();
}, getColumnForField:function(fieldName) {
  return this.getHeaderContainer().getColumnForField(fieldName);
}, getColumns:function(selector) {
  return this.getHeaderContainer().getColumns(selector);
}, getVisibleColumns:function() {
  return this.getHeaderContainer().getVisibleColumns();
}, insertColumn:function(index, column) {
  return this.getHeaderContainer().insert(index, column);
}, mapToCell:function(value, column) {
  var me = this, ret;
  if (value) {
    if (value.isGridCell && value.row.getGrid() === me) {
      ret = value;
    } else {
      if (value.isEntity) {
        value = me.mapToItem(value);
      }
      if (value) {
        if (value.isGridRow) {
          column = column || me.getFirstVisibleColumn();
          if (column) {
            ret = value.getCellByColumn(column);
          }
        } else {
          ret = Ext.Component.from(value, me.innerCt, 'gridcellbase');
        }
      }
    }
  }
  return ret || null;
}, mapToItem:function(value, as) {
  if (value && value.isGridCell) {
    value = value.row;
  }
  return this.callParent([value, as]);
}, mapToRowBody:function(value) {
  if (value) {
    if (!value.isGridRow) {
      value = this.mapToItem(value);
    }
    if (value && value.isGridRow) {
      value = value.getBody();
    }
  }
  return value || null;
}, removeColumn:function(column) {
  return this.getHeaderContainer().remove(column);
}, registerActionable:function(actionable) {
  this.getNavigationModel().registerActionable(actionable);
}, unregisterActionable:function(actionable) {
  this.getNavigationModel().unregisterActionable(actionable);
}, onColumnAdd:function(container, column, columnIndex) {
  var me = this, items, ln, i, row;
  if (!me.initializingColumns && !me.destroying) {
    items = me.items.items;
    ln = items.length;
    for (i = 0; i < ln; i++) {
      row = items[i];
      if (row.isGridRow) {
        row.insertColumn(columnIndex, column);
      }
    }
    me.onColumnChange('columnadd', [me, column, columnIndex]);
  }
}, onColumnHide:function(container, column) {
  var me = this, items, ln, i, row;
  if (me.initialized && !me.destroying) {
    items = me.items.items;
    ln = items.length;
    for (i = 0; i < ln; i++) {
      row = items[i];
      if (row.isGridRow) {
        row.hideColumn(column);
      }
    }
    me.onColumnChange('columnhide', [me, column]);
  }
}, onColumnMove:function(container, columns, group, fromIdx) {
  var me = this, before = null, colLen = columns.length, items, ln, i, j, row, column, index, leaves;
  if (me.initialized && !me.destroying) {
    items = me.items.items;
    ln = items.length;
    leaves = me.getHeaderContainer().getLeaves();
    index = leaves.indexOf(columns[colLen - 1]);
    before = leaves[index + 1] || null;
    for (i = colLen - 1; i >= 0; --i) {
      column = columns[i];
      for (j = 0; j < ln; j++) {
        row = items[j];
        if (row.isGridRow) {
          row.insertColumnBefore(column, before);
        }
      }
      me.onColumnChange('columnmove', [me, column, fromIdx + i, leaves.indexOf(column)]);
      before = column;
    }
  }
}, onColumnRemove:function(container, column) {
  var me = this, items, ln, i, row;
  if (me.initialized && !me.destroying) {
    if (column === me.sortedColumn) {
      me.sortedColumn = null;
    }
    items = me.items.items;
    ln = items.length;
    for (i = 0; i < ln; i++) {
      row = items[i];
      if (row.isGridRow) {
        row.removeColumn(column);
      }
    }
    me.onColumnChange('columnremove', [me, column]);
  }
}, onColumnResize:function(container, column, width, oldWidth) {
  if (!this.destroying) {
    if (oldWidth && !column.getHidden()) {
      this.fireEvent('columnresize', this, column, width);
    }
  }
}, onColumnShow:function(container, column) {
  var me = this, items, ln, i, row;
  if (me.initialized && !me.destroying) {
    items = me.items.items;
    ln = items.length;
    for (i = 0; i < ln; i++) {
      row = items[i];
      if (row.isGridRow) {
        row.showColumn(column);
      }
    }
    me.onColumnChange('columnshow', [me, column]);
  }
}, onColumnSort:function(container, column, direction) {
  this.fireEvent('columnsort', this, column, direction);
}, onRender:function() {
  var hideHeaders = this._hideHeaders;
  this.callParent();
  if (hideHeaders) {
    this.updateHideHeaders(hideHeaders);
  }
}, privates:{dataItemMap:{header:1, footer:1}, handleStoreSort:function() {
  if (this.rendered) {
    this.getHeaderContainer().setSortState();
  }
}, onStoreGroupChange:function(store, grouper) {
  this.callParent([store, grouper]);
  this.handleStoreSort();
}, onStoreSort:function() {
  this.handleStoreSort();
}, registerColumn:function(column) {
  var me = this, columns = me.registeredColumns, headerCt = me.getHeaderContainer();
  if (!column.isGridColumn) {
    column = Ext.create(column);
  }
  if (!columns) {
    me.registeredColumns = columns = [];
  }
  columns.push(column);
  if (!me.isConfiguring || headerCt && headerCt.items.getCount()) {
    headerCt.add(column);
  }
  return column;
}, unregisterColumn:function(column, destroy) {
  var columns = this.registeredColumns, headerCt = this.getHeaderContainer();
  if (!this.destroying) {
    if (columns) {
      Ext.Array.remove(columns, column);
    }
    if (headerCt) {
      headerCt.remove(column, destroy === true);
    }
  }
  return column;
}, generateSelectorFunctions:function() {
  var me = this;
  me.callParent();
  me.eventDelegate = function(candidate) {
    var comp = Ext.Component.from(candidate), ret = true, row;
    if (!comp || comp === me) {
      return false;
    }
    if (comp.getRefOwner() === me) {
      ret = comp.isGridRow || me.dataItemMap[comp.$dataItem];
    } else {
      row = comp.row;
      ret = row && row.isGridRow && (row.grid || row.list) === me;
    }
    return ret;
  };
}, getFirstVisibleColumn:function() {
  var columns = this.getVisibleColumns();
  return columns.length ? columns[0] : null;
}, getLastVisibleColumn:function() {
  var columns = this.getVisibleColumns(), len = columns.length;
  return len ? columns[len - 1] : null;
}, isFirstVisibleColumn:function(column) {
  return this.getFirstVisibleColumn() === column;
}, isLastVisibleColumn:function(column) {
  return this.getLastVisibleColumn() === column;
}, createDataItem:function(cfg) {
  var item = this.callParent([cfg]);
  item.grid = this;
  return item;
}, onColumnChange:function(changeEvent, eventArgs) {
  var me = this;
  if (changeEvent !== 'columnmove' && changeEvent !== 'columnadd' && changeEvent !== 'columnremove') {
    me.refreshInnerWidth();
  }
  if (!me.isConfiguring) {
    me.fireEventArgs(changeEvent, eventArgs);
  }
  me.clearItemCaches();
}, refreshInnerWidth:function() {
  var headerCtBody = this.getHeaderContainer().bodyElement.dom, scrollWidth;
  scrollWidth = headerCtBody.scrollWidth;
  this.setInnerWidth(scrollWidth > headerCtBody.clientWidth ? scrollWidth : null);
}, onColumnComputedWidthChange:function(changedColumns, totalColumnWidth) {
  var me = this, groupingInfo = me.groupingInfo;
  if (!me.destroying) {
    me.setInnerWidth(totalColumnWidth);
    me.setCellSizes(changedColumns, me.items.items);
    me.setCellSizes(changedColumns, me.itemCache);
    if (me.isGrouping()) {
      me.setCellSizes(changedColumns, groupingInfo.headers.unused);
      me.setCellSizes(changedColumns, groupingInfo.footers.unused);
    }
    me.fireEvent('columnlayout', me, changedColumns, totalColumnWidth);
  }
}, onCellSelect:function(location) {
  var cell = location.getCell();
  if (cell) {
    cell.addCls(this.selectedCls);
  }
}, onCellDeselect:function(location) {
  var cell = location.getCell();
  if (cell) {
    cell.removeCls(this.selectedCls);
  }
}, setCellSizes:function(changedColumns, items) {
  var len = items.length, changedColCount = changedColumns.length, row, i, j;
  for (i = 0; i < len; i++) {
    row = items[i];
    if (row.isGridRow) {
      for (j = 0; j < changedColCount; j++) {
        row.setColumnWidth(changedColumns[j]);
      }
    }
  }
}, updateColumnLines:function(columnLines) {
  this.el.toggleCls(this.columnLinesCls, columnLines);
}, updateColumnResize:function(enabled) {
  var me = this, plugin = me.findPlugin('columnresizing');
  if (!plugin) {
    if (enabled) {
      me.addPlugin('columnresizing');
    }
  } else {
    plugin.setGrid(enabled ? me : null);
  }
}, updateColumns:function(columns) {
  var me = this, header = me.getHeaderContainer(), count = columns && columns.length, persist = me.registeredColumns;
  if (header) {
    me.rowHeight = null;
    if (header) {
      header.beginColumnUpdate();
      if (header.getItems().getCount()) {
        if (persist) {
          header.remove(persist, false);
        }
        if (count) {
          header.remove(columns.filter(function(col) {
            return col.isInstance;
          }), false);
        }
        header.removeAll(true, true);
      }
      if (count) {
        me.initializingColumns = me.isConfiguring;
        header.setColumns(columns);
        if (persist) {
          header.add(persist);
        }
        delete me.initializingColumns;
      }
      header.endColumnUpdate();
    }
  }
}, applyRowNumbers:function(rowNumbers) {
  var me = this;
  if (rowNumbers) {
    rowNumbers = me.rowNumbererColumn = Ext.create(Ext.apply({xtype:'rownumberer', weight:-1000, editRenderer:me.renderEmpty}, rowNumbers));
  }
  return rowNumbers;
}, updateRowNumbers:function(rowNumbers, oldRowNumbers) {
  if (oldRowNumbers) {
    this.unregisterColumn(oldRowNumbers, true);
  }
  if (rowNumbers) {
    this.registerColumn(rowNumbers);
  }
}, renderEmpty:function() {
  return '';
}, applyColumnsMenuItem:function(config, existing) {
  return Ext.updateWidget(existing, config, this, 'createColumnsMenuItem');
}, createColumnsMenuItem:function(config) {
  return Ext.apply({grid:this}, config);
}, applyHeaderContainer:function(config, existing) {
  return Ext.updateWidget(existing, config, this, 'createHeaderContainer');
}, createHeaderContainer:function(config) {
  config = this.mergeProxiedConfigs('headerContainer', config, true);
  config.sortable = this.getSortable();
  config.grid = this;
  return config;
}, updateHeaderContainer:function(headerContainer) {
  if (headerContainer) {
    headerContainer.on({columnresize:'onColumnResize', columnshow:'onColumnShow', columnhide:'onColumnHide', columnadd:'onColumnAdd', columnmove:'onColumnMove', columnremove:'onColumnRemove', columnsort:'onColumnSort', scope:this});
  }
}, updateHideHeaders:function(hideHeaders) {
  if (this.isRendered) {
    var headerContainer = this.getHeaderContainer();
    if (hideHeaders) {
      headerContainer.el.setStyle({marginBottom:'-' + headerContainer.el.measure('h') + 'px'});
    } else {
      headerContainer.el.setStyle({marginBottom:''});
    }
  }
}, updateTitle:function(title) {
  var titleBar = this.getTitleBar();
  if (titleBar) {
    if (title) {
      titleBar.setTitle(title);
      if (titleBar.isHidden()) {
        titleBar.show();
      }
    } else {
      titleBar.hide();
    }
  }
}, applyTitleBar:function(config, existing) {
  return Ext.updateWidget(existing, config);
}, updateTitleBar:function(titleBar) {
  if (titleBar && !titleBar.getTitle()) {
    titleBar.setTitle(this.getTitle());
  }
}, applyTotalColumnWidth:function(totalColumnWidth) {
  var rows = this.dataItems;
  return rows.length === 0 ? undefined : totalColumnWidth;
}, updateVerticalOverflow:function(value, was) {
  var headerContainer = this.getHeaderContainer(), verticalScrollbarWidth = Ext.getScrollbarSize().width;
  this.callParent([value, was]);
  headerContainer.setVerticalOverflow(verticalScrollbarWidth > 0 && value);
}}}, function(Grid) {
  Grid.prototype.indexModifiedFields = Ext.Array.toMap;
});
Ext.define('Ext.theme.material.grid.Grid', {override:'Ext.grid.Grid', config:{rowLines:true, striped:false}});
Ext.define('Ext.grid.column.Text', {extend:Ext.grid.column.Column, xtype:'textcolumn', cell:{xtype:'textcell'}});
Ext.define('Ext.layout.Center', {extend:Ext.layout.Auto, alias:'layout.center', cls:Ext.baseCSSPrefix + 'layout-center', itemCls:Ext.baseCSSPrefix + 'layout-center-item'});
Ext.define('Ext.menu.Separator', {extend:Ext.Component, alias:'widget.menuseparator', isMenuSeparator:true, focusable:false, classCls:Ext.baseCSSPrefix + 'menuseparator', ariaRole:'separator'});
Ext.define('Ext.panel.Header', {extend:Ext.Container, xtype:'panelheader', isPanelHeader:true, config:{icon:null, iconAlign:null, iconCls:null, titleRotation:'auto', title:null, titleAlign:null, layout:{type:'box', vertical:false, align:'center'}, position:null}, autoSize:null, classCls:Ext.baseCSSPrefix + 'panelheader', verticalCls:Ext.baseCSSPrefix + 'vertical', horizontalCls:Ext.baseCSSPrefix + 'horizontal', toolEndCls:Ext.baseCSSPrefix + 'end', toolStartCls:Ext.baseCSSPrefix + 'start', rotationMap:{top:'0', 
right:'90', bottom:'0', left:'270'}, dockCls:{top:Ext.baseCSSPrefix + 'docked-top', right:Ext.baseCSSPrefix + 'docked-right', bottom:Ext.baseCSSPrefix + 'docked-bottom', left:Ext.baseCSSPrefix + 'docked-left'}, weighted:true, vertical:false, inheritUi:true, addTools:function(tools) {
  var items = Ext.Array.from(tools);
  if (items && items.length) {
    items = this.add(items);
  }
  return items;
}, applyTitle:function(newTitle, oldTitle) {
  var title = oldTitle;
  if (title) {
    if (!newTitle || typeof newTitle === 'string') {
      title.setText(newTitle || '');
    } else {
      if (newTitle) {
        title.setConfig(newTitle);
      }
    }
  } else {
    title = Ext.create(this.createTitle(newTitle));
  }
  return title;
}, createTitle:function(config) {
  var panel = this.getRefOwner();
  if (config && typeof config === 'string') {
    config = {text:config};
  }
  return Ext.merge({xtype:'paneltitle', instanceCls:panel && panel.titleCls || null, flex:'1 1 auto'}, config);
}, onItemAdd:function(item, index) {
  var me = this, title = me.getTitle(), titleWeight = title && title.weight || -10, itemWeight = item.weight || 0;
  me.callParent([item, index]);
  if (item.isTool) {
    item.addCls(itemWeight < titleWeight ? me.toolStartCls : me.toolEndCls);
  }
}, onItemRemove:function(item, index, destroying) {
  this.callParent([item, index, destroying]);
  if (item.isTool) {
    item.removeCls([this.toolStartCls, this.toolEndCls]);
  }
}, updateIcon:function(icon) {
  this.ensureTitle().setIcon(icon);
}, updateIconAlign:function(align) {
  this.ensureTitle().setIconAlign(align);
}, updateIconCls:function(cls) {
  this.ensureTitle().setIconCls(cls);
}, updateTitle:function(title, oldTitle) {
  if (oldTitle) {
    oldTitle.setConfig(title);
  } else {
    this.add(title);
  }
}, updateTitleAlign:function(align) {
  this.ensureTitle().setTextAlign(align);
}, updateTitleRotation:function(rotation) {
  var me = this, owner;
  if (rotation === 'auto') {
    if (me.isConfiguring) {
      return;
    }
    owner = me.getRefOwner();
    if (!owner) {
      Ext.raise('Cannot use rotation auto without an owning panel.');
    }
    if (owner) {
      rotation = me.rotationMap[owner.getHeaderPosition()];
    }
  }
  me.rotateTitle(rotation);
}, updatePosition:function(position, oldPosition) {
  var me = this, layout = me.getLayout(), isLeft = position === 'left', isRight = position === 'right', vertical = me.vertical = isLeft || isRight, verticalCls = me.verticalCls, horizontalCls = me.horizontalCls, dockCls = me.dockCls;
  layout.setVertical(vertical);
  layout.setReverse(isLeft);
  if (oldPosition) {
    me.removeCls(dockCls[oldPosition]);
  }
  if (position) {
    me.addCls(dockCls[position]);
  }
  if (vertical) {
    me.replaceCls(horizontalCls, verticalCls);
  } else {
    me.replaceCls(verticalCls, horizontalCls);
  }
  if (me.getTitleRotation() === 'auto') {
    me.rotateTitle(me.rotationMap[position]);
  }
}, privates:{clearTools:function() {
  var items = this.getItems().items, c, i;
  for (i = items.length; i-- > 0;) {
    c = items[i];
    if (c.isTool && !c.$internal) {
      this.remove(c);
    }
  }
}, ensureTitle:function() {
  var me = this, title = me.getTitle();
  if (!title) {
    me.setTitle('');
    title = me.getTitle();
  }
  return title;
}, isVertical:function() {
  return this.vertical;
}, rotateTitle:function(rotation) {
  this.ensureTitle().setRotation(rotation);
}, sortByWeight:function(item1, item2) {
  return (item1.weight || 0) - (item2.weight || 0);
}}, deprecated:{'6.5':{configs:{glyph:null}}}});
Ext.define('Ext.theme.material.panel.Header', {override:'Ext.panel.Header', config:{titleAlign:'left'}});
Ext.define('Ext.tab.Tab', {extend:Ext.Button, xtype:'tab', alternateClassName:'Ext.Tab', isTab:true, config:{active:null, title:null, closable:null}, pressedDelay:true, classCls:Ext.baseCSSPrefix + 'tab', activeCls:Ext.baseCSSPrefix + 'active', closableCls:Ext.baseCSSPrefix + 'closable', getTemplate:function() {
  var template = this.callParent();
  template.push({reference:'activeIndicatorElement', cls:Ext.baseCSSPrefix + 'active-indicator-el'}, {reference:'closeIconElement', cls:Ext.baseCSSPrefix + 'close-icon-el ' + Ext.baseCSSPrefix + 'font-icon ' + Ext.baseCSSPrefix + 'no-ripple', listeners:{click:'onClick'}});
  return template;
}, shouldRipple:function() {
  return this.getRipple();
}, onClick:function(e) {
  var me = this, tabBar = me.tabBar;
  if (e.currentTarget === me.closeIconElement.dom) {
    if (tabBar && !me.getDisabled()) {
      tabBar.closeTab(me);
    }
    e.stopPropagation();
  } else {
    return me.callParent([e]);
  }
}, updateTitle:function(title) {
  this.setText(title);
}, updateActive:function(active, oldActive) {
  var me = this, el = me.el, activeCls = me.activeCls;
  if (active && !oldActive) {
    el.addCls(activeCls);
    me.fireEvent('activate', me);
  } else {
    if (oldActive) {
      el.removeCls(activeCls);
      me.fireEvent('deactivate', me);
    }
  }
}, updateClosable:function(closable) {
  this.toggleCls(this.closableCls, !!closable);
}, onAdded:function(parent, instanced) {
  this.callParent([parent, instanced]);
  this.tabBar = parent.isTabBar ? parent : null;
}, onRemoved:function(destroying) {
  this.callParent([destroying]);
  this.tabBar = null;
}}, function() {
  this.override({activate:function() {
    this.setActive(true);
  }, deactivate:function() {
    this.setActive(false);
  }});
});
Ext.define('Ext.theme.material.tab.Tab', {override:'Ext.tab.Tab', config:{iconAlign:'top', flex:1}, platformConfig:{desktop:{maxWidth:200}}});
Ext.define('Ext.tab.Bar', {extend:Ext.Toolbar, alternateClassName:'Ext.TabBar', xtype:'tabbar', isTabBar:true, config:{defaultTabUI:null, animateIndicator:false}, defaultType:'tab', layout:{type:'hbox', align:'stretch'}, eventedConfig:{activeTab:null}, baseCls:Ext.baseCSSPrefix + 'tabbar', indicatorAnimationSpeed:150, initialize:function() {
  var me = this;
  me.callParent();
  me.on({tap:'onTabTap', delegate:'\x3e tab', scope:me});
}, getTemplate:function() {
  var template = this.callParent();
  template.push({reference:'stripElement', cls:Ext.baseCSSPrefix + 'strip-el'});
  return template;
}, onTabTap:function(tab) {
  this.setActiveTab(tab);
}, applyActiveTab:function(newActiveTab, oldActiveTab) {
  if (!newActiveTab && newActiveTab !== 0) {
    return;
  }
  var newTabInstance = this.parseActiveTab(newActiveTab);
  if (!newTabInstance) {
    if (oldActiveTab) {
      Ext.Logger.warn('Trying to set a non-existent activeTab');
    }
    return;
  }
  return newTabInstance;
}, updateDocked:function(newDocked) {
  var layout = this.getLayout(), initialConfig = this.getInitialConfig(), pack;
  if (!initialConfig.layout || !initialConfig.layout.pack) {
    pack = newDocked == 'bottom' ? 'center' : 'left';
    if (layout.isLayout) {
      layout.setPack(pack);
    } else {
      layout.pack = layout && layout.pack ? layout.pack : pack;
    }
  }
  this.callParent(arguments);
}, updateActiveTab:function(newTab, oldTab) {
  var me = this, animateIndicator = this.getAnimateIndicator();
  if (animateIndicator && newTab && oldTab && oldTab.parent) {
    me.animateTabIndicator(newTab, oldTab);
  } else {
    if (newTab) {
      newTab.setActive(true);
    }
    if (oldTab && oldTab.parent) {
      oldTab.setActive(false);
      this.previousTab = oldTab;
    }
  }
}, updateAnimateIndicator:function() {
  var me = this;
  if (me.$animateIndicatorElement) {
    me.$animateIndicatorElement.destroy();
  }
  if (me.$indicatorAnimationListeners) {
    me.$indicatorAnimationListeners.destroy();
  }
  me.$indicatorAnimationListeners = me.$animateIndicatorElement = null;
}, animateTabIndicator:function(newTab, oldTab) {
  var me = this, newTabElement = newTab.element, oldTabElement = oldTab.element, oldIndicator = oldTab.activeIndicatorElement, newIndicator = newTab.activeIndicatorElement, tabbarElement = me.element, oldIndicatorProps, newIndicatorProps, animateIndicatorElement;
  newTab.setActive(true);
  oldIndicatorProps = {transform:{translateX:oldTabElement.getX() - tabbarElement.getX()}, width:oldTabElement.getWidth(), height:oldIndicator.getHeight(), 'background-color':oldIndicator.getStyle('background-color')};
  newIndicatorProps = {transform:{translateX:newTabElement.getX() - tabbarElement.getX()}, width:newTabElement.getWidth(), height:newIndicator.getHeight(), 'background-color':newIndicator.getStyle('background-color')};
  oldTab.setActive(false);
  newIndicator.hide();
  if (oldIndicatorProps.height || newIndicatorProps.height) {
    animateIndicatorElement = me.$animateIndicatorElement;
    if (!animateIndicatorElement) {
      animateIndicatorElement = me.$animateIndicatorElement = me.element.insertFirst({cls:Ext.baseCSSPrefix + 'active-indicator-el'});
    }
    animateIndicatorElement.show();
    if (me.$indicatorAnimationListeners) {
      me.$indicatorAnimationListeners.destroy();
      me.$indicatorAnimationListeners = null;
    }
    me.$indicatorAnimation = animateIndicatorElement.animate({duration:me.indicatorAnimationSpeed, from:oldIndicatorProps, to:newIndicatorProps});
    me.$indicatorAnimationListeners = me.$indicatorAnimation.on({destroyable:true, animationend:{fn:function() {
      newIndicator.show();
      animateIndicatorElement.hide();
      me.$indicatorAnimationListeners.destroy();
      me.$indicatorAnimation = me.$indicatorAnimationListeners = null;
    }, single:true}});
  }
}, parseActiveTab:function(tab) {
  if (typeof tab == 'number') {
    return this.query('\x3e tab')[tab];
  } else {
    if (typeof tab == 'string') {
      tab = this.getComponent(tab) || Ext.getCmp(tab);
    }
  }
  return tab;
}, onItemAdd:function(item, index) {
  var defaultTabUI = this.getDefaultTabUI();
  if (defaultTabUI && item.isTab && item.getUi() == null) {
    item.setUi(defaultTabUI);
  }
  this.callParent([item, index]);
}, privates:{findNextActivatableTab:function(tabToClose) {
  var me = this, previousTab = me.previousTab, nextTab;
  if (tabToClose.getActive() && me.getItems().getCount() > 1) {
    if (previousTab && previousTab !== tabToClose && !previousTab.getDisabled()) {
      nextTab = previousTab;
    } else {
      nextTab = tabToClose.next('tab:not([disabled\x3dtrue])') || tabToClose.prev('tab:not([disabled\x3dtrue])');
    }
  }
  return nextTab || me.getActiveTab();
}, closeTab:function(tab) {
  var me = this, nextActivatableTab = me.findNextActivatableTab(tab), parent = me.parent;
  if (parent && parent.isTabPanel) {
    if (nextActivatableTab) {
      parent.setActiveItem(nextActivatableTab.card);
    }
    parent.remove(tab.card);
  } else {
    if (nextActivatableTab) {
      me.setActiveTab(nextActivatableTab);
    }
    me.remove(tab);
  }
}}});
Ext.define('Ext.theme.material.tab.Bar', {override:'Ext.tab.Bar', config:{animateIndicator:true}, platformConfig:{desktop:{layout:{pack:'center'}}}});
Ext.define('Ext.tab.Panel', {extend:Ext.Container, xtype:'tabpanel', alternateClassName:'Ext.TabPanel', isTabPanel:true, config:{tabBar:true, tabBarPosition:'top', layout:{type:'card', animation:{type:'slide'}}, cls:Ext.baseCSSPrefix + 'tabpanel'}, defaults:{allowHeader:false}, initialize:function() {
  var me = this;
  me.callParent();
  me.on({beforeactivetabchange:'doTabChange', delegate:'\x3e tabbar', scope:me});
  me.on({disabledchange:'onItemDisabledChange', delegate:'\x3e component', scope:me});
}, applyScrollable:function() {
  return false;
}, updateUi:function(ui, oldUi) {
  var bar;
  this.callParent([ui, oldUi]);
  bar = this.getTabBar();
  if (this.initialized && bar) {
    bar.setUi(ui);
  }
}, updateActiveItem:function(newActiveItem, oldActiveItem) {
  if (newActiveItem) {
    var items = this.getInnerItems(), oldIndex = items.indexOf(oldActiveItem), newIndex = items.indexOf(newActiveItem), tabBar = this.getTabBar(), oldTab = tabBar.parseActiveTab(oldIndex), newTab = tabBar.parseActiveTab(newIndex);
    this.callParent(arguments);
    if (newIndex != -1) {
      this.forcedChange = true;
      tabBar.setActiveTab(newIndex);
      this.forcedChange = false;
      if (oldTab) {
        oldTab.setActive(false);
      }
      if (newTab) {
        newTab.setActive(true);
      }
    }
  }
}, doTabChange:function(tabBar, newTab) {
  var oldActiveItem = this.getActiveItem(), newActiveItem;
  this.setActiveItem(tabBar.indexOf(newTab));
  newActiveItem = this.getActiveItem();
  return this.forcedChange || oldActiveItem !== newActiveItem;
}, applyTabBar:function(config) {
  var innerItems, activeItem;
  if (this.isConfiguring) {
    activeItem = this.initialConfig.activeItem || 0;
  } else {
    innerItems = this.getInnerItems();
    activeItem = innerItems.indexOf(this._activeItem);
  }
  if (config === true) {
    config = {};
  }
  if (config) {
    Ext.applyIf(config, {ui:this.getUi(), docked:this.getTabBarPosition(), activeItem:activeItem});
    return Ext.factory(config, Ext.tab.Bar, this.getTabBar());
  }
  return null;
}, updateTabBar:function(tabBar, oldTabBar) {
  var me = this;
  if (oldTabBar && me.removingTabBar === undefined) {
    me.remove(oldTabBar, true);
  }
  if (tabBar) {
    me.add(tabBar);
    me.setTabBarPosition(tabBar.getDocked());
  }
}, updateTabBarPosition:function(position) {
  var tabBar = this.getTabBar();
  if (tabBar) {
    tabBar.setDocked(position);
  }
}, onItemAdd:function(card, index) {
  var me = this;
  if (!card.isInnerItem()) {
    return me.callParent([card, index]);
  }
  var tabBar = me.getTabBar(), initialConfig = card.getInitialConfig(), tabConfig = initialConfig.tab || {}, tabTitle = card.getTitle ? card.getTitle() : initialConfig.title, tabClosable = card.getClosable ? card.getClosable() : initialConfig.closable, tabIconAlign = card.getIconAlign ? card.getIconAlign() : initialConfig.iconAlign, tabIconCls = card.getIconCls ? card.getIconCls() : initialConfig.iconCls, tabIcon = card.getIcon ? card.getIcon() : initialConfig.icon, tabHidden = card.getHidden ? card.getHidden() : 
  initialConfig.hidden, tabDisabled = card.getDisabled ? card.getDisabled() : initialConfig.disabled, tabBadgeText = card.getBadgeText ? card.getBadgeText() : initialConfig.badgeText, innerItems = me.getInnerItems(), index = innerItems.indexOf(card), tabs = tabBar.query('\x3e tab'), activeTab = tabBar.getActiveTab(), currentTabInstance = tabs.length >= innerItems.length && tabs[index], header = card.getConfig('header', false, true), tabInstance;
  if (tabTitle && !tabConfig.title) {
    tabConfig.title = tabTitle;
  }
  if (tabClosable && !tabConfig.closable) {
    tabConfig.closable = tabClosable;
  }
  if (tabIconAlign && !tabConfig.iconAlign) {
    tabConfig.iconAlign = tabIconAlign;
  }
  if (tabIconCls && !tabConfig.iconCls) {
    tabConfig.iconCls = tabIconCls;
  }
  if (tabIcon && !tabConfig.icon) {
    tabConfig.icon = tabIcon;
  }
  if (tabHidden && !tabConfig.hidden) {
    tabConfig.hidden = tabHidden;
  }
  if (tabDisabled && !tabConfig.disabled) {
    tabConfig.disabled = tabDisabled;
  }
  if (tabBadgeText && !tabConfig.badgeText) {
    tabConfig.badgeText = tabBadgeText;
  }
  if (!currentTabInstance && !tabConfig.title && !tabConfig.iconCls) {
    if (!tabConfig.title && !tabConfig.iconCls) {
      Ext.Logger.error('Adding a card to a tab container without specifying any tab configuration');
    }
  }
  tabInstance = Ext.factory(tabConfig, Ext.tab.Tab, currentTabInstance);
  if (!currentTabInstance) {
    tabBar.insert(index, tabInstance);
  }
  card.tab = tabInstance;
  tabInstance.card = card;
  if (header) {
    header.setHidden(true);
  }
  me.callParent([card, index]);
  if (!activeTab && activeTab !== 0) {
    tabBar.setActiveTab(tabInstance);
  }
}, onItemDisabledChange:function(item, newDisabled) {
  if (item && item.tab) {
    item.tab.setDisabled(newDisabled);
  }
}, onItemRemove:function(item, index, destroying) {
  var me = this, meDestroying = me.meDestroying, clearBar, tabBar;
  if (!meDestroying) {
    tabBar = me.getTabBar();
    if (item === tabBar) {
      clearBar = me.removingTabBar === undefined;
    } else {
      if (tabBar) {
        tabBar.remove(item.tab, true);
      }
    }
  }
  me.callParent([item, index, destroying]);
  if (clearBar) {
    me.removingTabBar = destroying;
    me.setTabBar(null);
    delete me.removingTabBar;
  }
}});
Ext.define('Ext.tip.Manager', {config:{tooltip:{xtype:'tooltip', align:'', anchorToTarget:false, anchor:false, closeAction:'hide', quickShowInterval:0, maxWidth:'80vw'}, overflowTip:{align:'l-r?', anchor:true, showOnTap:true}}, interceptTitles:false, constructor:function(config) {
  var me = this, tip;
  me.initConfig(config);
  me._fly = new Ext.dom.Fly;
  me.tip = tip = Ext.create(me.createTooltip());
  tip.allowRealign = false;
  tip.on({beforeshow:'onBeforeShow', hovertarget:'onHoverTarget', scope:me});
  me.globalListeners = Ext.on({scope:me, destroyable:true, dragstart:'dragDisable', dragend:'dragEnable', dragcancel:'dragEnable'});
  if (!me.self.instance) {
    me.self.instance = me;
  }
}, disable:function() {
  var n = ++this.disabled;
  if (n === 1) {
    this.getTooltip().disable();
  }
}, enable:function() {
  var n = --this.disabled;
  if (n === 0) {
    this.getTooltip().enable();
  } else {
    if (n < 0) {
      this.disabled = 0;
    }
  }
}, destroy:function() {
  var me = this;
  if (me.self.instance === me) {
    me.self.instance = null;
  }
  me._fly.detach();
  me.globalListeners = me.tip = Ext.destroy(me.tip, me.globalListeners);
  me.callParent();
}, createTooltip:function() {
  var me = this, config = me.getTooltip();
  return Ext.apply({id:'ext-global-tooltip', delegate:me.delegateQuickTip.bind(me), target:Ext.getBody()}, config);
}, hide:function() {
  if (this.tip) {
    this.tip.hide();
  }
}, privates:{disabled:0, _propertyMap:function() {
  var numFn = function(v) {
    return parseInt(v, 10);
  }, boolFn = function(v) {
    return !!v;
  }, fn = Ext.identityFn;
  return {ui:{prop:'data-qui', parse:fn}, html:{prop:'data-qtip', parse:fn}, width:{prop:'data-qwidth', parse:numFn}, minWidth:{prop:'data-qminWidth', parse:fn}, maxWidth:{prop:'data-qmaxWidth', parse:fn}, title:{prop:'data-qtitle', parse:fn}, autoHide:{prop:'data-qautoHide', parse:boolFn}, cls:{prop:'data-qcls', parse:fn}, axisLock:{prop:'data-axislock', parse:fn}, align:{prop:'data-qalign', parse:fn}, alignDelegate:{prop:'data-qaligndelegate', parse:fn}, anchor:{prop:'data-qanchor', parse:fn}, 
  showDelay:{prop:'data-qshowDelay', parse:numFn}, hideDelay:{prop:'data-qhideDelay', parse:numFn}, dismissDelay:{prop:'data-qdismissDelay', parse:numFn}, trackMouse:{prop:'data-qtrackMouse', parse:boolFn}, anchorToTarget:{prop:'data-qanchorToTarget', parse:boolFn}, allowOver:{prop:'data-qallowover', parse:boolFn}, closable:true};
}(), applyOverflowTip:function(config) {
  var phone = Ext.platformTags.phone;
  return Ext.apply({axisLock:!phone, maxWidth:phone ? '80vw' : 400}, config);
}, delegateQuickTip:function(dom) {
  var qtip = this.getTipConfig(dom, 'html');
  return !!qtip;
}, dragDisable:function() {
  if (!this.disabled) {
    this.tip.disable();
  }
}, dragEnable:function() {
  if (!this.disabled) {
    this.tip.enable();
  }
}, getTipConfig:function(dom, property) {
  var me = this, propertyMap = me._propertyMap, tipDefaults = me._tipDefaults, fly = me._fly, data = fly.attach(dom).getData().qtip, tip = me.tip, textAttr = propertyMap.html.prop, name, text, ret, value, item;
  if (!tipDefaults && property !== 'html') {
    me._tipDefaults = tipDefaults = {};
    for (name in propertyMap) {
      tipDefaults[name] = tip.getConfig(name);
    }
  }
  if (data) {
    if (property) {
      ret = data[property];
    } else {
      ret = Ext.apply({}, tipDefaults);
      Ext.apply(ret, data);
    }
  } else {
    if (dom.hasAttribute(textAttr)) {
      text = dom.getAttribute(textAttr);
      if (!text) {
        text = me.interceptTitles && dom.title;
        if (text) {
          dom.setAttribute(textAttr, text);
          dom.removeAttribute('title');
        }
      }
    } else {
      if (dom.hasAttribute('data-qoverflow')) {
        text = fly.dom.innerHTML;
        if (property !== 'html') {
          tipDefaults = Ext.apply({}, me.getOverflowTip(), tipDefaults);
        }
        if (!property) {
          if (!me.hasTextOverflow(dom)) {
            return false;
          }
        }
      }
    }
    if (text) {
      if (property === 'html') {
        ret = text;
      } else {
        if (property) {
          item = propertyMap[property];
          if (item.prop) {
            if (dom.hasAttribute(item.prop)) {
              ret = item.parse(dom.getAttribute(item.prop));
            }
          }
        } else {
          ret = data = {html:text};
          for (name in propertyMap) {
            if (name !== 'html') {
              item = propertyMap[name];
              value = null;
              if (item.prop) {
                if (dom.hasAttribute(item.prop)) {
                  value = item.parse(dom.getAttribute(item.prop));
                }
              }
              if (value === null) {
                value = tipDefaults[name];
              }
              data[name] = value;
            }
          }
        }
      }
    }
  }
  fly.detach();
  if (property && ret == null && property !== 'html') {
    ret = tipDefaults[property];
  }
  return ret;
}, onBeforeShow:function(tip) {
  var me = this, dom = tip.currentTarget.dom, data, header;
  if (dom) {
    data = me.getTipConfig(dom);
    if (data === false) {
      return false;
    }
    if (!data) {
      return;
    }
    data.anchorToTarget = !!(data.align || data.anchor);
    tip.setConfig(data);
    header = tip.getHeader();
    if (header) {
      header.setHidden(!data.title && !data.closable);
    }
  }
}, priorityConfigs:['showDelay', 'anchor', 'anchorToTarget', 'align', 'trackMouse'], onHoverTarget:function(tip, currentTarget) {
  var dom = currentTarget.dom, cfg;
  if (dom) {
    cfg = {};
    this.priorityConfigs.forEach(function(name) {
      cfg[name] = this.getTipConfig(dom, name);
    }, this);
    cfg.anchorToTarget = !!(cfg.align || cfg.anchor);
    tip.setConfig(cfg);
  }
}, hasTextOverflow:function(candidate) {
  if (Ext.fly(candidate).isStyle('text-overflow', 'ellipsis')) {
    var textSize = Ext.util.TextMetrics.measure(candidate, candidate.innerHTML);
    return textSize.width > Ext.fly(candidate).getViewRegion().width;
  }
}}});
Ext.namespace('Ext.theme.is').Neptune = true;
Ext.theme.name = 'Neptune';
Ext.theme.getDocCls = function() {
  return Ext.platformTags.desktop ? '' : 'x-big';
};
Ext.define('Ext.theme.Material', {singleton:true, _autoUpdateMeta:true, _defaultWeight:'500', _colors:{'red':{50:'#ffebee', 100:'#ffcdd2', 200:'#ef9a9a', 300:'#e57373', 400:'#ef5350', 500:'#f44336', 600:'#e53935', 700:'#d32f2f', 800:'#c62828', 900:'#b71c1c', 'a100':'#ff8a80', 'a200':'#ff5252', 'a400':'#ff1744', 'a700':'#d50000'}, 'pink':{50:'#fce4ec', 100:'#f8bbd0', 200:'#f48fb1', 300:'#f06292', 400:'#ec407a', 500:'#e91e63', 600:'#d81b60', 700:'#c2185b', 800:'#ad1457', 900:'#880e4f', 'a100':'#ff80ab', 
'a200':'#ff4081', 'a400':'#f50057', 'a700':'#c51162'}, 'purple':{50:'#f3e5f5', 100:'#e1bee7', 200:'#ce93d8', 300:'#ba68c8', 400:'#ab47bc', 500:'#9c27b0', 600:'#8e24aa', 700:'#7b1fa2', 800:'#6a1b9a', 900:'#4a148c', 'a100':'#ea80fc', 'a200':'#e040fb', 'a400':'#d500f9', 'a700':'#aa00ff'}, 'deep-purple':{50:'#ede7f6', 100:'#d1c4e9', 200:'#b39ddb', 300:'#9575cd', 400:'#7e57c2', 500:'#673ab7', 600:'#5e35b1', 700:'#512da8', 800:'#4527a0', 900:'#311b92', 'a100':'#b388ff', 'a200':'#7c4dff', 'a400':'#651fff', 
'a700':'#6200ea'}, 'indigo':{50:'#e8eaf6', 100:'#c5cae9', 200:'#9fa8da', 300:'#7986cb', 400:'#5c6bc0', 500:'#3f51b5', 600:'#3949ab', 700:'#303f9f', 800:'#283593', 900:'#1a237e', 'a100':'#8c9eff', 'a200':'#536dfe', 'a400':'#3d5afe', 'a700':'#304ffe'}, 'blue':{50:'#e3f2fd', 100:'#bbdefb', 200:'#90caf9', 300:'#64b5f6', 400:'#42a5f5', 500:'#2196f3', 600:'#1e88e5', 700:'#1976d2', 800:'#1565c0', 900:'#0d47a1', 'a100':'#82b1ff', 'a200':'#448aff', 'a400':'#2979ff', 'a700':'#2962ff'}, 'light-blue':{50:'#e1f5fe', 
100:'#b3e5fc', 200:'#81d4fa', 300:'#4fc3f7', 400:'#29b6f6', 500:'#03a9f4', 600:'#039be5', 700:'#0288d1', 800:'#0277bd', 900:'#01579b', 'a100':'#80d8ff', 'a200':'#40c4ff', 'a400':'#00b0ff', 'a700':'#0091ea'}, 'cyan':{50:'#e0f7fa', 100:'#b2ebf2', 200:'#80deea', 300:'#4dd0e1', 400:'#26c6da', 500:'#00bcd4', 600:'#00acc1', 700:'#0097a7', 800:'#00838f', 900:'#006064', 'a100':'#84ffff', 'a200':'#18ffff', 'a400':'#00e5ff', 'a700':'#00b8d4'}, 'teal':{50:'#e0f2f1', 100:'#b2dfdb', 200:'#80cbc4', 300:'#4db6ac', 
400:'#26a69a', 500:'#009688', 600:'#00897b', 700:'#00796b', 800:'#00695c', 900:'#004d40', 'a100':'#a7ffeb', 'a200':'#64ffda', 'a400':'#1de9b6', 'a700':'#00bfa5'}, 'green':{50:'#e8f5e9', 100:'#c8e6c9', 200:'#a5d6a7', 300:'#81c784', 400:'#66bb6a', 500:'#4caf50', 600:'#43a047', 700:'#388e3c', 800:'#2e7d32', 900:'#1b5e20', 'a100':'#b9f6ca', 'a200':'#69f0ae', 'a400':'#00e676', 'a700':'#00c853'}, 'light-green':{50:'#f1f8e9', 100:'#dcedc8', 200:'#c5e1a5', 300:'#aed581', 400:'#9ccc65', 500:'#8bc34a', 600:'#7cb342', 
700:'#689f38', 800:'#558b2f', 900:'#33691e', 'a100':'#ccff90', 'a200':'#b2ff59', 'a400':'#76ff03', 'a700':'#64dd17'}, 'lime':{50:'#f9fbe7', 100:'#f0f4c3', 200:'#e6ee9c', 300:'#dce775', 400:'#d4e157', 500:'#cddc39', 600:'#c0ca33', 700:'#afb42b', 800:'#9e9d24', 900:'#827717', 'a100':'#f4ff81', 'a200':'#eeff41', 'a400':'#c6ff00', 'a700':'#aeea00'}, 'yellow':{50:'#fffde7', 100:'#fff9c4', 200:'#fff59d', 300:'#fff176', 400:'#ffee58', 500:'#ffeb3b', 600:'#fdd835', 700:'#fbc02d', 800:'#f9a825', 900:'#f57f17', 
'a100':'#ffff8d', 'a200':'#ffff00', 'a400':'#ffea00', 'a700':'#ffd600'}, 'amber':{50:'#fff8e1', 100:'#ffecb3', 200:'#ffe082', 300:'#ffd54f', 400:'#ffca28', 500:'#ffc107', 600:'#ffb300', 700:'#ffa000', 800:'#ff8f00', 900:'#ff6f00', 'a100':'#ffe57f', 'a200':'#ffd740', 'a400':'#ffc400', 'a700':'#ffab00'}, 'orange':{50:'#fff3e0', 100:'#ffe0b2', 200:'#ffcc80', 300:'#ffb74d', 400:'#ffa726', 500:'#ff9800', 600:'#fb8c00', 700:'#f57c00', 800:'#ef6c00', 900:'#e65100', 'a100':'#ffd180', 'a200':'#ffab40', 'a400':'#ff9100', 
'a700':'#ff6d00'}, 'deep-orange':{50:'#fbe9e7', 100:'#ffccbc', 200:'#ffab91', 300:'#ff8a65', 400:'#ff7043', 500:'#ff5722', 600:'#f4511e', 700:'#e64a19', 800:'#d84315', 900:'#bf360c', 'a100':'#ff9e80', 'a200':'#ff6e40', 'a400':'#ff3d00', 'a700':'#dd2c00'}, 'brown':{50:'#efebe9', 100:'#d7ccc8', 200:'#bcaaa4', 300:'#a1887f', 400:'#8d6e63', 500:'#795548', 600:'#6d4c41', 700:'#5d4037', 800:'#4e342e', 900:'#3e2723'}, 'grey':{50:'#fafafa', 100:'#f5f5f5', 200:'#eeeeee', 300:'#e0e0e0', 400:'#bdbdbd', 500:'#9e9e9e', 
600:'#757575', 700:'#616161', 800:'#424242', 900:'#212121'}, 'blue-grey':{50:'#eceff1', 100:'#cfd8dc', 200:'#b0bec5', 300:'#90a4ae', 400:'#78909c', 500:'#607d8b', 600:'#546e7a', 700:'#455a64', 800:'#37474f', 900:'#263238', 1E3:'#11171a'}}, hasFashion:function() {
  return !!window.Fashion && !!Fashion.css && Fashion.css.setVariables;
}, setAutoUpdateMeta:function(value) {
  this._autoUpdateMeta = value;
}, getAutoUpdateMeta:function() {
  return this._autoUpdateMeta;
}, getDefaultWeight:function() {
  return this._defaultWeight;
}, setDarkMode:function(value) {
  if (!this.hasFashion()) {
    Ext.Logger.warn('Fashion was not found and is required to set CSS Variables for Material Theme');
    return;
  }
  Fashion.css.setVariables({'dark-mode':value ? 'true' : 'false'});
}, setColors:function(colorsConfig) {
  if (!this.hasFashion()) {
    Ext.Logger.warn('Fashion was not found and is required to set CSS Variables for Material Theme');
    return;
  }
  colorsConfig = Ext.merge({baseWeight:this.getDefaultWeight(), accentWeight:this.getDefaultWeight()}, colorsConfig);
  var baseColor = this._colors[colorsConfig.base], accentColor = this._colors[colorsConfig.accent], obj = {};
  if (baseColor) {
    if (baseColor[colorsConfig.baseWeight]) {
      obj['base-color-name'] = colorsConfig.base;
      if (this.getAutoUpdateMeta()) {
        this.updateMetaThemeColor(colorsConfig.base, colorsConfig.baseWeight);
      }
    } else {
      Ext.Logger.warn('Base color weight: ' + colorsConfig.baseWeight + ' is not a valid weight', this);
    }
  } else {
    if (colorsConfig.base) {
      Ext.Logger.warn('Base color: ' + colorsConfig.base + ' is not a valid material color', this);
    }
  }
  if (accentColor) {
    if (accentColor[colorsConfig.accentWeight]) {
      obj['accent-color-name'] = colorsConfig.accent;
    } else {
      Ext.Logger.warn('Accent color weight: ' + colorsConfig.accentWeight + ' is not a valid weight', this);
    }
  } else {
    if (colorsConfig.accent) {
      Ext.Logger.warn('Accent color: ' + colorsConfig.accent + ' is not a valid material color', this);
    }
  }
  if (colorsConfig.darkMode !== null) {
    obj['dark-mode'] = colorsConfig.darkMode ? 'true' : 'false';
  }
  Fashion.css.setVariables(obj);
}, updateMetaThemeColor:function(colorName, weight) {
  var color = this._colors[colorName], toolbarIsDynamic = Ext.manifest.material.toolbar.dynamic, meta;
  if (!weight) {
    weight = this.getDefaultWeight();
  }
  if (Ext.platformTags.android && Ext.platformTags.chrome && toolbarIsDynamic && color) {
    color = color[weight];
    meta = Ext.query('meta[name\x3d"theme-color"]')[0];
    if (meta) {
      meta.setAttribute('content', color);
    }
  }
}, getColors:function() {
  return this._colors;
}});
if (Ext.platformTags.android && Ext.platformTags.chrome && Ext.manifest.material && Ext.manifest.material.toolbar) {
  var color = Ext.manifest.material.toolbar.color, toolbarIsDynamic = Ext.manifest.material.toolbar.dynamic, head = document.head, meta;
  if (toolbarIsDynamic && Ext.supports.CSSVariables) {
    color = getComputedStyle(document.body).getPropertyValue('--primary-color-md');
    color = color.replace(/ /g, '').replace(/^#(?:\\3)?/, '#');
  }
  if (color) {
    meta = document.createElement('meta');
    meta.setAttribute('name', 'theme-color');
    meta.setAttribute('content', color);
    head.appendChild(meta);
  }
}
Ext.namespace('Ext.theme.is').Material = true;
Ext.theme.name = 'Material';
Ext.namespace('Ext.theme.is')['theme-material-919697f8-c137-4d0c-908d-71b0e3cbe5bb'] = true;
Ext.theme.name = 'theme-material-919697f8-c137-4d0c-908d-71b0e3cbe5bb';
Ext.define('facturaElecWeb.model.model_facturas', {extend:Ext.data.Model, fields:[{name:'codigo'}, {name:'fechaCreacion'}, {name:'documentoCliente'}, {name:'nombreCliente'}, {name:'nitEmpresa'}, {name:'nombreEmpresa'}, {name:'total'}]});
Ext.define('facturaElecWeb.model.model_gestion_cliente', {extend:Ext.data.Model, fields:[{name:'id'}, {name:'tipoDocumento'}, {name:'documento'}, {name:'nombre'}, {name:'pais'}, {name:'ciudad'}, {name:'direccion'}, {name:'telefono'}, {name:'correo'}]});
Ext.define('facturaElecWeb.model.model_gestion_empresa', {extend:Ext.data.Model, fields:[{name:'id'}, {name:'nit'}, {name:'nombre'}, {name:'ciudad'}, {name:'direccion'}, {name:'telefono'}, {name:'email'}]});
Ext.define('facturaElecWeb.model.model_gestion_factura', {extend:Ext.data.Model, fields:[{name:'id'}, {name:'codigo'}, {name:'fechaCreacion'}, {name:'idCliente'}, {name:'nombreCliente'}, {name:'nitEmpresa'}, {name:'nombreEmpresa'}, {name:'idProducto'}, {name:'nombreProducto'}, {name:'cantidad'}, {name:'totalProducto'}, {name:'total'}]});
Ext.define('facturaElecWeb.model.model_gestion_producto', {extend:Ext.data.Model, fields:[{name:'id'}, {name:'codigo'}, {name:'marca'}, {name:'nombre'}, {name:'garantia'}, {name:'precio'}, {name:'descripcion'}, {name:'cantidad'}, {name:'totalProducto'}]});
Ext.define('facturaElecWeb.model.model_gestion_usuarios', {extend:Ext.data.Model, fields:[{name:'id'}, {name:'firstname'}, {name:'lastname'}, {name:'email'}, {name:'password'}, {name:'active'}, {name:'roles'}]});
Ext.define('facturaElecWeb.model.model_info_count', {extend:Ext.data.Model, fields:[{name:'factura'}, {name:'producto'}, {name:'cliente'}, {name:'empresa'}, {name:'usuario'}]});
Ext.define('facturaElecWeb.store.store_factura_productos', {extend:Ext.data.Store, constructor:function(cfg) {
  var me = this;
  cfg = cfg || {};
  me.callParent([Ext.apply({storeId:'store_factura_productos', autoLoad:true, model:'facturaElecWeb.model.model_gestion_producto', proxy:{type:'ajax', api:{read:'facturaController/listarProductos'}, timeout:600000, reader:{type:'json', messageProperty:'message', rootProperty:'data'}, writer:{type:'json', writeAllFields:true, allowSingle:false}, listeners:{onAjaxException:{fn:me.onAjaxOnAjaxException}}}}, cfg)]);
}, onAjaxOnAjaxException:function(ajax) {
  facturaElec.app.showError(proxy, operation, this);
}});
Ext.define('facturaElecWeb.store.store_gestion_all_factura', {extend:Ext.data.Store, constructor:function(cfg) {
  var me = this;
  cfg = cfg || {};
  me.callParent([Ext.apply({storeId:'store_gestion_all_factura', autoLoad:true, model:'facturaElecWeb.model.model_facturas', proxy:{type:'ajax', api:{read:'facturaController/listarFacturas'}, timeout:600000, reader:{type:'json', rootProperty:'data'}}}, cfg)]);
}});
Ext.define('facturaElecWeb.store.store_gestion_all_producto_factura', {extend:Ext.data.Store, constructor:function(cfg) {
  var me = this;
  cfg = cfg || {};
  me.callParent([Ext.apply({storeId:'store_gestion_all_producto_factura', autoLoad:true, model:'facturaElecWeb.model.model_gestion_producto', proxy:{type:'ajax', api:{read:'facturaController/listarProductosFactura'}, timeout:600000, reader:{type:'json', rootProperty:'data'}}}, cfg)]);
}});
Ext.define('facturaElecWeb.store.store_gestion_cliente', {extend:Ext.data.Store, constructor:function(cfg) {
  var me = this;
  cfg = cfg || {};
  me.callParent([Ext.apply({storeId:'store_gestion_cliente', model:'facturaElecWeb.model.model_gestion_cliente', proxy:{type:'ajax', api:{create:'clienteController/agregarCliente', read:'clienteController/listarClientes', update:'clienteController/actualizarCliente', destroy:'clienteController/eliminarCliente'}, timeout:600000, reader:{type:'json', messageProperty:'message', rootProperty:'data'}, writer:{type:'json', writeAllFields:true, allowSingle:false}, listeners:{onAjaxOnAjaxException:{fn:me.onJsonOnAjaxOnAjaxException}}}}, 
  cfg)]);
}, onJsonOnAjaxOnAjaxException:function(json) {
  facturaElec.app.showError(proxy, operation, this);
}});
Ext.define('facturaElecWeb.store.store_gestion_empresa', {extend:Ext.data.Store, constructor:function(cfg) {
  var me = this;
  cfg = cfg || {};
  me.callParent([Ext.apply({storeId:'store_gestion_empresa', autoLoad:true, model:'facturaElecWeb.model.model_gestion_empresa', proxy:{type:'ajax', api:{create:'empresaController/agregarEmpresa', read:'empresaController/listarEmpresas', update:'empresaController/actualizarEmpresa', destroy:'empresaController/eliminarEmpresa'}, timeout:600000, reader:{type:'json', messageProperty:'message', rootProperty:'data'}, writer:{type:'json', writeAllFields:true, allowSingle:false}}, listeners:{onAjaxOnAjaxException:{fn:me.onJsonstoreOnAjaxOnAjaxException}}}, 
  cfg)]);
}, onJsonstoreOnAjaxOnAjaxException:function(jsonstore) {
  facturaElec.app.showError(proxy, operation, this);
}});
Ext.define('facturaElecWeb.store.store_gestion_factura', {extend:Ext.data.Store, constructor:function(cfg) {
  var me = this;
  cfg = cfg || {};
  me.callParent([Ext.apply({storeId:'store_gestion_factura', autoLoad:true, model:'facturaElecWeb.model.model_gestion_factura', proxy:{type:'ajax', api:{read:'facturaController/listarFacturas'}, timeout:600000, reader:{type:'json', messageProperty:'message', rootProperty:'data'}, listeners:{onAjaxOnAjaxException:{fn:me.onAjaxOnAjaxOnAjaxException}}}}, cfg)]);
}, onAjaxOnAjaxOnAjaxException:function(ajax) {
}});
Ext.define('facturaElecWeb.store.store_gestion_producto', {extend:Ext.data.Store, constructor:function(cfg) {
  var me = this;
  cfg = cfg || {};
  me.callParent([Ext.apply({storeId:'store_gestion_producto', model:'facturaElecWeb.model.model_gestion_producto', proxy:{type:'ajax', api:{create:'productoController/agregarProducto', read:'productoController/listarProductos', update:'productoController/actualizarProducto', destroy:'productoController/eliminarProducto'}, timeout:600000, reader:{type:'json', messageProperty:'message', rootProperty:'data'}, writer:{type:'json', writeAllFields:true, allowSingle:false}, listeners:{onAjaxException:{fn:me.onAjaxOnAjaxException}}}}, 
  cfg)]);
}, onAjaxOnAjaxException:function(ajax) {
  facturaElec.app.showError(proxy, operation, this);
}});
Ext.define('facturaElecWeb.store.store_gestion_producto_factura', {extend:Ext.data.Store, constructor:function(cfg) {
  var me = this;
  cfg = cfg || {};
  me.callParent([Ext.apply({storeId:'store_gestion_producto_factura', model:'facturaElecWeb.model.model_gestion_producto', proxy:{type:'memory'}}, cfg)]);
}});
Ext.define('facturaElecWeb.store.store_gestion_usuarios', {extend:Ext.data.Store, constructor:function(cfg) {
  var me = this;
  cfg = cfg || {};
  me.callParent([Ext.apply({storeId:'store_gestion_usuarios', model:'facturaElecWeb.model.model_gestion_usuarios', proxy:{type:'ajax', api:{read:'sesionUsuario/listarUsuarios'}, timeout:60000, reader:{type:'json', rootProperty:'data'}, listeners:{onJsonOnAjaxOnAjaxException:{fn:me.onAjaxOnJsonOnAjaxOnAjaxException}}}}, cfg)]);
}, onAjaxOnJsonOnAjaxOnAjaxException:function(ajax) {
  facturaElec.app.showError(proxy, operation, this);
}});
Ext.define('facturaElecWeb.store.store_info_count', {extend:Ext.data.Store, constructor:function(cfg) {
  var me = this;
  cfg = cfg || {};
  me.callParent([Ext.apply({storeId:'store_info_count', model:'facturaElecWeb.model.model_info_count', proxy:{type:'ajax', api:{read:'informacionController/infoCount'}, reader:{type:'json', rootProperty:'data'}}}, cfg)]);
}});
Ext.define('facturaElecWeb.view.ctn_accountViewModel', {extend:Ext.app.ViewModel, alias:'viewmodel.ctn_account'});
Ext.define('facturaElecWeb.view.ctn_accountViewController', {extend:Ext.app.ViewController, alias:'controller.ctn_account', onCtn_accountInitialize:function(component, eOpts) {
  Ext.Ajax.request({url:'/sesionUsuario/usuario', method:'GET', success:function(response, opts) {
    var user = JSON.parse(response.responseText);
    Ext.ComponentQuery.query('[itemId\x3dfirstname]')[0].setValue(user.data.firstname);
    Ext.ComponentQuery.query('[itemId\x3dlastname]')[0].setValue(user.data.lastname);
    Ext.ComponentQuery.query('[itemId\x3demail]')[0].setValue(user.data.email);
    Ext.ComponentQuery.query('[itemId\x3didUser]')[0].setValue(user.data.id);
    Ext.ComponentQuery.query('[itemId\x3dpassword]')[0].setValue('');
    Ext.getCmp('ctn_account').getViewModel().set('oldEmail', user.data.email);
    Ext.getCmp('ctn_statistics_view').getViewModel().set('filtro', user.data.roles[0].role);
    Ext.getCmp('ctn_statistics_view').fn_find_statistcs(user.data.roles[0].role);
    if (user.data.roles[0].role != 'ADMIN') {
      Ext.getCmp('tbp_menu').items.items[2].hide();
      Ext.getCmp('tbp_menu').items.items[2].tab.hide();
    }
  }, failure:function(response, opts) {
  }});
}});
Ext.define('facturaElecWeb.view.ctn_account', {extend:Ext.Container, alias:'widget.ctn_account', controller:'ctn_account', viewModel:{type:'ctn_account'}, id:'ctn_account', layout:'hbox', items:[{xtype:'container', name:'ctn_form_account', width:'40%', displayed:true, padding:'50 20 0 20', items:[{xtype:'container', name:'ctn_icon_account', layout:{type:'hbox', align:'center', pack:'center'}, items:[{xtype:'image', cls:'image-generic-frm', name:'image_account', src:'https://image.flaticon.com/icons/svg/74/74472.svg'}]}, 
{xtype:'formpanel', id:'frmAccount', name:'frmAccount', layout:{type:'vbox', align:'center', pack:'center'}, items:[{xtype:'textfield', hidden:true, itemId:'idUser', label:'Field', labelCls:'my-text'}, {xtype:'textfield', validators:function(value) {
  if (value.length > 100) {
    return 'El nombre supera el tamao permitido (100)';
  } else {
    if (/^([0-9])*$/.test(value)) {
      return 'El nombre tiene caracteres invalidos.(0-9)';
    } else {
      return true;
    }
  }
}, itemId:'firstname', name:'firstname', width:'70%', label:'Nombre', labelCls:'my-text', required:true, requiredMessage:'El nombre es obligatorio'}, {xtype:'textfield', validators:function(value) {
  if (value.length > 100) {
    return 'El apellido supera el tamao permitido (100)';
  } else {
    if (/^([0-9])*$/.test(value)) {
      return 'El apellido tiene caracteres invalidos.(0-9)';
    } else {
      return true;
    }
  }
}, itemId:'lastname', name:'lastname', width:'70%', label:'Apellido', labelCls:'my-text', required:true, requiredMessage:'El apellido es obligatorio'}, {xtype:'textfield', validators:function(value) {
  if (!Ext.isEmpty(value) && Ext.isEmpty(value.trim())) {
    return 'El campo correo no admite espacios';
  } else {
    if (value.length > 100) {
      return 'El correo supera el tamao permitido (100)';
    } else {
      if (!/^(")?(?:[^\."])(?:(?:[\.])?(?:[\w\-!#$%&'*+\/=?\^_`{|}~]))*\1@(\w[\-\w]*\.){1,5}([A-Za-z]){2,6}$/.test(value)) {
        return 'Correo invalido.(demo@demo.com)';
      } else {
        return true;
      }
    }
  }
}, itemId:'email', name:'email', width:'70%', label:'Correo electronico', labelCls:'my-text', required:true, requiredMessage:'El correo electronico es obligatorio'}, {xtype:'passwordfield', validators:function(value) {
  if (value.length < 8 || value.length > 20) {
    return 'La contrasea debe tener entre 8 y 20 caracteres';
  } else {
    return true;
  }
}, itemId:'password', name:'password', width:'70%', label:'Contrasea', labelCls:'my-text', required:true, requiredMessage:'La contrasea es obligatoria', placeholder:'Ingrese o cambie su contrasea'}, {xtype:'container', name:'ctn_buttons_account', margin:'50 0 0 0', layout:{type:'hbox', align:'center', pack:'center'}, items:[{xtype:'button', handler:function(button, e) {
  Ext.getCmp('ctn_account').fn_cerrar_sesion();
}, cls:'blackIcon', tooltip:'Cerrar sesin', text:'Cerrar sesin'}, {xtype:'button', handler:function(button, e) {
  var form = Ext.getCmp('frmAccount');
  var values = form.getValues();
  var id = Ext.ComponentQuery.query('[itemId\x3didUser]')[0].getValue();
  var oldEmail = Ext.getCmp('ctn_account').getViewModel().get('oldEmail');
  if (form.validate()) {
    Ext.Ajax.request({url:'sesionUsuario/actualizarUsuario', method:'POST', params:{active:values.activo, email:values.email, oldEmail:oldEmail, firstname:values.firstname, id:id, lastname:values.lastname, password:values.password}, success:function(response, opts) {
      var respuesta = JSON.parse(response.responseText);
      if (respuesta.success) {
        Ext.toast('Edicin Exitosa', 1000);
        Ext.getCmp('ctn_account').fn_cerrar_sesion();
      } else {
        Ext.toast(respuesta.message, 1000);
      }
    }, failure:function(response, opts) {
      Ext.toast('Error al llevar a cabo el proceso', 1000);
    }});
  }
}, cls:'blackIcon', tooltip:'Guardar los cambios', text:'Guardar'}]}]}]}, {xtype:'container', cls:'fondoPrincipal', name:'ctn_imagen_account', width:'60%'}], listeners:{initialize:'onCtn_accountInitialize'}, fn_cerrar_sesion:function() {
  Ext.Ajax.request({url:'/logout', method:'GET', success:function(response, opts) {
    Ext.toast('Exito cerrar sesion', 1000);
    window.location.href = '';
  }, failure:function(response, opts) {
    Ext.toast('Error al cerrar sesion', 1000);
  }});
}});
Ext.define('facturaElecWeb.view.ctn_client_viewViewModel', {extend:Ext.app.ViewModel, alias:'viewmodel.ctn_client_view'});
Ext.define('facturaElecWeb.view.ctn_client_viewViewController', {extend:Ext.app.ViewController, alias:'controller.ctn_client_view', onCtn_client_viewInitialize:function(component, eOpts) {
  Ext.getStore('store_gestion_cliente').load();
}});
Ext.define('facturaElecWeb.view.grd_clientViewModel', {extend:Ext.app.ViewModel, alias:'viewmodel.grd_client'});
Ext.define('facturaElecWeb.view.grd_client', {extend:Ext.grid.Grid, alias:'widget.grd_client', viewModel:{type:'grd_client'}, height:'100%', id:'grd_client', width:'100%', scrollable:'vertical', layout:'vbox', store:'store_gestion_cliente', defaultListenerScope:true, columns:[{xtype:'gridcolumn', width:'20%', dataIndex:'documento', text:'Documento'}, {xtype:'gridcolumn', width:'25%', dataIndex:'nombre', text:'Nombre'}, {xtype:'gridcolumn', width:'15%', dataIndex:'ciudad', text:'Ciudad'}, {xtype:'gridcolumn', 
width:'15%', dataIndex:'telefono', text:'Telefono'}, {xtype:'gridcolumn', width:'25%', dataIndex:'correo', text:'Correo'}], listeners:{select:'onGridSelect'}, onGridSelect:function(dataview, selected, eOpts) {
  var filter = selected[0].data.documento;
  Ext.getCmp('ctn_client_view').fn_find_client(filter);
  Ext.getCmp('data_view_client').setStore('store_gestion_cliente');
  Ext.getCmp('ctn_client_view').getViewModel().set('filtro', filter);
}});
Ext.define('facturaElecWeb.view.ctn_client_view', {extend:Ext.Container, alias:'widget.ctn_client_view', controller:'ctn_client_view', viewModel:{type:'ctn_client_view'}, id:'ctn_client_view', layout:'hbox', defaultListenerScope:true, items:[{xtype:'container', flex:2.5, cls:'borde-gestion-info', name:'ctn_info_client', padding:'50 0 50 0', layout:'vbox', items:[{xtype:'container', flex:0.5, name:'ctn_search_client', layout:'center', items:[{xtype:'searchfield', validators:function(value) {
  if (!/^([0-9])*$/.test(value)) {
    return 'El documento debe ser  un nmero entero';
  } else {
    if (value < 0) {
      return 'La cantidad de caracteres ingresada es invlida';
    } else {
      return true;
    }
  }
}, itemId:'search_field_client', name:'search_field_cliente', width:'70%', labelCls:'my-text', placeholder:'Buscar por documento', listeners:{keyup:'onSearch_field_clientKeyup'}}]}, {xtype:'dataview', id:'data_view_client', padding:'0 0 0 30', itemTpl:['\x3cdiv class\x3d"table-generic"\x3e', '    \x3ctable\x3e', '', '        \x3ctbody \x3e', '            \x3ctr\x3e', '', '                \x3cth class\x3d"row-generic"\x3eTipo de documento:\x3c/th\x3e', '', '                \x3ctd class\x3d"row-generic"\x3e{tipoDocumento}\x3c/td\x3e', 
'', '            \x3c/tr\x3e', '            \x3ctr\x3e', '', '                \x3cth class\x3d"row-generic"\x3eDocumento:\x3c/th\x3e', '', '                \x3ctd class\x3d"row-generic"\x3e{documento}\x3c/td\x3e', '', '            \x3c/tr\x3e', '            \x3ctr\x3e', '', '                \x3cth class\x3d"row-generic"\x3eNombre:\x3c/th\x3e', '', '                \x3ctd class\x3d"row-generic"\x3e{nombre}\x3c/td\x3e', '', '            \x3c/tr\x3e', '            \x3ctr\x3e', '', '                \x3cth class\x3d"row-generic"\x3ePais:\x3c/th\x3e', 
'', '                \x3ctd class\x3d"row-generic"\x3e{pais}\x3c/td\x3e', '', '            \x3c/tr\x3e', '            \x3ctr\x3e', '', '                \x3cth class\x3d"row-generic"\x3eCiudad:\x3c/th\x3e', '', '                \x3ctd class\x3d"row-generic"\x3e{ciudad}\x3c/td\x3e', '', '            \x3c/tr\x3e', '            \x3ctr\x3e', '', '                \x3cth class\x3d"row-generic"\x3eDireccin:\x3c/th\x3e', '', '                \x3ctd class\x3d"row-generic"\x3e{direccion}\x3c/td\x3e', '', '            \x3c/tr\x3e', 
'            \x3ctr\x3e', '', '                \x3cth class\x3d"row-generic"\x3eTelefono:\x3c/th\x3e', '', '                \x3ctd class\x3d"row-generic"\x3e{telefono}\x3c/td\x3e', '', '            \x3c/tr\x3e', '            \x3ctr\x3e', '', '                \x3cth class\x3d"row-generic"\x3eCorreo:\x3c/th\x3e', '', '                \x3ctd class\x3d"row-generic"\x3e{correo}\x3c/td\x3e', '', '            \x3c/tr\x3e', '        \x3c/tbody\x3e', '    \x3c/table\x3e', '\x3c/div\x3e']}, {xtype:'container', 
flex:0.8, name:'ctn_bottons_client', padding:5, layout:{type:'hbox', align:'center', pack:'center'}, items:[{xtype:'button', handler:function(button, e) {
  Ext.getCmp('ctn_client_view').fn_find_client(null);
  Ext.getCmp('data_view_client').setStore('');
  Ext.ComponentQuery.query('[itemId\x3dsearch_field_client]')[0].setValue('');
  Ext.getCmp('ctn_client_view').getViewModel().set('filtro', null);
}, cls:'color-buttons', height:50, id:'btn_refresh_client', ui:'round', width:50, margin:'0 5 0 0', tooltip:'Refrescar', iconCls:'x-fa fa-refresh'}, {xtype:'button', handler:function(button, e) {
  var filter = Ext.getCmp('ctn_client_view').getViewModel().get('filtro');
  if (filter != null) {
    Ext.Msg.show({title:'Confirmacin', message:'Esta seguro de eliminar el cliente con documento ' + filter + '?', width:300, closable:false, buttons:[{text:'No', itemId:'no'}, {text:'Si', itemId:'yes'}], multiline:false, fn:function(buttonValue, inputText, showConfig) {
      if (buttonValue === 'yes') {
        Ext.Ajax.request({url:'clienteController/eliminarCliente?documento\x3d' + filter, method:'GET', success:function(response, opts) {
          Ext.getCmp('ctn_client_view').fn_find_client(null);
          Ext.getCmp('data_view_client').setStore('');
          Ext.getCmp('ctn_client_view').getViewModel().set('filtro', null);
          Ext.ComponentQuery.query('[itemId\x3dsearch_field_client]')[0].setValue('');
          var info = Ext.getCmp('ctn_statistics_view').getViewModel().get('filtro');
          Ext.getCmp('ctn_statistics_view').fn_find_statistcs(info);
          Ext.toast('Exito al eliminar', 1000);
        }, failure:function(response, opts) {
          Ext.toast('Error al llevar a cabo el proceso, El cliente esta vinculado a una factura', 1000);
        }});
      } else {
        this.close();
      }
    }, icon:Ext.Msg.QUESTION});
  } else {
    Ext.toast('Seleccione un cliente', 1000);
  }
}, cls:'color-buttons', height:50, name:'btn_delete_client', ui:'round', width:50, margin:'0 5 0 0', tooltip:'Eliminar cliente', iconCls:'x-fa fa-trash blackIcon'}, {xtype:'button', handler:function(button, e) {
  var filter = Ext.getCmp('ctn_client_view').getViewModel().get('filtro');
  if (filter != null) {
    var vtn = Ext.create('widget.vtn_generar_cliente', {title:' EDITAR CLIENTE !'}).show();
    var store = Ext.getStore('store_gestion_cliente');
    var record = store.findRecord('documento', filter, 0, false, true, true);
    var form = Ext.getCmp('frm_clientes');
    form.setRecord(record);
  } else {
    Ext.toast('Seleccione un cliente', 1000);
  }
}, cls:'color-buttons', height:50, name:'btn_edit_client', ui:'round', width:50, margin:'0 5 0 0', tooltip:'Editar cliente', iconCls:'x-fa fa-pencil-square-o blackIcon'}, {xtype:'button', handler:function(button, e) {
  var vtn = Ext.create('widget.vtn_generar_cliente', {title:' NUEVO CLIENTE !'}).show();
}, cls:'color-buttons', height:50, name:'btn_add_client', ui:'round', width:50, tooltip:'Crear un nuevo cliente', iconCls:'x-fa fa-plus blackIcon'}]}]}, {xtype:'container', flex:4.5, name:'ctn_grid_client', padding:'30 30 0 30', items:[{xtype:'container', height:'100%', name:'ctn_grid_medium_ client', width:'100%', layout:{type:'vbox', align:'center', pack:'center'}, items:[{xtype:'container', height:'70%', name:'ctn_grid_internal_client', width:'100%', items:[{xtype:'grd_client', itemId:'grd_client_view'}]}]}]}], 
listeners:{initialize:{fn:'onCtn_client_viewInitialize', scope:'controller'}}, onSearch_field_clientKeyup:function(textfield, e, eOpts) {
  var filter = textfield.getValue();
  if (e.event.keyCode == 13) {
    Ext.getCmp('ctn_client_view').fn_find_client(filter);
    Ext.getCmp('data_view_client').setStore('store_gestion_cliente');
    Ext.getCmp('ctn_client_view').getViewModel().set('filtro', filter);
  }
  if (!textfield.getValue()) {
    Ext.getCmp('ctn_client_view').fn_find_client(null);
    Ext.getCmp('data_view_client').setStore('');
  }
}, fn_find_client:function(filter) {
  var storeClient = Ext.getStore('store_gestion_cliente');
  storeClient.proxy.extraParams = {filtro:filter};
  storeClient.load({params:{filtro:filter}, callback:function(records, operation, success) {
    if (success) {
      var noAlmacenado = false;
      var total = storeClient.totalCount;
      if (total === 0) {
        Ext.getCmp('data_view_client').setStore('');
        Ext.ComponentQuery.query('[itemId\x3dsearch_field_client]')[0].setValue('');
        Ext.getCmp('ctn_client_view').getViewModel().set('filtro', null);
        Ext.toast('No hay resultados para la bsqueda', 1000);
      }
    }
  }});
}});
Ext.define('facturaElecWeb.view.ctn_company_viewViewModel', {extend:Ext.app.ViewModel, alias:'viewmodel.ctn_company_view'});
Ext.define('facturaElecWeb.view.ctn_company_viewViewController', {extend:Ext.app.ViewController, alias:'controller.ctn_company_view', onCtn_company_viewInitialize:function(component, eOpts) {
  Ext.getStore('store_gestion_empresa').load();
}});
Ext.define('facturaElecWeb.view.grd_companyViewModel', {extend:Ext.app.ViewModel, alias:'viewmodel.grd_company'});
Ext.define('facturaElecWeb.view.grd_company', {extend:Ext.grid.Grid, alias:'widget.grd_company', viewModel:{type:'grd_company'}, height:'100%', id:'grd_company', width:'100%', layout:'vbox', store:'store_gestion_empresa', defaultListenerScope:true, columns:[{xtype:'gridcolumn', width:'20%', dataIndex:'nit', text:'Nit'}, {xtype:'gridcolumn', width:'30%', dataIndex:'nombre', text:'Nombre'}, {xtype:'gridcolumn', width:'20%', dataIndex:'telefono', text:'Telefono'}, {xtype:'gridcolumn', width:'30%', dataIndex:'email', 
text:'E-mail'}], listeners:{select:'onGridSelect'}, onGridSelect:function(dataview, selected, eOpts) {
  var filter = selected[0].data.nit;
  Ext.getCmp('ctn_company_view').fn_find_company(filter);
  Ext.getCmp('data_view_company').setStore('store_gestion_empresa');
  Ext.getCmp('ctn_company_view').getViewModel().set('filtro', filter);
}});
Ext.define('facturaElecWeb.view.ctn_company_view', {extend:Ext.Container, alias:'widget.ctn_company_view', controller:'ctn_company_view', viewModel:{type:'ctn_company_view'}, id:'ctn_company_view', layout:'hbox', defaultListenerScope:true, items:[{xtype:'container', flex:2.5, cls:'borde-gestion-info', name:'ctn_info_company', padding:'50 0 50 0', layout:'vbox', items:[{xtype:'container', flex:0.5, name:'ctn_search_company', layout:'center', items:[{xtype:'searchfield', validators:function(value) {
  if (!/^([0-9])*$/.test(value)) {
    return 'El nit debe ser  un nmero entero';
  } else {
    if (value < 0) {
      return 'La cantidad de caracteres ingresada es invlida';
    } else {
      return true;
    }
  }
}, itemId:'search_field_company', name:'search_field_company', width:'70%', labelCls:'my-text', placeholder:'Buscar por nit', listeners:{keyup:'onSearch_field_companyKeyup'}}]}, {xtype:'dataview', id:'data_view_company', padding:'0 0 0 30', itemTpl:['\x3cdiv class\x3d"table-generic"\x3e', '    \x3ctable\x3e', '', '        \x3ctbody \x3e', '            \x3ctr\x3e', '', '                \x3cth class\x3d"row-generic"\x3eNit:\x3c/th\x3e', '', '                \x3ctd class\x3d"row-generic"\x3e{nit}\x3c/td\x3e', 
'', '            \x3c/tr\x3e', '            \x3ctr\x3e', '', '                \x3cth class\x3d"row-generic"\x3eNombre:\x3c/th\x3e', '', '                \x3ctd class\x3d"row-generic"\x3e{nombre}\x3c/td\x3e', '', '            \x3c/tr\x3e', '            \x3ctr\x3e', '', '                \x3cth class\x3d"row-generic"\x3eCiudad:\x3c/th\x3e', '', '                \x3ctd class\x3d"row-generic"\x3e{ciudad}\x3c/td\x3e', '', '            \x3c/tr\x3e', '            \x3ctr\x3e', '', '                \x3cth class\x3d"row-generic"\x3eDireccin:\x3c/th\x3e', 
'', '                \x3ctd class\x3d"row-generic"\x3e{direccion}\x3c/td\x3e', '', '            \x3c/tr\x3e', '            \x3ctr\x3e', '', '                \x3cth class\x3d"row-generic"\x3eTelefono:\x3c/th\x3e', '', '                \x3ctd class\x3d"row-generic"\x3e{telefono}\x3c/td\x3e', '', '            \x3c/tr\x3e', '            \x3ctr\x3e', '', '                \x3cth class\x3d"row-generic"\x3eCorreo:\x3c/th\x3e', '', '                \x3ctd class\x3d"row-generic"\x3e{email}\x3c/td\x3e', '', 
'            \x3c/tr\x3e', '', '', '        \x3c/tbody\x3e', '    \x3c/table\x3e', '\x3c/div\x3e']}, {xtype:'container', flex:0.8, name:'ctn_bottons_company', padding:5, layout:{type:'hbox', align:'center', pack:'center'}, items:[{xtype:'button', handler:function(button, e) {
  Ext.getCmp('ctn_company_view').fn_find_company(null);
  Ext.getCmp('data_view_company').setStore('');
  Ext.getCmp('ctn_company_view').getViewModel().set('filtro', null);
  Ext.ComponentQuery.query('[itemId\x3dsearch_field_company]')[0].setValue('');
}, cls:'color-buttons', height:50, id:'btn_refresh_company', ui:'round', width:50, margin:'0 5 0 0', iconCls:'x-fa fa-refresh blackIcon'}, {xtype:'button', handler:function(button, e) {
  var filter = Ext.getCmp('ctn_company_view').getViewModel().get('filtro');
  if (filter != null) {
    Ext.Msg.show({title:'Confirmacin', message:'Esta seguro de eliminar la empresa con nit ' + filter + '?', width:300, closable:false, buttons:[{text:'No', itemId:'no'}, {text:'Si', itemId:'yes'}], multiline:false, fn:function(buttonValue, inputText, showConfig) {
      if (buttonValue === 'yes') {
        Ext.Ajax.request({url:'empresaController/eliminarEmpresa?nit\x3d' + filter, method:'GET', success:function(response, opts) {
          Ext.getCmp('ctn_company_view').fn_find_company(null);
          Ext.getCmp('data_view_company').setStore('');
          Ext.getCmp('ctn_company_view').getViewModel().set('filtro', null);
          Ext.ComponentQuery.query('[itemId\x3dsearch_field_company]')[0].setValue('');
          var info = Ext.getCmp('ctn_statistics_view').getViewModel().get('filtro');
          Ext.getCmp('ctn_statistics_view').fn_find_statistcs(info);
          Ext.toast('Exito al eliminar', 1000);
        }, failure:function(response, opts) {
          Ext.toast('Error al llevar a cabo el proceso, La empresa esta vinculada a una factura', 1000);
        }});
      } else {
        this.close();
      }
    }, icon:Ext.Msg.QUESTION});
  } else {
    Ext.toast('Seleccione una empresa', 1000);
  }
}, cls:'color-buttons', height:50, name:'btn_delete_company', ui:'round', width:50, margin:'0 5 0 0', iconCls:'x-fa fa-trash blackIcon'}, {xtype:'button', handler:function(button, e) {
  var filter = Ext.getCmp('ctn_company_view').getViewModel().get('filtro');
  if (filter != null) {
    var vtn = Ext.create('widget.vtn_generar_empresa', {title:' EDITAR EMPRESA !'}).show();
    var store = Ext.getStore('store_gestion_empresa');
    var record = store.findRecord('nit', filter, 0, false, true, true);
    var form = Ext.getCmp('frm_empresas');
    form.setRecord(record);
  } else {
    Ext.toast('Seleccione una empresa', 1000);
  }
}, cls:'color-buttons', height:50, name:'btn_edit_company', ui:'round', width:50, margin:'0 5 0 0', iconCls:'x-fa fa-pencil-square-o blackIcon'}, {xtype:'button', handler:function(button, e) {
  var vtn = Ext.create('widget.vtn_generar_empresa', {title:' NUEVA EMPRESA !'}).show();
  window.nombreEmpresaEditar = '';
}, cls:'color-buttons', height:50, name:'btn_add_company', ui:'round', width:50, iconCls:'x-fa fa-plus blackIcon'}]}]}, {xtype:'container', flex:4.5, name:'ctn_grid_company', padding:'30 30 0 30', items:[{xtype:'container', height:'100%', name:'ctn_grid_medium_company', width:'100%', layout:{type:'vbox', align:'center', pack:'center'}, items:[{xtype:'container', height:'70%', name:'ctn_grid_internal_company', width:'100%', items:[{xtype:'grd_company', itemId:'grd_company_view'}]}]}]}], listeners:{initialize:{fn:'onCtn_company_viewInitialize', 
scope:'controller'}}, onSearch_field_companyKeyup:function(textfield, e, eOpts) {
  var filter = textfield.getValue();
  if (e.event.keyCode == 13) {
    Ext.getCmp('ctn_company_view').fn_find_company(filter);
    Ext.getCmp('data_view_company').setStore('store_gestion_empresa');
    Ext.getCmp('ctn_company_view').getViewModel().set('filtro', filter);
  }
  if (!textfield.getValue()) {
    Ext.getCmp('ctn_company_view').fn_find_company(null);
    Ext.getCmp('data_view_company').setStore('');
  }
}, fn_find_company:function(filter) {
  var storeCompany = Ext.getStore('store_gestion_empresa');
  storeCompany.proxy.extraParams = {filtro:filter};
  storeCompany.load({params:{filtro:filter}, callback:function(records, operation, success) {
    if (success) {
      var noAlmacenado = false;
      var total = storeCompany.totalCount;
      if (total === 0) {
        Ext.getCmp('data_view_company').setStore('');
        Ext.getCmp('ctn_company_view').getViewModel().set('filtro', null);
        Ext.ComponentQuery.query('[itemId\x3dsearch_field_company]')[0].setValue('');
        Ext.toast('No hay resultados para la bsqueda', 1000);
      }
    }
  }});
}});
Ext.define('facturaElecWeb.view.ctn_invoice_viewViewModel', {extend:Ext.app.ViewModel, alias:'viewmodel.ctn_invoice_view'});
Ext.define('facturaElecWeb.view.grd_invoiceViewModel', {extend:Ext.app.ViewModel, alias:'viewmodel.grd_invoice'});
Ext.define('facturaElecWeb.view.grd_invoice', {extend:Ext.grid.Grid, alias:'widget.grd_invoice', viewModel:{type:'grd_invoice'}, height:'100%', id:'grd_invoice', width:'100%', scrollable:'vertical', layout:'vbox', store:'store_gestion_all_factura', defaultListenerScope:true, columns:[{xtype:'gridcolumn', width:'20%', dataIndex:'codigo', text:'Codigo'}, {xtype:'gridcolumn', width:'20%', dataIndex:'fechaCreacion', formatter:'date("Y-m-d")', text:'Fecha'}, {xtype:'gridcolumn', width:'20%', dataIndex:'nombreCliente', 
text:'Cliente'}, {xtype:'gridcolumn', width:'20%', dataIndex:'nombreEmpresa', text:'Empresa'}, {xtype:'numbercolumn', width:'20%', dataIndex:'total', text:'Total'}], listeners:{select:'onGridSelect'}, onGridSelect:function(dataview, selected, eOpts) {
  var filter = selected[0].data.codigo;
  Ext.getCmp('ctn_invoice_view').fn_find_invoice(filter);
  Ext.getCmp('ctn_invoice_view').fn_find_product_invoice(filter);
  Ext.getCmp('data_view_invoice').setStore('store_gestion_all_factura');
  Ext.getCmp('ctn_invoice_view').getViewModel().set('filtro', filter);
}});
Ext.define('facturaElecWeb.view.ctn_invoice_view', {extend:Ext.Container, alias:'widget.ctn_invoice_view', viewModel:{type:'ctn_invoice_view'}, id:'ctn_invoice_view', layout:'hbox', defaultListenerScope:true, items:[{xtype:'container', flex:2.5, cls:'borde-gestion-info', name:'ctn_info_invoice', padding:'10 0 0 0', layout:'vbox', items:[{xtype:'container', flex:0.5, name:'ctn_search_invoice', layout:'center', items:[{xtype:'searchfield', validators:function(value) {
  if (!/^([0-9])*$/.test(value)) {
    return 'El codigo debe ser  un nmero entero';
  } else {
    if (value < 0) {
      return 'La cantidad de caracteres ingresada es invlida';
    } else {
      return true;
    }
  }
}, itemId:'search_field_invoice', name:'search_field_invoice', width:'70%', labelCls:'my-text', placeholder:'Buscar por codigo', listeners:{keyup:'onSearch_field_invoiceKeyup'}}]}, {xtype:'container', name:'ctn_info_invoice_full', scrollable:'vertical', items:[{xtype:'dataview', id:'data_view_invoice', margin:'0 0 10 0', padding:'0 0 0 30', itemTpl:['\x3cdiv class\x3d"table-generic"\x3e', '    \x3ctable\x3e', '', '        \x3ctbody \x3e', '            \x3ctr\x3e', '', '                \x3cth class\x3d"row-generic"\x3eCodigo:\x3c/th\x3e', 
'', '                \x3ctd class\x3d"row-generic"\x3e{codigo}\x3c/td\x3e', '', '            \x3c/tr\x3e', '            \x3ctr\x3e', '', '                \x3cth class\x3d"row-generic"\x3eFecha de creacin:\x3c/th\x3e', '', '                \x3ctd class\x3d"row-generic"\x3e{fechaCreacion}\x3c/td\x3e', '', '            \x3c/tr\x3e', '            \x3ctr\x3e', '', '                \x3cth class\x3d"row-generic"\x3eDocumento Cliente:\x3c/th\x3e', '', '                \x3ctd class\x3d"row-generic"\x3e{documentoCliente}\x3c/td\x3e', 
'', '            \x3c/tr\x3e', '            \x3ctr\x3e', '', '                \x3cth class\x3d"row-generic"\x3eNombre del cliente:\x3c/th\x3e', '', '                \x3ctd class\x3d"row-generic"\x3e{nombreCliente}\x3c/td\x3e', '', '            \x3c/tr\x3e', '            \x3ctr\x3e', '', '                \x3cth class\x3d"row-generic"\x3eNit Empresa:\x3c/th\x3e', '', '                \x3ctd class\x3d"row-generic"\x3e{nitEmpresa}\x3c/td\x3e', '', '            \x3c/tr\x3e', '            \x3ctr\x3e', 
'', '                \x3cth class\x3d"row-generic"\x3eNombre de la empresa:\x3c/th\x3e', '', '                \x3ctd class\x3d"row-generic"\x3e{nombreEmpresa}\x3c/td\x3e', '', '            \x3c/tr\x3e', '            \x3ctr\x3e', '', '                \x3cth class\x3d"row-generic"\x3eTotal:\x3c/th\x3e', '', '                \x3ctd class\x3d"row-generic"\x3e$ {total}\x3c/td\x3e', '', '            \x3c/tr\x3e', '        \x3c/tbody\x3e', '    \x3c/table\x3e', '\x3c/div\x3e']}, {xtype:'grid', height:'100%', 
hidden:true, id:'grd_view_product_invoice', width:'100%', store:'store_gestion_all_producto_factura', title:'                      Productos', columns:[{xtype:'gridcolumn', width:'25%', dataIndex:'codigo', text:'Codigo'}, {xtype:'gridcolumn', width:'25%', dataIndex:'nombre', text:'Nombre'}, {xtype:'gridcolumn', width:'25%', dataIndex:'marca', text:'Marca'}, {xtype:'numbercolumn', width:'25%', dataIndex:'precio', text:'Precio'}]}]}, {xtype:'container', flex:0.8, name:'ctn_buttons_invoice', padding:5, 
layout:{type:'hbox', align:'center', pack:'center'}, items:[{xtype:'button', handler:function(button, e) {
  debugger;
  Ext.getCmp('ctn_invoice_view').fn_find_invoice(null);
  Ext.getCmp('data_view_invoice').setStore('');
  Ext.getCmp('grd_view_product_invoice').setHidden(true);
  Ext.ComponentQuery.query('[itemId\x3dsearch_field_invoice]')[0].setValue('');
  Ext.getCmp('ctn_invoice_view').getViewModel().set('filtro', null);
}, cls:'color-buttons', height:50, id:'btn_refresh_invoice', ui:'round', width:50, margin:'0 5 0 0', iconCls:'x-fa fa-refresh blackIcon'}, {xtype:'button', handler:function(button, e) {
  var filter = Ext.getCmp('ctn_invoice_view').getViewModel().get('filtro');
  if (filter != null) {
    Ext.Msg.show({title:'Confirmacin', message:'Esta seguro de eliminar la factura con codigo ' + filter + '?', width:300, closable:false, buttons:[{text:'No', itemId:'no'}, {text:'Si', itemId:'yes'}], multiline:false, fn:function(buttonValue, inputText, showConfig) {
      if (buttonValue === 'yes') {
        Ext.Ajax.request({url:'facturaController/eliminarFactura?codigo\x3d' + filter, method:'GET', success:function(response, opts) {
          Ext.getCmp('ctn_invoice_view').fn_find_invoice(null);
          Ext.getCmp('data_view_invoice').setStore('');
          Ext.getCmp('grd_view_product_invoice').setHidden(true);
          Ext.getCmp('ctn_invoice_view').getViewModel().set('filtro', null);
          Ext.ComponentQuery.query('[itemId\x3dsearch_field_invoice]')[0].setValue('');
          var info = Ext.getCmp('ctn_statistics_view').getViewModel().get('filtro');
          Ext.getCmp('ctn_statistics_view').fn_find_statistcs(info);
          Ext.toast('Exito al eliminar', 1000);
        }, failure:function(response, opts) {
          Ext.toast('Error al llevar a cabo el proceso, El cliente esta vinculado a una factura', 1000);
        }});
      } else {
        this.close();
      }
    }, icon:Ext.Msg.QUESTION});
  } else {
    Ext.toast('Seleccione una factura', 1000);
  }
}, cls:'color-buttons', height:50, name:'btn_delete_invoice', ui:'round', width:50, margin:'0 5 0 0', iconCls:'x-fa fa-trash blackIcon'}, {xtype:'button', handler:function(button, e) {
  var filter = Ext.getCmp('ctn_invoice_view').getViewModel().get('filtro');
  if (filter != null) {
    Ext.getStore('store_gestion_producto_factura').data.clear();
    var vtn = Ext.create('widget.vtn_generar_factura', {title:' EDITAR FACTURA !'}).show();
    Ext.getCmp('vtn_generar_factura').getViewModel().set('inhabilitarCodigo', false);
    var store = Ext.getStore('store_gestion_all_factura');
    var record = store.findRecord('codigo', filter, 0, false, true, true);
    var form = Ext.getCmp('frm_factura');
    form.setRecord(record);
    var storeProductosFactura = Ext.getStore('store_factura_productos');
    storeProductosFactura.proxy.extraParams = {codigo:filter};
    storeProductosFactura.load({params:{codigo:filter}, callback:function(records, operation, success) {
      if (success) {
        for (var i = 0; i < records.length; i++) {
          Ext.getStore('store_gestion_producto_factura').add(records[i].data);
        }
        var noAlmacenado = false;
        var total = storeProductosFactura.totalCount;
        if (total === 0) {
          Ext.toast('No hay resultados para la bsqueda', 1000);
        }
      }
    }});
  } else {
    Ext.toast('Seleccione una factura', 1000);
  }
}, cls:'color-buttons', height:50, name:'btn_edit_invoice', ui:'round', width:50, margin:'0 5 0 0', iconCls:'x-fa fa-pencil-square-o blackIcon'}, {xtype:'button', handler:function(button, e) {
  Ext.getStore('store_gestion_producto_factura').data.clear();
  var vtn = Ext.create('widget.vtn_generar_factura', {title:' NUEVA FACTURA !'}).show();
  Ext.getCmp('vtn_generar_factura').getViewModel().set('inhabilitarCodigo', true);
}, cls:'color-buttons', height:50, name:'btn_add_invoice', ui:'round', width:50, margin:'0 5 0 0', iconCls:'x-fa fa-plus blackIcon'}, {xtype:'button', handler:function(button, e) {
  var filter = Ext.getCmp('ctn_invoice_view').getViewModel().get('filtro');
  if (filter != null) {
    Ext.getStore('store_gestion_producto_factura').data.clear();
    var storeAllFactura = Ext.getStore('store_gestion_all_factura');
    var storeProductosFactura = Ext.getStore('store_factura_productos');
    storeProductosFactura.proxy.extraParams = {codigo:filter};
    storeProductosFactura.load({params:{codigo:filter}, callback:function(records, operation, success) {
      if (success) {
        for (var i = 0; i < records.length; i++) {
          Ext.getStore('store_gestion_producto_factura').add(records[i].data);
        }
        var storeAllProductoFactura = Ext.getStore('store_gestion_producto_factura');
        var pdf = new jsPDF;
        pdf.text(80, 10, 'Factura electronica');
        pdf.text(170, 10, 'Version 001');
        pdf.text(20, 40, 'Codigo');
        pdf.text(90, 40, '' + storeAllFactura.data.items[0].data.codigo);
        pdf.text(20, 50, 'Fecha');
        pdf.text(90, 50, '' + storeAllFactura.data.items[0].data.fechaCreacion);
        pdf.text(20, 60, 'Identificacin del cliente');
        pdf.text(90, 60, '' + storeAllFactura.data.items[0].data.documentoCliente);
        pdf.text(20, 70, 'Nombre del cliente');
        pdf.text(90, 70, '' + storeAllFactura.data.items[0].data.nombreCliente);
        pdf.text(20, 80, 'Nit de la empresa');
        pdf.text(90, 80, '' + storeAllFactura.data.items[0].data.nitEmpresa);
        pdf.text(20, 90, 'Nombre de la empresa');
        pdf.text(90, 90, '' + storeAllFactura.data.items[0].data.nombreEmpresa);
        pdf.text(20, 100, 'Total');
        pdf.text(90, 100, '$ ' + storeAllFactura.data.items[0].data.total);
        pdf.text(90, 120, 'Productos');
        pdf.text(5, 130, 'Codigo');
        pdf.text(45, 130, 'Nombre');
        pdf.text(95, 130, 'Precio');
        pdf.text(140, 130, 'Cantidad');
        pdf.text(170, 130, 'Total');
        var y = 140;
        for (var i = 0; i < storeAllProductoFactura.data.items.length; i++) {
          y = y + 10;
          pdf.text(5, y, '' + storeAllProductoFactura.data.items[i].data.codigo);
          pdf.text(45, y, '' + storeAllProductoFactura.data.items[i].data.nombre);
          pdf.text(95, y, '$ ' + storeAllProductoFactura.data.items[i].data.precio);
          pdf.text(140, y, '' + storeAllProductoFactura.data.items[i].data.cantidad);
          pdf.text(170, y, '$ ' + storeAllProductoFactura.data.items[i].data.totalProducto);
        }
        pdf.save(filter + '.pdf');
        Ext.toast('Exito al generar la factura', 1000);
        Ext.getCmp('ctn_invoice_view').fn_find_invoice(null);
        Ext.getCmp('data_view_invoice').setStore('');
        Ext.getCmp('grd_view_product_invoice').setHidden(true);
        Ext.ComponentQuery.query('[itemId\x3dsearch_field_invoice]')[0].setValue('');
        Ext.getCmp('ctn_invoice_view').getViewModel().set('filtro', null);
        var noAlmacenado = false;
        var total = storeProductosFactura.totalCount;
        if (total === 0) {
          Ext.toast('No hay resultados para la bsqueda', 1000);
        }
      }
    }});
  } else {
    Ext.toast('Seleccione una factura', 1000);
  }
}, cls:'color-buttons', height:50, name:'btn_download_invoice', ui:'round', width:50, iconCls:'x-fa fa-download blackIcon'}]}]}, {xtype:'container', flex:4.5, name:'ctn_grid_invoice', padding:'30 30 0 30', items:[{xtype:'container', height:'100%', name:'ctn_grid_medium_invoice', width:'100%', layout:{type:'vbox', align:'center', pack:'center'}, items:[{xtype:'container', height:'70%', name:'ctn_grid_internal_invoice', width:'100%', items:[{xtype:'grd_invoice', itemId:'grd_invoice_view'}]}]}]}], onSearch_field_invoiceKeyup:function(textfield, 
e, eOpts) {
  var filter = textfield.getValue();
  if (e.event.keyCode == 13) {
    Ext.getCmp('ctn_invoice_view').fn_find_invoice(filter);
    Ext.getCmp('ctn_invoice_view').fn_find_product_invoice(filter);
    Ext.getCmp('data_view_invoice').setStore('store_gestion_all_factura');
    Ext.getCmp('ctn_invoice_view').getViewModel().set('filtro', filter);
  }
  if (!textfield.getValue()) {
    Ext.getCmp('ctn_invoice_view').fn_find_invoice(null);
    Ext.getCmp('data_view_invoice').setStore('');
    Ext.getCmp('grd_view_product_invoice').setHidden(true);
  }
}, fn_find_invoice:function(filter) {
  var storeInvoice = Ext.getStore('store_gestion_all_factura');
  storeInvoice.proxy.extraParams = {filtro:filter};
  storeInvoice.load({params:{filtro:filter}, callback:function(records, operation, success) {
    if (success) {
      var noAlmacenado = false;
      var total = storeInvoice.totalCount;
      if (total === 0) {
        Ext.getCmp('grd_view_product_invoice').setHidden(true);
        Ext.getCmp('data_view_invoice').setStore('');
        Ext.getCmp('grd_view_product_invoice').setHidden(true);
        Ext.ComponentQuery.query('[itemId\x3dsearch_field_invoice]')[0].setValue('');
        Ext.getCmp('ctn_invoice_view').getViewModel().set('filtro', null);
        Ext.toast('No hay resultados para la bsqueda', 1000);
      }
      if (filter != null) {
        Ext.getCmp('grd_view_product_invoice').setHidden(false);
      }
    }
  }});
}, fn_find_product_invoice:function(filter) {
  var storeProductInvoice = Ext.getStore('store_gestion_all_producto_factura');
  storeProductInvoice.proxy.extraParams = {filtro:filter};
  storeProductInvoice.load({params:{filtro:filter}, callback:function(records, operation, success) {
    if (success) {
      var noAlmacenado = false;
      var total = storeProductInvoice.totalCount;
      if (total === 0) {
        Ext.toast('No hay resultados para la bsqueda', 1000);
      }
    }
  }});
}});
Ext.define('facturaElecWeb.view.ctn_product_viewViewModel', {extend:Ext.app.ViewModel, alias:'viewmodel.ctn_product_view'});
Ext.define('facturaElecWeb.view.ctn_product_viewViewController', {extend:Ext.app.ViewController, alias:'controller.ctn_product_view', onCtn_product_viewInitialize:function(component, eOpts) {
  Ext.getStore('store_gestion_producto').load();
}});
Ext.define('facturaElecWeb.view.grd_productViewModel', {extend:Ext.app.ViewModel, alias:'viewmodel.grd_product'});
Ext.define('facturaElecWeb.view.grd_product', {extend:Ext.grid.Grid, alias:'widget.grd_product', viewModel:{type:'grd_product'}, height:'100%', itemId:'grd_product', width:'100%', scrollable:'vertical', layout:'vbox', store:'store_gestion_producto', defaultListenerScope:true, columns:[{xtype:'gridcolumn', width:'20%', align:'center', dataIndex:'codigo', text:'Codigo'}, {xtype:'gridcolumn', width:'30%', align:'center', dataIndex:'nombre', text:'Nombre'}, {xtype:'gridcolumn', width:'20%', align:'center', 
dataIndex:'marca', text:'Marca'}, {xtype:'numbercolumn', width:'30%', align:'center', dataIndex:'precio', text:'Precio'}], listeners:{select:'onGridSelect'}, onGridSelect:function(dataview, selected, eOpts) {
  var filter = selected[0].data.codigo;
  if (Ext.getCmp('vtn_seleccionar_detalle_factura') && Ext.getCmp('vtn_seleccionar_detalle_factura').getViewModel().get('detalleProducto') === false) {
    if (Ext.getStore('store_gestion_producto_factura').find('codigo', filter, 0, false, true, true) === -1) {
      var store = Ext.getStore('store_gestion_producto');
      store.findRecord('codigo', filter, 0, false, true, true);
      var vtn = Ext.create('widget.vtn_generar_producto', {title:' AGREGAR PRODUCTO !'}).show();
      var form = Ext.getCmp('frm_productos');
      var record = store.findRecord('codigo', filter, 0, false, true, true);
      form.setRecord(record);
      Ext.getCmp('vtn_generar_producto').getViewModel().set('detalleProducto', false);
      Ext.getCmp('vtn_generar_producto').getViewModel().set('detalleCrearFactura', true);
      Ext.getCmp('vtn_generar_producto').getViewModel().set('detalleSaveFactura', false);
    } else {
      Ext.toast('El producto ya ha sido agregado', 1000);
    }
  } else {
    Ext.getCmp('ctn_product_view').fn_find_product(filter);
    Ext.getCmp('data_view_product').setStore('store_gestion_producto');
    Ext.getCmp('ctn_product_view').getViewModel().set('filtro', filter);
  }
}});
Ext.define('facturaElecWeb.view.ctn_product_view', {extend:Ext.Container, alias:'widget.ctn_product_view', controller:'ctn_product_view', viewModel:{type:'ctn_product_view'}, id:'ctn_product_view', layout:'hbox', defaultListenerScope:true, items:[{xtype:'container', flex:2.5, cls:'borde-gestion-info', name:'ctn_info_product', padding:'50 0 50 0', layout:'vbox', items:[{xtype:'container', flex:0.5, name:'ctn_search_product', layout:'center', items:[{xtype:'searchfield', validators:function(value) {
  if (!/^([0-9])*$/.test(value)) {
    return 'El codigo debe ser  un nmero entero';
  } else {
    if (value < 0) {
      return 'La cantidad de caracteres ingresada es invlida';
    } else {
      return true;
    }
  }
}, itemId:'search_field_product', name:'search_field_product', width:'70%', labelCls:'my-text', placeholder:'Buscar por codigo', listeners:{keyup:'onSearch_field_productKeyup'}}]}, {xtype:'dataview', id:'data_view_product', padding:'0 0 0 30', itemTpl:['\x3cdiv class\x3d"table-generic"\x3e', '    \x3ctable\x3e', '', '        \x3ctbody \x3e', '            \x3ctr\x3e', '', '                \x3cth class\x3d"row-generic"\x3eCodigo:\x3c/th\x3e', '', '                \x3ctd class\x3d"row-generic"\x3e{codigo}\x3c/td\x3e', 
'', '            \x3c/tr\x3e', '            \x3ctr\x3e', '', '                \x3cth class\x3d"row-generic"\x3eMarca:\x3c/th\x3e', '', '                \x3ctd class\x3d"row-generic"\x3e{marca}\x3c/td\x3e', '', '            \x3c/tr\x3e', '            \x3ctr\x3e', '', '                \x3cth class\x3d"row-generic"\x3eNombre:\x3c/th\x3e', '', '                \x3ctd class\x3d"row-generic"\x3e{nombre}\x3c/td\x3e', '', '            \x3c/tr\x3e', '            \x3ctr\x3e', '', '                \x3cth class\x3d"row-generic"\x3eGarantia:\x3c/th\x3e', 
'', '                \x3ctd class\x3d"row-generic"\x3e{garantia}\x3c/td\x3e', '', '            \x3c/tr\x3e', '            \x3ctr\x3e', '', '                \x3cth class\x3d"row-generic"\x3eDescripcin:\x3c/th\x3e', '', '                \x3ctd class\x3d"row-generic"\x3e{descripcion}\x3c/td\x3e', '', '            \x3c/tr\x3e', '            \x3ctr\x3e', '', '                \x3cth class\x3d"row-generic"\x3ePrecio:\x3c/th\x3e', '', '                \x3ctd class\x3d"row-generic"\x3e$ {precio}\x3c/td\x3e', 
'', '            \x3c/tr\x3e', '        \x3c/tbody\x3e', '    \x3c/table\x3e', '\x3c/div\x3e', '']}, {xtype:'container', flex:0.8, name:'ctn_bottons_product', padding:5, layout:{type:'hbox', align:'center', pack:'center'}, items:[{xtype:'button', handler:function(button, e) {
  Ext.getCmp('ctn_product_view').fn_find_product(null);
  Ext.getCmp('data_view_product').setStore('');
  Ext.ComponentQuery.query('[itemId\x3dsearch_field_product]')[0].setValue('');
  Ext.getCmp('ctn_product_view').getViewModel().set('filtro', null);
}, cls:'color-buttons', height:50, id:'btn_refresh_product', ui:'round', width:50, margin:'0 5 0 0', iconCls:'x-fa fa-refresh blackIcon'}, {xtype:'button', handler:function(button, e) {
  var filter = Ext.getCmp('ctn_product_view').getViewModel().get('filtro');
  if (filter != null) {
    Ext.Msg.show({title:'Confirmacin', message:'Esta seguro de eliminar el producto con codigo ' + filter + '?', width:300, closable:false, buttons:[{text:'No', itemId:'no'}, {text:'Si', itemId:'yes'}], multiline:false, fn:function(buttonValue, inputText, showConfig) {
      if (buttonValue === 'yes') {
        Ext.Ajax.request({url:'productoController/eliminarProducto?codigo\x3d' + filter, method:'GET', success:function(response, opts) {
          Ext.getCmp('ctn_product_view').fn_find_product(null);
          Ext.getCmp('data_view_product').setStore('');
          Ext.getCmp('ctn_product_view').getViewModel().set('filtro', null);
          Ext.ComponentQuery.query('[itemId\x3dsearch_field_product]')[0].setValue('');
          var info = Ext.getCmp('ctn_statistics_view').getViewModel().get('filtro');
          Ext.getCmp('ctn_statistics_view').fn_find_statistcs(info);
          Ext.toast('Exito al eliminar', 1000);
        }, failure:function(response, opts) {
          Ext.toast('Error al llevar a cabo el proceso, El cliente esta vinculado a una factura', 1000);
        }});
      } else {
        this.close();
      }
    }, icon:Ext.Msg.QUESTION});
  } else {
    Ext.toast('Seleccione un producto', 1000);
  }
}, cls:'color-buttons', height:50, name:'btn_delete_product', ui:'round', width:50, margin:'0 5 0 0', iconCls:'x-fa fa-trash blackIcon'}, {xtype:'button', handler:function(button, e) {
  var filter = Ext.getCmp('ctn_product_view').getViewModel().get('filtro');
  if (filter != null) {
    var vtn = Ext.create('widget.vtn_generar_producto', {title:' EDITAR PRODUCTO !'}).show();
    Ext.getCmp('vtn_generar_producto').getViewModel().set('detalleProducto', true);
    var store = Ext.getStore('store_gestion_producto');
    var record = store.findRecord('codigo', filter, 0, false, true, true);
    var form = Ext.getCmp('frm_productos');
    form.setRecord(record);
    Ext.getCmp('vtn_generar_producto').getViewModel().set('detalleCrearFactura', true);
    Ext.getCmp('vtn_generar_producto').getViewModel().set('detalleSaveFactura', false);
  } else {
    Ext.toast('Seleccione un producto', 1000);
  }
}, cls:'color-buttons', height:50, name:'btn_edit_product', ui:'round', width:50, margin:'0 5 0 0', iconCls:'x-fa fa-pencil-square-o blackIcon'}, {xtype:'button', handler:function(button, e) {
  var vtn = Ext.create('widget.vtn_generar_producto', {title:' NUEVO PRODUCTO !'}).show();
  Ext.getCmp('vtn_generar_producto').getViewModel().set('detalleCrearFactura', true);
  Ext.getCmp('vtn_generar_producto').getViewModel().set('detalleSaveFactura', false);
  Ext.getCmp('vtn_generar_producto').getViewModel().set('detalleProducto', true);
}, cls:'color-buttons', height:50, name:'btn_add_product', ui:'round', width:50, iconCls:'x-fa fa-plus blackIcon'}]}]}, {xtype:'container', flex:4.5, name:'ctn_grid_product', padding:'30 30 0 30', items:[{xtype:'container', height:'100%', name:'ctn_medium_product', width:'100%', layout:{type:'vbox', align:'center', pack:'center'}, items:[{xtype:'container', height:'70%', name:'ctn_internal_product', width:'100%', items:[{xtype:'grd_product', itemId:'grd_product_view'}]}]}]}], listeners:{initialize:{fn:'onCtn_product_viewInitialize', 
scope:'controller'}}, onSearch_field_productKeyup:function(textfield, e, eOpts) {
  var filter = textfield.getValue();
  if (e.event.keyCode == 13) {
    Ext.getCmp('ctn_product_view').fn_find_product(filter);
    Ext.getCmp('data_view_product').setStore('store_gestion_producto');
    Ext.getCmp('ctn_product_view').getViewModel().set('filtro', filter);
  }
  if (!textfield.getValue()) {
    Ext.getCmp('ctn_product_view').fn_find_product(null);
    Ext.getCmp('data_view_product').setStore('');
  }
}, fn_find_product:function(filter) {
  var storeProduct = Ext.getStore('store_gestion_producto');
  storeProduct.proxy.extraParams = {filtro:filter};
  storeProduct.load({params:{filtro:filter}, callback:function(records, operation, success) {
    if (success) {
      var noAlmacenado = false;
      var total = storeProduct.totalCount;
      if (total === 0) {
        Ext.getCmp('data_view_product').setStore('');
        Ext.ComponentQuery.query('[itemId\x3dsearch_field_product]')[0].setValue('');
        Ext.getCmp('ctn_product_view').getViewModel().set('filtro', null);
        Ext.toast('No hay resultados para la bsqueda', 1000);
      }
    }
  }});
}});
Ext.define('facturaElecWeb.view.ctn_statistics_viewViewModel', {extend:Ext.app.ViewModel, alias:'viewmodel.ctn_statistics_view'});
Ext.define('facturaElecWeb.view.ctn_statistics_view', {extend:Ext.Container, alias:'widget.ctn_statistics_view', viewModel:{type:'ctn_statistics_view'}, id:'ctn_statistics_view', padding:20, items:[{xtype:'dataview', height:'100%', width:'100%', scrollable:false, itemTpl:['\x3ctpl if\x3d\'[Ext.getCmp("ctn_statistics_view").getViewModel().get("filtro")] \x3d\x3d "ADMIN"\'\x3e', '', '    \x3cdiv class\x3d"row w-100 h-50"\x3e', '        \x3cdiv class\x3d"col-md-3"\x3e', '            \x3cdiv class\x3d"card border-warning mx-sm-1 p-3"\x3e', 
'                \x3cdiv class\x3d"card border-warning shadow text-warning p-3 my-card" \x3e\x3cspan class\x3d"fa fa-eye" aria-hidden\x3d"true"\x3e\x3c/span\x3e\x3c/div\x3e', '                \x3cdiv class\x3d"text-warning text-center mt-3"\x3e\x3ch4\x3eUsuarios\x3c/h4\x3e\x3c/div\x3e', '                \x3cdiv class\x3d"text-warning text-center mt-2"\x3e\x3ch1\x3e{usuario}\x3c/h1\x3e\x3c/div\x3e', '            \x3c/div\x3e', '        \x3c/div\x3e', '        \x3cdiv class\x3d"col-md-1"\x3e\x3c/div\x3e', 
'        \x3cdiv class\x3d"col-md-3"\x3e', '            \x3cdiv class\x3d"card border-warning mx-sm-1 p-3"\x3e', '                \x3cdiv class\x3d"card border-warning shadow text-warning p-3 my-card"\x3e\x3cspan class\x3d"fa fa-eye" aria-hidden\x3d"true"\x3e\x3c/span\x3e\x3c/div\x3e', '                \x3cdiv class\x3d"text-warning text-center mt-3"\x3e\x3ch4\x3eFacturas\x3c/h4\x3e\x3c/div\x3e', '                \x3cdiv class\x3d"text-warning text-center mt-2"\x3e\x3ch1\x3e{factura}\x3c/h1\x3e\x3c/div\x3e', 
'            \x3c/div\x3e', '        \x3c/div\x3e', '        \x3cdiv class\x3d"col-md-1"\x3e\x3c/div\x3e', '        \x3cdiv class\x3d"col-md-3"\x3e', '            \x3cdiv class\x3d"card border-warning mx-sm-1 p-3"\x3e', '                \x3cdiv class\x3d"card border-warning shadow text-warning p-3 my-card" \x3e\x3cspan class\x3d"fa fa-eye" aria-hidden\x3d"true"\x3e\x3c/span\x3e\x3c/div\x3e', '                \x3cdiv class\x3d"text-warning text-center mt-3"\x3e\x3ch4\x3eProductos\x3c/h4\x3e\x3c/div\x3e', 
'                \x3cdiv class\x3d"text-warning text-center mt-2"\x3e\x3ch1\x3e{producto}\x3c/h1\x3e\x3c/div\x3e', '            \x3c/div\x3e', '        \x3c/div\x3e', '    \x3c/div\x3e', '', '    \x3cdiv class\x3d"row w-100" style\x3d"margin: 20px 0px 0px"\x3e', '        \x3cdiv class\x3d"col-md-3"\x3e\x3c/div\x3e', '', '        \x3cdiv class\x3d"col-md-3"\x3e', '            \x3cdiv class\x3d"card border-warning mx-sm-1 p-3"\x3e', '                \x3cdiv class\x3d"card border-warning shadow text-warning p-3 my-card"\x3e\x3cspan class\x3d"fa fa-eye" aria-hidden\x3d"true"\x3e\x3c/span\x3e\x3c/div\x3e', 
'                \x3cdiv class\x3d"text-warning text-center mt-3"\x3e\x3ch4\x3eClientes\x3c/h4\x3e\x3c/div\x3e', '                \x3cdiv class\x3d"text-warning text-center mt-2"\x3e\x3ch1\x3e{cliente}\x3c/h1\x3e\x3c/div\x3e', '            \x3c/div\x3e', '        \x3c/div\x3e', '', '        \x3cdiv class\x3d"col-md-3"\x3e', '            \x3cdiv class\x3d"card border-warning mx-sm-1 p-3"\x3e', '                \x3cdiv class\x3d"card border-warning shadow text-warning p-3 my-card" \x3e\x3cspan class\x3d"fa fa-eye" aria-hidden\x3d"true"\x3e\x3c/span\x3e\x3c/div\x3e', 
'                \x3cdiv class\x3d"text-warning text-center mt-3"\x3e\x3ch4\x3eEmpresas\x3c/h4\x3e\x3c/div\x3e', '                \x3cdiv class\x3d"text-warning text-center mt-2"\x3e\x3ch1\x3e{empresa}\x3c/h1\x3e\x3c/div\x3e', '            \x3c/div\x3e', '        \x3c/div\x3e', '', '        \x3cdiv class\x3d"col-md-3"\x3e\x3c/div\x3e', '    \x3c/div\x3e', '', '\x3c/tpl\x3e', '', '\x3ctpl if\x3d\'[Ext.getCmp("ctn_statistics_view").getViewModel().get("filtro")] \x3d\x3d "USER"\'\x3e', '', '    \x3cdiv class\x3d"row w-100 h-50" style\x3d"margin:150px 0px 0px"\x3e', 
'        \x3cdiv class\x3d"col-md-3"\x3e', '            \x3cdiv class\x3d"card border-warning mx-sm-1 p-3"\x3e', '                \x3cdiv class\x3d"card border-warning shadow text-warning p-3 my-card"\x3e\x3cspan class\x3d"fa fa-eye" aria-hidden\x3d"true"\x3e\x3c/span\x3e\x3c/div\x3e', '                \x3cdiv class\x3d"text-warning text-center mt-3"\x3e\x3ch4\x3eFacturas\x3c/h4\x3e\x3c/div\x3e', '                \x3cdiv class\x3d"text-warning text-center mt-2"\x3e\x3ch1\x3e{factura}\x3c/h1\x3e\x3c/div\x3e', 
'            \x3c/div\x3e', '        \x3c/div\x3e', '        \x3cdiv class\x3d"col-md-3"\x3e', '            \x3cdiv class\x3d"card border-warning mx-sm-1 p-3"\x3e', '                \x3cdiv class\x3d"card border-warning shadow text-warning p-3 my-card" \x3e\x3cspan class\x3d"fa fa-eye" aria-hidden\x3d"true"\x3e\x3c/span\x3e\x3c/div\x3e', '                \x3cdiv class\x3d"text-warning text-center mt-3"\x3e\x3ch4\x3eProductos\x3c/h4\x3e\x3c/div\x3e', '                \x3cdiv class\x3d"text-warning text-center mt-2"\x3e\x3ch1\x3e{producto}\x3c/h1\x3e\x3c/div\x3e', 
'            \x3c/div\x3e', '        \x3c/div\x3e', '', '', '        \x3cdiv class\x3d"col-md-3"\x3e', '            \x3cdiv class\x3d"card border-warning mx-sm-1 p-3"\x3e', '                \x3cdiv class\x3d"card border-warning shadow text-warning p-3 my-card"\x3e\x3cspan class\x3d"fa fa-eye" aria-hidden\x3d"true"\x3e\x3c/span\x3e\x3c/div\x3e', '                \x3cdiv class\x3d"text-warning text-center mt-3"\x3e\x3ch4\x3eClientes\x3c/h4\x3e\x3c/div\x3e', '                \x3cdiv class\x3d"text-warning text-center mt-2"\x3e\x3ch1\x3e{cliente}\x3c/h1\x3e\x3c/div\x3e', 
'            \x3c/div\x3e', '        \x3c/div\x3e', '', '        \x3cdiv class\x3d"col-md-3"\x3e', '            \x3cdiv class\x3d"card border-warning mx-sm-1 p-3"\x3e', '                \x3cdiv class\x3d"card border-warning shadow text-warning p-3 my-card" \x3e\x3cspan class\x3d"fa fa-eye" aria-hidden\x3d"true"\x3e\x3c/span\x3e\x3c/div\x3e', '                \x3cdiv class\x3d"text-warning text-center mt-3"\x3e\x3ch4\x3eEmpresas\x3c/h4\x3e\x3c/div\x3e', '                \x3cdiv class\x3d"text-warning text-center mt-2"\x3e\x3ch1\x3e{empresa}\x3c/h1\x3e\x3c/div\x3e', 
'            \x3c/div\x3e', '        \x3c/div\x3e', '    \x3c/div\x3e', '\x3c/tpl\x3e', ''], store:'store_info_count'}], fn_find_statistcs:function(filter) {
  var storeInfo = Ext.getStore('store_info_count');
  storeInfo.proxy.extraParams = {role:filter};
  storeInfo.load({params:{role:filter}, callback:function(records, operation, success) {
    if (success) {
      var noAlmacenado = false;
      var total = storeInfo.totalCount;
      if (total === 0) {
        Ext.getCmp('ctn_statistics_view').getViewModel().set('filtro', null);
        Ext.toast('No hay resultados para la bsqueda', 1000);
      }
    }
  }});
}});
Ext.define('facturaElecWeb.view.ctn_user_viewViewModel', {extend:Ext.app.ViewModel, alias:'viewmodel.ctn_user_view'});
Ext.define('facturaElecWeb.view.ctn_user_viewViewController', {extend:Ext.app.ViewController, alias:'controller.ctn_user_view', onContainerInitialize:function(component, eOpts) {
  Ext.getStore('store_gestion_usuarios').load();
}});
Ext.define('facturaElecWeb.view.grd_userViewModel', {extend:Ext.app.ViewModel, alias:'viewmodel.grd_user'});
Ext.define('facturaElecWeb.view.grd_user', {extend:Ext.grid.Grid, alias:'widget.grd_user', viewModel:{type:'grd_user'}, height:'100%', id:'grd_user', width:'100%', scrollable:'vertical', layout:'vbox', store:'store_gestion_usuarios', defaultListenerScope:true, columns:[{xtype:'textcolumn', width:'25%', dataIndex:'firstname', text:'Nombre'}, {xtype:'textcolumn', width:'25%', dataIndex:'lastname', text:'Apellido'}, {xtype:'textcolumn', width:'30%', dataIndex:'email', text:'E-mail'}, {xtype:'textcolumn', 
width:'20%', dataIndex:'active', text:'Activo'}], listeners:{select:'onGrd_userSelect'}, onGrd_userSelect:function(dataview, selected, eOpts) {
  var filter = selected[0].data.id;
  Ext.getCmp('ctn_user_view').fn_find_user(selected[0].data.email);
  Ext.getCmp('data_view_user').setStore('store_gestion_usuarios');
  Ext.getCmp('ctn_user_view').getViewModel().set('filtro', filter);
  Ext.getCmp('ctn_user_view').getViewModel().set('oldEmail', selected[0].data.email);
}});
Ext.define('facturaElecWeb.view.ctn_user_view', {extend:Ext.Container, alias:'widget.ctn_user_view', controller:'ctn_user_view', viewModel:{type:'ctn_user_view'}, id:'ctn_user_view', displayed:true, layout:'hbox', defaultListenerScope:true, items:[{xtype:'container', flex:2.5, cls:'borde-gestion-info', name:'ctn_info_user', padding:'50 0 50 0', layout:'vbox', items:[{xtype:'container', flex:0.5, name:'ctn_search_user', layout:'center', items:[{xtype:'searchfield', validators:function(value) {
  if (!Ext.isEmpty(value) && Ext.isEmpty(value.trim())) {
    return 'El campo correo no admite espacios';
  } else {
    if (value.length > 100) {
      return 'El correo supera el tamao permitido (100)';
    } else {
      if (!/^(")?(?:[^\."])(?:(?:[\.])?(?:[\w\-!#$%&'*+\/=?\^_`{|}~]))*\1@(\w[\-\w]*\.){1,5}([A-Za-z]){2,6}$/.test(value)) {
        return 'Correo invalido.(demo@demo.com)';
      } else {
        return true;
      }
    }
  }
}, itemId:'search_field_user', name:'search_field_user', width:'70%', labelCls:'my-text', placeholder:'Buscar por correo electronico', listeners:{keyup:'onSearch_field_userKeyup'}}]}, {xtype:'dataview', id:'data_view_user', padding:'0 0 0 30', itemTpl:['\x3cdiv class\x3d"table-generic"\x3e', '    \x3ctable\x3e', '', '        \x3ctbody \x3e', '            \x3ctr\x3e', '', '                \x3cth class\x3d"row-generic"\x3eNombre:\x3c/th\x3e', '', '                \x3ctd class\x3d"row-generic"\x3e{firstname}\x3c/td\x3e', 
'', '            \x3c/tr\x3e', '            \x3ctr\x3e', '', '                \x3cth class\x3d"row-generic"\x3eApellido:\x3c/th\x3e', '', '                \x3ctd class\x3d"row-generic"\x3e{lastname}\x3c/td\x3e', '', '            \x3c/tr\x3e', '            \x3ctr\x3e', '', '                \x3cth class\x3d"row-generic"\x3eE-mail:\x3c/th\x3e', '', '                \x3ctd class\x3d"row-generic"\x3e{email}\x3c/td\x3e', '', '            \x3c/tr\x3e', '            \x3ctr\x3e', '', '                \x3cth class\x3d"row-generic"\x3eEstado:\x3c/th\x3e', 
'', '                \x3ctd class\x3d"row-generic"\x3e{active}\x3c/td\x3e', '', '            \x3c/tr\x3e', '', '            ', '        \x3c/tbody\x3e', '    \x3c/table\x3e', '\x3c/div\x3e']}, {xtype:'container', flex:0.8, name:'ctn_bottons_user', padding:5, layout:{type:'hbox', align:'center', pack:'center'}, items:[{xtype:'button', handler:function(button, e) {
  Ext.getCmp('ctn_user_view').fn_find_user(null);
  Ext.getCmp('data_view_user').setStore('');
  Ext.ComponentQuery.query('[itemId\x3dsearch_field_user]')[0].setValue('');
  Ext.getCmp('ctn_user_view').getViewModel().set('filtro', null);
  Ext.getCmp('ctn_user_view').getViewModel().set('oldEmail', null);
}, cls:'color-buttons', height:50, id:'btn_refresh_user', ui:'round', width:50, margin:'0 5 0 0', tooltip:'Refrescar', iconCls:'x-fa fa-refresh'}, {xtype:'button', handler:function(button, e) {
  var filter = Ext.getCmp('ctn_user_view').getViewModel().get('filtro');
  if (filter != null) {
    Ext.Msg.show({title:'Confirmacin', message:'Esta seguro de eliminar el usuario?', width:300, closable:false, buttons:[{text:'No', itemId:'no'}, {text:'Si', itemId:'yes'}], multiline:false, fn:function(buttonValue, inputText, showConfig) {
      if (buttonValue === 'yes') {
        Ext.Ajax.request({url:'sesionUsuario/eliminarUsuario?id\x3d' + filter, method:'GET', success:function(response, opts) {
          Ext.getCmp('ctn_user_view').fn_find_user(null);
          Ext.getCmp('data_view_user').setStore('');
          Ext.ComponentQuery.query('[itemId\x3dsearch_field_user]')[0].setValue('');
          Ext.getCmp('ctn_user_view').getViewModel().set('filtro', null);
          Ext.getCmp('ctn_user_view').getViewModel().set('oldEmail', null);
          var info = Ext.getCmp('ctn_statistics_view').getViewModel().get('filtro');
          Ext.getCmp('ctn_statistics_view').fn_find_statistcs(info);
          Ext.toast('Exito al eliminar', 1000);
        }, failure:function(response, opts) {
          Ext.toast('Error al llevar a cabo el proceso, comuniquese con el administrador', 1000);
        }});
      } else {
        this.close();
      }
    }, icon:Ext.Msg.QUESTION});
  } else {
    Ext.toast('Seleccione un usuario', 1000);
  }
}, cls:'color-buttons', height:50, name:'btn_delete_user', ui:'round', width:50, margin:'0 5 0 0', tooltip:'Eliminar usuario', iconCls:'x-fa fa-trash'}, {xtype:'button', handler:function(button, e) {
  var filter = Ext.getCmp('ctn_user_view').getViewModel().get('filtro');
  if (filter != null) {
    var vtn = Ext.create('widget.vtn_generar_usuario', {title:' EDITAR USUARIO !'}).show();
    var store = Ext.getStore('store_gestion_usuarios');
    var record = store.findRecord('id', filter, 0, false, true, true);
    var form = Ext.getCmp('frmUser');
    form.setRecord(record);
    Ext.getCmp('cbx_roles_usuario').setValue(record.data.roles[0].role);
    Ext.getCmp('txt_password_usuario').setValue(null);
  } else {
    Ext.toast('Seleccione un usuario', 1000);
  }
}, cls:'color-buttons', height:50, name:'btn_edit_user', ui:'round', width:50, margin:'0 5 0 0', tooltip:'Editar usuario', iconCls:'x-fa fa-pencil-square-o'}, {xtype:'button', handler:function(button, e) {
  var vtn = Ext.create('widget.vtn_generar_usuario', {title:' NUEVO USUARIO !'}).show();
}, cls:'color-buttons', height:50, name:'btn_add_user', ui:'round', width:50, tooltip:'Crear un nuevo usuario', iconCls:'x-fa fa-plus'}]}]}, {xtype:'container', flex:4.5, name:'ctn_grid_user', padding:'30 30 0 30', items:[{xtype:'container', height:'100%', name:'ctn_grid_medium_ user', width:'100%', layout:{type:'vbox', align:'center', pack:'center'}, items:[{xtype:'container', height:'70%', name:'ctn_grid_internal_user', width:'100%', items:[{xtype:'grd_user'}]}]}]}], listeners:{initialize:{fn:'onContainerInitialize', 
scope:'controller'}}, onSearch_field_userKeyup:function(textfield, e, eOpts) {
  var filter = textfield.getValue();
  if (e.event.keyCode == 13) {
    Ext.getCmp('ctn_user_view').fn_find_client(filter);
    Ext.getCmp('data_view_user').setStore('store_gestion_cliente');
    Ext.getCmp('ctn_user_view').getViewModel().set('filtro', filter);
    Ext.getCmp('ctn_user_view').getViewModel().set('oldEmail', filter);
  }
  if (!textfield.getValue()) {
    Ext.getCmp('ctn_user_view').fn_find_user(null);
    Ext.getCmp('data_view_user').setStore('');
    Ext.ComponentQuery.query('[itemId\x3dsearch_field_user]')[0].setValue('');
    Ext.getCmp('ctn_user_view').getViewModel().set('filtro', null);
    Ext.getCmp('ctn_user_view').getViewModel().set('oldEmail', null);
  }
}, fn_find_user:function(filter) {
  var storeUser = Ext.getStore('store_gestion_usuarios');
  storeUser.proxy.extraParams = {filtro:filter};
  storeUser.load({params:{filtro:filter}, callback:function(records, operation, success) {
    if (success) {
      var noAlmacenado = false;
      var total = storeUser.totalCount;
      if (total === 0) {
        Ext.getCmp('data_view_user').setStore('');
        Ext.ComponentQuery.query('[itemId\x3dsearch_field_user]')[0].setValue('');
        Ext.getCmp('ctn_user_view').getViewModel().set('filtro', null);
        Ext.getCmp('ctn_user_view').getViewModel().set('oldEmail', null);
        Ext.toast('No hay resultados para la bsqueda', 1000);
      }
    }
  }});
}});
Ext.define('facturaElecWeb.view.tbp_menuViewModel', {extend:Ext.app.ViewModel, alias:'viewmodel.tbp_menu'});
Ext.define('facturaElecWeb.view.tbp_menu', {extend:Ext.tab.Panel, alias:'widget.tbp_menu', viewModel:{type:'tbp_menu'}, activeItem:6, id:'tbp_menu', activeChildTabIndex:7, tabBar:{docked:'top', activeTab:1, animateIndicator:true, layout:{type:'hbox', reverse:true}}, items:[{xtype:'ctn_account', title:'Cuenta'}, {xtype:'ctn_user_view', tabIndex:7, title:'Usuarios'}, {xtype:'ctn_company_view', itemId:'ctn_company_view1', tabIndex:4, title:'Empresas'}, {xtype:'ctn_client_view', itemId:'ctn_client_view1', 
tabIndex:3, title:'Clientes'}, {xtype:'ctn_product_view', itemId:'ctn_product_view1', tabIndex:2, title:'Productos'}, {xtype:'ctn_invoice_view', itemId:'ctn_invoice_view1', tabIndex:1, title:'Facturas'}, {xtype:'ctn_statistics_view', itemId:'ctn_statistics_view1', tabIndex:0, title:'Informacin'}]});
Ext.define('facturaElecWeb.view.vtn_generar_productoViewModel1', {extend:Ext.app.ViewModel, alias:'viewmodel.vtn_generar_cliente'});
Ext.define('facturaElecWeb.view.vtn_generar_cliente', {extend:Ext.Dialog, alias:'widget.vtn_generar_cliente', viewModel:{type:'vtn_generar_cliente'}, height:'90%', id:'vtn_generar_cliente', itemId:'vtn_generar_cliente', name:'vtn_generar_cliente', width:'60%', displayed:true, scrollable:'vertical', layout:'center', closable:true, closeToolText:'Cerrar', titleAlign:'center', items:[{xtype:'formpanel', id:'frm_clientes', width:'100%', items:[{xtype:'container', name:'ctn_image_client', margin:'-7 0 10 0', 
layout:{type:'hbox', align:'center', pack:'center'}, items:[{xtype:'image', cls:'image-generic-frm', name:'image_client', src:'https://image.flaticon.com/icons/svg/80/80886.svg'}]}, {xtype:'container', name:'ctn_frm_client', layout:'hbox', items:[{xtype:'container', name:'ctn_column_left_client', width:'50%', margin:'0 10 0 0', layout:'vbox', items:[{xtype:'combobox', name:'tipoDocumento', width:'100%', label:'Tipo de documento', labelCls:'my-text', required:true, requiredMessage:'Digite el tipo de documento', 
displayField:'nombre', store:[{sigla:'CC', nombre:'Cdula de ciudadana'}, {sigla:'CE', nombre:'Cdula de extranjera'}, {sigla:'PS', nombre:'Pasaporte'}], valueField:'sigla', queryMode:'local'}, {xtype:'textfield', validators:function(value) {
  if (value.length > 100) {
    return 'El nombre supera el tamao permitido (100)';
  } else {
    if (/^([0-9])*$/.test(value)) {
      return 'El nombre tiene caracteres invalidos.(0-9)';
    } else {
      return true;
    }
  }
}, name:'nombre', width:'100%', label:'Nombre', labelCls:'my-text', required:true, requiredMessage:'Digite un nombre'}, {xtype:'textfield', validators:function(value) {
  if (value.length > 100) {
    return 'La campo ciudad supera el tamao permitido (100)';
  } else {
    if (/^([0-9])*$/.test(value)) {
      return 'El campo ciudad tiene caracteres invalidos.(0-9)';
    } else {
      return true;
    }
  }
}, name:'ciudad', width:'100%', label:'Ciudad', labelCls:'my-text', required:true, requiredMessage:'Digite una ciudad'}, {xtype:'textfield', validators:function(value) {
  var store = Ext.getStore('store_gestion_cliente');
  var Existente = false;
  var idClient = null;
  var idForm = Ext.getCmp('frm_clientes').getRecord() ? Ext.getCmp('frm_clientes').getRecord().id : null;
  store.each(function(record) {
    if (value == record.data.telefono) {
      Existente = true;
      idClient = record.id;
    }
  });
  if (!Ext.isEmpty(value) && Ext.isEmpty(value.trim())) {
    return 'El campo telefono no admite espacios';
  } else {
    if (value.length > 20) {
      return 'El numero de telefono supera el tamao permitido (20)';
    } else {
      if (!/^([0-9])*$/.test(value)) {
        return 'El telefono debe ser  un nmero entero';
      } else {
        if (Existente && idClient != idForm) {
          return 'Ya existe un cliente con este telefono';
        } else {
          return true;
        }
      }
    }
  }
}, name:'telefono', width:'100%', label:'Telefono', labelCls:'my-text', required:true, requiredMessage:'Digite un telefono'}]}, {xtype:'container', name:'ctn_column_rigth_client', width:'50%', margin:'0 0 0 10', layout:'vbox', items:[{xtype:'textfield', validators:function(value) {
  var store = Ext.getStore('store_gestion_cliente');
  var Existente = false;
  var idClient = null;
  var idForm = Ext.getCmp('frm_clientes').getRecord() ? Ext.getCmp('frm_clientes').getRecord().id : null;
  store.each(function(record) {
    if (value == record.data.documento) {
      Existente = true;
      idClient = record.id;
    }
  });
  if (!Ext.isEmpty(value) && Ext.isEmpty(value.trim())) {
    return 'El campo documento no admite espacios';
  } else {
    if (value.length > 50) {
      return 'El numero de documento supera el tamao permitido (50)';
    } else {
      if (!/^([0-9])*$/.test(value)) {
        return 'El documento debe ser  un nmero entero';
      } else {
        if (Existente && idClient != idForm) {
          return 'Ya existe un cliente con este documento';
        } else {
          return true;
        }
      }
    }
  }
}, name:'documento', width:'100%', label:'Nmero de documento', labelCls:'my-text', required:true, requiredMessage:'Digite el nmero de documento'}, {xtype:'textfield', validators:function(value) {
  if (value.length > 100) {
    return 'El campo pais supera el tamao permitido (100)';
  } else {
    if (/^([0-9])*$/.test(value)) {
      return 'El campo pais tiene caracteres invalidos.(0-9)';
    } else {
      return true;
    }
  }
}, name:'pais', width:'100%', label:'Pais', labelCls:'my-text', required:true, requiredMessage:'Digite un pais'}, {xtype:'textfield', validators:function(value) {
  if (value.length > 100) {
    return 'La dirrecin supera el tamao permitido (100)';
  } else {
    return true;
  }
}, name:'direccion', width:'100%', label:'Direccin', labelCls:'my-text', required:true, requiredMessage:'Digite una direccin'}, {xtype:'textfield', validators:function(value) {
  var store = Ext.getStore('store_gestion_cliente');
  var Existente = false;
  var idClient = null;
  var idForm = Ext.getCmp('frm_clientes').getRecord() ? Ext.getCmp('frm_clientes').getRecord().id : null;
  store.each(function(record) {
    if (value == record.data.correo) {
      Existente = true;
      idClient = record.id;
    }
  });
  if (!Ext.isEmpty(value) && Ext.isEmpty(value.trim())) {
    return 'El campo correo no admite espacios';
  } else {
    if (value.length > 100) {
      return 'El correo supera el tamao permitido (100)';
    } else {
      if (!/^(")?(?:[^\."])(?:(?:[\.])?(?:[\w\-!#$%&'*+\/=?\^_`{|}~]))*\1@(\w[\-\w]*\.){1,5}([A-Za-z]){2,6}$/.test(value)) {
        return 'Correo invalido.(demo@demo.com)';
      } else {
        if (Existente && idClient != idForm) {
          return 'Ya existe un cliente con este correo';
        } else {
          return true;
        }
      }
    }
  }
}, name:'correo', width:'100%', label:'Correo', labelCls:'my-text', required:true, requiredMessage:'Digite un E-Mail'}]}]}, {xtype:'container', name:'ctn_buttons_frm_client', width:'100%', padding:'10 0 0 0', layout:{type:'hbox', align:'center', pack:'center'}, items:[{xtype:'textfield', hidden:true, name:'id', label:'Field'}, {xtype:'button', handler:function(button, e) {
  var form = Ext.getCmp('frm_clientes');
  var values = form.getValues();
  var peticion;
  if (form.validate()) {
    if (form.getRecord()) {
      var record = form.getRecord();
      record.set(values);
      Ext.Ajax.request({url:'clienteController/actualizarCliente', method:'POST', params:{id:values.id, tipoDocumento:values.tipoDocumento, documento:values.documento, nombre:values.nombre, pais:values.pais, ciudad:values.ciudad, direccion:values.direccion, telefono:values.telefono, correo:values.correo}, success:function(response, opts) {
        Ext.getCmp('ctn_client_view').fn_find_client(null);
        Ext.getCmp('data_view_client').setStore('');
        Ext.ComponentQuery.query('[itemId\x3dsearch_field_client]')[0].setValue('');
        Ext.getCmp('ctn_client_view').getViewModel().set('filtro', null);
        Ext.toast('Edicin Exitosa', 1000);
      }, failure:function(response, opts) {
        Ext.toast('Error al llevar a cabo el proceso', 1000);
      }});
      Ext.getCmp('vtn_generar_cliente').unmask();
      Ext.getCmp('vtn_generar_cliente').close();
    } else {
      form.submit({url:'clienteController/agregarCliente', waitMsg:'espere', success:function(response, opts) {
        Ext.getStore('store_gestion_cliente').load();
        Ext.getCmp('grd_client').refresh();
        var info = Ext.getCmp('ctn_statistics_view').getViewModel().get('filtro');
        Ext.getCmp('ctn_statistics_view').fn_find_statistcs(info);
        Ext.toast('Creacin Exitosa', 1000);
      }, failure:function(response, opts) {
        Ext.toast('Error al llevar a cabo el proceso', 1000);
      }});
      Ext.getCmp('vtn_generar_cliente').unmask();
      Ext.getCmp('vtn_generar_cliente').close();
    }
  } else {
    Ext.toast('Error al validar el formulario!', 1000);
  }
}, cls:'color-buttons', height:50, id:'btn_cliente', ui:'round', width:50, iconCls:'x-fa fa-check blackIcon'}]}]}]});
Ext.define('facturaElecWeb.view.vtn_generar_productoViewModel2', {extend:Ext.app.ViewModel, alias:'viewmodel.vtn_generar_empresa'});
Ext.define('facturaElecWeb.view.vtn_generar_empresa', {extend:Ext.Dialog, alias:'widget.vtn_generar_empresa', viewModel:{type:'vtn_generar_empresa'}, height:'90%', id:'vtn_generar_empresa', itemId:'vtn_generar_empresa', name:'vtn_generar_empresa', width:'60%', displayed:true, layout:'center', closable:true, closeToolText:'Cerrar', titleAlign:'center', items:[{xtype:'formpanel', id:'frm_empresas', width:'100%', items:[{xtype:'container', name:'ctn_image_company', margin:'-7 0 10 0', layout:{type:'hbox', 
align:'center', pack:'center'}, items:[{xtype:'image', cls:'image-generic-frm', name:'image_frm_company', src:'https://image.flaticon.com/icons/svg/31/31495.svg'}]}, {xtype:'container', name:'ctn_frm_company', layout:'hbox', items:[{xtype:'container', name:'ctn_column_left_company', width:'50%', margin:'0 10 0 0', layout:'vbox', items:[{xtype:'textfield', validators:function(value) {
  var store = Ext.getStore('store_gestion_empresa');
  var Existente = false;
  var idCompany = null;
  var idForm = Ext.getCmp('frm_empresas').getRecord() ? Ext.getCmp('frm_empresas').getRecord().id : null;
  store.each(function(record) {
    if (value == record.data.nit) {
      Existente = true;
      idCompany = record.id;
    }
  });
  if (!Ext.isEmpty(value) && Ext.isEmpty(value.trim())) {
    return 'El campo nit no admite espacios';
  } else {
    if (value.length > 50) {
      return 'El numero de nit supera el tamao permitido (50)';
    } else {
      if (!/^([0-9])*$/.test(value)) {
        return 'El nit debe ser  un nmero entero';
      } else {
        if (Existente && idCompany != idForm) {
          return 'Ya existe una empresa con este nit';
        } else {
          return true;
        }
      }
    }
  }
}, name:'nit', width:'100%', label:'NIT', labelCls:'my-text', required:true, requiredMessage:'Digite un NIT'}, {xtype:'textfield', validators:function(value) {
  if (value.length > 100) {
    return 'La campo ciudad supera el tamao permitido (100)';
  } else {
    if (/^([0-9])*$/.test(value)) {
      return 'El campo ciudad tiene caracteres invalidos.(0-9)';
    } else {
      return true;
    }
  }
}, name:'ciudad', width:'100%', label:'Ciudad', labelCls:'my-text', required:true, requiredMessage:'Digite una ciudad'}, {xtype:'textfield', validators:function(value) {
  var store = Ext.getStore('store_gestion_empresa');
  var Existente = false;
  var idCompany = null;
  var idForm = Ext.getCmp('frm_empresas').getRecord() ? Ext.getCmp('frm_empresas').getRecord().id : null;
  store.each(function(record) {
    if (value == record.data.telefono) {
      Existente = true;
      idCompany = record.id;
    }
  });
  if (!Ext.isEmpty(value) && Ext.isEmpty(value.trim())) {
    return 'El campo telefono no admite espacios';
  } else {
    if (value.length > 20) {
      return 'El numero de telefono supera el tamao permitido (20)';
    } else {
      if (!/^([0-9])*$/.test(value)) {
        return 'El telefono debe ser  un nmero entero';
      } else {
        if (Existente && idCompany != idForm) {
          return 'Ya existe una empresa con este telefono';
        } else {
          return true;
        }
      }
    }
  }
}, name:'telefono', width:'100%', label:'Telefono', labelCls:'my-text', required:true, requiredMessage:'Digite un telefono'}]}, {xtype:'container', name:'ctn_column_rigth_company', width:'50%', margin:'0 0 0 10', layout:'vbox', items:[{xtype:'textfield', validators:function(value) {
  if (value.length > 100) {
    return 'El nombre supera el tamao permitido (100)';
  } else {
    if (/^([0-9])*$/.test(value)) {
      return 'El nombre tiene caracteres invalidos.(0-9)';
    } else {
      return true;
    }
  }
}, name:'nombre', width:'100%', label:'Nombre', labelCls:'my-text', required:true, requiredMessage:'Digite un nombre'}, {xtype:'textfield', validators:function(value) {
  if (value.length > 100) {
    return 'La dirrecin supera el tamao permitido (100)';
  } else {
    return true;
  }
}, name:'direccion', width:'100%', label:'Direccin', labelCls:'my-text', required:true, requiredMessage:'Digite una direccin'}, {xtype:'textfield', validators:function(value) {
  var store = Ext.getStore('store_gestion_empresa');
  var Existente = false;
  var idCompany = null;
  var idForm = Ext.getCmp('frm_empresas').getRecord() ? Ext.getCmp('frm_empresas').getRecord().id : null;
  store.each(function(record) {
    if (value == record.data.email) {
      Existente = true;
      idCompany = record.id;
    }
  });
  if (!Ext.isEmpty(value) && Ext.isEmpty(value.trim())) {
    return 'El campo correo no admite espacios';
  } else {
    if (value.length > 100) {
      return 'El correo supera el tamao permitido (100)';
    } else {
      if (!/^(")?(?:[^\."])(?:(?:[\.])?(?:[\w\-!#$%&'*+\/=?\^_`{|}~]))*\1@(\w[\-\w]*\.){1,5}([A-Za-z]){2,6}$/.test(value)) {
        return 'Correo invalido.(demo@demo.com)';
      } else {
        if (Existente && idCompany != idForm) {
          return 'Ya existe un cliente con este correo';
        } else {
          return true;
        }
      }
    }
  }
}, name:'email', width:'100%', label:'Correo', labelCls:'my-text', required:true, requiredMessage:'Digite un e-mail'}]}]}, {xtype:'textfield', hidden:true, name:'id', label:'Field'}, {xtype:'container', height:'30%', name:'ctn_buttons_company', width:'100%', padding:'10 0 0 0', layout:{type:'hbox', align:'center', pack:'center'}, items:[{xtype:'button', handler:function(button, e) {
  var form = Ext.getCmp('frm_empresas');
  var values = form.getValues();
  var peticion;
  if (form.validate()) {
    if (form.getRecord()) {
      var record = form.getRecord();
      record.set(values);
      Ext.Ajax.request({url:'empresaController/actualizarEmpresa', method:'POST', params:{id:values.id, nit:values.nit, nombre:values.nombre, ciudad:values.ciudad, direccion:values.direccion, telefono:values.telefono, email:values.email}, success:function(response, opts) {
        Ext.getCmp('ctn_company_view').fn_find_company(null);
        Ext.getCmp('data_view_company').setStore('');
        Ext.getCmp('ctn_company_view').getViewModel().set('filtro', null);
        Ext.ComponentQuery.query('[itemId\x3dsearch_field_company]')[0].setValue('');
        Ext.toast('Edicin Exitosa', 1000);
      }, failure:function(response, opts) {
        Ext.toast('Error al llevar a cabo el proceso', 1000);
      }});
      Ext.getCmp('vtn_generar_empresa').unmask();
      Ext.getCmp('vtn_generar_empresa').close();
    } else {
      form.submit({url:'empresaController/agregarEmpresa', waitMsg:'espere', success:function(response, opts) {
        Ext.getStore('store_gestion_empresa').load();
        Ext.getCmp('grd_company').refresh();
        var info = Ext.getCmp('ctn_statistics_view').getViewModel().get('filtro');
        Ext.getCmp('ctn_statistics_view').fn_find_statistcs(info);
        Ext.toast('Creacin Exitosa', 1000);
      }, failure:function(response, opts) {
        Ext.toast('Error al llevar a cabo el proceso', 1000);
      }});
      Ext.getCmp('vtn_generar_empresa').unmask();
      Ext.getCmp('vtn_generar_empresa').close();
    }
  } else {
    Ext.toast('Error al validar el formulario!', 1000);
  }
}, cls:'color-buttons', height:50, id:'btn_empresa', ui:'round', width:50, scrollable:'vertical', iconCls:'x-fa fa-check blackIcon'}]}]}]});
Ext.define('facturaElecWeb.view.vtn_generar_facturaViewModel', {extend:Ext.app.ViewModel, alias:'viewmodel.vtn_generar_factura'});
Ext.define('facturaElecWeb.view.vtn_generar_factura', {extend:Ext.Dialog, alias:'widget.vtn_generar_factura', viewModel:{type:'vtn_generar_factura'}, height:'90%', id:'vtn_generar_factura', itemId:'vtn_generar_factura', name:'vtn_generar_factura', width:'60%', displayed:true, scrollable:false, closable:true, closeToolText:'Cerra', titleAlign:'center', defaultListenerScope:true, items:[{xtype:'formpanel', height:'100%', id:'frm_factura', width:'100%', scrollable:false, items:[{xtype:'container', name:'ctn_imagen_factura', 
margin:'-7 0 10 0', layout:{type:'hbox', align:'center', pack:'center'}, items:[{xtype:'image', cls:'image-generic-frm', name:'img_factura', src:'https://image.flaticon.com/icons/svg/1849/1849086.svg'}]}, {xtype:'container', height:'50%', name:'ctn_frm_factura', scrollable:'vertical', layout:'vbox', items:[{xtype:'container', name:'ctn_detalle_factura', width:'100%', layout:'hbox', items:[{xtype:'textfield', id:'txt_cliente_factura', name:'documentoCliente', width:'30%', docked:'left', label:'Documento cliente', 
labelCls:'my-text', required:true, requiredMessage:'Seleccione un cliente', editable:false}, {xtype:'button', handler:function(button, e) {
  var vtn = Ext.create('widget.vtn_seleccionar_detalle_factura', {title:' SELECIONAR CLIENTE !'}).show();
  Ext.getCmp('vtn_seleccionar_detalle_factura').getViewModel().set('detalleCliente', false);
  Ext.getCmp('vtn_seleccionar_detalle_factura').getViewModel().set('detalleEmpresa', true);
  Ext.getCmp('vtn_seleccionar_detalle_factura').getViewModel().set('detalleProducto', true);
}, cls:'color-buttons', height:30, name:'btn_cliente_factura', ui:'round', width:30, docked:'left', tooltip:'Seleccionar cliente', iconCls:'x-fa fa-plus blackIcon'}, {xtype:'textfield', id:'txt_empresa_factura', name:'nitEmpresa', width:'30%', docked:'right', margin:'0 0 0 10', label:'Nit empresa', labelCls:'my-text', required:true, requiredMessage:'Seleccione una empresa', editable:false}, {xtype:'button', handler:function(button, e) {
  var vtn = Ext.create('widget.vtn_seleccionar_detalle_factura', {title:' SELECIONAR EMPRESA !'}).show();
  Ext.getCmp('vtn_seleccionar_detalle_factura').getViewModel().set('detalleCliente', true);
  Ext.getCmp('vtn_seleccionar_detalle_factura').getViewModel().set('detalleEmpresa', false);
  Ext.getCmp('vtn_seleccionar_detalle_factura').getViewModel().set('detalleProducto', true);
}, cls:'color-buttons', height:30, name:'btn_empresa_factura', ui:'round', width:30, docked:'right', tooltip:'Seleccionar empresa', iconCls:'x-fa fa-plus blackIcon'}]}, {xtype:'container', name:'ctn_productos_factura', width:'100%', margin:'10 0 0 0', layout:'vbox', items:[{xtype:'container', name:'ctn_detalle_producto', margin:'0 0 10 0', layout:{type:'hbox', align:'center', pack:'center'}, items:[{xtype:'displayfield', label:'Productos', labelCls:'my-text'}, {xtype:'button', handler:function(button, 
e) {
  var vtn = Ext.create('widget.vtn_seleccionar_detalle_factura', {title:' SELECIONAR PRODUCTO !'}).show();
  Ext.getCmp('vtn_seleccionar_detalle_factura').getViewModel().set('detalleCliente', true);
  Ext.getCmp('vtn_seleccionar_detalle_factura').getViewModel().set('detalleEmpresa', true);
  Ext.getCmp('vtn_seleccionar_detalle_factura').getViewModel().set('detalleProducto', false);
}, cls:'color-buttons', height:30, name:'btn_agregar_producto', ui:'round', width:30, iconCls:'x-fa fa-plus blackIcon'}]}, {xtype:'grid', height:200, id:'grd_productos_factura', itemId:'mygrid1', name:'productos', width:'100%', scrollable:'vertical', store:'store_gestion_producto_factura', columns:[{xtype:'gridcolumn', width:'20%', dataIndex:'nombre', text:'Nombre'}, {xtype:'gridcolumn', width:'15%', dataIndex:'marca', text:'Marca'}, {xtype:'gridcolumn', width:'15%', dataIndex:'garantia', text:'Garantia'}, 
{xtype:'numbercolumn', width:'20%', dataIndex:'precio', text:'Precio'}, {xtype:'gridcolumn', width:'15%', dataIndex:'cantidad', text:'Cantidad'}, {xtype:'numbercolumn', width:'15%', dataIndex:'totalProducto', text:'Total'}], listeners:{refresh:'onGrd_productos_facturaRefresh', select:'onGrd_productos_facturaSelect'}}]}]}, {xtype:'container', name:'ctn_total_factura', margin:'10 0 3 0', layout:{type:'hbox', align:'center', pack:'center'}, items:[{xtype:'container', name:'ctn_internal_total_factura', 
width:'30%', items:[{xtype:'numberfield', height:'10%', id:'txt_total_factura', name:'total', docked:'left', label:'Total', labelCls:'my-text', required:true, requiredMessage:'Seleccione un producto', clearable:false, editable:false}]}, {xtype:'container', name:'ctn_buttons_factura', width:'40%', layout:'center', items:[{xtype:'button', handler:function(button, e) {
  debugger;
  var form = Ext.getCmp('frm_factura');
  var values = form.getValues();
  if (form.validate()) {
    var storeData = Ext.getStore('store_gestion_producto_factura').data;
    var JSONData = [];
    for (var i = 0; i < storeData.length; i++) {
      JSONData.push(storeData.items[i].data);
    }
    JSONData = JSON.stringify(JSONData);
    if (values.codigo === null) {
      Ext.ComponentQuery.query('[itemId\x3dtxt_codigo_factura]')[0].setValue(0);
    }
    Ext.getCmp('grd_view_product_invoice').hide();
    form.submit({url:'facturaController/agregarFactura', params:{producto:JSONData}, waitMsg:'Espere...', success:function(fp, o) {
      Ext.getStore('store_gestion_producto_factura').data.clear();
      Ext.getCmp('ctn_invoice_view').fn_find_invoice(null);
      Ext.getCmp('data_view_invoice').setStore('');
      Ext.ComponentQuery.query('[itemId\x3dsearch_field_invoice]')[0].setValue('');
      Ext.getCmp('ctn_invoice_view').getViewModel().set('filtro', null);
      var filter = Ext.getCmp('ctn_statistics_view').getViewModel().get('filtro');
      Ext.getCmp('ctn_statistics_view').fn_find_statistcs(filter);
      Ext.getCmp('vtn_generar_factura').close();
      Ext.toast('Proceso exitoso', 1000);
    }, failure:function(response, opts) {
      Ext.toast('Error al llevar a cabo el proceso', 1000);
    }});
  } else {
    Ext.toast('Error al validar el formulario!', 1000);
  }
}, cls:'color-buttons', height:50, name:'btn_factura', ui:'round', width:50, tooltip:'Continuar proceso', iconCls:'x-fa fa-check blackIcon'}]}, {xtype:'container', name:'ctn_codigo_factura', width:'30%', items:[{xtype:'textfield', itemId:'txt_codigo_factura', name:'codigo', label:'Codigo', labelCls:'my-text', clearable:false, editable:false, bind:{hidden:'{inhabilitarCodigo}'}}]}]}]}], onGrd_productos_facturaRefresh:function(dataview, eOpts) {
  var storeData = Ext.getStore('store_gestion_producto_factura').data;
  var totalFactura = 0;
  for (var i = 0; i < storeData.length; i++) {
    totalFactura = totalFactura + storeData.items[i].data.totalProducto;
  }
  if (totalFactura === 0) {
    Ext.getCmp('txt_total_factura').setValue(null);
  } else {
    Ext.getCmp('txt_total_factura').setValue(totalFactura);
  }
}, onGrd_productos_facturaSelect:function(dataview, selected, eOpts) {
  var filter = selected[0].data.codigo;
  var store = Ext.getStore('store_gestion_producto_factura');
  store.findRecord('codigo', filter, 0, false, true, true);
  var vtn = Ext.create('widget.vtn_generar_producto', {title:' EDITAR PRODUCTO !'}).show();
  var form = Ext.getCmp('frm_productos');
  var record = store.findRecord('codigo', filter, 0, false, true, true);
  form.setRecord(record);
  Ext.getCmp('vtn_generar_producto').getViewModel().set('detalleProducto', false);
  Ext.getCmp('vtn_generar_producto').getViewModel().set('detalleCrearFactura', false);
  Ext.getCmp('vtn_generar_producto').getViewModel().set('detalleSaveFactura', true);
}});
Ext.define('facturaElecWeb.view.vtn_generar_productoViewModel', {extend:Ext.app.ViewModel, alias:'viewmodel.vtn_generar_producto'});
Ext.define('facturaElecWeb.view.vtn_generar_producto', {extend:Ext.Dialog, alias:'widget.vtn_generar_producto', viewModel:{type:'vtn_generar_producto'}, height:'90%', id:'vtn_generar_producto', itemId:'vtn_generar_producto', name:'vtn_generar_producto', width:'60%', displayed:true, scrollable:false, layout:'center', closable:true, closeToolText:'Cerrar', titleAlign:'center', defaultListenerScope:true, items:[{xtype:'formpanel', id:'frm_productos', width:'100%', items:[{xtype:'container', name:'ctn_image_company', 
margin:'-7 0 10 0', layout:{type:'hbox', align:'center', pack:'center'}, items:[{xtype:'image', cls:'image-generic-frm', name:'image_frm_product', src:'https://image.flaticon.com/icons/svg/1170/1170628.svg'}]}, {xtype:'container', name:'ctn_frm_product', scrollable:'vertical', layout:{type:'hbox', align:'center', pack:'center'}, items:[{xtype:'container', name:'ctn_column_left_product', width:'45%', margin:'0 10 0 0', items:[{xtype:'textfield', validators:function(value) {
  var store = Ext.getStore('store_gestion_producto');
  var Existente = false;
  var idProduct = null;
  var idForm = Ext.getCmp('frm_productos').getRecord() ? Ext.getCmp('frm_productos').getRecord().id : null;
  store.each(function(record) {
    if (value == record.data.codigo) {
      Existente = true;
      idProduct = record.id;
    }
  });
  if (!Ext.isEmpty(value) && Ext.isEmpty(value.trim())) {
    return 'El campo codigo no admite espacios';
  } else {
    if (value.length > 50) {
      return 'El numero de codigo supera el tamao permitido (50)';
    } else {
      if (!/^([0-9])*$/.test(value)) {
        return 'El codigo debe ser  un nmero entero';
      } else {
        if (Existente && idProduct != idForm) {
          return 'Ya existe un producto con este codigo';
        } else {
          return true;
        }
      }
    }
  }
}, name:'codigo', width:'100%', label:'Cdigo', labelCls:'my-text', required:true, requiredMessage:'Digite un cdigo', bind:{clearable:'{detalleProducto}', editable:'{detalleProducto}'}}, {xtype:'textfield', validators:function(value) {
  if (value.length > 100) {
    return 'El campo marca supera el tamao permitido (100)';
  } else {
    if (/^([0-9])*$/.test(value)) {
      return 'El campo marca tiene caracteres invalidos.(0-9)';
    } else {
      return true;
    }
  }
}, name:'marca', width:'100%', label:'Marca', labelCls:'my-text', required:true, requiredMessage:'Digite una marca', bind:{clearable:'{detalleProducto}', editable:'{detalleProducto}'}}, {xtype:'textfield', validators:function(value) {
  if (!Ext.isEmpty(value) && Ext.isEmpty(value.trim())) {
    return 'El campo precio no admite espacios';
  } else {
    if (value.length > 50) {
      return 'El campo precio supera el tamao permitido (50)';
    } else {
      if (!/^([0-9])*$/.test(value)) {
        return 'El precio debe ser  un nmero entero';
      } else {
        return true;
      }
    }
  }
}, id:'txt_precio_producto', name:'precio', width:'100%', label:'Precio', labelCls:'my-text', required:true, requiredMessage:'Digite un precio', bind:{clearable:'{detalleProducto}', editable:'{detalleProducto}'}}, {xtype:'container', cls:'border-cantidad-factura-producto', name:'ctn_cantidad_producto', padding:5, bind:{hidden:'{detalleProducto}'}, items:[{xtype:'numberfield', validators:function(value) {
  if (value.length > 9) {
    return 'El campo cantidad supera el tamao permitido (20)';
  } else {
    if (!/^([0-9])*$/.test(value)) {
      return 'La cantidad debe ser  un nmero entero';
    } else {
      return true;
    }
  }
}, id:'txt_cantidad_producto', name:'cantidad', label:'Cantidad', labelCls:'my-text', required:true, requiredMessage:'Digite una cantidad', bind:{hidden:'{detalleProducto}'}, listeners:{keyup:'onTxt_cantidad_productoKeyup1'}}]}]}, {xtype:'container', name:'ctn_column_rigth_company', width:'45%', margin:'0 0 0 10', layout:'vbox', items:[{xtype:'textfield', validators:function(value) {
  if (value.length > 100) {
    return 'El nombre supera el tamao permitido (100)';
  } else {
    if (/^([0-9])*$/.test(value)) {
      return 'El nombre tiene caracteres invalidos.(0-9)';
    } else {
      return true;
    }
  }
}, name:'nombre', width:'100%', label:'Nombre', labelCls:'my-text', required:true, requiredMessage:'Digite un nombre', bind:{clearable:'{detalleProducto}', editable:'{detalleProducto}'}}, {xtype:'textfield', validators:function(value) {
  if (!Ext.isEmpty(value) && Ext.isEmpty(value.trim())) {
    return 'El campo garantia no admite espacios';
  } else {
    if (value.length > 4) {
      return 'El campo garantia supera el tamao permitido (4)';
    } else {
      if (!/^([0-9])*$/.test(value)) {
        return 'El campo garantia debe ser  un nmero entero';
      } else {
        return true;
      }
    }
  }
}, name:'garantia', width:'100%', label:'Garantia  (Meses)', labelCls:'my-text', required:true, requiredMessage:'Digite una garantia', bind:{clearable:'{detalleProducto}', editable:'{detalleProducto}'}}, {xtype:'textfield', validators:function(value) {
  if (value.length > 2500) {
    return 'El campo descripcion supera el tamao permitido (2500)';
  } else {
    return true;
  }
}, name:'descripcion', width:'100%', label:'Descripcin', labelCls:'my-text', required:true, requiredMessage:'Digite una descripcin', bind:{clearable:'{detalleProducto}', editable:'{detalleProducto}'}}, {xtype:'container', cls:'border-totalProducto-factura-producto', name:'ctn_total_producto', padding:5, bind:{hidden:'{detalleProducto}'}, items:[{xtype:'numberfield', id:'txt_total_producto', name:'totalProducto', label:'Total', labelCls:'my-text', required:true, requiredMessage:'Digite una cantidad', 
clearable:false, bind:{hidden:'{detalleProducto}', editable:'{detalleProducto}'}}]}]}, {xtype:'textfield', hidden:true, name:'id', label:'Field'}]}, {xtype:'container', height:'30%', name:'ctn_buttons_company', width:'100%', padding:'10 0 0 0', layout:{type:'hbox', align:'center', pack:'center'}, items:[{xtype:'button', handler:function(button, e) {
  if (Ext.getCmp('vtn_generar_producto').getViewModel().get('detalleProducto') === false) {
    var form = Ext.getCmp('frm_productos');
    var values = form.getValues();
    if (form.validate()) {
      Ext.Msg.show({title:'Confirmacin', message:'Est seguro de agregar el producto con codigo ' + values.codigo + '?', width:300, closable:false, buttons:[{text:'No', itemId:'no'}, {text:'Si', itemId:'yes'}], multiline:false, fn:function(buttonValue, inputText, showConfig) {
        if (buttonValue === 'yes') {
          Ext.getStore('store_gestion_producto_factura').add(values);
          Ext.getCmp('grd_productos_factura').refresh();
          Ext.getCmp('vtn_generar_producto').close();
          Ext.toast('El producto se agreco con exito', 1000);
        } else {
          this.close();
        }
      }, icon:Ext.Msg.QUESTION});
    } else {
      Ext.toast('Error al validar el formulario!', 1000);
    }
  } else {
    Ext.getCmp('txt_cantidad_producto').setRequired(false);
    Ext.getCmp('txt_total_producto').setRequired(false);
    var form = Ext.getCmp('frm_productos');
    var values = form.getValues();
    if (form.validate()) {
      if (form.getRecord()) {
        var record = form.getRecord();
        record.set(values);
        Ext.Ajax.request({url:'productoController/actualizarProducto', method:'POST', params:{id:values.id, codigo:values.codigo, marca:values.marca, nombre:values.nombre, garantia:values.garantia, precio:values.precio, descripcion:values.descripcion}, success:function(response, opts) {
          Ext.getCmp('ctn_product_view').fn_find_product(null);
          Ext.getCmp('data_view_product').setStore('');
          Ext.getCmp('ctn_product_view').getViewModel().set('filtro', null);
          Ext.ComponentQuery.query('[itemId\x3dsearch_field_product]')[0].setValue('');
          Ext.toast('Edicin Exitosa', 1000);
        }, failure:function(response, opts) {
          Ext.toast('Error al llevar a cabo el proceso', 1000);
        }});
        Ext.getCmp('vtn_generar_producto').unmask();
        Ext.getCmp('vtn_generar_producto').close();
      } else {
        form.submit({url:'productoController/agregarProducto', waitMsg:'espere', success:function(response, opts) {
          Ext.getStore('store_gestion_producto').load();
          var info = Ext.getCmp('ctn_statistics_view').getViewModel().get('filtro');
          Ext.getCmp('ctn_statistics_view').fn_find_statistcs(info);
          Ext.toast('Creacin Exitosa', 1000);
        }, failure:function(response, opts) {
          Ext.toast('Error al llevar a cabo el proceso', 1000);
        }});
        Ext.getCmp('vtn_generar_producto').unmask();
        Ext.getCmp('vtn_generar_producto').close();
      }
    } else {
      Ext.toast('Error al validar el formulario!', 1000);
    }
  }
}, cls:'color-buttons', height:50, id:'btn_producto', ui:'round', width:50, tooltip:'Continuar proceso', iconCls:'x-fa fa-check blackIcon', bind:{hidden:'{detalleSaveFactura}'}}, {xtype:'button', handler:function(button, e) {
  var store = Ext.getStore('store_gestion_producto_factura');
  var codigo = Ext.getCmp('frm_productos').getValues().codigo;
  if (store.data.length != 0) {
    Ext.Msg.show({title:'Confirmacin', message:'Esta seguro de eliminar el producto con codigo ' + codigo + ' de la factura?', width:300, closable:false, buttons:[{text:'No', itemId:'no'}, {text:'Si', itemId:'yes'}], multiline:false, fn:function(buttonValue, inputText, showConfig) {
      if (buttonValue === 'yes') {
        store.remove(Ext.getStore('store_gestion_producto_factura').findRecord('codigo', codigo));
        var storeData = Ext.getStore('store_gestion_producto_factura').data;
        var totalFactura = 0;
        for (var i = 0; i < storeData.length; i++) {
          totalFactura = totalFactura + storeData.items[i].data.totalProducto;
        }
        if (totalFactura === 0) {
          Ext.getCmp('txt_total_factura').setValue(null);
        } else {
          Ext.getCmp('txt_total_factura').setValue(totalFactura);
        }
        Ext.getCmp('vtn_generar_producto').close();
        Ext.toast('Exito al eliminar!', 1000);
      } else {
        this.close();
      }
    }, icon:Ext.Msg.QUESTION});
  } else {
    Ext.toast('No es posible eliminar, comuniquese con el administrador!', 1000);
  }
}, cls:'color-buttons', height:50, name:'btn_delete', ui:'round', width:50, tooltip:'Remover producto', iconCls:'x-fa fa-trash blackIcon', bind:{hidden:'{detalleCrearFactura}'}}, {xtype:'button', handler:function(button, e) {
  var store = Ext.getStore('store_gestion_producto_factura');
  var form = Ext.getCmp('frm_productos');
  var codigo = form.getValues().codigo;
  var total = form.getValues().totalProducto;
  var cantidad = form.getValues().cantidad;
  var data = store.data.items;
  for (var i = 0; i < data.length; i++) {
    if (data[i].data.codigo === codigo) {
      data[i].data.cantidad = cantidad;
      data[i].data.totalProducto = total;
    }
  }
  store.setData(null);
  store.setData(data);
  debugger;
  var totalFactura = 0;
  for (var i = 0; i < store.data.length; i++) {
    totalFactura = totalFactura + store.data.items[i].data.totalProducto;
  }
  if (totalFactura === 0) {
    Ext.getCmp('txt_total_factura').setValue(null);
  } else {
    Ext.getCmp('txt_total_factura').setValue(totalFactura);
  }
  Ext.getCmp('vtn_generar_producto').close();
  Ext.toast('Exito al editar el producto', 1000);
}, cls:'color-buttons', height:50, name:'btn_save_cache', ui:'round', width:50, tooltip:'Guardar cambio', iconCls:'x-fa fa-share-square-o blackIcon', bind:{hidden:'{detalleCrearFactura}'}}]}]}], onTxt_cantidad_productoKeyup1:function(textfield, e, eOpts) {
  if (e.event.keyCode >= 48 && e.event.keyCode <= 57 || e.event.keyCode >= 96 && e.event.keyCode <= 105 || e.event.keyCode === 8) {
    Ext.getCmp('txt_total_producto').setValue(Ext.getCmp('txt_precio_producto').getValue() * textfield.getValue());
  }
  if (!textfield.getValue() || textfield.getValue() === 0) {
    Ext.getCmp('txt_total_producto').setValue();
  }
}});
Ext.define('facturaElecWeb.view.vtn_generar_usuarioViewModel', {extend:Ext.app.ViewModel, alias:'viewmodel.vtn_generar_usuario'});
Ext.define('facturaElecWeb.view.vtn_generar_usuario', {extend:Ext.Dialog, alias:'widget.vtn_generar_usuario', viewModel:{type:'vtn_generar_usuario'}, height:'90%', id:'vtn_generar_usuario', itemId:'vtn_generar_usuario', name:'vtn_generar_usuario', width:'60%', displayed:true, scrollable:'vertical', layout:'center', closable:true, closeToolText:'Cerrar', titleAlign:'center', items:[{xtype:'formpanel', id:'frmUser', width:'100%', items:[{xtype:'container', name:'ctn_image_user', margin:'-7 0 10 0', 
layout:{type:'hbox', align:'center', pack:'center'}, items:[{xtype:'image', cls:'image-generic-frm', name:'image_user', src:'https://image.flaticon.com/icons/svg/74/74472.svg'}]}, {xtype:'container', name:'ctn_frm_user', layout:'hbox', items:[{xtype:'container', name:'ctn_column_left_user', width:'45%', docked:'left', margin:'0 10 0 0', layout:{type:'vbox', align:'center', pack:'center'}, items:[{xtype:'textfield', validators:function(value) {
  if (value.length > 100) {
    return 'El nombre supera el tamao permitido (100)';
  } else {
    if (/^([0-9])*$/.test(value)) {
      return 'El nombre tiene caracteres invalidos.(0-9)';
    } else {
      return true;
    }
  }
}, name:'firstname', width:'100%', label:'Nombre', labelCls:'my-text', required:true, requiredMessage:'Digite un nombre'}, {xtype:'textfield', validators:function(value) {
  var store = Ext.getStore('store_gestion_usuarios');
  var Existente = false;
  var idUsuario = null;
  var idForm = Ext.getCmp('frmUser').getRecord() ? Ext.getCmp('frmUser').getRecord().id : null;
  store.each(function(record) {
    if (value == record.data.correo) {
      Existente = true;
      idUsuario = record.id;
    }
  });
  if (!Ext.isEmpty(value) && Ext.isEmpty(value.trim())) {
    return 'El campo correo no admite espacios';
  } else {
    if (value.length > 100) {
      return 'El correo supera el tamao permitido (100)';
    } else {
      if (!/^(")?(?:[^\."])(?:(?:[\.])?(?:[\w\-!#$%&'*+\/=?\^_`{|}~]))*\1@(\w[\-\w]*\.){1,5}([A-Za-z]){2,6}$/.test(value)) {
        return 'Correo invalido.(demo@demo.com)';
      } else {
        if (Existente && idUsuario != idForm) {
          return 'Ya existe un usuario con este correo';
        } else {
          return true;
        }
      }
    }
  }
}, name:'email', width:'100%', label:'E-mail', labelCls:'my-text', required:true, requiredMessage:'Digite un E-Mail'}, {xtype:'combobox', name:'active', width:'100%', label:'Estado', labelCls:'my-text', required:true, requiredMessage:'Seleccione el estado del usuario', displayField:'nombre', store:[{active:0, nombre:'Deshabilitado'}, {active:1, nombre:'Habilitado'}], valueField:'active', queryMode:'local'}]}, {xtype:'container', name:'ctn_column_rigth_user', width:'45%', docked:'right', margin:'0 0 0 10', 
layout:{type:'vbox', align:'center', pack:'center'}, items:[{xtype:'textfield', validators:function(value) {
  if (value.length > 100) {
    return 'El apellido supera el tamao permitido (100)';
  } else {
    if (/^([0-9])*$/.test(value)) {
      return 'El apellido tiene caracteres invalidos.(0-9)';
    } else {
      return true;
    }
  }
}, name:'lastname', width:'100%', label:'Apellido', labelCls:'my-text', required:true, requiredMessage:'Digite un apellido'}, {xtype:'passwordfield', id:'txt_password_usuario', name:'password', width:'100%', label:'Contrasea', labelCls:'my-text', placeholder:'Ingrese o cambie la contrasea'}, {xtype:'combobox', id:'cbx_roles_usuario', name:'roles', width:'100%', label:'Rol', labelCls:'my-text', required:true, requiredMessage:'Seleccione un rol', displayField:'role', store:[{id:1, role:'ADMIN'}, 
{id:2, role:'USER'}], valueField:'role', queryMode:'local'}]}]}, {xtype:'container', name:'ctn_buttons_frm_user', width:'100%', margin:'10 0 0 0', layout:{type:'hbox', align:'center', pack:'center'}, items:[{xtype:'textfield', hidden:true, name:'id', label:'Field'}, {xtype:'button', handler:function(button, e) {
  var form = Ext.getCmp('frmUser');
  var values = form.getValues();
  var oldEmail = Ext.getCmp('ctn_user_view').getViewModel().get('oldEmail');
  var peticion;
  if (form.validate()) {
    if (form.getRecord()) {
      var record = form.getRecord();
      record.set(values);
      Ext.Ajax.request({url:'sesionUsuario/actualizarUsuarios', method:'POST', params:{active:values.active, email:values.email, oldEmail:oldEmail, firstname:values.firstname, id:values.id, lastname:values.lastname, password:values.password, roles:values.roles}, success:function(response, opts) {
        Ext.getCmp('ctn_user_view').fn_find_user(null);
        Ext.getCmp('data_view_user').setStore('');
        Ext.ComponentQuery.query('[itemId\x3dsearch_field_user]')[0].setValue('');
        Ext.getCmp('ctn_user_view').getViewModel().set('filtro', null);
        Ext.getCmp('ctn_user_view').getViewModel().set('oldEmail', null);
        Ext.toast('Edicin Exitosa', 1000);
      }, failure:function(response, opts) {
        Ext.toast('Error al llevar a cabo el proceso', 1000);
      }});
      Ext.getCmp('vtn_generar_usuario').unmask();
      Ext.getCmp('vtn_generar_usuario').close();
    } else {
      form.submit({url:'sesionUsuario/agregarUsuario', waitMsg:'espere', success:function(response, opts) {
        Ext.getCmp('ctn_user_view').fn_find_user(null);
        Ext.getCmp('data_view_user').setStore('');
        Ext.ComponentQuery.query('[itemId\x3dsearch_field_user]')[0].setValue('');
        Ext.getCmp('ctn_user_view').getViewModel().set('filtro', null);
        Ext.getCmp('ctn_user_view').getViewModel().set('oldEmail', null);
        var info = Ext.getCmp('ctn_statistics_view').getViewModel().get('filtro');
        Ext.getCmp('ctn_statistics_view').fn_find_statistcs(info);
        Ext.toast('Creacin Exitosa', 1000);
      }, failure:function(response, opts) {
        Ext.toast('Error al llevar a cabo el proceso', 1000);
      }});
      Ext.getCmp('vtn_generar_usuario').unmask();
      Ext.getCmp('vtn_generar_usuario').close();
    }
  } else {
    Ext.toast('Error al validar el formulario!', 1000);
  }
}, cls:'color-buttons', height:50, id:'btn_user', ui:'round', width:50, tooltip:'Continuar proceso', iconCls:'x-fa fa-check blackIcon'}]}]}]});
Ext.define('facturaElecWeb.view.vtn_seleccionar_detalle_facturaViewModel', {extend:Ext.app.ViewModel, alias:'viewmodel.vtn_seleccionar_detalle_factura'});
Ext.define('facturaElecWeb.view.vtn_seleccionar_detalle_factura', {extend:Ext.Dialog, alias:'widget.vtn_seleccionar_detalle_factura', viewModel:{type:'vtn_seleccionar_detalle_factura'}, height:'90%', id:'vtn_seleccionar_detalle_factura', width:'60%', displayed:true, closable:true, closeToolText:'Cerra', titleAlign:'center', defaultListenerScope:true, items:[{xtype:'container', name:'buscar_detalle', layout:{type:'hbox', align:'center', pack:'center'}, items:[{xtype:'searchfield', validators:function(value) {
  if (!/^([0-9])*$/.test(value)) {
    return 'El documento debe ser  un nmero entero';
  } else {
    if (value < 0) {
      return 'La cantidad de caracteres ingresada es invlida';
    } else {
      return true;
    }
  }
}, height:'10%', itemId:'buscar_cliente_factura', name:'search_field_cliente', width:'70%', labelCls:'my-text', placeholder:'Buscar por documento', bind:{hidden:'{detalleCliente}'}, listeners:{keyup:'onBuscar_cliente_facturaKeyup'}}, {xtype:'searchfield', validators:function(value) {
  if (!/^([0-9])*$/.test(value)) {
    return 'El nit debe ser  un nmero entero';
  } else {
    if (value < 0) {
      return 'La cantidad de caracteres ingresada es invlida';
    } else {
      return true;
    }
  }
}, itemId:'buscar_empresa_factura', name:'search_field_company', width:'70%', labelCls:'my-text', placeholder:'Buscar por nit', bind:{hidden:'{detalleEmpresa}'}, listeners:{keyup:'onBuscar_empresa_facturaKeyup'}}, {xtype:'searchfield', validators:function(value) {
  if (!/^([0-9])*$/.test(value)) {
    return 'El codigo debe ser  un nmero entero';
  } else {
    if (value < 0) {
      return 'La cantidad de caracteres ingresada es invlida';
    } else {
      return true;
    }
  }
}, itemId:'buscar_producto_factura', name:'search_field_product', width:'70%', labelCls:'my-text', placeholder:'Buscar por codigo', bind:{hidden:'{detalleProducto}'}, listeners:{keyup:'onBuscar_producto_facturaKeyup'}}]}, {xtype:'grid', height:'100%', id:'grd_client_factura', width:'100%', scrollable:'vertical', layout:'vbox', store:'store_gestion_cliente', bind:{hidden:'{detalleCliente}'}, columns:[{xtype:'gridcolumn', width:'20%', dataIndex:'documento', text:'Documento'}, {xtype:'gridcolumn', width:'25%', 
dataIndex:'nombre', text:'Nombre'}, {xtype:'gridcolumn', width:'15%', dataIndex:'ciudad', text:'Ciudad'}, {xtype:'gridcolumn', width:'15%', dataIndex:'telefono', text:'Telefono'}, {xtype:'gridcolumn', width:'25%', dataIndex:'correo', text:'Correo'}], listeners:{select:'onGridSelect1'}}, {xtype:'grid', height:'100%', id:'grd_company_factura', width:'100%', layout:'vbox', store:'store_gestion_empresa', bind:{hidden:'{detalleEmpresa}'}, columns:[{xtype:'gridcolumn', width:'20%', dataIndex:'nit', text:'Nit'}, 
{xtype:'gridcolumn', width:'30%', dataIndex:'nombre', text:'Nombre'}, {xtype:'gridcolumn', width:'20%', dataIndex:'telefono', text:'Telefono'}, {xtype:'gridcolumn', width:'30%', dataIndex:'email', text:'E-mail'}], listeners:{select:'onGridSelect2'}}, {xtype:'grd_product', bind:{hidden:'{detalleProducto}'}}], onBuscar_cliente_facturaKeyup:function(textfield, e, eOpts) {
  var filter = textfield.getValue();
  if (e.event.keyCode == 13) {
    Ext.getCmp('vtn_seleccionar_detalle_factura').fn_find_detalle(filter, 1);
  }
  if (!textfield.getValue()) {
    Ext.getCmp('vtn_seleccionar_detalle_factura').fn_find_detalle(null, 1);
  }
}, onBuscar_empresa_facturaKeyup:function(textfield, e, eOpts) {
  var filter = textfield.getValue();
  if (e.event.keyCode == 13) {
    Ext.getCmp('vtn_seleccionar_detalle_factura').fn_find_detalle(filter, 2);
  }
  if (!textfield.getValue()) {
    Ext.getCmp('vtn_seleccionar_detalle_factura').fn_find_detalle(null, 2);
  }
}, onBuscar_producto_facturaKeyup:function(textfield, e, eOpts) {
  var filter = textfield.getValue();
  if (e.event.keyCode == 13) {
    Ext.getCmp('vtn_seleccionar_detalle_factura').fn_find_detalle(filter, 3);
  }
  if (!textfield.getValue()) {
    Ext.getCmp('vtn_seleccionar_detalle_factura').fn_find_detalle(null, 3);
  }
}, onGridSelect1:function(dataview, selected, eOpts) {
  var filter = selected[0].data.documento;
  Ext.Msg.show({title:'Confirmacin', message:'Est seguro de agregar el cliente con documento ' + filter + '?', width:300, closable:false, buttons:[{text:'No', itemId:'no'}, {text:'Si', itemId:'yes'}], multiline:false, fn:function(buttonValue, inputText, showConfig) {
    if (buttonValue === 'yes') {
      Ext.getCmp('txt_cliente_factura').setValue(filter);
      Ext.getCmp('vtn_seleccionar_detalle_factura').close();
      Ext.toast('El cliente se agrego con Exito', 1000);
    } else {
      this.close();
    }
  }, icon:Ext.Msg.QUESTION});
}, onGridSelect2:function(dataview, selected, eOpts) {
  var filter = selected[0].data.nit;
  Ext.Msg.show({title:'Confirmacin', message:'Est seguro de agregar la empresa con nit ' + filter + '?', width:300, closable:false, buttons:[{text:'No', itemId:'no'}, {text:'Si', itemId:'yes'}], multiline:false, fn:function(buttonValue, inputText, showConfig) {
    if (buttonValue === 'yes') {
      Ext.getCmp('txt_empresa_factura').setValue(filter);
      Ext.getCmp('vtn_seleccionar_detalle_factura').close();
      Ext.toast('La empresa se agrego con Exito', 1000);
    } else {
      this.close();
    }
  }, icon:Ext.Msg.QUESTION});
}, fn_find_detalle:function(filter, detalle) {
  switch(detalle) {
    case 1:
      var storeClient = Ext.getStore('store_gestion_cliente');
      storeClient.proxy.extraParams = {filtro:filter};
      storeClient.load({params:{filtro:filter}, callback:function(records, operation, success) {
        if (success) {
          var noAlmacenado = false;
          var total = storeClient.totalCount;
          if (total === 0) {
            Ext.toast('No hay resultados para la bsqueda', 1000);
          }
        }
      }});
      break;
    case 2:
      var storeCompany = Ext.getStore('store_gestion_empresa');
      storeCompany.proxy.extraParams = {filtro:filter};
      storeCompany.load({params:{filtro:filter}, callback:function(records, operation, success) {
        if (success) {
          var noAlmacenado = false;
          var total = storeCompany.totalCount;
          if (total === 0) {
            Ext.toast('No hay resultados para la bsqueda', 1000);
          }
        }
      }});
      break;
    case 3:
      var storeProduct = Ext.getStore('store_gestion_producto');
      storeProduct.proxy.extraParams = {filtro:filter};
      storeProduct.load({params:{filtro:filter}, callback:function(records, operation, success) {
        if (success) {
          var noAlmacenado = false;
          var total = storeProduct.totalCount;
          if (total === 0) {
            Ext.toast('No hay resultados para la bsqueda', 1000);
          }
        }
      }});
      break;
  }
}});
!function(t, e) {
  'object' == typeof exports && 'undefined' != typeof module ? module.exports = e() : 'function' == typeof define && define.amd ? define(e) : t.jspdf = e();
}(this, function() {
  $jscomp.initSymbol();
  $jscomp.initSymbol();
  $jscomp.initSymbolIterator();
  var t = 'function' == typeof Symbol && 'symbol' == typeof Symbol.iterator ? function(t) {
    return typeof t;
  } : function(t) {
    $jscomp.initSymbol();
    $jscomp.initSymbol();
    $jscomp.initSymbol();
    return t && 'function' == typeof Symbol && t.constructor === Symbol && t !== Symbol.prototype ? 'symbol' : typeof t;
  }, e = (function() {
    function t(t) {
      this.value = t;
    }
    function e(e) {
      function n(t, e) {
        return new Promise(function(n, i) {
          var s = {key:t, arg:e, resolve:n, reject:i, next:null};
          a ? a = a.next = s : (o = a = s, r(t, e));
        });
      }
      function r(n, o) {
        try {
          var a = e[n](o), s = a.value;
          s instanceof t ? Promise.resolve(s.value).then(function(t) {
            r('next', t);
          }, function(t) {
            r('throw', t);
          }) : i(a.done ? 'return' : 'normal', a.value);
        } catch (t$35) {
          i('throw', t$35);
        }
      }
      function i(t, e) {
        switch(t) {
          case 'return':
            o.resolve({value:e, done:!0});
            break;
          case 'throw':
            o.reject(e);
            break;
          default:
            o.resolve({value:e, done:!1});
        }
        o = o.next, o ? r(o.key, o.arg) : a = null;
      }
      var o, a;
      this._invoke = n, 'function' != typeof e['return'] && (this['return'] = void 0);
    }
    $jscomp.initSymbol();
    $jscomp.initSymbol();
    $jscomp.initSymbol();
    return 'function' == typeof Symbol && Symbol.asyncIterator && (e.prototype[Symbol.asyncIterator] = function() {
      return this;
    }), e.prototype.next = function(t) {
      return this._invoke('next', t);
    }, e.prototype['throw'] = function(t) {
      return this._invoke('throw', t);
    }, e.prototype['return'] = function(t) {
      return this._invoke('return', t);
    }, {wrap:function(t) {
      return function() {
        return new e(t.apply(this, arguments));
      };
    }, await:function(e) {
      return new t(e);
    }};
  }(), function(e) {
    function n(t) {
      var n = {};
      this.subscribe = function(t, e, r) {
        if ('function' != typeof e) {
          return !1;
        }
        n.hasOwnProperty(t) || (n[t] = {});
        var i = Math.random().toString(35);
        return n[t][i] = [e, !!r], i;
      }, this.unsubscribe = function(t) {
        for (var e in n) {
          if (n[e][t]) {
            return delete n[e][t], !0;
          }
        }
        return !1;
      }, this.publish = function(r) {
        if (n.hasOwnProperty(r)) {
          var i = Array.prototype.slice.call(arguments, 1), o = [];
          for (var a in n[r]) {
            var s = n[r][a];
            try {
              s[0].apply(t, i);
            } catch (t$36) {
              e.console && console.error('jsPDF PubSub Error', t$36.message, t$36);
            }
            s[1] && o.push(a);
          }
          o.length && o.forEach(this.unsubscribe);
        }
      };
    }
    function r(c, l, u, h) {
      var f = {};
      'object' === ('undefined' == typeof c ? 'undefined' : t(c)) && (f = c, c = f.orientation, l = f.unit || l, u = f.format || u, h = f.compress || f.compressPdf || h), l = l || 'mm', u = u || 'a4', c = ('' + (c || 'P')).toLowerCase();
      var d, p, g, m, w, y, v, b, x, k = (('' + u).toLowerCase(), !!h && 'function' == typeof Uint8Array), _ = f.textColor || '0 g', C = f.drawColor || '0 G', A = f.fontSize || 16, S = f.lineHeight || 1.15, q = f.lineWidth || 0.200025, T = 2, P = !1, I = [], E = {}, O = {}, F = 0, R = [], B = [], D = [], j = [], z = [], N = 0, L = 0, M = 0, U = {title:'', subject:'', author:'', keywords:'', creator:''}, H = {}, W = new n(H), X = function(t) {
        return t.toFixed(2);
      }, V = function(t) {
        return t.toFixed(3);
      }, Y = function(t) {
        return ('0' + parseInt(t)).slice(-2);
      }, G = function(t) {
        P ? R[m].push(t) : (M += t.length + 1, j.push(t));
      }, J = function() {
        return T++, I[T] = M, G(T + ' 0 obj'), T;
      }, Q = function() {
        var t = 2 * R.length + 1;
        t += z.length;
        var e = {objId:t, content:''};
        return z.push(e), e;
      }, K = function() {
        return T++, I[T] = function() {
          return M;
        }, T;
      }, $ = function(t) {
        I[t] = M;
      }, Z = function(t) {
        G('stream'), G(t), G('endstream');
      }, tt = function() {
        var t, n, i, o, s, c, l, u, h, f = [];
        for (l = e.adler32cs || r.adler32cs, k && 'undefined' == typeof l && (k = !1), t = 1; t <= F; t++) {
          if (f.push(J()), u = (w = D[t].width) * p, h = (y = D[t].height) * p, G('\x3c\x3c/Type /Page'), G('/Parent 1 0 R'), G('/Resources 2 0 R'), G('/MediaBox [0 0 ' + X(u) + ' ' + X(h) + ']'), W.publish('putPage', {pageNumber:t, page:R[t]}), G('/Contents ' + (T + 1) + ' 0 R'), G('\x3e\x3e'), G('endobj'), n = R[t].join('\n'), J(), k) {
            for (i = [], o = n.length; o--;) {
              i[o] = n.charCodeAt(o);
            }
            c = l.from(n), s = new a(6), s.append(new Uint8Array(i)), n = s.flush(), i = new Uint8Array(n.length + 6), i.set(new Uint8Array([120, 156])), i.set(n, 2), i.set(new Uint8Array([255 & c, c >> 8 & 255, c >> 16 & 255, c >> 24 & 255]), n.length + 2), n = String.fromCharCode.apply(null, i), G('\x3c\x3c/Length ' + n.length + ' /Filter [/FlateDecode]\x3e\x3e');
          } else {
            G('\x3c\x3c/Length ' + n.length + '\x3e\x3e');
          }
          Z(n), G('endobj');
        }
        I[1] = M, G('1 0 obj'), G('\x3c\x3c/Type /Pages');
        var d = '/Kids [';
        for (o = 0; o < F; o++) {
          d += f[o] + ' 0 R ';
        }
        G(d + ']'), G('/Count ' + F), G('\x3e\x3e'), G('endobj'), W.publish('postPutPages');
      }, et = function(t) {
        t.objectNumber = J(), G('\x3c\x3c/BaseFont/' + t.PostScriptName + '/Type/Font'), 'string' == typeof t.encoding && G('/Encoding/' + t.encoding), G('/Subtype/Type1\x3e\x3e'), G('endobj');
      }, nt = function() {
        for (var t in E) {
          E.hasOwnProperty(t) && et(E[t]);
        }
      }, rt = function() {
        W.publish('putXobjectDict');
      }, it = function() {
        G('/ProcSet [/PDF /Text /ImageB /ImageC /ImageI]'), G('/Font \x3c\x3c');
        for (var t in E) {
          E.hasOwnProperty(t) && G('/' + t + ' ' + E[t].objectNumber + ' 0 R');
        }
        G('\x3e\x3e'), G('/XObject \x3c\x3c'), rt(), G('\x3e\x3e');
      }, ot = function() {
        nt(), W.publish('putResources'), I[2] = M, G('2 0 obj'), G('\x3c\x3c'), it(), G('\x3e\x3e'), G('endobj'), W.publish('postPutResources');
      }, at = function() {
        W.publish('putAdditionalObjects');
        for (var t = 0; t < z.length; t++) {
          var e = z[t];
          I[e.objId] = M, G(e.objId + ' 0 obj'), G(e.content), G('endobj');
        }
        T += z.length, W.publish('postPutAdditionalObjects');
      }, st = function(t, e, n) {
        O.hasOwnProperty(e) || (O[e] = {}), O[e][n] = t;
      }, ct = function(t, e, n, r) {
        var i = 'F' + (Object.keys(E).length + 1).toString(10), o = E[i] = {id:i, PostScriptName:t, fontName:e, fontStyle:n, encoding:r, metadata:{}};
        return st(i, e, n), W.publish('addFont', o), i;
      }, lt = function() {
        for (var t = 'helvetica', e = 'times', n = 'courier', r = 'normal', i = 'bold', o = 'italic', a = 'bolditalic', s = 'StandardEncoding', c = 'zapfdingbats', l = [['Helvetica', t, r], ['Helvetica-Bold', t, i], ['Helvetica-Oblique', t, o], ['Helvetica-BoldOblique', t, a], ['Courier', n, r], ['Courier-Bold', n, i], ['Courier-Oblique', n, o], ['Courier-BoldOblique', n, a], ['Times-Roman', e, r], ['Times-Bold', e, i], ['Times-Italic', e, o], ['Times-BoldItalic', e, a], ['ZapfDingbats', c]], u = 
        0, h = l.length; u < h; u++) {
          var f = ct(l[u][0], l[u][1], l[u][2], s), d = l[u][0].split('-');
          st(f, d[0], d[1] || '');
        }
        W.publish('addFonts', {fonts:E, dictionary:O});
      }, ut = function(t) {
        return t.foo = function() {
          try {
            return t.apply(this, arguments);
          } catch (t$37) {
            var n = t$37.stack || '';
            ~n.indexOf(' at ') && (n = n.split(' at ')[1]);
            var r = 'Error in function ' + n.split('\n')[0].split('\x3c')[0] + ': ' + t$37.message;
            if (!e.console) {
              throw new Error(r);
            }
            e.console.error(r, t$37), e.alert && alert(r);
          }
        }, t.foo.bar = t, t.foo;
      }, ht = function(t, e) {
        var n, r, i, o, a, s, c, l, u;
        if (e = e || {}, i = e.sourceEncoding || 'Unicode', a = e.outputEncoding, (e.autoencode || a) && E[d].metadata && E[d].metadata[i] && E[d].metadata[i].encoding && (o = E[d].metadata[i].encoding, !a && E[d].encoding && (a = E[d].encoding), !a && o.codePages && (a = o.codePages[0]), 'string' == typeof a && (a = o[a]), a)) {
          for (c = !1, s = [], n = 0, r = t.length; n < r; n++) {
            l = a[t.charCodeAt(n)], l ? s.push(String.fromCharCode(l)) : s.push(t[n]), s[n].charCodeAt(0) >> 8 && (c = !0);
          }
          t = s.join('');
        }
        for (n = t.length; void 0 === c && 0 !== n;) {
          t.charCodeAt(n - 1) >> 8 && (c = !0), n--;
        }
        if (!c) {
          return t;
        }
        for (s = e.noBOM ? [] : [254, 255], n = 0, r = t.length; n < r; n++) {
          if (l = t.charCodeAt(n), u = l >> 8, u >> 8) {
            throw new Error('Character at position ' + n + " of string '" + t + "' exceeds 16bits. Cannot be encoded into UCS-2 BE");
          }
          s.push(u), s.push(l - (u << 8));
        }
        return String.fromCharCode.apply(void 0, s);
      }, ft = function(t, e) {
        return ht(t, e).replace(/\\/g, '\\\\').replace(/\(/g, '\\(').replace(/\)/g, '\\)');
      }, dt = function() {
        G('/Producer (jsPDF ' + r.version + ')');
        for (var t in U) {
          U.hasOwnProperty(t) && U[t] && G('/' + t.substr(0, 1).toUpperCase() + t.substr(1) + ' (' + ft(U[t]) + ')');
        }
        var e = new Date, n = e.getTimezoneOffset(), i = n < 0 ? '+' : '-', o = Math.floor(Math.abs(n / 60)), a = Math.abs(n % 60), s = [i, Y(o), "'", Y(a), "'"].join('');
        G(['/CreationDate (D:', e.getFullYear(), Y(e.getMonth() + 1), Y(e.getDate()), Y(e.getHours()), Y(e.getMinutes()), Y(e.getSeconds()), s, ')'].join(''));
      }, pt = function() {
        switch(G('/Type /Catalog'), G('/Pages 1 0 R'), b || (b = 'fullwidth'), b) {
          case 'fullwidth':
            G('/OpenAction [3 0 R /FitH null]');
            break;
          case 'fullheight':
            G('/OpenAction [3 0 R /FitV null]');
            break;
          case 'fullpage':
            G('/OpenAction [3 0 R /Fit]');
            break;
          case 'original':
            G('/OpenAction [3 0 R /XYZ null null 1]');
            break;
          default:
            var t = '' + b;
            '%' === t.substr(t.length - 1) && (b = parseInt(b) / 100), 'number' == typeof b && G('/OpenAction [3 0 R /XYZ null null ' + X(b) + ']');
        }
        switch(x || (x = 'continuous'), x) {
          case 'continuous':
            G('/PageLayout /OneColumn');
            break;
          case 'single':
            G('/PageLayout /SinglePage');
            break;
          case 'two':
          case 'twoleft':
            G('/PageLayout /TwoColumnLeft');
            break;
          case 'tworight':
            G('/PageLayout /TwoColumnRight');
        }
        v && G('/PageMode /' + v), W.publish('putCatalog');
      }, gt = function() {
        G('/Size ' + (T + 1)), G('/Root ' + T + ' 0 R'), G('/Info ' + (T - 1) + ' 0 R');
      }, mt = function(t, e) {
        var n = 'string' == typeof e && e.toLowerCase();
        if ('string' == typeof t) {
          var r = t.toLowerCase();
          s.hasOwnProperty(r) && (t = s[r][0] / p, e = s[r][1] / p);
        }
        if (Array.isArray(t) && (e = t[1], t = t[0]), n) {
          switch(n.substr(0, 1)) {
            case 'l':
              e > t && (n = 's');
              break;
            case 'p':
              t > e && (n = 's');
          }
          's' === n && (g = t, t = e, e = g);
        }
        P = !0, R[++F] = [], D[F] = {width:Number(t) || w, height:Number(e) || y}, B[F] = {}, vt(F);
      }, wt = function() {
        mt.apply(this, arguments), G(X(q * p) + ' w'), G(C), 0 !== N && G(N + ' J'), 0 !== L && G(L + ' j'), W.publish('addPage', {pageNumber:F});
      }, yt = function(t) {
        t > 0 && t <= F && (R.splice(t, 1), D.splice(t, 1), F--, m > F && (m = F), this.setPage(m));
      }, vt = function(t) {
        t > 0 && t <= F && (m = t, w = D[t].width, y = D[t].height);
      }, bt = function(t, e) {
        var n;
        switch(t = void 0 !== t ? t : E[d].fontName, e = void 0 !== e ? e : E[d].fontStyle, void 0 !== t && (t = t.toLowerCase()), t) {
          case 'sans-serif':
          case 'verdana':
          case 'arial':
          case 'helvetica':
            t = 'helvetica';
            break;
          case 'fixed':
          case 'monospace':
          case 'terminal':
          case 'courier':
            t = 'courier';
            break;
          case 'serif':
          case 'cursive':
          case 'fantasy':
          default:
            t = 'times';
        }
        try {
          n = O[t][e];
        } catch (t$38) {
        }
        return n || (n = O.times[e], null == n && (n = O.times.normal)), n;
      }, xt = function() {
        P = !1, T = 2, M = 0, j = [], I = [], z = [], W.publish('buildDocument'), G('%PDF-' + o), tt(), at(), ot(), J(), G('\x3c\x3c'), dt(), G('\x3e\x3e'), G('endobj'), J(), G('\x3c\x3c'), pt(), G('\x3e\x3e'), G('endobj');
        var t, e = M, n = '0000000000';
        for (G('xref'), G('0 ' + (T + 1)), G(n + ' 65535 f '), t = 1; t <= T; t++) {
          var r = I[t];
          G('function' == typeof r ? (n + I[t]()).slice(-10) + ' 00000 n ' : (n + I[t]).slice(-10) + ' 00000 n ');
        }
        return G('trailer'), G('\x3c\x3c'), gt(), G('\x3e\x3e'), G('startxref'), G('' + e), G('%%EOF'), P = !0, j.join('\n');
      }, kt = function(t) {
        var e = 'S';
        return 'F' === t ? e = 'f' : 'FD' === t || 'DF' === t ? e = 'B' : 'f' !== t && 'f*' !== t && 'B' !== t && 'B*' !== t || (e = t), e;
      }, _t = function() {
        for (var t = xt(), e = t.length, n = new ArrayBuffer(e), r = new Uint8Array(n); e--;) {
          r[e] = t.charCodeAt(e);
        }
        return n;
      }, Ct = function() {
        return new Blob([_t()], {type:'application/pdf'});
      }, At = ut(function(t, n) {
        var r = 'dataur' === ('' + t).substr(0, 6) ? 'data:application/pdf;base64,' + btoa(xt()) : 0;
        switch(t) {
          case void 0:
            return xt();
          case 'save':
            if (navigator.getUserMedia && (void 0 === e.URL || void 0 === e.URL.createObjectURL)) {
              return H.output('dataurlnewwindow');
            }
            i(Ct(), n), 'function' == typeof i.unload && e.setTimeout && setTimeout(i.unload, 911);
            break;
          case 'arraybuffer':
            return _t();
          case 'blob':
            return Ct();
          case 'bloburi':
          case 'bloburl':
            return e.URL && e.URL.createObjectURL(Ct()) || void 0;
          case 'datauristring':
          case 'dataurlstring':
            return r;
          case 'dataurlnewwindow':
            var o = e.open(r);
            if (o || 'undefined' == typeof safari) {
              return o;
            }
          case 'datauri':
          case 'dataurl':
            return e.document.location.href = r;
          default:
            throw new Error('Output type "' + t + '" is not supported.');
        }
      });
      switch(l) {
        case 'pt':
          p = 1;
          break;
        case 'mm':
          p = 72 / 25.4000508;
          break;
        case 'cm':
          p = 72 / 2.54000508;
          break;
        case 'in':
          p = 72;
          break;
        case 'px':
          p = 96 / 72;
          break;
        case 'pc':
          p = 12;
          break;
        case 'em':
          p = 12;
          break;
        case 'ex':
          p = 6;
          break;
        default:
          throw 'Invalid unit: ' + l;
      }
      H.internal = {pdfEscape:ft, getStyle:kt, getFont:function() {
        return E[bt.apply(H, arguments)];
      }, getFontSize:function() {
        return A;
      }, getLineHeight:function() {
        return A * S;
      }, write:function(t) {
        G(1 === arguments.length ? t : Array.prototype.join.call(arguments, ' '));
      }, getCoordinateString:function(t) {
        return X(t * p);
      }, getVerticalCoordinateString:function(t) {
        return X((y - t) * p);
      }, collections:{}, newObject:J, newAdditionalObject:Q, newObjectDeferred:K, newObjectDeferredBegin:$, putStream:Z, events:W, scaleFactor:p, pageSize:{get width() {
        return w;
      }, get height() {
        return y;
      }}, output:function(t, e) {
        return At(t, e);
      }, getNumberOfPages:function() {
        return R.length - 1;
      }, pages:R, out:G, f2:X, getPageInfo:function(t) {
        var e = 2 * (t - 1) + 3;
        return {objId:e, pageNumber:t, pageContext:B[t]};
      }, getCurrentPageInfo:function() {
        var t = 2 * (m - 1) + 3;
        return {objId:t, pageNumber:m, pageContext:B[m]};
      }, getPDFVersion:function() {
        return o;
      }}, H.addPage = function() {
        return wt.apply(this, arguments), this;
      }, H.setPage = function() {
        return vt.apply(this, arguments), this;
      }, H.insertPage = function(t) {
        return this.addPage(), this.movePage(m, t), this;
      }, H.movePage = function(t, e) {
        if (t > e) {
          for (var n = R[t], r = D[t], i = B[t], o = t; o > e; o--) {
            R[o] = R[o - 1], D[o] = D[o - 1], B[o] = B[o - 1];
          }
          R[e] = n, D[e] = r, B[e] = i, this.setPage(e);
        } else {
          if (t < e) {
            for (var n = R[t], r = D[t], i = B[t], o = t; o < e; o++) {
              R[o] = R[o + 1], D[o] = D[o + 1], B[o] = B[o + 1];
            }
            R[e] = n, D[e] = r, B[e] = i, this.setPage(e);
          }
        }
        return this;
      }, H.deletePage = function() {
        return yt.apply(this, arguments), this;
      }, H.setDisplayMode = function(t, e, n) {
        b = t, x = e, v = n;
        var r = [void 0, null, 'UseNone', 'UseOutlines', 'UseThumbs', 'FullScreen'];
        if (r.indexOf(n) == -1) {
          throw new Error('Page mode must be one of UseNone, UseOutlines, UseThumbs, or FullScreen. "' + n + '" is not recognized.');
        }
        return this;
      }, H.text = function(t, e, n, r, i, o) {
        function a(t) {
          return t = t.split('\t').join(Array(f.TabLen || 9).join(' ')), ft(t, r);
        }
        'number' == typeof t && (g = n, n = e, e = t, t = g), 'string' == typeof t && (t = t.match(/[\n\r]/) ? t.split(/\r\n|\r|\n/g) : [t]), 'string' == typeof i && (o = i, i = null), 'string' == typeof r && (o = r, r = null), 'number' == typeof r && (i = r, r = null);
        var s, c = '', l = 'Td';
        if (i) {
          i *= Math.PI / 180;
          var u = Math.cos(i), h = Math.sin(i);
          c = [X(u), X(h), X(h * -1), X(u), ''].join(' '), l = 'Tm';
        }
        r = r || {}, 'noBOM' in r || (r.noBOM = !0), 'autoencode' in r || (r.autoencode = !0);
        var m = '', w = this.internal.getCurrentPageInfo().pageContext;
        if (!0 === r.stroke ? w.lastTextWasStroke !== !0 && (m = '1 Tr\n', w.lastTextWasStroke = !0) : (w.lastTextWasStroke && (m = '0 Tr\n'), w.lastTextWasStroke = !1), 'undefined' == typeof this._runningPageHeight && (this._runningPageHeight = 0), 'string' == typeof t) {
          t = a(t);
        } else {
          if ('[object Array]' !== Object.prototype.toString.call(t)) {
            throw new Error('Type of text must be string or Array. "' + t + '" is not recognized.');
          }
          for (var v = t.concat(), b = [], x = v.length; x--;) {
            b.push(a(v.shift()));
          }
          var k = Math.ceil((y - n - this._runningPageHeight) * p / (A * S));
          if (0 <= k && k < b.length + 1, o) {
            var C, q, T, P = A * S, I = t.map(function(t) {
              return this.getStringUnitWidth(t) * A / p;
            }, this);
            if (T = Math.max.apply(Math, I), 'center' === o) {
              C = e - T / 2, e -= I[0] / 2;
            } else {
              if ('right' !== o) {
                throw new Error('Unrecognized alignment option, use "center" or "right".');
              }
              C = e - T, e -= I[0];
            }
            q = e, t = b[0];
            for (var E = 1, x = b.length; E < x; E++) {
              var O = T - I[E];
              'center' === o && (O /= 2), t += ') Tj\n' + (C - q + O) + ' -' + P + ' Td (' + b[E], q = C + O;
            }
          } else {
            t = b.join(') Tj\nT* (');
          }
        }
        var F;
        return s || (F = X((y - n) * p)), G('BT\n/' + d + ' ' + A + ' Tf\n' + A * S + ' TL\n' + m + _ + '\n' + c + X(e * p) + ' ' + F + ' ' + l + '\n(' + t + ') Tj\nET'), s && this.text(s, e, n), this;
      }, H.lstext = function(t, e, n, r) {
        console.warn('jsPDF.lstext is deprecated');
        for (var i = 0, o = t.length; i < o; i++, e += r) {
          this.text(t[i], e, n);
        }
        return this;
      }, H.line = function(t, e, n, r) {
        return this.lines([[n - t, r - e]], t, e);
      }, H.clip = function() {
        G('W'), G('S');
      }, H.clip_fixed = function(t) {
        G('evenodd' === t ? 'W*' : 'W'), G('n');
      }, H.lines = function(t, e, n, r, i, o) {
        var a, s, c, l, u, h, f, d, m, w, v;
        for ('number' == typeof t && (g = n, n = e, e = t, t = g), r = r || [1, 1], G(V(e * p) + ' ' + V((y - n) * p) + ' m '), a = r[0], s = r[1], l = t.length, w = e, v = n, c = 0; c < l; c++) {
          u = t[c], 2 === u.length ? (w = u[0] * a + w, v = u[1] * s + v, G(V(w * p) + ' ' + V((y - v) * p) + ' l')) : (h = u[0] * a + w, f = u[1] * s + v, d = u[2] * a + w, m = u[3] * s + v, w = u[4] * a + w, v = u[5] * s + v, G(V(h * p) + ' ' + V((y - f) * p) + ' ' + V(d * p) + ' ' + V((y - m) * p) + ' ' + V(w * p) + ' ' + V((y - v) * p) + ' c'));
        }
        return o && G(' h'), null !== i && G(kt(i)), this;
      }, H.rect = function(t, e, n, r, i) {
        kt(i);
        return G([X(t * p), X((y - e) * p), X(n * p), X(-r * p), 're'].join(' ')), null !== i && G(kt(i)), this;
      }, H.triangle = function(t, e, n, r, i, o, a) {
        return this.lines([[n - t, r - e], [i - n, o - r], [t - i, e - o]], t, e, [1, 1], a, !0), this;
      }, H.roundedRect = function(t, e, n, r, i, o, a) {
        var s = 4 / 3 * (Math.SQRT2 - 1);
        return this.lines([[n - 2 * i, 0], [i * s, 0, i, o - o * s, i, o], [0, r - 2 * o], [0, o * s, -(i * s), o, -i, o], [-n + 2 * i, 0], [-(i * s), 0, -i, -(o * s), -i, -o], [0, -r + 2 * o], [0, -(o * s), i * s, -o, i, -o]], t + i, e, [1, 1], a), this;
      }, H.ellipse = function(t, e, n, r, i) {
        var o = 4 / 3 * (Math.SQRT2 - 1) * n, a = 4 / 3 * (Math.SQRT2 - 1) * r;
        return G([X((t + n) * p), X((y - e) * p), 'm', X((t + n) * p), X((y - (e - a)) * p), X((t + o) * p), X((y - (e - r)) * p), X(t * p), X((y - (e - r)) * p), 'c'].join(' ')), G([X((t - o) * p), X((y - (e - r)) * p), X((t - n) * p), X((y - (e - a)) * p), X((t - n) * p), X((y - e) * p), 'c'].join(' ')), G([X((t - n) * p), X((y - (e + a)) * p), X((t - o) * p), X((y - (e + r)) * p), X(t * p), X((y - (e + r)) * p), 'c'].join(' ')), G([X((t + o) * p), X((y - (e + r)) * p), X((t + n) * p), X((y - (e + 
        a)) * p), X((t + n) * p), X((y - e) * p), 'c'].join(' ')), null !== i && G(kt(i)), this;
      }, H.circle = function(t, e, n, r) {
        return this.ellipse(t, e, n, n, r);
      }, H.setProperties = function(t) {
        for (var e in U) {
          U.hasOwnProperty(e) && t[e] && (U[e] = t[e]);
        }
        return this;
      }, H.setFontSize = function(t) {
        return A = t, this;
      }, H.setFont = function(t, e) {
        return d = bt(t, e), this;
      }, H.setFontStyle = H.setFontType = function(t) {
        return d = bt(void 0, t), this;
      }, H.getFontList = function() {
        var t, e, n, r = {};
        for (t in O) {
          if (O.hasOwnProperty(t)) {
            r[t] = n = [];
            for (e in O[t]) {
              O[t].hasOwnProperty(e) && n.push(e);
            }
          }
        }
        return r;
      }, H.addFont = function(t, e, n) {
        ct(t, e, n, 'StandardEncoding');
      }, H.setLineWidth = function(t) {
        return G((t * p).toFixed(2) + ' w'), this;
      }, H.setDrawColor = function(t, e, n, r) {
        var i;
        return i = void 0 === e || void 0 === r && t === e === n ? 'string' == typeof t ? t + ' G' : X(t / 255) + ' G' : void 0 === r ? 'string' == typeof t ? [t, e, n, 'RG'].join(' ') : [X(t / 255), X(e / 255), X(n / 255), 'RG'].join(' ') : 'string' == typeof t ? [t, e, n, r, 'K'].join(' ') : [X(t), X(e), X(n), X(r), 'K'].join(' '), G(i), this;
      }, H.setFillColor = function(e, n, r, i) {
        var o;
        return void 0 === n || void 0 === i && e === n === r ? o = 'string' == typeof e ? e + ' g' : X(e / 255) + ' g' : void 0 === i || 'object' === ('undefined' == typeof i ? 'undefined' : t(i)) ? (o = 'string' == typeof e ? [e, n, r, 'rg'].join(' ') : [X(e / 255), X(n / 255), X(r / 255), 'rg'].join(' '), i && 0 === i.a && (o = ['255', '255', '255', 'rg'].join(' '))) : o = 'string' == typeof e ? [e, n, r, i, 'k'].join(' ') : [X(e), X(n), X(r), X(i), 'k'].join(' '), G(o), this;
      }, H.setTextColor = function(t, e, n) {
        if ('string' == typeof t && /^#[0-9A-Fa-f]{6}$/.test(t)) {
          var r = parseInt(t.substr(1), 16);
          t = r >> 16 & 255, e = r >> 8 & 255, n = 255 & r;
        }
        return _ = 0 === t && 0 === e && 0 === n || 'undefined' == typeof e ? V(t / 255) + ' g' : [V(t / 255), V(e / 255), V(n / 255), 'rg'].join(' '), this;
      }, H.CapJoinStyles = {0:0, butt:0, but:0, miter:0, 1:1, round:1, rounded:1, circle:1, 2:2, projecting:2, project:2, square:2, bevel:2}, H.setLineCap = function(t) {
        var e = this.CapJoinStyles[t];
        if (void 0 === e) {
          throw new Error("Line cap style of '" + t + "' is not recognized. See or extend .CapJoinStyles property for valid styles");
        }
        return N = e, G(e + ' J'), this;
      }, H.setLineJoin = function(t) {
        var e = this.CapJoinStyles[t];
        if (void 0 === e) {
          throw new Error("Line join style of '" + t + "' is not recognized. See or extend .CapJoinStyles property for valid styles");
        }
        return L = e, G(e + ' j'), this;
      }, H.output = At, H.save = function(t) {
        H.output('save', t);
      };
      for (var St in r.API) {
        r.API.hasOwnProperty(St) && ('events' === St && r.API.events.length ? !function(t, e) {
          var n, r, i;
          for (i = e.length - 1; i !== -1; i--) {
            n = e[i][0], r = e[i][1], t.subscribe.apply(t, [n].concat('function' == typeof r ? [r] : r));
          }
        }(W, r.API.events) : H[St] = r.API[St]);
      }
      return lt(), d = 'F1', wt(u, c), W.publish('initialized'), H;
    }
    var o = '1.3', s = {a0:[2383.94, 3370.39], a1:[1683.78, 2383.94], a2:[1190.55, 1683.78], a3:[841.89, 1190.55], a4:[595.28, 841.89], a5:[419.53, 595.28], a6:[297.64, 419.53], a7:[209.76, 297.64], a8:[147.4, 209.76], a9:[104.88, 147.4], a10:[73.7, 104.88], b0:[2834.65, 4008.19], b1:[2004.09, 2834.65], b2:[1417.32, 2004.09], b3:[1000.63, 1417.32], b4:[708.66, 1000.63], b5:[498.9, 708.66], b6:[354.33, 498.9], b7:[249.45, 354.33], b8:[175.75, 249.45], b9:[124.72, 175.75], b10:[87.87, 124.72], c0:[2599.37, 
    3676.54], c1:[1836.85, 2599.37], c2:[1298.27, 1836.85], c3:[918.43, 1298.27], c4:[649.13, 918.43], c5:[459.21, 649.13], c6:[323.15, 459.21], c7:[229.61, 323.15], c8:[161.57, 229.61], c9:[113.39, 161.57], c10:[79.37, 113.39], dl:[311.81, 623.62], letter:[612, 792], 'government-letter':[576, 756], legal:[612, 1008], 'junior-legal':[576, 360], ledger:[1224, 792], tabloid:[792, 1224], 'credit-card':[153, 243]};
    return r.API = {events:[]}, r.version = '1.x-master', 'function' == typeof define && define.amd ? define('jsPDF', function() {
      return r;
    }) : 'undefined' != typeof module && module.exports ? module.exports = r : e.jsPDF = r, r;
  }('undefined' != typeof self && self || 'undefined' != typeof window && window || void 0));
  (window.AcroForm = function(t) {
    var n = window.AcroForm;
    n.scale = function(t) {
      return t * (r.internal.scaleFactor / 1);
    }, n.antiScale = function(t) {
      return 1 / r.internal.scaleFactor * t;
    };
    var r = {fields:[], xForms:[], acroFormDictionaryRoot:null, printedOut:!1, internal:null};
    e.API.acroformPlugin = r;
    var i = function() {
      for (var t in this.acroformPlugin.acroFormDictionaryRoot.Fields) {
        var e = this.acroformPlugin.acroFormDictionaryRoot.Fields[t];
        e.hasAnnotation && a.call(this, e);
      }
    }, o = function() {
      if (this.acroformPlugin.acroFormDictionaryRoot) {
        throw new Error('Exception while creating AcroformDictionary');
      }
      this.acroformPlugin.acroFormDictionaryRoot = new n.AcroFormDictionary, this.acroformPlugin.internal = this.internal, this.acroformPlugin.acroFormDictionaryRoot._eventID = this.internal.events.subscribe('postPutResources', l), this.internal.events.subscribe('buildDocument', i), this.internal.events.subscribe('putCatalog', c), this.internal.events.subscribe('postPutPages', u);
    }, a = function(t) {
      var n = {type:'reference', object:t};
      e.API.annotationPlugin.annotations[this.internal.getPageInfo(t.page).pageNumber].push(n);
    }, s = function(t) {
      this.acroformPlugin.printedOut && (this.acroformPlugin.printedOut = !1, this.acroformPlugin.acroFormDictionaryRoot = null), this.acroformPlugin.acroFormDictionaryRoot || o.call(this), this.acroformPlugin.acroFormDictionaryRoot.Fields.push(t);
    }, c = function() {
      'undefined' != typeof this.acroformPlugin.acroFormDictionaryRoot ? this.internal.write('/AcroForm ' + this.acroformPlugin.acroFormDictionaryRoot.objId + ' 0 R') : console.log('Root missing...');
    }, l = function() {
      this.internal.events.unsubscribe(this.acroformPlugin.acroFormDictionaryRoot._eventID), delete this.acroformPlugin.acroFormDictionaryRoot._eventID, this.acroformPlugin.printedOut = !0;
    }, u = function(t) {
      var e = !t;
      t || (this.internal.newObjectDeferredBegin(this.acroformPlugin.acroFormDictionaryRoot.objId), this.internal.out(this.acroformPlugin.acroFormDictionaryRoot.getString()));
      var t = t || this.acroformPlugin.acroFormDictionaryRoot.Kids;
      for (var r in t) {
        var i = t[r], o = i.Rect;
        i.Rect && (i.Rect = n.internal.calculateCoordinates.call(this, i.Rect)), this.internal.newObjectDeferredBegin(i.objId);
        var a = '';
        if (a += i.objId + ' 0 obj\n', a += '\x3c\x3c\n' + i.getContent(), i.Rect = o, i.hasAppearanceStream && !i.appearanceStreamContent) {
          var s = n.internal.calculateAppearanceStream.call(this, i);
          a += '/AP \x3c\x3c /N ' + s + ' \x3e\x3e\n', this.acroformPlugin.xForms.push(s);
        }
        if (i.appearanceStreamContent) {
          a += '/AP \x3c\x3c ';
          for (var c in i.appearanceStreamContent) {
            var l = i.appearanceStreamContent[c];
            if (a += '/' + c + ' ', a += '\x3c\x3c ', Object.keys(l).length >= 1 || Array.isArray(l)) {
              for (var r in l) {
                var u = l[r];
                'function' == typeof u && (u = u.call(this, i)), a += '/' + r + ' ' + u + ' ', this.acroformPlugin.xForms.indexOf(u) >= 0 || this.acroformPlugin.xForms.push(u);
              }
            } else {
              var u = l;
              'function' == typeof u && (u = u.call(this, i)), a += '/' + r + ' ' + u + ' \n', this.acroformPlugin.xForms.indexOf(u) >= 0 || this.acroformPlugin.xForms.push(u);
            }
            a += ' \x3e\x3e\n';
          }
          a += '\x3e\x3e\n';
        }
        a += '\x3e\x3e\nendobj\n', this.internal.out(a);
      }
      e && h.call(this, this.acroformPlugin.xForms);
    }, h = function(t) {
      for (var e in t) {
        var n = e, r = t[e];
        this.internal.newObjectDeferredBegin(r && r.objId);
        var i = '';
        i += r ? r.getString() : '', this.internal.out(i), delete t[n];
      }
    };
    t.addField = function(t) {
      return t instanceof n.TextField ? d.call(this, t) : t instanceof n.ChoiceField ? p.call(this, t) : t instanceof n.Button ? f.call(this, t) : t instanceof n.ChildClass ? s.call(this, t) : t && s.call(this, t), t.page = this.acroformPlugin.internal.getCurrentPageInfo().pageNumber, this;
    };
    var f = function(t) {
      var t = t || new n.Field;
      t.FT = '/Btn';
      var e = t.Ff || 0;
      t.pushbutton && (e = n.internal.setBitPosition(e, 17), delete t.pushbutton), t.radio && (e = n.internal.setBitPosition(e, 16), delete t.radio), t.noToggleToOff && (e = n.internal.setBitPosition(e, 15)), t.Ff = e, s.call(this, t);
    }, d = function(t) {
      var t = t || new n.Field;
      t.FT = '/Tx';
      var e = t.Ff || 0;
      t.multiline && (e = 4096 | e), t.password && (e = 8192 | e), t.fileSelect && (e |= 1 << 20), t.doNotSpellCheck && (e |= 1 << 22), t.doNotScroll && (e |= 1 << 23), t.Ff = t.Ff || e, s.call(this, t);
    }, p = function(t) {
      var e = t || new n.Field;
      e.FT = '/Ch';
      var r = e.Ff || 0;
      e.combo && (r = n.internal.setBitPosition(r, 18), delete e.combo), e.edit && (r = n.internal.setBitPosition(r, 19), delete e.edit), e.sort && (r = n.internal.setBitPosition(r, 20), delete e.sort), e.multiSelect && this.internal.getPDFVersion() >= 1.4 && (r = n.internal.setBitPosition(r, 22), delete e.multiSelect), e.doNotSpellCheck && this.internal.getPDFVersion() >= 1.4 && (r = n.internal.setBitPosition(r, 23), delete e.doNotSpellCheck), e.Ff = r, s.call(this, e);
    };
  })(e.API);
  var n = window.AcroForm;
  n.internal = {}, n.createFormXObject = function(t) {
    var e = new n.FormXObject, r = n.Appearance.internal.getHeight(t) || 0, i = n.Appearance.internal.getWidth(t) || 0;
    return e.BBox = [0, 0, i, r], e;
  }, n.Appearance = {CheckBox:{createAppearanceStream:function() {
    var t = {N:{On:n.Appearance.CheckBox.YesNormal}, D:{On:n.Appearance.CheckBox.YesPushDown, Off:n.Appearance.CheckBox.OffPushDown}};
    return t;
  }, createMK:function() {
    return '\x3c\x3c /CA (3)\x3e\x3e';
  }, YesPushDown:function(t) {
    var e = n.createFormXObject(t), r = '';
    t.Q = 1;
    var i = n.internal.calculateX(t, '3', 'ZapfDingbats', 50);
    return r += '0.749023 g\n             0 0 ' + n.Appearance.internal.getWidth(t) + ' ' + n.Appearance.internal.getHeight(t) + ' re\n             f\n             BMC\n             q\n             0 0 1 rg\n             /F13 ' + i.fontSize + ' Tf 0 g\n             BT\n', r += i.text, r += 'ET\n             Q\n             EMC\n', e.stream = r, e;
  }, YesNormal:function(t) {
    var e = n.createFormXObject(t), r = '';
    t.Q = 1;
    var i = n.internal.calculateX(t, '3', 'ZapfDingbats', 0.9 * n.Appearance.internal.getHeight(t));
    return r += '1 g\n0 0 ' + n.Appearance.internal.getWidth(t) + ' ' + n.Appearance.internal.getHeight(t) + ' re\nf\nq\n0 0 1 rg\n0 0 ' + (n.Appearance.internal.getWidth(t) - 1) + ' ' + (n.Appearance.internal.getHeight(t) - 1) + ' re\nW\nn\n0 g\nBT\n/F13 ' + i.fontSize + ' Tf 0 g\n', r += i.text, r += 'ET\n             Q\n', e.stream = r, e;
  }, OffPushDown:function(t) {
    var e = n.createFormXObject(t), r = '';
    return r += '0.749023 g\n            0 0 ' + n.Appearance.internal.getWidth(t) + ' ' + n.Appearance.internal.getHeight(t) + ' re\n            f\n', e.stream = r, e;
  }}, RadioButton:{Circle:{createAppearanceStream:function(t) {
    var e = {D:{Off:n.Appearance.RadioButton.Circle.OffPushDown}, N:{}};
    return e.N[t] = n.Appearance.RadioButton.Circle.YesNormal, e.D[t] = n.Appearance.RadioButton.Circle.YesPushDown, e;
  }, createMK:function() {
    return '\x3c\x3c /CA (l)\x3e\x3e';
  }, YesNormal:function(t) {
    var e = n.createFormXObject(t), r = '', i = n.Appearance.internal.getWidth(t) <= n.Appearance.internal.getHeight(t) ? n.Appearance.internal.getWidth(t) / 4 : n.Appearance.internal.getHeight(t) / 4;
    i *= 0.9;
    var o = n.Appearance.internal.Bezier_C;
    return r += 'q\n1 0 0 1 ' + n.Appearance.internal.getWidth(t) / 2 + ' ' + n.Appearance.internal.getHeight(t) / 2 + ' cm\n' + i + ' 0 m\n' + i + ' ' + i * o + ' ' + i * o + ' ' + i + ' 0 ' + i + ' c\n-' + i * o + ' ' + i + ' -' + i + ' ' + i * o + ' -' + i + ' 0 c\n-' + i + ' -' + i * o + ' -' + i * o + ' -' + i + ' 0 -' + i + ' c\n' + i * o + ' -' + i + ' ' + i + ' -' + i * o + ' ' + i + ' 0 c\nf\nQ\n', e.stream = r, e;
  }, YesPushDown:function(t) {
    var e = n.createFormXObject(t), r = '', i = n.Appearance.internal.getWidth(t) <= n.Appearance.internal.getHeight(t) ? n.Appearance.internal.getWidth(t) / 4 : n.Appearance.internal.getHeight(t) / 4;
    i *= 0.9;
    var o = 2 * i, a = o * n.Appearance.internal.Bezier_C, s = i * n.Appearance.internal.Bezier_C;
    return r += '0.749023 g\n            q\n           1 0 0 1 ' + n.Appearance.internal.getWidth(t) / 2 + ' ' + n.Appearance.internal.getHeight(t) / 2 + ' cm\n' + o + ' 0 m\n' + o + ' ' + a + ' ' + a + ' ' + o + ' 0 ' + o + ' c\n-' + a + ' ' + o + ' -' + o + ' ' + a + ' -' + o + ' 0 c\n-' + o + ' -' + a + ' -' + a + ' -' + o + ' 0 -' + o + ' c\n' + a + ' -' + o + ' ' + o + ' -' + a + ' ' + o + ' 0 c\n            f\n            Q\n            0 g\n            q\n            1 0 0 1 ' + n.Appearance.internal.getWidth(t) / 
    2 + ' ' + n.Appearance.internal.getHeight(t) / 2 + ' cm\n' + i + ' 0 m\n' + i + ' ' + s + ' ' + s + ' ' + i + ' 0 ' + i + ' c\n-' + s + ' ' + i + ' -' + i + ' ' + s + ' -' + i + ' 0 c\n-' + i + ' -' + s + ' -' + s + ' -' + i + ' 0 -' + i + ' c\n' + s + ' -' + i + ' ' + i + ' -' + s + ' ' + i + ' 0 c\n            f\n            Q\n', e.stream = r, e;
  }, OffPushDown:function(t) {
    var e = n.createFormXObject(t), r = '', i = n.Appearance.internal.getWidth(t) <= n.Appearance.internal.getHeight(t) ? n.Appearance.internal.getWidth(t) / 4 : n.Appearance.internal.getHeight(t) / 4;
    i *= 0.9;
    var o = 2 * i, a = o * n.Appearance.internal.Bezier_C;
    return r += '0.749023 g\n            q\n 1 0 0 1 ' + n.Appearance.internal.getWidth(t) / 2 + ' ' + n.Appearance.internal.getHeight(t) / 2 + ' cm\n' + o + ' 0 m\n' + o + ' ' + a + ' ' + a + ' ' + o + ' 0 ' + o + ' c\n-' + a + ' ' + o + ' -' + o + ' ' + a + ' -' + o + ' 0 c\n-' + o + ' -' + a + ' -' + a + ' -' + o + ' 0 -' + o + ' c\n' + a + ' -' + o + ' ' + o + ' -' + a + ' ' + o + ' 0 c\n            f\n            Q\n', e.stream = r, e;
  }}, Cross:{createAppearanceStream:function(t) {
    var e = {D:{Off:n.Appearance.RadioButton.Cross.OffPushDown}, N:{}};
    return e.N[t] = n.Appearance.RadioButton.Cross.YesNormal, e.D[t] = n.Appearance.RadioButton.Cross.YesPushDown, e;
  }, createMK:function() {
    return '\x3c\x3c /CA (8)\x3e\x3e';
  }, YesNormal:function(t) {
    var e = n.createFormXObject(t), r = '', i = n.Appearance.internal.calculateCross(t);
    return r += 'q\n            1 1 ' + (n.Appearance.internal.getWidth(t) - 2) + ' ' + (n.Appearance.internal.getHeight(t) - 2) + ' re\n            W\n            n\n            ' + i.x1.x + ' ' + i.x1.y + ' m\n            ' + i.x2.x + ' ' + i.x2.y + ' l\n            ' + i.x4.x + ' ' + i.x4.y + ' m\n            ' + i.x3.x + ' ' + i.x3.y + ' l\n            s\n            Q\n', e.stream = r, e;
  }, YesPushDown:function(t) {
    var e = n.createFormXObject(t), r = n.Appearance.internal.calculateCross(t), i = '';
    return i += '0.749023 g\n            0 0 ' + n.Appearance.internal.getWidth(t) + ' ' + n.Appearance.internal.getHeight(t) + ' re\n            f\n            q\n            1 1 ' + (n.Appearance.internal.getWidth(t) - 2) + ' ' + (n.Appearance.internal.getHeight(t) - 2) + ' re\n            W\n            n\n            ' + r.x1.x + ' ' + r.x1.y + ' m\n            ' + r.x2.x + ' ' + r.x2.y + ' l\n            ' + r.x4.x + ' ' + r.x4.y + ' m\n            ' + r.x3.x + ' ' + r.x3.y + ' l\n            s\n            Q\n', 
    e.stream = i, e;
  }, OffPushDown:function(t) {
    var e = n.createFormXObject(t), r = '';
    return r += '0.749023 g\n            0 0 ' + n.Appearance.internal.getWidth(t) + ' ' + n.Appearance.internal.getHeight(t) + ' re\n            f\n', e.stream = r, e;
  }}}, createDefaultAppearanceStream:function(t) {
    var e = '';
    return e += '/Helv 0 Tf 0 g';
  }}, n.Appearance.internal = {Bezier_C:0.551915024494, calculateCross:function(t) {
    var e = function(t, e) {
      return t > e ? e : t;
    }, r = n.Appearance.internal.getWidth(t), i = n.Appearance.internal.getHeight(t), o = e(r, i), a = {x1:{x:(r - o) / 2, y:(i - o) / 2 + o}, x2:{x:(r - o) / 2 + o, y:(i - o) / 2}, x3:{x:(r - o) / 2, y:(i - o) / 2}, x4:{x:(r - o) / 2 + o, y:(i - o) / 2 + o}};
    return a;
  }}, n.Appearance.internal.getWidth = function(t) {
    return t.Rect[2];
  }, n.Appearance.internal.getHeight = function(t) {
    return t.Rect[3];
  }, n.internal.inherit = function(t, e) {
    Object.create || function(t) {
      var e = function() {
      };
      return e.prototype = t, new e;
    };
    t.prototype = Object.create(e.prototype), t.prototype.constructor = t;
  }, n.internal.arrayToPdfArray = function(t) {
    if (Array.isArray(t)) {
      var e = ' [';
      for (var n in t) {
        var r = t[n].toString();
        e += r, e += n < t.length - 1 ? ' ' : '';
      }
      return e += ']';
    }
  }, n.internal.toPdfString = function(t) {
    return t = t || '', 0 !== t.indexOf('(') && (t = '(' + t), ')' != t.substring(t.length - 1) && (t += '('), t;
  }, n.PDFObject = function() {
    var t;
    Object.defineProperty(this, 'objId', {get:function() {
      return t || (this.internal ? t = this.internal.newObjectDeferred() : e.API.acroformPlugin.internal && (t = e.API.acroformPlugin.internal.newObjectDeferred())), t || console.log("Couldn't create Object ID"), t;
    }, configurable:!1});
  }, n.PDFObject.prototype.toString = function() {
    return this.objId + ' 0 R';
  }, n.PDFObject.prototype.getString = function() {
    var t = this.objId + ' 0 obj\n\x3c\x3c', e = this.getContent();
    return t += e + '\x3e\x3e\n', this.stream && (t += 'stream\n', t += this.stream, t += 'endstream\n'), t += 'endobj\n';
  }, n.PDFObject.prototype.getContent = function() {
    var t = function(t) {
      var e = '', r = Object.keys(t).filter(function(t) {
        return 'content' != t && 'appearanceStreamContent' != t && '_' != t.substring(0, 1);
      });
      for (var i in r) {
        var o = r[i], a = t[o];
        a && (e += Array.isArray(a) ? '/' + o + ' ' + n.internal.arrayToPdfArray(a) + '\n' : a instanceof n.PDFObject ? '/' + o + ' ' + a.objId + ' 0 R\n' : '/' + o + ' ' + a + '\n');
      }
      return e;
    }, e = '';
    return e += t(this);
  }, n.FormXObject = function() {
    n.PDFObject.call(this), this.Type = '/XObject', this.Subtype = '/Form', this.FormType = 1, this.BBox, this.Matrix, this.Resources = '2 0 R', this.PieceInfo;
    var t;
    Object.defineProperty(this, 'Length', {enumerable:!0, get:function() {
      return void 0 !== t ? t.length : 0;
    }}), Object.defineProperty(this, 'stream', {enumerable:!1, set:function(e) {
      t = e;
    }, get:function() {
      return t ? t : null;
    }});
  }, n.internal.inherit(n.FormXObject, n.PDFObject), n.AcroFormDictionary = function() {
    n.PDFObject.call(this);
    var t = [];
    Object.defineProperty(this, 'Kids', {enumerable:!1, configurable:!0, get:function() {
      return t.length > 0 ? t : void 0;
    }}), Object.defineProperty(this, 'Fields', {enumerable:!0, configurable:!0, get:function() {
      return t;
    }}), this.DA;
  }, n.internal.inherit(n.AcroFormDictionary, n.PDFObject), n.Field = function() {
    n.PDFObject.call(this);
    var t;
    Object.defineProperty(this, 'Rect', {enumerable:!0, configurable:!1, get:function() {
      if (t) {
        var e = t;
        return e;
      }
    }, set:function(e) {
      t = e;
    }});
    var e = '';
    Object.defineProperty(this, 'FT', {enumerable:!0, set:function(t) {
      e = t;
    }, get:function() {
      return e;
    }});
    var r;
    Object.defineProperty(this, 'T', {enumerable:!0, configurable:!1, set:function(t) {
      r = t;
    }, get:function() {
      if (!r || r.length < 1) {
        if (this instanceof n.ChildClass) {
          return;
        }
        return '(FieldObject' + n.Field.FieldNum++ + ')';
      }
      return '(' == r.substring(0, 1) && r.substring(r.length - 1) ? r : '(' + r + ')';
    }});
    var i;
    Object.defineProperty(this, 'DA', {enumerable:!0, get:function() {
      if (i) {
        return '(' + i + ')';
      }
    }, set:function(t) {
      i = t;
    }});
    var o;
    Object.defineProperty(this, 'DV', {enumerable:!0, configurable:!0, get:function() {
      if (o) {
        return o;
      }
    }, set:function(t) {
      o = t;
    }}), Object.defineProperty(this, 'Type', {enumerable:!0, get:function() {
      return this.hasAnnotation ? '/Annot' : null;
    }}), Object.defineProperty(this, 'Subtype', {enumerable:!0, get:function() {
      return this.hasAnnotation ? '/Widget' : null;
    }}), this.BG, Object.defineProperty(this, 'hasAnnotation', {enumerable:!1, get:function() {
      return !!(this.Rect || this.BC || this.BG);
    }}), Object.defineProperty(this, 'hasAppearanceStream', {enumerable:!1, configurable:!0, writable:!0}), Object.defineProperty(this, 'page', {enumerable:!1, configurable:!0, writable:!0});
  }, n.Field.FieldNum = 0, n.internal.inherit(n.Field, n.PDFObject), n.ChoiceField = function() {
    n.Field.call(this), this.FT = '/Ch', this.Opt = [], this.V = '()', this.TI = 0, this.combo = !1, Object.defineProperty(this, 'edit', {enumerable:!0, set:function(t) {
      1 == t ? (this._edit = !0, this.combo = !0) : this._edit = !1;
    }, get:function() {
      return !!this._edit && this._edit;
    }, configurable:!1}), this.hasAppearanceStream = !0, Object.defineProperty(this, 'V', {get:function() {
      n.internal.toPdfString();
    }});
  }, n.internal.inherit(n.ChoiceField, n.Field), window.ChoiceField = n.ChoiceField, n.ListBox = function() {
    n.ChoiceField.call(this);
  }, n.internal.inherit(n.ListBox, n.ChoiceField), window.ListBox = n.ListBox, n.ComboBox = function() {
    n.ListBox.call(this), this.combo = !0;
  }, n.internal.inherit(n.ComboBox, n.ListBox), window.ComboBox = n.ComboBox, n.EditBox = function() {
    n.ComboBox.call(this), this.edit = !0;
  }, n.internal.inherit(n.EditBox, n.ComboBox), window.EditBox = n.EditBox, n.Button = function() {
    n.Field.call(this), this.FT = '/Btn';
  }, n.internal.inherit(n.Button, n.Field), window.Button = n.Button, n.PushButton = function() {
    n.Button.call(this), this.pushbutton = !0;
  }, n.internal.inherit(n.PushButton, n.Button), window.PushButton = n.PushButton, n.RadioButton = function() {
    n.Button.call(this), this.radio = !0;
    var t = [];
    Object.defineProperty(this, 'Kids', {enumerable:!0, get:function() {
      if (t.length > 0) {
        return t;
      }
    }}), Object.defineProperty(this, '__Kids', {get:function() {
      return t;
    }});
    var e;
    Object.defineProperty(this, 'noToggleToOff', {enumerable:!1, get:function() {
      return e;
    }, set:function(t) {
      e = t;
    }});
  }, n.internal.inherit(n.RadioButton, n.Button), window.RadioButton = n.RadioButton, n.ChildClass = function(t, e) {
    n.Field.call(this), this.Parent = t, this._AppearanceType = n.Appearance.RadioButton.Circle, this.appearanceStreamContent = this._AppearanceType.createAppearanceStream(e), this.F = n.internal.setBitPosition(this.F, 3, 1), this.MK = this._AppearanceType.createMK(), this.AS = '/Off', this._Name = e;
  }, n.internal.inherit(n.ChildClass, n.Field), n.RadioButton.prototype.setAppearance = function(t) {
    if (!('createAppearanceStream' in t && 'createMK' in t)) {
      return void console.log("Couldn't assign Appearance to RadioButton. Appearance was Invalid!");
    }
    for (var e in this.__Kids) {
      var n = this.__Kids[e];
      n.appearanceStreamContent = t.createAppearanceStream(n._Name), n.MK = t.createMK();
    }
  }, n.RadioButton.prototype.createOption = function(t) {
    var r = this, i = (this.__Kids.length, new n.ChildClass(r, t));
    return this.__Kids.push(i), e.API.addField(i), i;
  }, n.CheckBox = function() {
    Button.call(this), this.appearanceStreamContent = n.Appearance.CheckBox.createAppearanceStream(), this.MK = n.Appearance.CheckBox.createMK(), this.AS = '/On', this.V = '/On';
  }, n.internal.inherit(n.CheckBox, n.Button), window.CheckBox = n.CheckBox, n.TextField = function() {
    n.Field.call(this), this.DA = n.Appearance.createDefaultAppearanceStream(), this.F = 4;
    var t;
    Object.defineProperty(this, 'V', {get:function() {
      return t ? '(' + t + ')' : t;
    }, enumerable:!0, set:function(e) {
      t = e;
    }});
    var e;
    Object.defineProperty(this, 'DV', {get:function() {
      return e ? '(' + e + ')' : e;
    }, enumerable:!0, set:function(t) {
      e = t;
    }});
    var r = !1;
    Object.defineProperty(this, 'multiline', {enumerable:!1, get:function() {
      return r;
    }, set:function(t) {
      r = t;
    }});
    var i = !1;
    Object.defineProperty(this, 'MaxLen', {enumerable:!0, get:function() {
      return i;
    }, set:function(t) {
      i = t;
    }}), Object.defineProperty(this, 'hasAppearanceStream', {enumerable:!1, get:function() {
      return this.V || this.DV;
    }});
  }, n.internal.inherit(n.TextField, n.Field), window.TextField = n.TextField, n.PasswordField = function() {
    TextField.call(this), Object.defineProperty(this, 'password', {value:!0, enumerable:!1, configurable:!1, writable:!1});
  }, n.internal.inherit(n.PasswordField, n.TextField), window.PasswordField = n.PasswordField, n.internal.calculateFontSpace = function(t, e, r) {
    var r = r || 'helvetica', i = n.internal.calculateFontSpace.canvas || (n.internal.calculateFontSpace.canvas = document.createElement('canvas')), o = i.getContext('2d');
    o.save();
    var a = e + ' ' + r;
    o.font = a;
    var s = o.measureText(t);
    o.fontcolor = 'black';
    var o = i.getContext('2d');
    s.height = 1.5 * o.measureText('3').width, o.restore();
    s.width;
    return s;
  }, n.internal.calculateX = function(t, e, r, i) {
    var i = i || 12, r = r || 'helvetica', o = {text:'', fontSize:''};
    e = '(' == e.substr(0, 1) ? e.substr(1) : e, e = ')' == e.substr(e.length - 1) ? e.substr(0, e.length - 1) : e;
    var a = e.split(' '), s = i, c = 2, l = 2, u = n.Appearance.internal.getHeight(t) || 0;
    u = u < 0 ? -u : u;
    var h = n.Appearance.internal.getWidth(t) || 0;
    h = h < 0 ? -h : h;
    var f = function(t, e, i) {
      if (t + 1 < a.length) {
        var o = e + ' ' + a[t + 1], s = n.internal.calculateFontSpace(o, i + 'px', r).width, c = h - 2 * l;
        return s <= c;
      }
      return !1;
    };
    s++;
    t: for (;;) {
      var e = '';
      s--;
      var d = n.internal.calculateFontSpace('3', s + 'px', r).height, p = t.multiline ? u - s : (u - d) / 2;
      p += c;
      var g = -l, m = g, w = p, y = 0, v = 0, b = 0;
      if (0 == s) {
        s = 12, e = '(...) Tj\n', e += '% Width of Text: ' + n.internal.calculateFontSpace(e, '1px').width + ', FieldWidth:' + h + '\n';
        break;
      }
      b = n.internal.calculateFontSpace(a[0] + ' ', s + 'px', r).width;
      var x = '', k = 0;
      for (var _ in a) {
        x += a[_] + ' ', x = ' ' == x.substr(x.length - 1) ? x.substr(0, x.length - 1) : x;
        var C = parseInt(_);
        b = n.internal.calculateFontSpace(x + ' ', s + 'px', r).width;
        var A = f(C, x, s), S = _ >= a.length - 1;
        if (!A || S) {
          if (A || S) {
            if (S) {
              v = C;
            } else {
              if (t.multiline && (d + c) * (k + 2) + c > u) {
                continue t;
              }
            }
          } else {
            if (!t.multiline) {
              continue t;
            }
            if ((d + c) * (k + 2) + c > u) {
              continue t;
            }
            v = C;
          }
          for (var q = '', T = y; T <= v; T++) {
            q += a[T] + ' ';
          }
          switch(q = ' ' == q.substr(q.length - 1) ? q.substr(0, q.length - 1) : q, b = n.internal.calculateFontSpace(q, s + 'px', r).width, t.Q) {
            case 2:
              g = h - b - l;
              break;
            case 1:
              g = (h - b) / 2;
              break;
            case 0:
            default:
              g = l;
          }
          e += g + ' ' + w + ' Td\n', e += '(' + q + ') Tj\n', e += -g + ' 0 Td\n', w = -(s + c), m = g, b = 0, y = v + 1, k++, x = '';
        } else {
          x += ' ';
        }
      }
      break;
    }
    return o.text = e, o.fontSize = s, o;
  }, n.internal.calculateAppearanceStream = function(t) {
    if (t.appearanceStreamContent) {
      return t.appearanceStreamContent;
    }
    if (t.V || t.DV) {
      var e = '', r = t.V || t.DV, i = n.internal.calculateX(t, r);
      e += '/Tx BMC\nq\n/F1 ' + i.fontSize + ' Tf\n1 0 0 1 0 0 Tm\n', e += 'BT\n', e += i.text, e += 'ET\n', e += 'Q\nEMC\n';
      var o = new n.createFormXObject(t);
      o.stream = e;
      return o;
    }
  }, n.internal.calculateCoordinates = function(t, e, r, i) {
    var o = {};
    if (this.internal) {
      var a = function(t) {
        return t * this.internal.scaleFactor;
      };
      Array.isArray(t) ? (t[0] = n.scale(t[0]), t[1] = n.scale(t[1]), t[2] = n.scale(t[2]), t[3] = n.scale(t[3]), o.lowerLeft_X = t[0] || 0, o.lowerLeft_Y = a.call(this, this.internal.pageSize.height) - t[3] - t[1] || 0, o.upperRight_X = t[0] + t[2] || 0, o.upperRight_Y = a.call(this, this.internal.pageSize.height) - t[1] || 0) : (t = n.scale(t), e = n.scale(e), r = n.scale(r), i = n.scale(i), o.lowerLeft_X = t || 0, o.lowerLeft_Y = this.internal.pageSize.height - e || 0, o.upperRight_X = t + r || 
      0, o.upperRight_Y = this.internal.pageSize.height - e + i || 0);
    } else {
      Array.isArray(t) ? (o.lowerLeft_X = t[0] || 0, o.lowerLeft_Y = t[1] || 0, o.upperRight_X = t[0] + t[2] || 0, o.upperRight_Y = t[1] + t[3] || 0) : (o.lowerLeft_X = t || 0, o.lowerLeft_Y = e || 0, o.upperRight_X = t + r || 0, o.upperRight_Y = e + i || 0);
    }
    return [o.lowerLeft_X, o.lowerLeft_Y, o.upperRight_X, o.upperRight_Y];
  }, n.internal.calculateColor = function(t, e, n) {
    var r = new Array(3);
    return r.r = 0 | t, r.g = 0 | e, r.b = 0 | n, r;
  }, n.internal.getBitPosition = function(t, e) {
    t = t || 0;
    var n = 1;
    return n <<= e - 1, t | n;
  }, n.internal.setBitPosition = function(t, e, n) {
    t = t || 0, n = n || 1;
    var r = 1;
    if (r <<= e - 1, 1 == n) {
      var t = t | r;
    } else {
      var t = t & ~r;
    }
    return t;
  }, function(t) {
    t.addHTML = function(t, e, n, r, i) {
      if ('undefined' == typeof html2canvas && 'undefined' == typeof rasterizeHTML) {
        throw new Error('You need either https://github.com/niklasvh/html2canvas or https://github.com/cburgmer/rasterizeHTML.js');
      }
      'number' != typeof e && (r = e, i = n), 'function' == typeof r && (i = r, r = null);
      var o = this.internal, a = o.scaleFactor, s = o.pageSize.width, c = o.pageSize.height;
      if (r = r || {}, r.onrendered = function(t) {
        e = parseInt(e) || 0, n = parseInt(n) || 0;
        var o = r.dim || {}, l = o.h || 0, u = o.w || Math.min(s, t.width / a) - e, h = 'JPEG';
        if (r.format && (h = r.format), t.height > c && r.pagesplit) {
          var f = function() {
            for (var r = 0;;) {
              var o = document.createElement('canvas');
              o.width = Math.min(s * a, t.width), o.height = Math.min(c * a, t.height - r);
              var l = o.getContext('2d');
              l.drawImage(t, 0, r, t.width, o.height, 0, 0, o.width, o.height);
              var f = [o, e, r ? 0 : n, o.width / a, o.height / a, h, null, 'SLOW'];
              if (this.addImage.apply(this, f), r += o.height, r >= t.height) {
                break;
              }
              this.addPage();
            }
            i(u, r, null, f);
          }.bind(this);
          if ('CANVAS' === t.nodeName) {
            var d = new Image;
            d.onload = f, d.src = t.toDataURL('image/png'), t = d;
          } else {
            f();
          }
        } else {
          var p = Math.random().toString(35), g = [t, e, n, u, l, h, p, 'SLOW'];
          this.addImage.apply(this, g), i(u, l, p, g);
        }
      }.bind(this), 'undefined' != typeof html2canvas && !r.rstz) {
        return html2canvas(t, r);
      }
      if ('undefined' != typeof rasterizeHTML) {
        var l = 'drawDocument';
        return 'string' == typeof t && (l = /^http/.test(t) ? 'drawURL' : 'drawHTML'), r.width = r.width || s * a, rasterizeHTML[l](t, void 0, r).then(function(t) {
          r.onrendered(t.image);
        }, function(t) {
          i(null, t);
        });
      }
      return null;
    };
  }(e.API), function(e) {
    var n = 'addImage_', r = ['jpeg', 'jpg', 'png'], i = function t(e) {
      var n = this.internal.newObject(), r = this.internal.write, i = this.internal.putStream;
      if (e.n = n, r('\x3c\x3c/Type /XObject'), r('/Subtype /Image'), r('/Width ' + e.w), r('/Height ' + e.h), e.cs === this.color_spaces.INDEXED ? r('/ColorSpace [/Indexed /DeviceRGB ' + (e.pal.length / 3 - 1) + ' ' + ('smask' in e ? n + 2 : n + 1) + ' 0 R]') : (r('/ColorSpace /' + e.cs), e.cs === this.color_spaces.DEVICE_CMYK && r('/Decode [1 0 1 0 1 0 1 0]')), r('/BitsPerComponent ' + e.bpc), 'f' in e && r('/Filter /' + e.f), 'dp' in e && r('/DecodeParms \x3c\x3c' + e.dp + '\x3e\x3e'), 'trns' in 
      e && e.trns.constructor == Array) {
        for (var o = '', a = 0, s = e.trns.length; a < s; a++) {
          o += e.trns[a] + ' ' + e.trns[a] + ' ';
        }
        r('/Mask [' + o + ']');
      }
      if ('smask' in e && r('/SMask ' + (n + 1) + ' 0 R'), r('/Length ' + e.data.length + '\x3e\x3e'), i(e.data), r('endobj'), 'smask' in e) {
        var c = '/Predictor ' + e.p + ' /Colors 1 /BitsPerComponent ' + e.bpc + ' /Columns ' + e.w, l = {w:e.w, h:e.h, cs:'DeviceGray', bpc:e.bpc, dp:c, data:e.smask};
        'f' in e && (l.f = e.f), t.call(this, l);
      }
      e.cs === this.color_spaces.INDEXED && (this.internal.newObject(), r('\x3c\x3c /Length ' + e.pal.length + '\x3e\x3e'), i(this.arrayBufferToBinaryString(new Uint8Array(e.pal))), r('endobj'));
    }, o = function() {
      var t = this.internal.collections[n + 'images'];
      for (var e in t) {
        i.call(this, t[e]);
      }
    }, a = function() {
      var t, e = this.internal.collections[n + 'images'], r = this.internal.write;
      for (var i in e) {
        t = e[i], r('/I' + t.i, t.n, '0', 'R');
      }
    }, s = function(t) {
      return t && 'string' == typeof t && (t = t.toUpperCase()), t in e.image_compression ? t : e.image_compression.NONE;
    }, c = function() {
      var t = this.internal.collections[n + 'images'];
      return t || (this.internal.collections[n + 'images'] = t = {}, this.internal.events.subscribe('putResources', o), this.internal.events.subscribe('putXobjectDict', a)), t;
    }, l = function(t) {
      var e = 0;
      return t && (e = Object.keys ? Object.keys(t).length : function(t) {
        var e = 0;
        for (var n in t) {
          t.hasOwnProperty(n) && e++;
        }
        return e;
      }(t)), e;
    }, u = function(t) {
      return 'undefined' == typeof t || null === t;
    }, h = function(t) {
      return 'string' == typeof t && e.sHashCode(t);
    }, f = function(t) {
      return r.indexOf(t) === -1;
    }, d = function(t) {
      return 'function' != typeof e['process' + t.toUpperCase()];
    }, p = function(e) {
      return 'object' === ('undefined' == typeof e ? 'undefined' : t(e)) && 1 === e.nodeType;
    }, g = function(e, n, r) {
      if ('IMG' === e.nodeName && e.hasAttribute('src')) {
        var i = '' + e.getAttribute('src');
        if (!r && 0 === i.indexOf('data:image/')) {
          return i;
        }
        !n && /\.png(?:[?#].*)?$/i.test(i) && (n = 'png');
      }
      if ('CANVAS' === e.nodeName) {
        var o = e;
      } else {
        var o = document.createElement('canvas');
        o.width = e.clientWidth || e.width, o.height = e.clientHeight || e.height;
        var a = o.getContext('2d');
        if (!a) {
          throw 'addImage requires canvas to be supported by browser.';
        }
        if (r) {
          var s, c, l, u, h, f, d, p, g = Math.PI / 180;
          'object' === ('undefined' == typeof r ? 'undefined' : t(r)) && (s = r.x, c = r.y, l = r.bg, r = r.angle), p = r * g, u = Math.abs(Math.cos(p)), h = Math.abs(Math.sin(p)), f = o.width, d = o.height, o.width = d * h + f * u, o.height = d * u + f * h, isNaN(s) && (s = o.width / 2), isNaN(c) && (c = o.height / 2), a.clearRect(0, 0, o.width, o.height), a.fillStyle = l || 'white', a.fillRect(0, 0, o.width, o.height), a.save(), a.translate(s, c), a.rotate(p), a.drawImage(e, -(f / 2), -(d / 2)), 
          a.rotate(-p), a.translate(-s, -c), a.restore();
        } else {
          a.drawImage(e, 0, 0, o.width, o.height);
        }
      }
      return o.toDataURL('png' == ('' + n).toLowerCase() ? 'image/png' : 'image/jpeg');
    }, m = function(t, e) {
      var n;
      if (e) {
        for (var r in e) {
          if (t === e[r].alias) {
            n = e[r];
            break;
          }
        }
      }
      return n;
    }, w = function(t, e, n) {
      return t || e || (t = -96, e = -96), t < 0 && (t = -1 * n.w * 72 / t / this.internal.scaleFactor), e < 0 && (e = -1 * n.h * 72 / e / this.internal.scaleFactor), 0 === t && (t = e * n.w / n.h), 0 === e && (e = t * n.h / n.w), [t, e];
    }, y = function(t, e, n, r, i, o, a) {
      var s = w.call(this, n, r, i), c = this.internal.getCoordinateString, l = this.internal.getVerticalCoordinateString;
      n = s[0], r = s[1], a[o] = i, this.internal.write('q', c(n), '0 0', c(r), c(t), l(e + r), 'cm /I' + i.i, 'Do Q');
    };
    e.color_spaces = {DEVICE_RGB:'DeviceRGB', DEVICE_GRAY:'DeviceGray', DEVICE_CMYK:'DeviceCMYK', CAL_GREY:'CalGray', CAL_RGB:'CalRGB', LAB:'Lab', ICC_BASED:'ICCBased', INDEXED:'Indexed', PATTERN:'Pattern', SEPARATION:'Separation', DEVICE_N:'DeviceN'}, e.decode = {DCT_DECODE:'DCTDecode', FLATE_DECODE:'FlateDecode', LZW_DECODE:'LZWDecode', JPX_DECODE:'JPXDecode', JBIG2_DECODE:'JBIG2Decode', ASCII85_DECODE:'ASCII85Decode', ASCII_HEX_DECODE:'ASCIIHexDecode', RUN_LENGTH_DECODE:'RunLengthDecode', CCITT_FAX_DECODE:'CCITTFaxDecode'}, 
    e.image_compression = {NONE:'NONE', FAST:'FAST', MEDIUM:'MEDIUM', SLOW:'SLOW'}, e.sHashCode = function(t) {
      return Array.prototype.reduce && t.split('').reduce(function(t, e) {
        return t = (t << 5) - t + e.charCodeAt(0), t & t;
      }, 0);
    }, e.isString = function(t) {
      return 'string' == typeof t;
    }, e.extractInfoFromBase64DataURI = function(t) {
      return /^data:([\w]+?\/([\w]+?));base64,(.+?)$/g.exec(t);
    }, e.supportsArrayBuffer = function() {
      return 'undefined' != typeof ArrayBuffer && 'undefined' != typeof Uint8Array;
    }, e.isArrayBuffer = function(t) {
      return !!this.supportsArrayBuffer() && t instanceof ArrayBuffer;
    }, e.isArrayBufferView = function(t) {
      return !!this.supportsArrayBuffer() && ('undefined' != typeof Uint32Array && (t instanceof Int8Array || t instanceof Uint8Array || 'undefined' != typeof Uint8ClampedArray && t instanceof Uint8ClampedArray || t instanceof Int16Array || t instanceof Uint16Array || t instanceof Int32Array || t instanceof Uint32Array || t instanceof Float32Array || t instanceof Float64Array));
    }, e.binaryStringToUint8Array = function(t) {
      for (var e = t.length, n = new Uint8Array(e), r = 0; r < e; r++) {
        n[r] = t.charCodeAt(r);
      }
      return n;
    }, e.arrayBufferToBinaryString = function(t) {
      this.isArrayBuffer(t) && (t = new Uint8Array(t));
      for (var e = '', n = t.byteLength, r = 0; r < n; r++) {
        e += String.fromCharCode(t[r]);
      }
      return e;
    }, e.arrayBufferToBase64 = function(t) {
      for (var e, n, r, i, o, a = '', s = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/', c = new Uint8Array(t), l = c.byteLength, u = l % 3, h = l - u, f = 0; f < h; f += 3) {
        o = c[f] << 16 | c[f + 1] << 8 | c[f + 2], e = (16515072 & o) >> 18, n = (258048 & o) >> 12, r = (4032 & o) >> 6, i = 63 & o, a += s[e] + s[n] + s[r] + s[i];
      }
      return 1 == u ? (o = c[h], e = (252 & o) >> 2, n = (3 & o) << 4, a += s[e] + s[n] + '\x3d\x3d') : 2 == u && (o = c[h] << 8 | c[h + 1], e = (64512 & o) >> 10, n = (1008 & o) >> 4, r = (15 & o) << 2, a += s[e] + s[n] + s[r] + '\x3d'), a;
    }, e.createImageInfo = function(t, e, n, r, i, o, a, s, c, l, u, h, f) {
      var d = {alias:s, w:e, h:n, cs:r, bpc:i, i:a, data:t};
      return o && (d.f = o), c && (d.dp = c), l && (d.trns = l), u && (d.pal = u), h && (d.smask = h), f && (d.p = f), d;
    }, e.addImage = function(e, n, i, o, a, w, v, b, x) {
      if ('string' != typeof n) {
        var k = w;
        w = a, a = o, o = i, i = n, n = k;
      }
      if ('object' === ('undefined' == typeof e ? 'undefined' : t(e)) && !p(e) && 'imageData' in e) {
        var _ = e;
        e = _.imageData, n = _.format || n, i = _.x || i || 0, o = _.y || o || 0, a = _.w || a, w = _.h || w, v = _.alias || v, b = _.compression || b, x = _.rotation || _.angle || x;
      }
      if (isNaN(i) || isNaN(o)) {
        throw console.error('jsPDF.addImage: Invalid coordinates', arguments), new Error('Invalid coordinates passed to jsPDF.addImage');
      }
      var C, A = c.call(this);
      if (!(C = m(e, A))) {
        var S;
        if (p(e) && (e = g(e, n, x)), u(v) && (v = h(e)), !(C = m(v, A))) {
          if (this.isString(e)) {
            var q = this.extractInfoFromBase64DataURI(e);
            q ? (n = q[2], e = atob(q[3])) : 137 === e.charCodeAt(0) && 80 === e.charCodeAt(1) && 78 === e.charCodeAt(2) && 71 === e.charCodeAt(3) && (n = 'png');
          }
          if (n = (n || 'JPEG').toLowerCase(), f(n)) {
            throw new Error('addImage currently only supports formats ' + r + ", not '" + n + "'");
          }
          if (d(n)) {
            throw new Error("please ensure that the plugin for '" + n + "' support is added");
          }
          if (this.supportsArrayBuffer() && (e instanceof Uint8Array || (S = e, e = this.binaryStringToUint8Array(e))), C = this['process' + n.toUpperCase()](e, l(A), v, s(b), S), !C) {
            throw new Error('An unkwown error occurred whilst processing the image');
          }
        }
      }
      return y.call(this, i, o, a, w, C, C.i, A), this;
    };
    var v = function(t) {
      var e, n, r;
      if (255 === !t.charCodeAt(0) || 216 === !t.charCodeAt(1) || 255 === !t.charCodeAt(2) || 224 === !t.charCodeAt(3) || !t.charCodeAt(6) === 'J'.charCodeAt(0) || !t.charCodeAt(7) === 'F'.charCodeAt(0) || !t.charCodeAt(8) === 'I'.charCodeAt(0) || !t.charCodeAt(9) === 'F'.charCodeAt(0) || 0 === !t.charCodeAt(10)) {
        throw new Error('getJpegSize requires a binary string jpeg file');
      }
      for (var i = 256 * t.charCodeAt(4) + t.charCodeAt(5), o = 4, a = t.length; o < a;) {
        if (o += i, 255 !== t.charCodeAt(o)) {
          throw new Error('getJpegSize could not find the size of the image');
        }
        if (192 === t.charCodeAt(o + 1) || 193 === t.charCodeAt(o + 1) || 194 === t.charCodeAt(o + 1) || 195 === t.charCodeAt(o + 1) || 196 === t.charCodeAt(o + 1) || 197 === t.charCodeAt(o + 1) || 198 === t.charCodeAt(o + 1) || 199 === t.charCodeAt(o + 1)) {
          return n = 256 * t.charCodeAt(o + 5) + t.charCodeAt(o + 6), e = 256 * t.charCodeAt(o + 7) + t.charCodeAt(o + 8), r = t.charCodeAt(o + 9), [e, n, r];
        }
        o += 2, i = 256 * t.charCodeAt(o) + t.charCodeAt(o + 1);
      }
    }, b = function(t) {
      var e = t[0] << 8 | t[1];
      if (65496 !== e) {
        throw new Error('Supplied data is not a JPEG');
      }
      for (var n, r, i, o, a = t.length, s = (t[4] << 8) + t[5], c = 4; c < a;) {
        if (c += s, n = x(t, c), s = (n[2] << 8) + n[3], (192 === n[1] || 194 === n[1]) && 255 === n[0] && s > 7) {
          return n = x(t, c + 5), r = (n[2] << 8) + n[3], i = (n[0] << 8) + n[1], o = n[4], {width:r, height:i, numcomponents:o};
        }
        c += 2;
      }
      throw new Error('getJpegSizeFromBytes could not find the size of the image');
    }, x = function(t, e) {
      return t.subarray(e, e + 5);
    };
    e.processJPEG = function(t, e, n, r, i) {
      var o, a = this.color_spaces.DEVICE_RGB, s = this.decode.DCT_DECODE, c = 8;
      return this.isString(t) ? (o = v(t), this.createImageInfo(t, o[0], o[1], 1 == o[3] ? this.color_spaces.DEVICE_GRAY : a, c, s, e, n)) : (this.isArrayBuffer(t) && (t = new Uint8Array(t)), this.isArrayBufferView(t) ? (o = b(t), t = i || this.arrayBufferToBinaryString(t), this.createImageInfo(t, o.width, o.height, 1 == o.numcomponents ? this.color_spaces.DEVICE_GRAY : a, c, s, e, n)) : null);
    }, e.processJPG = function() {
      return this.processJPEG.apply(this, arguments);
    };
  }(e.API), function(t) {
    var n = {annotations:[], f2:function(t) {
      return t.toFixed(2);
    }, notEmpty:function(t) {
      if ('undefined' != typeof t && '' != t) {
        return !0;
      }
    }};
    return e.API.annotationPlugin = n, e.API.events.push(['addPage', function(t) {
      this.annotationPlugin.annotations[t.pageNumber] = [];
    }]), t.events.push(['putPage', function(t) {
      for (var e = this.annotationPlugin.annotations[t.pageNumber], r = !1, i = 0; i < e.length && !r; i++) {
        var o = e[i];
        switch(o.type) {
          case 'link':
            if (n.notEmpty(o.options.url) || n.notEmpty(o.options.pageNumber)) {
              r = !0;
              break;
            }
          case 'reference':
          case 'text':
          case 'freetext':
            r = !0;
        }
      }
      if (0 != r) {
        this.internal.write('/Annots [');
        for (var a = this.annotationPlugin.f2, s = this.internal.scaleFactor, c = this.internal.pageSize.height, l = this.internal.getPageInfo(t.pageNumber), i = 0; i < e.length; i++) {
          var o = e[i];
          switch(o.type) {
            case 'reference':
              this.internal.write(' ' + o.object.objId + ' 0 R ');
              break;
            case 'text':
              var u = this.internal.newAdditionalObject(), h = this.internal.newAdditionalObject(), f = o.title || 'Note', d = '/Rect [' + a(o.bounds.x * s) + ' ' + a(c - (o.bounds.y + o.bounds.h) * s) + ' ' + a((o.bounds.x + o.bounds.w) * s) + ' ' + a((c - o.bounds.y) * s) + '] ';
              y = '\x3c\x3c/Type /Annot /Subtype /Text ' + d + '/Contents (' + o.contents + ')', y += ' /Popup ' + h.objId + ' 0 R', y += ' /P ' + l.objId + ' 0 R', y += ' /T (' + f + ') \x3e\x3e', u.content = y;
              var p = u.objId + ' 0 R', g = 30, d = '/Rect [' + a((o.bounds.x + g) * s) + ' ' + a(c - (o.bounds.y + o.bounds.h) * s) + ' ' + a((o.bounds.x + o.bounds.w + g) * s) + ' ' + a((c - o.bounds.y) * s) + '] ';
              y = '\x3c\x3c/Type /Annot /Subtype /Popup ' + d + ' /Parent ' + p, o.open && (y += ' /Open true'), y += ' \x3e\x3e', h.content = y, this.internal.write(u.objId, '0 R', h.objId, '0 R');
              break;
            case 'freetext':
              var d = '/Rect [' + a(o.bounds.x * s) + ' ' + a((c - o.bounds.y) * s) + ' ' + a(o.bounds.x + o.bounds.w * s) + ' ' + a(c - (o.bounds.y + o.bounds.h) * s) + '] ', m = o.color || '#000000';
              y = '\x3c\x3c/Type /Annot /Subtype /FreeText ' + d + '/Contents (' + o.contents + ')', y += ' /DS(font: Helvetica,sans-serif 12.0pt; text-align:left; color:#' + m + ')', y += ' /Border [0 0 0]', y += ' \x3e\x3e', this.internal.write(y);
              break;
            case 'link':
              if (o.options.name) {
                var w = this.annotations._nameMap[o.options.name];
                o.options.pageNumber = w.page, o.options.top = w.y;
              } else {
                o.options.top || (o.options.top = 0);
              }
              var d = '/Rect [' + a(o.x * s) + ' ' + a((c - o.y) * s) + ' ' + a(o.x + o.w * s) + ' ' + a(c - (o.y + o.h) * s) + '] ', y = '';
              if (o.options.url) {
                y = '\x3c\x3c/Type /Annot /Subtype /Link ' + d + '/Border [0 0 0] /A \x3c\x3c/S /URI /URI (' + o.options.url + ') \x3e\x3e';
              } else {
                if (o.options.pageNumber) {
                  var t = this.internal.getPageInfo(o.options.pageNumber);
                  switch(y = '\x3c\x3c/Type /Annot /Subtype /Link ' + d + '/Border [0 0 0] /Dest [' + t.objId + ' 0 R', o.options.magFactor = o.options.magFactor || 'XYZ', o.options.magFactor) {
                    case 'Fit':
                      y += ' /Fit]';
                      break;
                    case 'FitH':
                      y += ' /FitH ' + o.options.top + ']';
                      break;
                    case 'FitV':
                      o.options.left = o.options.left || 0, y += ' /FitV ' + o.options.left + ']';
                      break;
                    case 'XYZ':
                    default:
                      var v = a((c - o.options.top) * s);
                      o.options.left = o.options.left || 0, 'undefined' == typeof o.options.zoom && (o.options.zoom = 0), y += ' /XYZ ' + o.options.left + ' ' + v + ' ' + o.options.zoom + ']';
                  }
                }
              }
              '' != y && (y += ' \x3e\x3e', this.internal.write(y));
          }
        }
        this.internal.write(']');
      }
    }]), t.createAnnotation = function(t) {
      switch(t.type) {
        case 'link':
          this.link(t.bounds.x, t.bounds.y, t.bounds.w, t.bounds.h, t);
          break;
        case 'text':
        case 'freetext':
          this.annotationPlugin.annotations[this.internal.getCurrentPageInfo().pageNumber].push(t);
      }
    }, t.link = function(t, e, n, r, i) {
      this.annotationPlugin.annotations[this.internal.getCurrentPageInfo().pageNumber].push({x:t, y:e, w:n, h:r, options:i, type:'link'});
    }, t.link = function(t, e, n, r, i) {
      this.annotationPlugin.annotations[this.internal.getCurrentPageInfo().pageNumber].push({x:t, y:e, w:n, h:r, options:i, type:'link'});
    }, t.textWithLink = function(t, e, n, r) {
      var i = this.getTextWidth(t), o = this.internal.getLineHeight();
      return this.text(t, e, n), n += 0.2 * o, this.link(e, n - o, i, o, r), i;
    }, t.getTextWidth = function(t) {
      var e = this.internal.getFontSize(), n = this.getStringUnitWidth(t) * e / this.internal.scaleFactor;
      return n;
    }, t.getLineHeight = function() {
      return this.internal.getLineHeight();
    }, this;
  }(e.API), function(t) {
    t.autoPrint = function() {
      var t;
      return this.internal.events.subscribe('postPutResources', function() {
        t = this.internal.newObject(), this.internal.write('\x3c\x3c /S/Named /Type/Action /N/Print \x3e\x3e', 'endobj');
      }), this.internal.events.subscribe('putCatalog', function() {
        this.internal.write('/OpenAction ' + t + ' 0 R');
      }), this;
    };
  }(e.API), function(t) {
    return t.events.push(['initialized', function() {
      this.canvas.pdf = this;
    }]), t.canvas = {getContext:function(t) {
      return this.pdf.context2d._canvas = this, this.pdf.context2d;
    }, style:{}}, Object.defineProperty(t.canvas, 'width', {get:function() {
      return this._width;
    }, set:function(t) {
      this._width = t, this.getContext('2d').pageWrapX = t + 1;
    }}), Object.defineProperty(t.canvas, 'height', {get:function() {
      return this._height;
    }, set:function(t) {
      this._height = t, this.getContext('2d').pageWrapY = t + 1;
    }}), this;
  }(e.API), function(t) {
    var e, n, r, i, o = 3, a = 13, s = {x:void 0, y:void 0, w:void 0, h:void 0, ln:void 0}, c = 1, l = function(t, e, n, r, i) {
      s = {x:t, y:e, w:n, h:r, ln:i};
    }, u = function() {
      return s;
    }, h = {left:0, top:0, bottom:0};
    t.setHeaderFunction = function(t) {
      i = t;
    }, t.getTextDimensions = function(t) {
      e = this.internal.getFont().fontName, n = this.table_font_size || this.internal.getFontSize(), r = this.internal.getFont().fontStyle;
      var i, o, a = 19.049976 / 25.4;
      o = document.createElement('font'), o.id = 'jsPDFCell';
      try {
        o.style.fontStyle = r;
      } catch (t$39) {
        o.style.fontWeight = r;
      }
      o.style.fontName = e, o.style.fontSize = n + 'pt';
      try {
        o.textContent = t;
      } catch (e$40) {
        o.innerText = t;
      }
      return document.body.appendChild(o), i = {w:(o.offsetWidth + 1) * a, h:(o.offsetHeight + 1) * a}, document.body.removeChild(o), i;
    }, t.cellAddPage = function() {
      var t = this.margins || h;
      this.addPage(), l(t.left, t.top, void 0, void 0), c += 1;
    }, t.cellInitialize = function() {
      s = {x:void 0, y:void 0, w:void 0, h:void 0, ln:void 0}, c = 1;
    }, t.cell = function(t, e, n, r, i, s, c) {
      var f = u(), d = !1;
      if (void 0 !== f.ln) {
        if (f.ln === s) {
          t = f.x + f.w, e = f.y;
        } else {
          var p = this.margins || h;
          f.y + f.h + r + a >= this.internal.pageSize.height - p.bottom && (this.cellAddPage(), d = !0, this.printHeaders && this.tableHeaderRow && this.printHeaderRow(s, !0)), e = u().y + u().h, d && (e = a + 10);
        }
      }
      if (void 0 !== i[0]) {
        if (this.printingHeaderRow ? this.rect(t, e, n, r, 'FD') : this.rect(t, e, n, r), 'right' === c) {
          i instanceof Array || (i = [i]);
          for (var g = 0; g < i.length; g++) {
            var m = i[g], w = this.getStringUnitWidth(m) * this.internal.getFontSize();
            this.text(m, t + n - w - o, e + this.internal.getLineHeight() * (g + 1));
          }
        } else {
          this.text(i, t + o, e + this.internal.getLineHeight());
        }
      }
      return l(t, e, n, r, s), this;
    }, t.arrayMax = function(t, e) {
      var n, r, i, o = t[0];
      for (n = 0, r = t.length; n < r; n += 1) {
        i = t[n], e ? e(o, i) === -1 && (o = i) : i > o && (o = i);
      }
      return o;
    }, t.table = function(e, n, r, i, o) {
      if (!r) {
        throw 'No data for PDF table';
      }
      var a, l, u, f, d, p, g, m, w, y, v = [], b = [], x = {}, k = {}, _ = [], C = [], A = !1, S = !0, q = 12, T = h;
      if (T.width = this.internal.pageSize.width, o && (o.autoSize === !0 && (A = !0), o.printHeaders === !1 && (S = !1), o.fontSize && (q = o.fontSize), o.css && 'undefined' != typeof o.css['font-size'] && (q = 16 * o.css['font-size']), o.margins && (T = o.margins)), this.lnMod = 0, s = {x:void 0, y:void 0, w:void 0, h:void 0, ln:void 0}, c = 1, this.printHeaders = S, this.margins = T, this.setFontSize(q), this.table_font_size = q, void 0 === i || null === i) {
        v = Object.keys(r[0]);
      } else {
        if (i[0] && 'string' != typeof i[0]) {
          var P = 19.049976 / 25.4;
          for (l = 0, u = i.length; l < u; l += 1) {
            a = i[l], v.push(a.name), b.push(a.prompt), k[a.name] = a.width * P;
          }
        } else {
          v = i;
        }
      }
      if (A) {
        for (y = function(t) {
          return t[a];
        }, l = 0, u = v.length; l < u; l += 1) {
          for (a = v[l], x[a] = r.map(y), _.push(this.getTextDimensions(b[l] || a).w), p = x[a], g = 0, f = p.length; g < f; g += 1) {
            d = p[g], _.push(this.getTextDimensions(d).w);
          }
          k[a] = t.arrayMax(_), _ = [];
        }
      }
      if (S) {
        var I = this.calculateLineHeight(v, k, b.length ? b : v);
        for (l = 0, u = v.length; l < u; l += 1) {
          a = v[l], C.push([e, n, k[a], I, String(b.length ? b[l] : a)]);
        }
        this.setTableHeaderRow(C), this.printHeaderRow(1, !1);
      }
      for (l = 0, u = r.length; l < u; l += 1) {
        var I;
        for (m = r[l], I = this.calculateLineHeight(v, k, m), g = 0, w = v.length; g < w; g += 1) {
          a = v[g], this.cell(e, n, k[a], I, m[a], l + 2, a.align);
        }
      }
      return this.lastCellPos = s, this.table_x = e, this.table_y = n, this;
    }, t.calculateLineHeight = function(t, e, n) {
      for (var r, i = 0, a = 0; a < t.length; a++) {
        r = t[a], n[r] = this.splitTextToSize(String(n[r]), e[r] - o);
        var s = this.internal.getLineHeight() * n[r].length + o;
        s > i && (i = s);
      }
      return i;
    }, t.setTableHeaderRow = function(t) {
      this.tableHeaderRow = t;
    }, t.printHeaderRow = function(t, e) {
      if (!this.tableHeaderRow) {
        throw 'Property tableHeaderRow does not exist.';
      }
      var n, r, o, s;
      if (this.printingHeaderRow = !0, void 0 !== i) {
        var u = i(this, c);
        l(u[0], u[1], u[2], u[3], -1);
      }
      this.setFontStyle('bold');
      var h = [];
      for (o = 0, s = this.tableHeaderRow.length; o < s; o += 1) {
        this.setFillColor(200, 200, 200), n = this.tableHeaderRow[o], e && (this.margins.top = a, n[1] = this.margins && this.margins.top || 0, h.push(n)), r = [].concat(n), this.cell.apply(this, r.concat(t));
      }
      h.length > 0 && this.setTableHeaderRow(h), this.setFontStyle('normal'), this.printingHeaderRow = !1;
    };
  }(e.API), function(t) {
    function e() {
      this._isStrokeTransparent = !1, this._strokeOpacity = 1, this.strokeStyle = '#000000', this.fillStyle = '#000000', this._isFillTransparent = !1, this._fillOpacity = 1, this.font = '12pt times', this.textBaseline = 'alphabetic', this.textAlign = 'start', this.lineWidth = 1, this.lineJoin = 'miter', this.lineCap = 'butt', this._transform = [1, 0, 0, 1, 0, 0], this.globalCompositeOperation = 'normal', this.globalAlpha = 1, this._clip_path = [], this.ignoreClearRect = !1, this.copy = function(t) {
        this._isStrokeTransparent = t._isStrokeTransparent, this._strokeOpacity = t._strokeOpacity, this.strokeStyle = t.strokeStyle, this._isFillTransparent = t._isFillTransparent, this._fillOpacity = t._fillOpacity, this.fillStyle = t.fillStyle, this.font = t.font, this.lineWidth = t.lineWidth, this.lineJoin = t.lineJoin, this.lineCap = t.lineCap, this.textBaseline = t.textBaseline, this.textAlign = t.textAlign, this._fontSize = t._fontSize, this._transform = t._transform.slice(0), this.globalCompositeOperation = 
        t.globalCompositeOperation, this.globalAlpha = t.globalAlpha, this._clip_path = t._clip_path.slice(0), this.ignoreClearRect = t.ignoreClearRect;
      };
    }
    t.events.push(['initialized', function() {
      this.context2d.pdf = this, this.context2d.internal.pdf = this, this.context2d.ctx = new e, this.context2d.ctxStack = [], this.context2d.path = [];
    }]), t.context2d = {pageWrapXEnabled:!1, pageWrapYEnabled:!1, pageWrapX:9999999, pageWrapY:9999999, ctx:new e, f2:function(t) {
      return t.toFixed(2);
    }, fillRect:function(t, e, n, r) {
      if (!this._isFillTransparent()) {
        t = this._wrapX(t), e = this._wrapY(e);
        var i = this._matrix_map_rect(this.ctx._transform, {x:t, y:e, w:n, h:r});
        this.pdf.rect(i.x, i.y, i.w, i.h, 'f');
      }
    }, strokeRect:function(t, e, n, r) {
      if (!this._isStrokeTransparent()) {
        t = this._wrapX(t), e = this._wrapY(e);
        var i = this._matrix_map_rect(this.ctx._transform, {x:t, y:e, w:n, h:r});
        this.pdf.rect(i.x, i.y, i.w, i.h, 's');
      }
    }, clearRect:function(t, e, n, r) {
      if (!this.ctx.ignoreClearRect) {
        t = this._wrapX(t), e = this._wrapY(e);
        var i = this._matrix_map_rect(this.ctx._transform, {x:t, y:e, w:n, h:r});
        this.save(), this.setFillStyle('#ffffff'), this.pdf.rect(i.x, i.y, i.w, i.h, 'f'), this.restore();
      }
    }, save:function() {
      this.ctx._fontSize = this.pdf.internal.getFontSize();
      var t = new e;
      t.copy(this.ctx), this.ctxStack.push(this.ctx), this.ctx = t;
    }, restore:function() {
      this.ctx = this.ctxStack.pop(), this.setFillStyle(this.ctx.fillStyle), this.setStrokeStyle(this.ctx.strokeStyle), this.setFont(this.ctx.font), this.pdf.setFontSize(this.ctx._fontSize), this.setLineCap(this.ctx.lineCap), this.setLineWidth(this.ctx.lineWidth), this.setLineJoin(this.ctx.lineJoin);
    }, rect:function(t, e, n, r) {
      this.moveTo(t, e), this.lineTo(t + n, e), this.lineTo(t + n, e + r), this.lineTo(t, e + r), this.lineTo(t, e), this.closePath();
    }, beginPath:function() {
      this.path = [];
    }, closePath:function() {
      this.path.push({type:'close'});
    }, _getRgba:function(t) {
      var e = {};
      if (this.internal.rxTransparent.test(t)) {
        e.r = 0, e.g = 0, e.b = 0, e.a = 0;
      } else {
        var n = this.internal.rxRgb.exec(t);
        null != n ? (e.r = parseInt(n[1]), e.g = parseInt(n[2]), e.b = parseInt(n[3]), e.a = 1) : (n = this.internal.rxRgba.exec(t), null != n ? (e.r = parseInt(n[1]), e.g = parseInt(n[2]), e.b = parseInt(n[3]), e.a = parseFloat(n[4])) : (e.a = 1, '#' != t.charAt(0) && (t = o.colorNameToHex(t), t || (t = '#000000')), 4 === t.length ? (e.r = t.substring(1, 2), e.r += r, e.g = t.substring(2, 3), e.g += g, e.b = t.substring(3, 4), e.b += b) : (e.r = t.substring(1, 3), e.g = t.substring(3, 5), e.b = 
        t.substring(5, 7)), e.r = parseInt(e.r, 16), e.g = parseInt(e.g, 16), e.b = parseInt(e.b, 16)));
      }
      return e.style = t, e;
    }, setFillStyle:function(t) {
      var e, n, r, i;
      if (this.internal.rxTransparent.test(t)) {
        e = 0, n = 0, r = 0, i = 0;
      } else {
        var a = this.internal.rxRgb.exec(t);
        null != a ? (e = parseInt(a[1]), n = parseInt(a[2]), r = parseInt(a[3]), i = 1) : (a = this.internal.rxRgba.exec(t), null != a ? (e = parseInt(a[1]), n = parseInt(a[2]), r = parseInt(a[3]), i = parseFloat(a[4])) : (i = 1, '#' != t.charAt(0) && (t = o.colorNameToHex(t), t || (t = '#000000')), 4 === t.length ? (e = t.substring(1, 2), e += e, n = t.substring(2, 3), n += n, r = t.substring(3, 4), r += r) : (e = t.substring(1, 3), n = t.substring(3, 5), r = t.substring(5, 7)), e = parseInt(e, 
        16), n = parseInt(n, 16), r = parseInt(r, 16)));
      }
      this.ctx.fillStyle = t, this.ctx._isFillTransparent = 0 == i, this.ctx._fillOpacity = i, this.pdf.setFillColor(e, n, r, {a:i}), this.pdf.setTextColor(e, n, r, {a:i});
    }, setStrokeStyle:function(t) {
      var e = this._getRgba(t);
      this.ctx.strokeStyle = e.style, this.ctx._isStrokeTransparent = 0 == e.a, this.ctx._strokeOpacity = e.a, 0 === e.a ? this.pdf.setDrawColor(255, 255, 255) : 1 === e.a ? this.pdf.setDrawColor(e.r, e.g, e.b) : this.pdf.setDrawColor(e.r, e.g, e.b);
    }, fillText:function(t, e, n, r) {
      if (!this._isFillTransparent()) {
        e = this._wrapX(e), n = this._wrapY(n);
        var i = this._matrix_map_point(this.ctx._transform, [e, n]);
        e = i[0], n = i[1];
        var o = this._matrix_rotation(this.ctx._transform), a = 57.2958 * o;
        if (this.ctx._clip_path.length > 0) {
          var s;
          s = window.outIntercept ? 'group' === window.outIntercept.type ? window.outIntercept.stream : window.outIntercept : this.internal.getCurrentPage(), s.push('q');
          var c = this.path;
          this.path = this.ctx._clip_path, this.ctx._clip_path = [], this._fill(null, !0), this.ctx._clip_path = this.path, this.path = c;
        }
        var l;
        if (l = this.pdf.hotfix && this.pdf.hotfix.scale_text ? this._getTransform()[0] : 1, l < 0.01) {
          this.pdf.text(t, e, this._getBaseline(n), null, a);
        } else {
          var u = this.pdf.internal.getFontSize();
          this.pdf.setFontSize(u * l), this.pdf.text(t, e, this._getBaseline(n), null, a), this.pdf.setFontSize(u);
        }
        this.ctx._clip_path.length > 0 && s.push('Q');
      }
    }, strokeText:function(t, e, n, r) {
      if (!this._isStrokeTransparent()) {
        e = this._wrapX(e), n = this._wrapY(n);
        var i = this._matrix_map_point(this.ctx._transform, [e, n]);
        e = i[0], n = i[1];
        var o = this._matrix_rotation(this.ctx._transform), a = 57.2958 * o;
        if (this.ctx._clip_path.length > 0) {
          var s;
          s = window.outIntercept ? 'group' === window.outIntercept.type ? window.outIntercept.stream : window.outIntercept : this.internal.getCurrentPage(), s.push('q');
          var c = this.path;
          this.path = this.ctx._clip_path, this.ctx._clip_path = [], this._fill(null, !0), this.ctx._clip_path = this.path, this.path = c;
        }
        var l;
        if (l = this.pdf.hotfix && this.pdf.hotfix.scale_text ? this._getTransform()[0] : 1, 1 === l) {
          this.pdf.text(t, e, this._getBaseline(n), {stroke:!0}, a);
        } else {
          var u = this.pdf.internal.getFontSize();
          this.pdf.setFontSize(u * l), this.pdf.text(t, e, this._getBaseline(n), {stroke:!0}, a), this.pdf.setFontSize(u);
        }
        this.ctx._clip_path.length > 0 && s.push('Q');
      }
    }, setFont:function(t) {
      this.ctx.font = t;
      var e = /\s*(\w+)\s+(\w+)\s+(\w+)\s+([\d\.]+)(px|pt|em)\s+(.*)?/;
      if (h = e.exec(t), null != h) {
        var n = h[1], r = (h[2], h[3]), i = h[4], o = h[5], a = h[6];
        i = 'px' === o ? Math.floor(parseFloat(i)) : 'em' === o ? Math.floor(parseFloat(i) * this.pdf.getFontSize()) : Math.floor(parseFloat(i)), this.pdf.setFontSize(i), 'bold' === r || '700' === r ? this.pdf.setFontStyle('bold') : 'italic' === n ? this.pdf.setFontStyle('italic') : this.pdf.setFontStyle('normal');
        var s, c = a, l = c.toLowerCase().split(/\s*,\s*/);
        s = l.indexOf('arial') != -1 ? 'Arial' : l.indexOf('verdana') != -1 ? 'Verdana' : l.indexOf('helvetica') != -1 ? 'Helvetica' : l.indexOf('sans-serif') != -1 ? 'sans-serif' : l.indexOf('fixed') != -1 ? 'Fixed' : l.indexOf('monospace') != -1 ? 'Monospace' : l.indexOf('terminal') != -1 ? 'Terminal' : l.indexOf('courier') != -1 ? 'Courier' : l.indexOf('times') != -1 ? 'Times' : l.indexOf('cursive') != -1 ? 'Cursive' : l.indexOf('fantasy') != -1 ? 'Fantasy' : (l.indexOf('serif') != -1, 'Serif');
        var u;
        u = 'bold' === r ? 'bold' : 'normal', this.pdf.setFont(s, u);
      } else {
        var e = /(\d+)(pt|px|em)\s+(\w+)\s*(\w+)?/, h = e.exec(t);
        if (null != h) {
          var f = h[1], c = (h[2], h[3]), u = h[4];
          u || (u = 'normal'), f = 'em' === o ? Math.floor(parseFloat(i) * this.pdf.getFontSize()) : Math.floor(parseFloat(f)), this.pdf.setFontSize(f), this.pdf.setFont(c, u);
        }
      }
    }, setTextBaseline:function(t) {
      this.ctx.textBaseline = t;
    }, getTextBaseline:function() {
      return this.ctx.textBaseline;
    }, setTextAlign:function(t) {
      this.ctx.textAlign = t;
    }, getTextAlign:function() {
      return this.ctx.textAlign;
    }, setLineWidth:function(t) {
      this.ctx.lineWidth = t, this.pdf.setLineWidth(t);
    }, setLineCap:function(t) {
      this.ctx.lineCap = t, this.pdf.setLineCap(t);
    }, setLineJoin:function(t) {
      this.ctx.lineJoin = t, this.pdf.setLineJoin(t);
    }, moveTo:function(t, e) {
      t = this._wrapX(t), e = this._wrapY(e);
      var n = this._matrix_map_point(this.ctx._transform, [t, e]);
      t = n[0], e = n[1];
      var r = {type:'mt', x:t, y:e};
      this.path.push(r);
    }, _wrapX:function(t) {
      return this.pageWrapXEnabled ? t % this.pageWrapX : t;
    }, _wrapY:function(t) {
      return this.pageWrapYEnabled ? (this._gotoPage(this._page(t)), (t - this.lastBreak) % this.pageWrapY) : t;
    }, transform:function(t, e, n, r, i, o) {
      this.ctx._transform = [t, e, n, r, i, o];
    }, setTransform:function(t, e, n, r, i, o) {
      this.ctx._transform = [t, e, n, r, i, o];
    }, _getTransform:function() {
      return this.ctx._transform;
    }, lastBreak:0, pageBreaks:[], _page:function(t) {
      if (this.pageWrapYEnabled) {
        this.lastBreak = 0;
        for (var e = 0, n = 0, r = 0; r < this.pageBreaks.length; r++) {
          if (t >= this.pageBreaks[r]) {
            e++, 0 === this.lastBreak && n++;
            var i = this.pageBreaks[r] - this.lastBreak;
            this.lastBreak = this.pageBreaks[r];
            var o = Math.floor(i / this.pageWrapY);
            n += o;
          }
        }
        if (0 === this.lastBreak) {
          var o = Math.floor(t / this.pageWrapY) + 1;
          n += o;
        }
        return n + e;
      }
      return this.pdf.internal.getCurrentPageInfo().pageNumber;
    }, _gotoPage:function(t) {
    }, lineTo:function(t, e) {
      t = this._wrapX(t), e = this._wrapY(e);
      var n = this._matrix_map_point(this.ctx._transform, [t, e]);
      t = n[0], e = n[1];
      var r = {type:'lt', x:t, y:e};
      this.path.push(r);
    }, bezierCurveTo:function(t, e, n, r, i, o) {
      t = this._wrapX(t), e = this._wrapY(e), n = this._wrapX(n), r = this._wrapY(r), i = this._wrapX(i), o = this._wrapY(o);
      var a;
      a = this._matrix_map_point(this.ctx._transform, [i, o]), i = a[0], o = a[1], a = this._matrix_map_point(this.ctx._transform, [t, e]), t = a[0], e = a[1], a = this._matrix_map_point(this.ctx._transform, [n, r]), n = a[0], r = a[1];
      var s = {type:'bct', x1:t, y1:e, x2:n, y2:r, x:i, y:o};
      this.path.push(s);
    }, quadraticCurveTo:function(t, e, n, r) {
      t = this._wrapX(t), e = this._wrapY(e), n = this._wrapX(n), r = this._wrapY(r);
      var i;
      i = this._matrix_map_point(this.ctx._transform, [n, r]), n = i[0], r = i[1], i = this._matrix_map_point(this.ctx._transform, [t, e]), t = i[0], e = i[1];
      var o = {type:'qct', x1:t, y1:e, x:n, y:r};
      this.path.push(o);
    }, arc:function(t, e, n, r, i, o) {
      if (t = this._wrapX(t), e = this._wrapY(e), !this._matrix_is_identity(this.ctx._transform)) {
        var a = this._matrix_map_point(this.ctx._transform, [t, e]);
        t = a[0], e = a[1];
        var s = this._matrix_map_point(this.ctx._transform, [0, 0]), c = this._matrix_map_point(this.ctx._transform, [0, n]);
        n = Math.sqrt(Math.pow(c[0] - s[0], 2) + Math.pow(c[1] - s[1], 2));
      }
      var l = {type:'arc', x:t, y:e, radius:n, startAngle:r, endAngle:i, anticlockwise:o};
      this.path.push(l);
    }, drawImage:function(t, e, n, r, i, o, a, s, c) {
      void 0 !== o && (e = o, n = a, r = s, i = c), e = this._wrapX(e), n = this._wrapY(n);
      var l, u = this._matrix_map_rect(this.ctx._transform, {x:e, y:n, w:r, h:i}), h = (this._matrix_map_rect(this.ctx._transform, {x:o, y:a, w:s, h:c}), /data:image\/(\w+).*/i), f = h.exec(t);
      l = null != f ? f[1] : 'png', this.pdf.addImage(t, l, u.x, u.y, u.w, u.h);
    }, _matrix_multiply:function(t, e) {
      var n = e[0], r = e[1], i = e[2], o = e[3], a = e[4], s = e[5], c = n * t[0] + r * t[2], l = i * t[0] + o * t[2], u = a * t[0] + s * t[2] + t[4];
      return r = n * t[1] + r * t[3], o = i * t[1] + o * t[3], s = a * t[1] + s * t[3] + t[5], n = c, i = l, a = u, [n, r, i, o, a, s];
    }, _matrix_rotation:function(t) {
      return Math.atan2(t[2], t[0]);
    }, _matrix_decompose:function(t) {
      var e = t[0], n = t[1], r = t[2], i = t[3], o = Math.sqrt(e * e + n * n);
      e /= o, n /= o;
      var a = e * r + n * i;
      r -= e * a, i -= n * a;
      var s = Math.sqrt(r * r + i * i);
      return r /= s, i /= s, a /= s, e * i < n * r && (e = -e, n = -n, a = -a, o = -o), {scale:[o, 0, 0, s, 0, 0], translate:[1, 0, 0, 1, t[4], t[5]], rotate:[e, n, -n, e, 0, 0], skew:[1, 0, a, 1, 0, 0]};
    }, _matrix_map_point:function(t, e) {
      var n = t[0], r = t[1], i = t[2], o = t[3], a = t[4], s = t[5], c = e[0], l = e[1], u = c * n + l * i + a, h = c * r + l * o + s;
      return [u, h];
    }, _matrix_map_point_obj:function(t, e) {
      var n = this._matrix_map_point(t, [e.x, e.y]);
      return {x:n[0], y:n[1]};
    }, _matrix_map_rect:function(t, e) {
      var n = this._matrix_map_point(t, [e.x, e.y]), r = this._matrix_map_point(t, [e.x + e.w, e.y + e.h]);
      return {x:n[0], y:n[1], w:r[0] - n[0], h:r[1] - n[1]};
    }, _matrix_is_identity:function(t) {
      return 1 == t[0] && (0 == t[1] && (0 == t[2] && (1 == t[3] && (0 == t[4] && 0 == t[5]))));
    }, rotate:function(t) {
      var e = [Math.cos(t), Math.sin(t), -Math.sin(t), Math.cos(t), 0, 0];
      this.ctx._transform = this._matrix_multiply(this.ctx._transform, e);
    }, scale:function(t, e) {
      var n = [t, 0, 0, e, 0, 0];
      this.ctx._transform = this._matrix_multiply(this.ctx._transform, n);
    }, translate:function(t, e) {
      var n = [1, 0, 0, 1, t, e];
      this.ctx._transform = this._matrix_multiply(this.ctx._transform, n);
    }, stroke:function() {
      if (this.ctx._clip_path.length > 0) {
        var t;
        t = window.outIntercept ? 'group' === window.outIntercept.type ? window.outIntercept.stream : window.outIntercept : this.internal.getCurrentPage(), t.push('q');
        var e = this.path;
        this.path = this.ctx._clip_path, this.ctx._clip_path = [], this._stroke(!0), this.ctx._clip_path = this.path, this.path = e, this._stroke(!1), t.push('Q');
      } else {
        this._stroke(!1);
      }
    }, _stroke:function(t) {
      if (t || !this._isStrokeTransparent()) {
        for (var e = [], n = !1, r = this.path, i = 0; i < r.length; i++) {
          var o = r[i];
          switch(o.type) {
            case 'mt':
              e.push({start:o, deltas:[], abs:[]});
              break;
            case 'lt':
              var a = [o.x - r[i - 1].x, o.y - r[i - 1].y];
              e[e.length - 1].deltas.push(a), e[e.length - 1].abs.push(o);
              break;
            case 'bct':
              var a = [o.x1 - r[i - 1].x, o.y1 - r[i - 1].y, o.x2 - r[i - 1].x, o.y2 - r[i - 1].y, o.x - r[i - 1].x, o.y - r[i - 1].y];
              e[e.length - 1].deltas.push(a);
              break;
            case 'qct':
              var s = r[i - 1].x + 2 / 3 * (o.x1 - r[i - 1].x), c = r[i - 1].y + 2 / 3 * (o.y1 - r[i - 1].y), l = o.x + 2 / 3 * (o.x1 - o.x), u = o.y + 2 / 3 * (o.y1 - o.y), h = o.x, f = o.y, a = [s - r[i - 1].x, c - r[i - 1].y, l - r[i - 1].x, u - r[i - 1].y, h - r[i - 1].x, f - r[i - 1].y];
              e[e.length - 1].deltas.push(a);
              break;
            case 'arc':
              0 == e.length && e.push({start:{x:0, y:0}, deltas:[], abs:[]}), e[e.length - 1].arc = !0, e[e.length - 1].abs.push(o);
              break;
            case 'close':
              n = !0;
          }
        }
        for (var i = 0; i < e.length; i++) {
          var d;
          if (d = i == e.length - 1 ? 's' : null, e[i].arc) {
            for (var p = e[i].abs, g = 0; g < p.length; g++) {
              var m = p[g], w = 360 * m.startAngle / (2 * Math.PI), y = 360 * m.endAngle / (2 * Math.PI), v = m.x, b = m.y;
              this.internal.arc2(this, v, b, m.radius, w, y, m.anticlockwise, d, t);
            }
          } else {
            var v = e[i].start.x, b = e[i].start.y;
            t ? (this.pdf.lines(e[i].deltas, v, b, null, null), this.pdf.clip_fixed()) : this.pdf.lines(e[i].deltas, v, b, null, d);
          }
        }
      }
    }, _isFillTransparent:function() {
      return this.ctx._isFillTransparent || 0 == this.globalAlpha;
    }, _isStrokeTransparent:function() {
      return this.ctx._isStrokeTransparent || 0 == this.globalAlpha;
    }, fill:function(t) {
      if (this.ctx._clip_path.length > 0) {
        var e;
        e = window.outIntercept ? 'group' === window.outIntercept.type ? window.outIntercept.stream : window.outIntercept : this.internal.getCurrentPage(), e.push('q');
        var n = this.path;
        this.path = this.ctx._clip_path, this.ctx._clip_path = [], this._fill(t, !0), this.ctx._clip_path = this.path, this.path = n, this._fill(t, !1), e.push('Q');
      } else {
        this._fill(t, !1);
      }
    }, _fill:function(t, e) {
      if (!this._isFillTransparent()) {
        var r, i = 'function' == typeof this.pdf.internal.newObject2;
        r = window.outIntercept ? 'group' === window.outIntercept.type ? window.outIntercept.stream : window.outIntercept : this.internal.getCurrentPage();
        var o = [], a = window.outIntercept;
        if (i) {
          switch(this.ctx.globalCompositeOperation) {
            case 'normal':
            case 'source-over':
              break;
            case 'destination-in':
            case 'destination-out':
              var s = this.pdf.internal.newStreamObject(), c = this.pdf.internal.newObject2();
              c.push('\x3c\x3c/Type /ExtGState'), c.push('/SMask \x3c\x3c/S /Alpha /G ' + s.objId + ' 0 R\x3e\x3e'), c.push('\x3e\x3e');
              var l = 'MASK' + c.objId;
              this.pdf.internal.addGraphicsState(l, c.objId);
              var u = '/' + l + ' gs';
              r.splice(0, 0, 'q'), r.splice(1, 0, u), r.push('Q'), window.outIntercept = s;
              break;
            default:
              var h = '/' + this.pdf.internal.blendModeMap[this.ctx.globalCompositeOperation.toUpperCase()];
              h && this.pdf.internal.out(h + ' gs');
          }
        }
        var f = this.ctx.globalAlpha;
        if (this.ctx._fillOpacity < 1 && (f = this.ctx._fillOpacity), i) {
          var d = this.pdf.internal.newObject2();
          d.push('\x3c\x3c/Type /ExtGState'), d.push('/CA ' + f), d.push('/ca ' + f), d.push('\x3e\x3e');
          var l = 'GS_O_' + d.objId;
          this.pdf.internal.addGraphicsState(l, d.objId), this.pdf.internal.out('/' + l + ' gs');
        }
        for (var p = this.path, g = 0; g < p.length; g++) {
          var m = p[g];
          switch(m.type) {
            case 'mt':
              o.push({start:m, deltas:[], abs:[]});
              break;
            case 'lt':
              var w = [m.x - p[g - 1].x, m.y - p[g - 1].y];
              o[o.length - 1].deltas.push(w), o[o.length - 1].abs.push(m);
              break;
            case 'bct':
              var w = [m.x1 - p[g - 1].x, m.y1 - p[g - 1].y, m.x2 - p[g - 1].x, m.y2 - p[g - 1].y, m.x - p[g - 1].x, m.y - p[g - 1].y];
              o[o.length - 1].deltas.push(w);
              break;
            case 'qct':
              var y = p[g - 1].x + 2 / 3 * (m.x1 - p[g - 1].x), v = p[g - 1].y + 2 / 3 * (m.y1 - p[g - 1].y), b = m.x + 2 / 3 * (m.x1 - m.x), x = m.y + 2 / 3 * (m.y1 - m.y), k = m.x, _ = m.y, w = [y - p[g - 1].x, v - p[g - 1].y, b - p[g - 1].x, x - p[g - 1].y, k - p[g - 1].x, _ - p[g - 1].y];
              o[o.length - 1].deltas.push(w);
              break;
            case 'arc':
              0 === o.length && o.push({deltas:[], abs:[]}), o[o.length - 1].arc = !0, o[o.length - 1].abs.push(m);
              break;
            case 'close':
              o.push({close:!0});
          }
        }
        for (var g = 0; g < o.length; g++) {
          var C;
          if (g == o.length - 1 ? (C = 'f', 'evenodd' === t && (C += '*')) : C = null, o[g].close) {
            this.pdf.internal.out('h'), this.pdf.internal.out('f');
          } else {
            if (o[g].arc) {
              o[g].start && this.internal.move2(this, o[g].start.x, o[g].start.y);
              for (var A = o[g].abs, S = 0; S < A.length; S++) {
                var q = A[S];
                if ('undefined' != typeof q.startAngle) {
                  var T = 360 * q.startAngle / (2 * Math.PI), P = 360 * q.endAngle / (2 * Math.PI), I = q.x, E = q.y;
                  if (0 === S && this.internal.move2(this, I, E), this.internal.arc2(this, I, E, q.radius, T, P, q.anticlockwise, null, e), S === A.length - 1 && o[g].start) {
                    var I = o[g].start.x, E = o[g].start.y;
                    this.internal.line2(n, I, E);
                  }
                } else {
                  this.internal.line2(n, q.x, q.y);
                }
              }
            } else {
              var I = o[g].start.x, E = o[g].start.y;
              e ? (this.pdf.lines(o[g].deltas, I, E, null, null), this.pdf.clip_fixed()) : this.pdf.lines(o[g].deltas, I, E, null, C);
            }
          }
        }
        window.outIntercept = a;
      }
    }, pushMask:function() {
      var t = 'function' == typeof this.pdf.internal.newObject2;
      if (!t) {
        return void console.log('jsPDF v2 not enabled');
      }
      var e = this.pdf.internal.newStreamObject(), n = this.pdf.internal.newObject2();
      n.push('\x3c\x3c/Type /ExtGState'), n.push('/SMask \x3c\x3c/S /Alpha /G ' + e.objId + ' 0 R\x3e\x3e'), n.push('\x3e\x3e');
      var r = 'MASK' + n.objId;
      this.pdf.internal.addGraphicsState(r, n.objId);
      var i = '/' + r + ' gs';
      this.pdf.internal.out(i);
    }, clip:function() {
      if (this.ctx._clip_path.length > 0) {
        for (var t = 0; t < this.path.length; t++) {
          this.ctx._clip_path.push(this.path[t]);
        }
      } else {
        this.ctx._clip_path = this.path;
      }
      this.path = [];
    }, measureText:function(t) {
      var e = this.pdf;
      return {getWidth:function() {
        var n = e.internal.getFontSize(), r = e.getStringUnitWidth(t) * n / e.internal.scaleFactor;
        return r *= 1.3333;
      }, get width() {
        return this.getWidth(t);
      }};
    }, _getBaseline:function(t) {
      var e = parseInt(this.pdf.internal.getFontSize()), n = 0.25 * e;
      switch(this.ctx.textBaseline) {
        case 'bottom':
          return t - n;
        case 'top':
          return t + e;
        case 'hanging':
          return t + e - n;
        case 'middle':
          return t + e / 2 - n;
        case 'ideographic':
          return t;
        case 'alphabetic':
        default:
          return t;
      }
    }};
    var n = t.context2d;
    return Object.defineProperty(n, 'fillStyle', {set:function(t) {
      this.setFillStyle(t);
    }, get:function() {
      return this.ctx.fillStyle;
    }}), Object.defineProperty(n, 'strokeStyle', {set:function(t) {
      this.setStrokeStyle(t);
    }, get:function() {
      return this.ctx.strokeStyle;
    }}), Object.defineProperty(n, 'lineWidth', {set:function(t) {
      this.setLineWidth(t);
    }, get:function() {
      return this.ctx.lineWidth;
    }}), Object.defineProperty(n, 'lineCap', {set:function(t) {
      this.setLineCap(t);
    }, get:function() {
      return this.ctx.lineCap;
    }}), Object.defineProperty(n, 'lineJoin', {set:function(t) {
      this.setLineJoin(t);
    }, get:function() {
      return this.ctx.lineJoin;
    }}), Object.defineProperty(n, 'miterLimit', {set:function(t) {
      this.ctx.miterLimit = t;
    }, get:function() {
      return this.ctx.miterLimit;
    }}), Object.defineProperty(n, 'textBaseline', {set:function(t) {
      this.setTextBaseline(t);
    }, get:function() {
      return this.getTextBaseline();
    }}), Object.defineProperty(n, 'textAlign', {set:function(t) {
      this.setTextAlign(t);
    }, get:function() {
      return this.getTextAlign();
    }}), Object.defineProperty(n, 'font', {set:function(t) {
      this.setFont(t);
    }, get:function() {
      return this.ctx.font;
    }}), Object.defineProperty(n, 'globalCompositeOperation', {set:function(t) {
      this.ctx.globalCompositeOperation = t;
    }, get:function() {
      return this.ctx.globalCompositeOperation;
    }}), Object.defineProperty(n, 'globalAlpha', {set:function(t) {
      this.ctx.globalAlpha = t;
    }, get:function() {
      return this.ctx.globalAlpha;
    }}), Object.defineProperty(n, 'ignoreClearRect', {set:function(t) {
      this.ctx.ignoreClearRect = t;
    }, get:function() {
      return this.ctx.ignoreClearRect;
    }}), n.internal = {}, n.internal.rxRgb = /rgb\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*\)/, n.internal.rxRgba = /rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*([\d\.]+)\s*\)/, n.internal.rxTransparent = /transparent|rgba\s*\(\s*(\d+)\s*,\s*(\d+)\s*,\s*(\d+)\s*,\s*0+\s*\)/, n.internal.arc = function(t, e, n, r, i, o, a, s) {
      for (var c = !0, l = this.pdf.internal.scaleFactor, u = this.pdf.internal.pageSize.height, h = this.pdf.internal.f2, f = i * (Math.PI / 180), d = o * (Math.PI / 180), p = this.createArc(r, f, d, a), g = 0; g < p.length; g++) {
        var m = p[g];
        c && 0 === g ? this.pdf.internal.out([h((m.x1 + e) * l), h((u - (m.y1 + n)) * l), 'm', h((m.x2 + e) * l), h((u - (m.y2 + n)) * l), h((m.x3 + e) * l), h((u - (m.y3 + n)) * l), h((m.x4 + e) * l), h((u - (m.y4 + n)) * l), 'c'].join(' ')) : this.pdf.internal.out([h((m.x2 + e) * l), h((u - (m.y2 + n)) * l), h((m.x3 + e) * l), h((u - (m.y3 + n)) * l), h((m.x4 + e) * l), h((u - (m.y4 + n)) * l), 'c'].join(' ')), t._lastPoint = {x:e, y:n};
      }
      null !== s && this.pdf.internal.out(this.pdf.internal.getStyle(s));
    }, n.internal.arc2 = function(t, e, n, r, i, o, a, s, c) {
      var l = e, u = n;
      c ? (this.arc(t, l, u, r, i, o, a, null), this.pdf.clip_fixed()) : this.arc(t, l, u, r, i, o, a, s);
    }, n.internal.move2 = function(t, e, n) {
      var r = this.pdf.internal.scaleFactor, i = this.pdf.internal.pageSize.height, o = this.pdf.internal.f2;
      this.pdf.internal.out([o(e * r), o((i - n) * r), 'm'].join(' ')), t._lastPoint = {x:e, y:n};
    }, n.internal.line2 = function(t, e, n) {
      var r = this.pdf.internal.scaleFactor, i = this.pdf.internal.pageSize.height, o = this.pdf.internal.f2, a = {x:e, y:n};
      this.pdf.internal.out([o(a.x * r), o((i - a.y) * r), 'l'].join(' ')), t._lastPoint = a;
    }, n.internal.createArc = function(t, e, n, r) {
      var i = 1.0E-5, o = 2 * Math.PI, a = Math.PI / 2, s = e;
      for ((s < o || s > o) && (s %= o), s < 0 && (s = o + s); e > n;) {
        e -= o;
      }
      var c = Math.abs(n - e);
      c < o && r && (c = o - c);
      for (var l = [], u = r ? -1 : 1, h = s; c > i;) {
        var f = u * Math.min(c, a), d = h + f;
        l.push(this.createSmallArc(t, h, d)), c -= Math.abs(d - h), h = d;
      }
      return l;
    }, n.internal.getCurrentPage = function() {
      return this.pdf.internal.pages[this.pdf.internal.getCurrentPageInfo().pageNumber];
    }, n.internal.createSmallArc = function(t, e, n) {
      var r = (n - e) / 2, i = t * Math.cos(r), o = t * Math.sin(r), a = i, s = -o, c = a * a + s * s, l = c + a * i + s * o, u = 4 / 3 * (Math.sqrt(2 * c * l) - l) / (a * o - s * i), h = a - u * s, f = s + u * a, d = h, p = -f, g = r + e, m = Math.cos(g), w = Math.sin(g);
      return {x1:t * Math.cos(e), y1:t * Math.sin(e), x2:h * m - f * w, y2:h * w + f * m, x3:d * m - p * w, y3:d * w + p * m, x4:t * Math.cos(n), y4:t * Math.sin(n)};
    }, this;
  }(e.API), function(e) {
    var n, r, i, a, s, c, l, u, h, f, d, p, g, m, w, y, v, b, x, k;
    n = function() {
      function t() {
      }
      return function(e) {
        return t.prototype = e, new t;
      };
    }(), f = function(t) {
      var e, n, r, i, o, a, s;
      for (n = 0, r = t.length, e = void 0, i = !1, a = !1; !i && n !== r;) {
        e = t[n] = t[n].trimLeft(), e && (i = !0), n++;
      }
      for (n = r - 1; r && !a && n !== -1;) {
        e = t[n] = t[n].trimRight(), e && (a = !0), n--;
      }
      for (o = /\s+$/g, s = !0, n = 0; n !== r;) {
        '\u2028' != t[n] && (e = t[n].replace(/\s+/g, ' '), s && (e = e.trimLeft()), e && (s = o.test(e)), t[n] = e), n++;
      }
      return t;
    }, d = function(t, e, n, r) {
      return this.pdf = t, this.x = e, this.y = n, this.settings = r, this.watchFunctions = [], this.init(), this;
    }, p = function(t) {
      var e, n, r;
      for (e = void 0, r = t.split(','), n = r.shift(); !e && n;) {
        e = i[n.trim().toLowerCase()], n = r.shift();
      }
      return e;
    }, g = function(t) {
      t = 'auto' === t ? '0px' : t, t.indexOf('em') > -1 && !isNaN(Number(t.replace('em', ''))) && (t = 18.719 * Number(t.replace('em', '')) + 'px'), t.indexOf('pt') > -1 && !isNaN(Number(t.replace('pt', ''))) && (t = 1.333 * Number(t.replace('pt', '')) + 'px');
      var e, n, r;
      return n = void 0, e = 16, (r = m[t]) ? r : (r = {'xx-small':9, 'x-small':11, small:13, medium:16, large:19, 'x-large':23, 'xx-large':28, auto:0}[{css_line_height_string:t}], r !== n ? m[t] = r / e : (r = parseFloat(t)) ? m[t] = r / e : (r = t.match(/([\d\.]+)(px)/), 3 === r.length ? m[t] = parseFloat(r[1]) / e : m[t] = 1));
    }, h = function(t) {
      var e, n, r;
      return r = function(t) {
        var e;
        return e = function(t) {
          return document.defaultView && document.defaultView.getComputedStyle ? document.defaultView.getComputedStyle(t, null) : t.currentStyle ? t.currentStyle : t.style;
        }(t), function(t) {
          return t = t.replace(/-\D/g, function(t) {
            return t.charAt(1).toUpperCase();
          }), e[t];
        };
      }(t), e = {}, n = void 0, e['font-family'] = p(r('font-family')) || 'times', e['font-style'] = a[r('font-style')] || 'normal', e['text-align'] = s[r('text-align')] || 'left', n = c[r('font-weight')] || 'normal', 'bold' === n && ('normal' === e['font-style'] ? e['font-style'] = n : e['font-style'] = n + e['font-style']), e['font-size'] = g(r('font-size')) || 1, e['line-height'] = g(r('line-height')) || 1, e.display = 'inline' === r('display') ? 'inline' : 'block', n = 'block' === e.display, 
      e['margin-top'] = n && g(r('margin-top')) || 0, e['margin-bottom'] = n && g(r('margin-bottom')) || 0, e['padding-top'] = n && g(r('padding-top')) || 0, e['padding-bottom'] = n && g(r('padding-bottom')) || 0, e['margin-left'] = n && g(r('margin-left')) || 0, e['margin-right'] = n && g(r('margin-right')) || 0, e['padding-left'] = n && g(r('padding-left')) || 0, e['padding-right'] = n && g(r('padding-right')) || 0, e['page-break-before'] = r('page-break-before') || 'auto', e['float'] = l[r('cssFloat')] || 
      'none', e.clear = u[r('clear')] || 'none', e.color = r('color'), e;
    }, w = function(t, e, n) {
      var r, i, o, a, s;
      if (o = !1, i = void 0, a = void 0, s = void 0, r = n['#' + t.id]) {
        if ('function' == typeof r) {
          o = r(t, e);
        } else {
          for (i = 0, a = r.length; !o && i !== a;) {
            o = r[i](t, e), i++;
          }
        }
      }
      if (r = n[t.nodeName], !o && r) {
        if ('function' == typeof r) {
          o = r(t, e);
        } else {
          for (i = 0, a = r.length; !o && i !== a;) {
            o = r[i](t, e), i++;
          }
        }
      }
      return o;
    }, k = function(t, e) {
      var n, r, i, o, a, s, c, l, u, h;
      for (n = [], r = [], i = 0, h = t.rows[0].cells.length, l = t.clientWidth; i < h;) {
        u = t.rows[0].cells[i], r[i] = {name:u.textContent.toLowerCase().replace(/\s+/g, ''), prompt:u.textContent.replace(/\r?\n/g, ''), width:u.clientWidth / l * e.pdf.internal.pageSize.width}, i++;
      }
      for (i = 1; i < t.rows.length;) {
        for (s = t.rows[i], a = {}, o = 0; o < s.cells.length;) {
          a[r[o].name] = s.cells[o].textContent.replace(/\r?\n/g, ''), o++;
        }
        n.push(a), i++;
      }
      return c = {rows:n, headers:r};
    };
    var _ = {SCRIPT:1, STYLE:1, NOSCRIPT:1, OBJECT:1, EMBED:1, SELECT:1}, C = 1;
    r = function(e, i, o) {
      var a, s, c, l, u, f, d, p, g;
      for (s = e.childNodes, a = void 0, c = h(e), u = 'block' === c.display, u && (i.setBlockBoundary(), i.setBlockStyle(c)), d = 19.049976 / 25.4, l = 0, f = s.length; l < f;) {
        if (a = s[l], 'object' === ('undefined' == typeof a ? 'undefined' : t(a))) {
          if (i.executeWatchFunctions(a), 1 === a.nodeType && 'HEADER' === a.nodeName) {
            var m = a, v = i.pdf.margins_doc.top;
            i.pdf.internal.events.subscribe('addPage', function(t) {
              i.y = v, r(m, i, o), i.pdf.margins_doc.top = i.y + 10, i.y += 10;
            }, !1);
          }
          if (8 === a.nodeType && '#comment' === a.nodeName) {
            ~a.textContent.indexOf('ADD_PAGE') && (i.pdf.addPage(), i.y = i.pdf.margins_doc.top);
          } else {
            if (1 !== a.nodeType || _[a.nodeName]) {
              if (3 === a.nodeType) {
                var b = a.nodeValue;
                if (a.nodeValue && 'LI' === a.parentNode.nodeName) {
                  if ('OL' === a.parentNode.parentNode.nodeName) {
                    b = C++ + '. ' + b;
                  } else {
                    var x = c['font-size'], A = (3 - 0.75 * x) * i.pdf.internal.scaleFactor, S = 0.75 * x * i.pdf.internal.scaleFactor, q = 1.74 * x / i.pdf.internal.scaleFactor;
                    g = function(t, e) {
                      this.pdf.circle(t + A, e + S, q, 'FD');
                    };
                  }
                }
                16 & a.ownerDocument.body.compareDocumentPosition(a) && i.addText(b, c);
              } else {
                'string' == typeof a && i.addText(a, c);
              }
            } else {
              var T;
              if ('IMG' === a.nodeName) {
                var P = a.getAttribute('src');
                T = y[i.pdf.sHashCode(P) || P];
              }
              if (T) {
                i.pdf.internal.pageSize.height - i.pdf.margins_doc.bottom < i.y + a.height && i.y > i.pdf.margins_doc.top && (i.pdf.addPage(), i.y = i.pdf.margins_doc.top, i.executeWatchFunctions(a));
                var I = h(a), E = i.x, O = 12 / i.pdf.internal.scaleFactor, F = (I['margin-left'] + I['padding-left']) * O, R = (I['margin-right'] + I['padding-right']) * O, B = (I['margin-top'] + I['padding-top']) * O, D = (I['margin-bottom'] + I['padding-bottom']) * O;
                E += void 0 !== I['float'] && 'right' === I['float'] ? i.settings.width - a.width - R : F, i.pdf.addImage(T, E, i.y + B, a.width, a.height), T = void 0, 'right' === I['float'] || 'left' === I['float'] ? (i.watchFunctions.push(function(t, e, n, r) {
                  return i.y >= e ? (i.x += t, i.settings.width += n, !0) : !!(r && 1 === r.nodeType && !_[r.nodeName] && i.x + r.width > i.pdf.margins_doc.left + i.pdf.margins_doc.width) && (i.x += t, i.y = e, i.settings.width += n, !0);
                }.bind(this, 'left' === I['float'] ? -a.width - F - R : 0, i.y + a.height + B + D, a.width)), i.watchFunctions.push(function(t, e, n) {
                  return !(i.y < t && e === i.pdf.internal.getNumberOfPages()) || 1 === n.nodeType && 'both' === h(n).clear && (i.y = t, !0);
                }.bind(this, i.y + a.height, i.pdf.internal.getNumberOfPages())), i.settings.width -= a.width + F + R, 'left' === I['float'] && (i.x += a.width + F + R)) : i.y += a.height + B + D;
              } else {
                if ('TABLE' === a.nodeName) {
                  p = k(a, i), i.y += 10, i.pdf.table(i.x, i.y, p.rows, p.headers, {autoSize:!1, printHeaders:o.printHeaders, margins:i.pdf.margins_doc, css:h(a)}), i.y = i.pdf.lastCellPos.y + i.pdf.lastCellPos.h + 20;
                } else {
                  if ('OL' === a.nodeName || 'UL' === a.nodeName) {
                    C = 1, w(a, i, o) || r(a, i, o), i.y += 10;
                  } else {
                    if ('LI' === a.nodeName) {
                      var j = i.x;
                      i.x += 20 / i.pdf.internal.scaleFactor, i.y += 3, w(a, i, o) || r(a, i, o), i.x = j;
                    } else {
                      'BR' === a.nodeName ? (i.y += c['font-size'] * i.pdf.internal.scaleFactor, i.addText('\u2028', n(c))) : w(a, i, o) || r(a, i, o);
                    }
                  }
                }
              }
            }
          }
        }
        l++;
      }
      if (o.outY = i.y, u) {
        return i.setBlockBoundary(g);
      }
    }, y = {}, v = function(t, e, n, r) {
      function i() {
        e.pdf.internal.events.publish('imagesLoaded'), r(a);
      }
      function o(t, n, r) {
        if (t) {
          var o = new Image;
          a = ++l, o.crossOrigin = '', o.onerror = o.onload = function() {
            if (o.complete && (0 === o.src.indexOf('data:image/') && (o.width = n || o.width || 0, o.height = r || o.height || 0), o.width + o.height)) {
              var a = e.pdf.sHashCode(t) || t;
              y[a] = y[a] || o;
            }
            --l || i();
          }, o.src = t;
        }
      }
      for (var a, s = t.getElementsByTagName('img'), c = s.length, l = 0; c--;) {
        o(s[c].getAttribute('src'), s[c].width, s[c].height);
      }
      return l || i();
    }, b = function(t, e, n) {
      var i = t.getElementsByTagName('footer');
      if (i.length > 0) {
        i = i[0];
        var o = e.pdf.internal.write, a = e.y;
        e.pdf.internal.write = function() {
        }, r(i, e, n);
        var s = Math.ceil(e.y - a) + 5;
        e.y = a, e.pdf.internal.write = o, e.pdf.margins_doc.bottom += s;
        for (var c = function(t) {
          var o = void 0 !== t ? t.pageNumber : 1, a = e.y;
          e.y = e.pdf.internal.pageSize.height - e.pdf.margins_doc.bottom, e.pdf.margins_doc.bottom -= s;
          for (var c = i.getElementsByTagName('span'), l = 0; l < c.length; ++l) {
            (' ' + c[l].className + ' ').replace(/[\n\t]/g, ' ').indexOf(' pageCounter ') > -1 && (c[l].innerHTML = o), (' ' + c[l].className + ' ').replace(/[\n\t]/g, ' ').indexOf(' totalPages ') > -1 && (c[l].innerHTML = '###jsPDFVarTotalPages###');
          }
          r(i, e, n), e.pdf.margins_doc.bottom += s, e.y = a;
        }, l = i.getElementsByTagName('span'), u = 0; u < l.length; ++u) {
          (' ' + l[u].className + ' ').replace(/[\n\t]/g, ' ').indexOf(' totalPages ') > -1 && e.pdf.internal.events.subscribe('htmlRenderingFinished', e.pdf.putTotalPages.bind(e.pdf, '###jsPDFVarTotalPages###'), !0);
        }
        e.pdf.internal.events.subscribe('addPage', c, !1), c(), _.FOOTER = 1;
      }
    }, x = function(t, e, n, i, o, a) {
      if (!e) {
        return !1;
      }
      'string' == typeof e || e.parentNode || (e = '' + e.innerHTML), 'string' == typeof e && (e = function(t) {
        var e, n, r, i;
        return r = 'jsPDFhtmlText' + Date.now().toString() + (1000 * Math.random()).toFixed(0), i = 'position: absolute !important;clip: rect(1px 1px 1px 1px); /* IE6, IE7 */clip: rect(1px, 1px, 1px, 1px);padding:0 !important;border:0 !important;height: 1px !important;width: 1px !important; top:auto;left:-100px;overflow: hidden;', n = document.createElement('div'), n.style.cssText = i, n.innerHTML = '\x3ciframe style\x3d"height:1px;width:1px" name\x3d"' + r + '" /\x3e', document.body.appendChild(n), 
        e = window.frames[r], e.document.open(), e.document.writeln(t), e.document.close(), e.document.body;
      }(e.replace(/<\/?script[^>]*?>/gi, '')));
      var s, c = new d(t, n, i, o);
      return v.call(this, e, c, o.elementHandlers, function(t) {
        b(e, c, o.elementHandlers), r(e, c, o.elementHandlers), c.pdf.internal.events.publish('htmlRenderingFinished'), s = c.dispose(), 'function' == typeof a ? a(s) : t && console.error('jsPDF Warning: rendering issues? provide a callback to fromHTML!');
      }), s || {x:c.x, y:c.y};
    }, d.prototype.init = function() {
      return this.paragraph = {text:[], style:[]}, this.pdf.internal.write('q');
    }, d.prototype.dispose = function() {
      return this.pdf.internal.write('Q'), {x:this.x, y:this.y, ready:!0};
    }, d.prototype.executeWatchFunctions = function(t) {
      var e = !1, n = [];
      if (this.watchFunctions.length > 0) {
        for (var r = 0; r < this.watchFunctions.length; ++r) {
          this.watchFunctions[r](t) === !0 ? e = !0 : n.push(this.watchFunctions[r]);
        }
        this.watchFunctions = n;
      }
      return e;
    }, d.prototype.splitFragmentsIntoLines = function(t, e) {
      var r, i, o, a, s, c, l, u, h, f, d, p, g, m, w;
      for (i = 12, d = this.pdf.internal.scaleFactor, s = {}, o = void 0, f = void 0, a = void 0, c = void 0, w = void 0, h = void 0, u = void 0, l = void 0, p = [], g = [p], r = 0, m = this.settings.width; t.length;) {
        if (c = t.shift(), w = e.shift(), c) {
          if (o = w['font-family'], f = w['font-style'], a = s[o + f], a || (a = this.pdf.internal.getFont(o, f).metadata.Unicode, s[o + f] = a), h = {widths:a.widths, kerning:a.kerning, fontSize:w['font-size'] * i, textIndent:r}, u = this.pdf.getStringUnitWidth(c, h) * h.fontSize / d, '\u2028' == c) {
            p = [], g.push(p);
          } else {
            if (r + u > m) {
              for (l = this.pdf.splitTextToSize(c, m, h), p.push([l.shift(), w]); l.length;) {
                p = [[l.shift(), w]], g.push(p);
              }
              r = this.pdf.getStringUnitWidth(p[0][0], h) * h.fontSize / d;
            } else {
              p.push([c, w]), r += u;
            }
          }
        }
      }
      if (void 0 !== w['text-align'] && ('center' === w['text-align'] || 'right' === w['text-align'] || 'justify' === w['text-align'])) {
        for (var y = 0; y < g.length; ++y) {
          var v = this.pdf.getStringUnitWidth(g[y][0][0], h) * h.fontSize / d;
          y > 0 && (g[y][0][1] = n(g[y][0][1]));
          var b = m - v;
          if ('right' === w['text-align']) {
            g[y][0][1]['margin-left'] = b;
          } else {
            if ('center' === w['text-align']) {
              g[y][0][1]['margin-left'] = b / 2;
            } else {
              if ('justify' === w['text-align']) {
                var x = g[y][0][0].split(' ').length - 1;
                g[y][0][1]['word-spacing'] = b / x, y === g.length - 1 && (g[y][0][1]['word-spacing'] = 0);
              }
            }
          }
        }
      }
      return g;
    }, d.prototype.RenderTextFragment = function(t, e) {
      var n, r, i;
      i = 0, n = 12, this.pdf.internal.pageSize.height - this.pdf.margins_doc.bottom < this.y + this.pdf.internal.getFontSize() && (this.pdf.internal.write('ET', 'Q'), this.pdf.addPage(), this.y = this.pdf.margins_doc.top, this.pdf.internal.write('q', 'BT 0 g', this.pdf.internal.getCoordinateString(this.x), this.pdf.internal.getVerticalCoordinateString(this.y), e.color, 'Td'), i = Math.max(i, e['line-height'], e['font-size']), this.pdf.internal.write(0, (-1 * n * i).toFixed(2), 'Td')), r = this.pdf.internal.getFont(e['font-family'], 
      e['font-style']);
      var o = this.getPdfColor(e.color);
      o !== this.lastTextColor && (this.pdf.internal.write(o), this.lastTextColor = o), void 0 !== e['word-spacing'] && e['word-spacing'] > 0 && this.pdf.internal.write(e['word-spacing'].toFixed(2), 'Tw'), this.pdf.internal.write('/' + r.id, (n * e['font-size']).toFixed(2), 'Tf', '(' + this.pdf.internal.pdfEscape(t) + ') Tj'), void 0 !== e['word-spacing'] && this.pdf.internal.write(0, 'Tw');
    }, d.prototype.getPdfColor = function(t) {
      var e, n, r, i, a = /rgb\s*\(\s*(\d+),\s*(\d+),\s*(\d+\s*)\)/, s = a.exec(t);
      if (null != s ? (n = parseInt(s[1]), r = parseInt(s[2]), i = parseInt(s[3])) : ('#' != t.charAt(0) && (t = o.colorNameToHex(t), t || (t = '#000000')), n = t.substring(1, 3), n = parseInt(n, 16), r = t.substring(3, 5), r = parseInt(r, 16), i = t.substring(5, 7), i = parseInt(i, 16)), 'string' == typeof n && /^#[0-9A-Fa-f]{6}$/.test(n)) {
        var c = parseInt(n.substr(1), 16);
        n = c >> 16 & 255, r = c >> 8 & 255, i = 255 & c;
      }
      var l = this.f3;
      return e = 0 === n && 0 === r && 0 === i || 'undefined' == typeof r ? l(n / 255) + ' g' : [l(n / 255), l(r / 255), l(i / 255), 'rg'].join(' ');
    }, d.prototype.f3 = function(t) {
      return t.toFixed(3);
    }, d.prototype.renderParagraph = function(t) {
      var e, n, r, i, o, a, s, c, l, u, h, d, p, g, m;
      if (i = f(this.paragraph.text), g = this.paragraph.style, e = this.paragraph.blockstyle, p = this.paragraph.priorblockstyle || {}, this.paragraph = {text:[], style:[], blockstyle:{}, priorblockstyle:e}, i.join('').trim()) {
        c = this.splitFragmentsIntoLines(i, g), s = void 0, l = void 0, n = 12, r = n / this.pdf.internal.scaleFactor, this.priorMarginBottom = this.priorMarginBottom || 0, d = (Math.max((e['margin-top'] || 0) - this.priorMarginBottom, 0) + (e['padding-top'] || 0)) * r, h = ((e['margin-bottom'] || 0) + (e['padding-bottom'] || 0)) * r, this.priorMarginBottom = e['margin-bottom'] || 0, 'always' === e['page-break-before'] && (this.pdf.addPage(), this.y = 0, d = ((e['margin-top'] || 0) + (e['padding-top'] || 
        0)) * r), u = this.pdf.internal.write, o = void 0, a = void 0, this.y += d, u('q', 'BT 0 g', this.pdf.internal.getCoordinateString(this.x), this.pdf.internal.getVerticalCoordinateString(this.y), 'Td');
        for (var w = 0; c.length;) {
          for (s = c.shift(), l = 0, o = 0, a = s.length; o !== a;) {
            s[o][0].trim() && (l = Math.max(l, s[o][1]['line-height'], s[o][1]['font-size']), m = 7 * s[o][1]['font-size']), o++;
          }
          var y = 0, v = 0;
          void 0 !== s[0][1]['margin-left'] && s[0][1]['margin-left'] > 0 && (v = this.pdf.internal.getCoordinateString(s[0][1]['margin-left']), y = v - w, w = v);
          var b = Math.max(e['margin-left'] || 0, 0) * r;
          for (u(y + b, (-1 * n * l).toFixed(2), 'Td'), o = 0, a = s.length; o !== a;) {
            s[o][0] && this.RenderTextFragment(s[o][0], s[o][1]), o++;
          }
          if (this.y += l * r, this.executeWatchFunctions(s[0][1]) && c.length > 0) {
            var x = [], k = [];
            c.forEach(function(t) {
              for (var e = 0, n = t.length; e !== n;) {
                t[e][0] && (x.push(t[e][0] + ' '), k.push(t[e][1])), ++e;
              }
            }), c = this.splitFragmentsIntoLines(f(x), k), u('ET', 'Q'), u('q', 'BT 0 g', this.pdf.internal.getCoordinateString(this.x), this.pdf.internal.getVerticalCoordinateString(this.y), 'Td');
          }
        }
        return t && 'function' == typeof t && t.call(this, this.x - 9, this.y - m / 2), u('ET', 'Q'), this.y += h;
      }
    }, d.prototype.setBlockBoundary = function(t) {
      return this.renderParagraph(t);
    }, d.prototype.setBlockStyle = function(t) {
      return this.paragraph.blockstyle = t;
    }, d.prototype.addText = function(t, e) {
      return this.paragraph.text.push(t), this.paragraph.style.push(e);
    }, i = {helvetica:'helvetica', 'sans-serif':'helvetica', 'times new roman':'times', serif:'times', times:'times', monospace:'courier', courier:'courier'}, c = {100:'normal', 200:'normal', 300:'normal', 400:'normal', 500:'bold', 600:'bold', 700:'bold', 800:'bold', 900:'bold', normal:'normal', bold:'bold', bolder:'bold', lighter:'normal'}, a = {normal:'normal', italic:'italic', oblique:'italic'}, s = {left:'left', right:'right', center:'center', justify:'justify'}, l = {none:'none', right:'right', 
    left:'left'}, u = {none:'none', both:'both'}, m = {normal:1}, e.fromHTML = function(t, e, n, r, i, o) {
      return this.margins_doc = o || {top:0, bottom:0}, r || (r = {}), r.elementHandlers || (r.elementHandlers = {}), x(this, t, isNaN(e) ? 4 : e, isNaN(n) ? 4 : n, r, i);
    };
  }(e.API), function(t) {
    var e, n, r;
    t.addJS = function(t) {
      return r = t, this.internal.events.subscribe('postPutResources', function(t) {
        e = this.internal.newObject(), this.internal.write('\x3c\x3c /Names [(EmbeddedJS) ' + (e + 1) + ' 0 R] \x3e\x3e', 'endobj'), n = this.internal.newObject(), this.internal.write('\x3c\x3c /S /JavaScript /JS (', r, ') \x3e\x3e', 'endobj');
      }), this.internal.events.subscribe('putCatalog', function() {
        void 0 !== e && void 0 !== n && this.internal.write('/Names \x3c\x3c/JavaScript ' + e + ' 0 R\x3e\x3e');
      }), this;
    };
  }(e.API), function(t) {
    return t.events.push(['postPutResources', function() {
      var t = this, e = /^(\d+) 0 obj$/;
      if (this.outline.root.children.length > 0) {
        for (var n = t.outline.render().split(/\r\n/), r = 0; r < n.length; r++) {
          var i = n[r], o = e.exec(i);
          if (null != o) {
            var a = o[1];
            t.internal.newObjectDeferredBegin(a);
          }
          t.internal.write(i);
        }
      }
      if (this.outline.createNamedDestinations) {
        for (var s = this.internal.pages.length, c = [], r = 0; r < s; r++) {
          var l = t.internal.newObject();
          c.push(l);
          var u = t.internal.getPageInfo(r + 1);
          t.internal.write('\x3c\x3c /D[' + u.objId + ' 0 R /XYZ null null null]\x3e\x3e endobj');
        }
        var h = t.internal.newObject();
        t.internal.write('\x3c\x3c /Names [ ');
        for (var r = 0; r < c.length; r++) {
          t.internal.write('(page_' + (r + 1) + ')' + c[r] + ' 0 R');
        }
        t.internal.write(' ] \x3e\x3e', 'endobj');
        t.internal.newObject();
        t.internal.write('\x3c\x3c /Dests ' + h + ' 0 R'), t.internal.write('\x3e\x3e', 'endobj');
      }
    }]), t.events.push(['putCatalog', function() {
      var t = this;
      t.outline.root.children.length > 0 && (t.internal.write('/Outlines', this.outline.makeRef(this.outline.root)), this.outline.createNamedDestinations && t.internal.write('/Names ' + namesOid + ' 0 R'));
    }]), t.events.push(['initialized', function() {
      var t = this;
      t.outline = {createNamedDestinations:!1, root:{children:[]}};
      t.outline.add = function(t, e, n) {
        var r = {title:e, options:n, children:[]};
        return null == t && (t = this.root), t.children.push(r), r;
      }, t.outline.render = function() {
        return this.ctx = {}, this.ctx.val = '', this.ctx.pdf = t, this.genIds_r(this.root), this.renderRoot(this.root), this.renderItems(this.root), this.ctx.val;
      }, t.outline.genIds_r = function(e) {
        e.id = t.internal.newObjectDeferred();
        for (var n = 0; n < e.children.length; n++) {
          this.genIds_r(e.children[n]);
        }
      }, t.outline.renderRoot = function(t) {
        this.objStart(t), this.line('/Type /Outlines'), t.children.length > 0 && (this.line('/First ' + this.makeRef(t.children[0])), this.line('/Last ' + this.makeRef(t.children[t.children.length - 1]))), this.line('/Count ' + this.count_r({count:0}, t)), this.objEnd();
      }, t.outline.renderItems = function(e) {
        for (var n = 0; n < e.children.length; n++) {
          var r = e.children[n];
          this.objStart(r), this.line('/Title ' + this.makeString(r.title)), this.line('/Parent ' + this.makeRef(e)), n > 0 && this.line('/Prev ' + this.makeRef(e.children[n - 1])), n < e.children.length - 1 && this.line('/Next ' + this.makeRef(e.children[n + 1])), r.children.length > 0 && (this.line('/First ' + this.makeRef(r.children[0])), this.line('/Last ' + this.makeRef(r.children[r.children.length - 1])));
          var i = this.count = this.count_r({count:0}, r);
          if (i > 0 && this.line('/Count ' + i), r.options && r.options.pageNumber) {
            var o = t.internal.getPageInfo(r.options.pageNumber);
            this.line('/Dest [' + o.objId + ' 0 R /XYZ 0 ' + this.ctx.pdf.internal.pageSize.height + ' 0]');
          }
          this.objEnd();
        }
        for (var n = 0; n < e.children.length; n++) {
          var r = e.children[n];
          this.renderItems(r);
        }
      }, t.outline.line = function(t) {
        this.ctx.val += t + '\r\n';
      }, t.outline.makeRef = function(t) {
        return t.id + ' 0 R';
      }, t.outline.makeString = function(e) {
        return '(' + t.internal.pdfEscape(e) + ')';
      }, t.outline.objStart = function(t) {
        this.ctx.val += '\r\n' + t.id + ' 0 obj\r\n\x3c\x3c\r\n';
      }, t.outline.objEnd = function(t) {
        this.ctx.val += '\x3e\x3e \r\nendobj\r\n';
      }, t.outline.count_r = function(t, e) {
        for (var n = 0; n < e.children.length; n++) {
          t.count++, this.count_r(t, e.children[n]);
        }
        return t.count;
      };
    }]), this;
  }(e.API), function(t) {
    var e = function() {
      return 'function' != typeof PNG || 'function' != typeof c;
    }, n = function(e) {
      return e !== t.image_compression.NONE && r();
    }, r = function() {
      var t = 'function' == typeof a;
      if (!t) {
        throw new Error('requires deflate.js for compression');
      }
      return t;
    }, i = function(e, n, r, i) {
      var c = 5, u = f;
      switch(i) {
        case t.image_compression.FAST:
          c = 3, u = h;
          break;
        case t.image_compression.MEDIUM:
          c = 6, u = d;
          break;
        case t.image_compression.SLOW:
          c = 9, u = p;
      }
      e = l(e, n, r, u);
      var g = new Uint8Array(o(c)), m = s(e), w = new a(c), y = w.append(e), v = w.flush(), b = g.length + y.length + v.length, x = new Uint8Array(b + 4);
      return x.set(g), x.set(y, g.length), x.set(v, g.length + y.length), x[b++] = m >>> 24 & 255, x[b++] = m >>> 16 & 255, x[b++] = m >>> 8 & 255, x[b++] = 255 & m, t.arrayBufferToBinaryString(x);
    }, o = function(t, e) {
      var n = 8, r = Math.LOG2E * Math.log(32768) - 8, i = r << 4 | n, o = i << 8, a = Math.min(3, (e - 1 & 255) >> 1);
      return o |= a << 6, o |= 0, o += 31 - o % 31, [i, 255 & o & 255];
    }, s = function(t, e) {
      for (var n, r = 1, i = 65535 & r, o = r >>> 16 & 65535, a = t.length, s = 0; a > 0;) {
        n = a > e ? e : a, a -= n;
        do {
          i += t[s++], o += i;
        } while (--n);
        i %= 65521, o %= 65521;
      }
      return (o << 16 | i) >>> 0;
    }, l = function(t, e, n, r) {
      for (var i, o, a, s = t.length / e, c = new Uint8Array(t.length + s), l = m(), u = 0; u < s; u++) {
        if (a = u * e, i = t.subarray(a, a + e), r) {
          c.set(r(i, n, o), a + u);
        } else {
          for (var h = 0, f = l.length, d = []; h < f; h++) {
            d[h] = l[h](i, n, o);
          }
          var p = w(d.concat());
          c.set(d[p], a + u);
        }
        o = i;
      }
      return c;
    }, u = function(t, e, n) {
      var r = Array.apply([], t);
      return r.unshift(0), r;
    }, h = function(t, e, n) {
      var r, i = [], o = 0, a = t.length;
      for (i[0] = 1; o < a; o++) {
        r = t[o - e] || 0, i[o + 1] = t[o] - r + 256 & 255;
      }
      return i;
    }, f = function(t, e, n) {
      var r, i = [], o = 0, a = t.length;
      for (i[0] = 2; o < a; o++) {
        r = n && n[o] || 0, i[o + 1] = t[o] - r + 256 & 255;
      }
      return i;
    }, d = function(t, e, n) {
      var r, i, o = [], a = 0, s = t.length;
      for (o[0] = 3; a < s; a++) {
        r = t[a - e] || 0, i = n && n[a] || 0, o[a + 1] = t[a] + 256 - (r + i >>> 1) & 255;
      }
      return o;
    }, p = function(t, e, n) {
      var r, i, o, a, s = [], c = 0, l = t.length;
      for (s[0] = 4; c < l; c++) {
        r = t[c - e] || 0, i = n && n[c] || 0, o = n && n[c - e] || 0, a = g(r, i, o), s[c + 1] = t[c] - a + 256 & 255;
      }
      return s;
    }, g = function(t, e, n) {
      var r = t + e - n, i = Math.abs(r - t), o = Math.abs(r - e), a = Math.abs(r - n);
      return i <= o && i <= a ? t : o <= a ? e : n;
    }, m = function() {
      return [u, h, f, d, p];
    }, w = function(t) {
      for (var e, n, r, i = 0, o = t.length; i < o;) {
        e = y(t[i].slice(1)), (e < n || !n) && (n = e, r = i), i++;
      }
      return r;
    }, y = function(t) {
      for (var e = 0, n = t.length, r = 0; e < n;) {
        r += Math.abs(t[e++]);
      }
      return r;
    }, v = function(e) {
      var n;
      switch(e) {
        case t.image_compression.FAST:
          n = 11;
          break;
        case t.image_compression.MEDIUM:
          n = 13;
          break;
        case t.image_compression.SLOW:
          n = 14;
          break;
        default:
          n = 12;
      }
      return n;
    };
    t.processPNG = function(t, r, o, a, s) {
      var c, l, u, h, f, d, p = this.color_spaces.DEVICE_RGB, g = this.decode.FLATE_DECODE, m = 8;
      if (this.isArrayBuffer(t) && (t = new Uint8Array(t)), this.isArrayBufferView(t)) {
        if (e()) {
          throw new Error('PNG support requires png.js and zlib.js');
        }
        if (c = new PNG(t), t = c.imgData, m = c.bits, p = c.colorSpace, h = c.colors, [4, 6].indexOf(c.colorType) !== -1) {
          if (8 === c.bits) {
            for (var w, y, b = 32 == c.pixelBitlength ? new Uint32Array(c.decodePixels().buffer) : 16 == c.pixelBitlength ? new Uint16Array(c.decodePixels().buffer) : new Uint8Array(c.decodePixels().buffer), x = b.length, k = new Uint8Array(x * c.colors), _ = new Uint8Array(x), C = c.pixelBitlength - c.bits, A = 0, S = 0; A < x; A++) {
              for (w = b[A], y = 0; y < C;) {
                k[S++] = w >>> y & 255, y += c.bits;
              }
              _[A] = w >>> y & 255;
            }
          }
          if (16 === c.bits) {
            for (var w, b = new Uint32Array(c.decodePixels().buffer), x = b.length, k = new Uint8Array(x * (32 / c.pixelBitlength) * c.colors), _ = new Uint8Array(x * (32 / c.pixelBitlength)), q = c.colors > 1, A = 0, S = 0, T = 0; A < x;) {
              w = b[A++], k[S++] = w >>> 0 & 255, q && (k[S++] = w >>> 16 & 255, w = b[A++], k[S++] = w >>> 0 & 255), _[T++] = w >>> 16 & 255;
            }
            m = 8;
          }
          n(a) ? (t = i(k, c.width * c.colors, c.colors, a), d = i(_, c.width, 1, a)) : (t = k, d = _, g = null);
        }
        if (3 === c.colorType && (p = this.color_spaces.INDEXED, f = c.palette, c.transparency.indexed)) {
          for (var P = c.transparency.indexed, I = 0, A = 0, x = P.length; A < x; ++A) {
            I += P[A];
          }
          if (I /= 255, I === x - 1 && P.indexOf(0) !== -1) {
            u = [P.indexOf(0)];
          } else {
            if (I !== x) {
              for (var b = c.decodePixels(), _ = new Uint8Array(b.length), A = 0, x = b.length; A < x; A++) {
                _[A] = P[b[A]];
              }
              d = i(_, c.width, 1);
            }
          }
        }
        var E = v(a);
        return l = g === this.decode.FLATE_DECODE ? '/Predictor ' + E + ' /Colors ' + h + ' /BitsPerComponent ' + m + ' /Columns ' + c.width : '/Colors ' + h + ' /BitsPerComponent ' + m + ' /Columns ' + c.width, (this.isArrayBuffer(t) || this.isArrayBufferView(t)) && (t = this.arrayBufferToBinaryString(t)), (d && this.isArrayBuffer(d) || this.isArrayBufferView(d)) && (d = this.arrayBufferToBinaryString(d)), this.createImageInfo(t, c.width, c.height, p, m, g, r, o, l, u, f, d, E);
      }
      throw new Error('Unsupported PNG image data, try using JPEG instead.');
    };
  }(e.API), function(t) {
    t.autoPrint = function() {
      var t;
      return this.internal.events.subscribe('postPutResources', function() {
        t = this.internal.newObject(), this.internal.write('\x3c\x3c /S/Named /Type/Action /N/Print \x3e\x3e', 'endobj');
      }), this.internal.events.subscribe('putCatalog', function() {
        this.internal.write('/OpenAction ' + t + ' 0 R');
      }), this;
    };
  }(e.API), function(t) {
    var e = t.getCharWidthsArray = function(t, e) {
      e || (e = {});
      var n, r, i, o = e.widths ? e.widths : this.internal.getFont().metadata.Unicode.widths, a = o.fof ? o.fof : 1, s = e.kerning ? e.kerning : this.internal.getFont().metadata.Unicode.kerning, c = s.fof ? s.fof : 1, l = 0, u = o[0] || a, h = [];
      for (n = 0, r = t.length; n < r; n++) {
        i = t.charCodeAt(n), h.push((o[i] || u) / a + (s[i] && s[i][l] || 0) / c), l = i;
      }
      return h;
    }, n = function(t) {
      for (var e = t.length, n = 0; e;) {
        e--, n += t[e];
      }
      return n;
    }, r = t.getStringUnitWidth = function(t, r) {
      return n(e.call(this, t, r));
    }, i = function(t, e, n, r) {
      for (var i = [], o = 0, a = t.length, s = 0; o !== a && s + e[o] < n;) {
        s += e[o], o++;
      }
      i.push(t.slice(0, o));
      var c = o;
      for (s = 0; o !== a;) {
        s + e[o] > r && (i.push(t.slice(c, o)), s = 0, c = o), s += e[o], o++;
      }
      return c !== o && i.push(t.slice(c, o)), i;
    }, o = function(t, o, a) {
      a || (a = {});
      var s, c, l, u, h, f, d = [], p = [d], g = a.textIndent || 0, m = 0, w = 0, y = t.split(' '), v = e(' ', a)[0];
      if (f = a.lineIndent === -1 ? y[0].length + 2 : a.lineIndent || 0) {
        var b = Array(f).join(' '), x = [];
        y.map(function(t) {
          t = t.split(/\s*\n/), t.length > 1 ? x = x.concat(t.map(function(t, e) {
            return (e && t.length ? '\n' : '') + t;
          })) : x.push(t[0]);
        }), y = x, f = r(b, a);
      }
      for (l = 0, u = y.length; l < u; l++) {
        var k = 0;
        if (s = y[l], f && '\n' == s[0] && (s = s.substr(1), k = 1), c = e(s, a), w = n(c), g + m + w > o || k) {
          if (w > o) {
            for (h = i(s, c, o - (g + m), o), d.push(h.shift()), d = [h.pop()]; h.length;) {
              p.push([h.shift()]);
            }
            w = n(c.slice(s.length - d[0].length));
          } else {
            d = [s];
          }
          p.push(d), g = w + f, m = v;
        } else {
          d.push(s), g += m + w, m = v;
        }
      }
      if (f) {
        var _ = function(t, e) {
          return (e ? b : '') + t.join(' ');
        };
      } else {
        var _ = function(t) {
          return t.join(' ');
        };
      }
      return p.map(_);
    };
    t.splitTextToSize = function(t, e, n) {
      n || (n = {});
      var r, i = n.fontSize || this.internal.getFontSize(), a = function(t) {
        var e = {0:1}, n = {};
        if (t.widths && t.kerning) {
          return {widths:t.widths, kerning:t.kerning};
        }
        var r = this.internal.getFont(t.fontName, t.fontStyle), i = 'Unicode';
        return r.metadata[i] ? {widths:r.metadata[i].widths || e, kerning:r.metadata[i].kerning || n} : {widths:e, kerning:n};
      }.call(this, n);
      r = Array.isArray(t) ? t : t.split(/\r?\n/);
      var s = 1 * this.internal.scaleFactor * e / i;
      a.textIndent = n.textIndent ? 1 * n.textIndent * this.internal.scaleFactor / i : 0, a.lineIndent = n.lineIndent;
      var c, l, u = [];
      for (c = 0, l = r.length; c < l; c++) {
        u = u.concat(o(r[c], s, a));
      }
      return u;
    };
  }(e.API), function(t) {
    var e = function(t) {
      for (var e = '0123456789abcdef', n = 'klmnopqrstuvwxyz', r = {}, i = 0; i < n.length; i++) {
        r[n[i]] = e[i];
      }
      var o, a, s, c, l, u = {}, h = 1, f = u, d = [], p = '', g = '', m = t.length - 1;
      for (i = 1; i != m;) {
        l = t[i], i += 1, "'" == l ? a ? (c = a.join(''), a = o) : a = [] : a ? a.push(l) : '{' == l ? (d.push([f, c]), f = {}, c = o) : '}' == l ? (s = d.pop(), s[0][s[1]] = f, c = o, f = s[0]) : '-' == l ? h = -1 : c === o ? r.hasOwnProperty(l) ? (p += r[l], c = parseInt(p, 16) * h, h = 1, p = '') : p += l : r.hasOwnProperty(l) ? (g += r[l], f[c] = parseInt(g, 16) * h, h = 1, c = o, g = '') : g += l;
      }
      return u;
    }, n = {codePages:['WinAnsiEncoding'], WinAnsiEncoding:e('{19m8n201n9q201o9r201s9l201t9m201u8m201w9n201x9o201y8o202k8q202l8r202m9p202q8p20aw8k203k8t203t8v203u9v2cq8s212m9t15m8w15n9w2dw9s16k8u16l9u17s9z17x8y17y9y}')}, r = {Unicode:{Courier:n, 'Courier-Bold':n, 'Courier-BoldOblique':n, 'Courier-Oblique':n, Helvetica:n, 'Helvetica-Bold':n, 'Helvetica-BoldOblique':n, 'Helvetica-Oblique':n, 'Times-Roman':n, 'Times-Bold':n, 'Times-BoldItalic':n, 'Times-Italic':n}}, i = {Unicode:{'Courier-Oblique':e("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), 
    'Times-BoldItalic':e("{'widths'{k3o2q4ycx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2r202m2n2n3m2o3m2p5n202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5n4l4m4m4m4n4m4o4s4p4m4q4m4r4s4s4y4t2r4u3m4v4m4w3x4x5t4y4s4z4s5k3x5l4s5m4m5n3r5o3x5p4s5q4m5r5t5s4m5t3x5u3x5v2l5w1w5x2l5y3t5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q2l6r3m6s3r6t1w6u1w6v3m6w1w6x4y6y3r6z3m7k3m7l3m7m2r7n2r7o1w7p3r7q2w7r4m7s3m7t2w7u2r7v2n7w1q7x2n7y3t202l3mcl4mal2ram3man3mao3map3mar3mas2lat4uau1uav3maw3way4uaz2lbk2sbl3t'fof'6obo2lbp3tbq3mbr1tbs2lbu1ybv3mbz3mck4m202k3mcm4mcn4mco4mcp4mcq5ycr4mcs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz2w203k6o212m6o2dw2l2cq2l3t3m3u2l17s3x19m3m}'kerning'{cl{4qu5kt5qt5rs17ss5ts}201s{201ss}201t{cks4lscmscnscoscpscls2wu2yu201ts}201x{2wu2yu}2k{201ts}2w{4qx5kx5ou5qx5rs17su5tu}2x{17su5tu5ou}2y{4qx5kx5ou5qx5rs17ss5ts}'fof'-6ofn{17sw5tw5ou5qw5rs}7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qs}3v{17su5tu5os5qs}7p{17su5tu}ck{4qu5kt5qt5rs17ss5ts}4l{4qu5kt5qt5rs17ss5ts}cm{4qu5kt5qt5rs17ss5ts}cn{4qu5kt5qt5rs17ss5ts}co{4qu5kt5qt5rs17ss5ts}cp{4qu5kt5qt5rs17ss5ts}6l{4qu5ou5qw5rt17su5tu}5q{ckuclucmucnucoucpu4lu}5r{ckuclucmucnucoucpu4lu}7q{cksclscmscnscoscps4ls}6p{4qu5ou5qw5rt17sw5tw}ek{4qu5ou5qw5rt17su5tu}el{4qu5ou5qw5rt17su5tu}em{4qu5ou5qw5rt17su5tu}en{4qu5ou5qw5rt17su5tu}eo{4qu5ou5qw5rt17su5tu}ep{4qu5ou5qw5rt17su5tu}es{17ss5ts5qs4qu}et{4qu5ou5qw5rt17sw5tw}eu{4qu5ou5qw5rt17ss5ts}ev{17ss5ts5qs4qu}6z{17sw5tw5ou5qw5rs}fm{17sw5tw5ou5qw5rs}7n{201ts}fo{17sw5tw5ou5qw5rs}fp{17sw5tw5ou5qw5rs}fq{17sw5tw5ou5qw5rs}7r{cksclscmscnscoscps4ls}fs{17sw5tw5ou5qw5rs}ft{17su5tu}fu{17su5tu}fv{17su5tu}fw{17su5tu}fz{cksclscmscnscoscps4ls}}}"), 
    'Helvetica-Bold':e("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}"), 
    Courier:e("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), 'Courier-BoldOblique':e("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), 'Times-Bold':e("{'widths'{k3q2q5ncx2r201n3m201o6o201s2l201t2l201u2l201w3m201x3m201y3m2k1t2l2l202m2n2n3m2o3m2p6o202q6o2r1w2s2l2t2l2u3m2v3t2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w3t3x3t3y3t3z3m4k5x4l4s4m4m4n4s4o4s4p4m4q3x4r4y4s4y4t2r4u3m4v4y4w4m4x5y4y4s4z4y5k3x5l4y5m4s5n3r5o4m5p4s5q4s5r6o5s4s5t4s5u4m5v2l5w1w5x2l5y3u5z3m6k2l6l3m6m3r6n2w6o3r6p2w6q2l6r3m6s3r6t1w6u2l6v3r6w1w6x5n6y3r6z3m7k3r7l3r7m2w7n2r7o2l7p3r7q3m7r4s7s3m7t3m7u2w7v2r7w1q7x2r7y3o202l3mcl4sal2lam3man3mao3map3mar3mas2lat4uau1yav3maw3tay4uaz2lbk2sbl3t'fof'6obo2lbp3rbr1tbs2lbu2lbv3mbz3mck4s202k3mcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw2r2m3rcy2rcz2rdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3rek3mel3mem3men3meo3mep3meq4ser2wes2wet2weu2wev2wew1wex1wey1wez1wfl3rfm3mfn3mfo3mfp3mfq3mfr3tfs3mft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3m3u2l17s4s19m3m}'kerning'{cl{4qt5ks5ot5qy5rw17sv5tv}201t{cks4lscmscnscoscpscls4wv}2k{201ts}2w{4qu5ku7mu5os5qx5ru17su5tu}2x{17su5tu5ou5qs}2y{4qv5kv7mu5ot5qz5ru17su5tu}'fof'-6o7t{cksclscmscnscoscps4ls}3u{17su5tu5os5qu}3v{17su5tu5os5qu}fu{17su5tu5ou5qu}7p{17su5tu5ou5qu}ck{4qt5ks5ot5qy5rw17sv5tv}4l{4qt5ks5ot5qy5rw17sv5tv}cm{4qt5ks5ot5qy5rw17sv5tv}cn{4qt5ks5ot5qy5rw17sv5tv}co{4qt5ks5ot5qy5rw17sv5tv}cp{4qt5ks5ot5qy5rw17sv5tv}6l{17st5tt5ou5qu}17s{ckuclucmucnucoucpu4lu4wu}5o{ckuclucmucnucoucpu4lu4wu}5q{ckzclzcmzcnzcozcpz4lz4wu}5r{ckxclxcmxcnxcoxcpx4lx4wu}5t{ckuclucmucnucoucpu4lu4wu}7q{ckuclucmucnucoucpu4lu}6p{17sw5tw5ou5qu}ek{17st5tt5qu}el{17st5tt5ou5qu}em{17st5tt5qu}en{17st5tt5qu}eo{17st5tt5qu}ep{17st5tt5ou5qu}es{17ss5ts5qu}et{17sw5tw5ou5qu}eu{17sw5tw5ou5qu}ev{17ss5ts5qu}6z{17sw5tw5ou5qu5rs}fm{17sw5tw5ou5qu5rs}fn{17sw5tw5ou5qu5rs}fo{17sw5tw5ou5qu5rs}fp{17sw5tw5ou5qu5rs}fq{17sw5tw5ou5qu5rs}7r{cktcltcmtcntcotcpt4lt5os}fs{17sw5tw5ou5qu5rs}ft{17su5tu5ou5qu}7m{5os}fv{17su5tu5ou5qu}fw{17su5tu5ou5qu}fz{cksclscmscnscoscps4ls}}}"), 
    Helvetica:e("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}"), 
    'Helvetica-BoldOblique':e("{'widths'{k3s2q4scx1w201n3r201o6o201s1w201t1w201u1w201w3m201x3m201y3m2k1w2l2l202m2n2n3r2o3r2p5t202q6o2r1s2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v2l3w3u3x3u3y3u3z3x4k6l4l4s4m4s4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3r4v4s4w3x4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v2l5w1w5x2l5y3u5z3r6k2l6l3r6m3x6n3r6o3x6p3r6q2l6r3x6s3x6t1w6u1w6v3r6w1w6x5t6y3x6z3x7k3x7l3x7m2r7n3r7o2l7p3x7q3r7r4y7s3r7t3r7u3m7v2r7w1w7x2r7y3u202l3rcl4sal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3xbq3rbr1wbs2lbu2obv3rbz3xck4s202k3rcm4scn4sco4scp4scq6ocr4scs4mct4mcu4mcv4mcw1w2m2zcy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3res3ret3reu3rev3rew1wex1wey1wez1wfl3xfm3xfn3xfo3xfp3xfq3xfr3ufs3xft3xfu3xfv3xfw3xfz3r203k6o212m6o2dw2l2cq2l3t3r3u2l17s4m19m3r}'kerning'{cl{4qs5ku5ot5qs17sv5tv}201t{2ww4wy2yw}201w{2ks}201x{2ww4wy2yw}2k{201ts201xs}2w{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}2x{5ow5qs}2y{7qs4qu5kw5os5qw5rs17su5tu7tsfzs}'fof'-6o7p{17su5tu5ot}ck{4qs5ku5ot5qs17sv5tv}4l{4qs5ku5ot5qs17sv5tv}cm{4qs5ku5ot5qs17sv5tv}cn{4qs5ku5ot5qs17sv5tv}co{4qs5ku5ot5qs17sv5tv}cp{4qs5ku5ot5qs17sv5tv}6l{17st5tt5os}17s{2kwclvcmvcnvcovcpv4lv4wwckv}5o{2kucltcmtcntcotcpt4lt4wtckt}5q{2ksclscmscnscoscps4ls4wvcks}5r{2ks4ws}5t{2kwclvcmvcnvcovcpv4lv4wwckv}eo{17st5tt5os}fu{17su5tu5ot}6p{17ss5ts}ek{17st5tt5os}el{17st5tt5os}em{17st5tt5os}en{17st5tt5os}6o{201ts}ep{17st5tt5os}es{17ss5ts}et{17ss5ts}eu{17ss5ts}ev{17ss5ts}6z{17su5tu5os5qt}fm{17su5tu5os5qt}fn{17su5tu5os5qt}fo{17su5tu5os5qt}fp{17su5tu5os5qt}fq{17su5tu5os5qt}fs{17su5tu5os5qt}ft{17su5tu5ot}7m{5os}fv{17su5tu5ot}fw{17su5tu5ot}}}"), 
    'Courier-Bold':e("{'widths'{k3w'fof'6o}'kerning'{'fof'-6o}}"), 'Times-Italic':e("{'widths'{k3n2q4ycx2l201n3m201o5t201s2l201t2l201u2l201w3r201x3r201y3r2k1t2l2l202m2n2n3m2o3m2p5n202q5t2r1p2s2l2t2l2u3m2v4n2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v2l3w4n3x4n3y4n3z3m4k5w4l3x4m3x4n4m4o4s4p3x4q3x4r4s4s4s4t2l4u2w4v4m4w3r4x5n4y4m4z4s5k3x5l4s5m3x5n3m5o3r5p4s5q3x5r5n5s3x5t3r5u3r5v2r5w1w5x2r5y2u5z3m6k2l6l3m6m3m6n2w6o3m6p2w6q1w6r3m6s3m6t1w6u1w6v2w6w1w6x4s6y3m6z3m7k3m7l3m7m2r7n2r7o1w7p3m7q2w7r4m7s2w7t2w7u2r7v2s7w1v7x2s7y3q202l3mcl3xal2ram3man3mao3map3mar3mas2lat4wau1vav3maw4nay4waz2lbk2sbl4n'fof'6obo2lbp3mbq3obr1tbs2lbu1zbv3mbz3mck3x202k3mcm3xcn3xco3xcp3xcq5tcr4mcs3xct3xcu3xcv3xcw2l2m2ucy2lcz2ldl4mdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek3mel3mem3men3meo3mep3meq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr4nfs3mft3mfu3mfv3mfw3mfz2w203k6o212m6m2dw2l2cq2l3t3m3u2l17s3r19m3m}'kerning'{cl{5kt4qw}201s{201sw}201t{201tw2wy2yy6q-t}201x{2wy2yy}2k{201tw}2w{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}2x{17ss5ts5os}2y{7qs4qy7rs5ky7mw5os5qx5ru17su5tu}'fof'-6o6t{17ss5ts5qs}7t{5os}3v{5qs}7p{17su5tu5qs}ck{5kt4qw}4l{5kt4qw}cm{5kt4qw}cn{5kt4qw}co{5kt4qw}cp{5kt4qw}6l{4qs5ks5ou5qw5ru17su5tu}17s{2ks}5q{ckvclvcmvcnvcovcpv4lv}5r{ckuclucmucnucoucpu4lu}5t{2ks}6p{4qs5ks5ou5qw5ru17su5tu}ek{4qs5ks5ou5qw5ru17su5tu}el{4qs5ks5ou5qw5ru17su5tu}em{4qs5ks5ou5qw5ru17su5tu}en{4qs5ks5ou5qw5ru17su5tu}eo{4qs5ks5ou5qw5ru17su5tu}ep{4qs5ks5ou5qw5ru17su5tu}es{5ks5qs4qs}et{4qs5ks5ou5qw5ru17su5tu}eu{4qs5ks5qw5ru17su5tu}ev{5ks5qs4qs}ex{17ss5ts5qs}6z{4qv5ks5ou5qw5ru17su5tu}fm{4qv5ks5ou5qw5ru17su5tu}fn{4qv5ks5ou5qw5ru17su5tu}fo{4qv5ks5ou5qw5ru17su5tu}fp{4qv5ks5ou5qw5ru17su5tu}fq{4qv5ks5ou5qw5ru17su5tu}7r{5os}fs{4qv5ks5ou5qw5ru17su5tu}ft{17su5tu5qs}fu{17su5tu5qs}fv{17su5tu5qs}fw{17su5tu5qs}}}"), 
    'Times-Roman':e("{'widths'{k3n2q4ycx2l201n3m201o6o201s2l201t2l201u2l201w2w201x2w201y2w2k1t2l2l202m2n2n3m2o3m2p5n202q6o2r1m2s2l2t2l2u3m2v3s2w1t2x2l2y1t2z1w3k3m3l3m3m3m3n3m3o3m3p3m3q3m3r3m3s3m203t2l203u2l3v1w3w3s3x3s3y3s3z2w4k5w4l4s4m4m4n4m4o4s4p3x4q3r4r4s4s4s4t2l4u2r4v4s4w3x4x5t4y4s4z4s5k3r5l4s5m4m5n3r5o3x5p4s5q4s5r5y5s4s5t4s5u3x5v2l5w1w5x2l5y2z5z3m6k2l6l2w6m3m6n2w6o3m6p2w6q2l6r3m6s3m6t1w6u1w6v3m6w1w6x4y6y3m6z3m7k3m7l3m7m2l7n2r7o1w7p3m7q3m7r4s7s3m7t3m7u2w7v3k7w1o7x3k7y3q202l3mcl4sal2lam3man3mao3map3mar3mas2lat4wau1vav3maw3say4waz2lbk2sbl3s'fof'6obo2lbp3mbq2xbr1tbs2lbu1zbv3mbz2wck4s202k3mcm4scn4sco4scp4scq5tcr4mcs3xct3xcu3xcv3xcw2l2m2tcy2lcz2ldl4sdm4sdn4sdo4sdp4sdq4sds4sdt4sdu4sdv4sdw4sdz3mek2wel2wem2wen2weo2wep2weq4mer2wes2wet2weu2wev2wew1wex1wey1wez1wfl3mfm3mfn3mfo3mfp3mfq3mfr3sfs3mft3mfu3mfv3mfw3mfz3m203k6o212m6m2dw2l2cq2l3t3m3u1w17s4s19m3m}'kerning'{cl{4qs5ku17sw5ou5qy5rw201ss5tw201ws}201s{201ss}201t{ckw4lwcmwcnwcowcpwclw4wu201ts}2k{201ts}2w{4qs5kw5os5qx5ru17sx5tx}2x{17sw5tw5ou5qu}2y{4qs5kw5os5qx5ru17sx5tx}'fof'-6o7t{ckuclucmucnucoucpu4lu5os5rs}3u{17su5tu5qs}3v{17su5tu5qs}7p{17sw5tw5qs}ck{4qs5ku17sw5ou5qy5rw201ss5tw201ws}4l{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cm{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cn{4qs5ku17sw5ou5qy5rw201ss5tw201ws}co{4qs5ku17sw5ou5qy5rw201ss5tw201ws}cp{4qs5ku17sw5ou5qy5rw201ss5tw201ws}6l{17su5tu5os5qw5rs}17s{2ktclvcmvcnvcovcpv4lv4wuckv}5o{ckwclwcmwcnwcowcpw4lw4wu}5q{ckyclycmycnycoycpy4ly4wu5ms}5r{cktcltcmtcntcotcpt4lt4ws}5t{2ktclvcmvcnvcovcpv4lv4wuckv}7q{cksclscmscnscoscps4ls}6p{17su5tu5qw5rs}ek{5qs5rs}el{17su5tu5os5qw5rs}em{17su5tu5os5qs5rs}en{17su5qs5rs}eo{5qs5rs}ep{17su5tu5os5qw5rs}es{5qs}et{17su5tu5qw5rs}eu{17su5tu5qs5rs}ev{5qs}6z{17sv5tv5os5qx5rs}fm{5os5qt5rs}fn{17sv5tv5os5qx5rs}fo{17sv5tv5os5qx5rs}fp{5os5qt5rs}fq{5os5qt5rs}7r{ckuclucmucnucoucpu4lu5os}fs{17sv5tv5os5qx5rs}ft{17ss5ts5qs}fu{17sw5tw5qs}fv{17sw5tw5qs}fw{17ss5ts5qs}fz{ckuclucmucnucoucpu4lu5os5rs}}}"), 
    'Helvetica-Oblique':e("{'widths'{k3p2q4mcx1w201n3r201o6o201s1q201t1q201u1q201w2l201x2l201y2l2k1w2l1w202m2n2n3r2o3r2p5t202q6o2r1n2s2l2t2l2u2r2v3u2w1w2x2l2y1w2z1w3k3r3l3r3m3r3n3r3o3r3p3r3q3r3r3r3s3r203t2l203u2l3v1w3w3u3x3u3y3u3z3r4k6p4l4m4m4m4n4s4o4s4p4m4q3x4r4y4s4s4t1w4u3m4v4m4w3r4x5n4y4s4z4y5k4m5l4y5m4s5n4m5o3x5p4s5q4m5r5y5s4m5t4m5u3x5v1w5w1w5x1w5y2z5z3r6k2l6l3r6m3r6n3m6o3r6p3r6q1w6r3r6s3r6t1q6u1q6v3m6w1q6x5n6y3r6z3r7k3r7l3r7m2l7n3m7o1w7p3r7q3m7r4s7s3m7t3m7u3m7v2l7w1u7x2l7y3u202l3rcl4mal2lam3ran3rao3rap3rar3ras2lat4tau2pav3raw3uay4taz2lbk2sbl3u'fof'6obo2lbp3rbr1wbs2lbu2obv3rbz3xck4m202k3rcm4mcn4mco4mcp4mcq6ocr4scs4mct4mcu4mcv4mcw1w2m2ncy1wcz1wdl4sdm4ydn4ydo4ydp4ydq4yds4ydt4sdu4sdv4sdw4sdz3xek3rel3rem3ren3reo3rep3req5ter3mes3ret3reu3rev3rew1wex1wey1wez1wfl3rfm3rfn3rfo3rfp3rfq3rfr3ufs3xft3rfu3rfv3rfw3rfz3m203k6o212m6o2dw2l2cq2l3t3r3u1w17s4m19m3r}'kerning'{5q{4wv}cl{4qs5kw5ow5qs17sv5tv}201t{2wu4w1k2yu}201x{2wu4wy2yu}17s{2ktclucmucnu4otcpu4lu4wycoucku}2w{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}2x{17sy5ty5oy5qs}2y{7qs4qz5k1m17sy5ow5qx5rsfsu5ty7tufzu}'fof'-6o7p{17sv5tv5ow}ck{4qs5kw5ow5qs17sv5tv}4l{4qs5kw5ow5qs17sv5tv}cm{4qs5kw5ow5qs17sv5tv}cn{4qs5kw5ow5qs17sv5tv}co{4qs5kw5ow5qs17sv5tv}cp{4qs5kw5ow5qs17sv5tv}6l{17sy5ty5ow}do{17st5tt}4z{17st5tt}7s{fst}dm{17st5tt}dn{17st5tt}5o{ckwclwcmwcnwcowcpw4lw4wv}dp{17st5tt}dq{17st5tt}7t{5ow}ds{17st5tt}5t{2ktclucmucnu4otcpu4lu4wycoucku}fu{17sv5tv5ow}6p{17sy5ty5ow5qs}ek{17sy5ty5ow}el{17sy5ty5ow}em{17sy5ty5ow}en{5ty}eo{17sy5ty5ow}ep{17sy5ty5ow}es{17sy5ty5qs}et{17sy5ty5ow5qs}eu{17sy5ty5ow5qs}ev{17sy5ty5ow5qs}6z{17sy5ty5ow5qs}fm{17sy5ty5ow5qs}fn{17sy5ty5ow5qs}fo{17sy5ty5ow5qs}fp{17sy5ty5qs}fq{17sy5ty5ow5qs}7r{5ow}fs{17sy5ty5ow5qs}ft{17sv5tv5ow}7m{5ow}fv{17sv5tv5ow}fw{17sv5tv5ow}}}")}};
    t.events.push(['addFont', function(t) {
      var e, n, o, a = 'Unicode';
      e = i[a][t.PostScriptName], e && (n = t.metadata[a] ? t.metadata[a] : t.metadata[a] = {}, n.widths = e.widths, n.kerning = e.kerning), o = r[a][t.PostScriptName], o && (n = t.metadata[a] ? t.metadata[a] : t.metadata[a] = {}, n.encoding = o, o.codePages && o.codePages.length && (t.encoding = o.codePages[0]));
    }]);
  }(e.API), function(t) {
    t.addSVG = function(t, e, n, r, i) {
      function o(t, e) {
        var n = e.createElement('style');
        n.type = 'text/css', n.styleSheet ? n.styleSheet.cssText = t : n.appendChild(e.createTextNode(t)), e.getElementsByTagName('head')[0].appendChild(n);
      }
      function a(t) {
        var e = 'childframe', n = t.createElement('iframe');
        return o('.jsPDF_sillysvg_iframe {display:none;position:absolute;}', t), n.name = e, n.setAttribute('width', 0), n.setAttribute('height', 0), n.setAttribute('frameborder', '0'), n.setAttribute('scrolling', 'no'), n.setAttribute('seamless', 'seamless'), n.setAttribute('class', 'jsPDF_sillysvg_iframe'), t.body.appendChild(n), n;
      }
      function s(t, e) {
        var n = (e.contentWindow || e.contentDocument).document;
        return n.write(t), n.close(), n.getElementsByTagName('svg')[0];
      }
      function c(t) {
        for (var e = parseFloat(t[1]), n = parseFloat(t[2]), r = [], i = 3, o = t.length; i < o;) {
          'c' === t[i] ? (r.push([parseFloat(t[i + 1]), parseFloat(t[i + 2]), parseFloat(t[i + 3]), parseFloat(t[i + 4]), parseFloat(t[i + 5]), parseFloat(t[i + 6])]), i += 7) : 'l' === t[i] ? (r.push([parseFloat(t[i + 1]), parseFloat(t[i + 2])]), i += 3) : i += 1;
        }
        return [e, n, r];
      }
      var l;
      if (e === l || n === l) {
        throw new Error("addSVG needs values for 'x' and 'y'");
      }
      var u = a(document), h = s(t, u), f = [1, 1], d = parseFloat(h.getAttribute('width')), p = parseFloat(h.getAttribute('height'));
      d && p && (r && i ? f = [r / d, i / p] : r ? f = [r / d, r / d] : i && (f = [i / p, i / p]));
      var g, m, w, y, v = h.childNodes;
      for (g = 0, m = v.length; g < m; g++) {
        w = v[g], w.tagName && 'PATH' === w.tagName.toUpperCase() && (y = c(w.getAttribute('d').split(' ')), y[0] = y[0] * f[0] + e, y[1] = y[1] * f[1] + n, this.lines.call(this, y[2], y[0], y[1], f));
      }
      return this;
    };
  }(e.API), function(t) {
    t.putTotalPages = function(t) {
      for (var e = new RegExp(t, 'g'), n = 1; n <= this.internal.getNumberOfPages(); n++) {
        for (var r = 0; r < this.internal.pages[n].length; r++) {
          this.internal.pages[n][r] = this.internal.pages[n][r].replace(e, this.internal.getNumberOfPages());
        }
      }
      return this;
    };
  }(e.API), function(t) {
    var e = '', n = '', r = '';
    t.addMetadata = function(t, i) {
      return n = i || 'http://jspdf.default.namespaceuri/', e = t, this.internal.events.subscribe('postPutResources', function() {
        if (e) {
          var t = '\x3cx:xmpmeta xmlns:x\x3d"adobe:ns:meta/"\x3e', i = '\x3crdf:RDF xmlns:rdf\x3d"http://www.w3.org/1999/02/22-rdf-syntax-ns#"\x3e\x3crdf:Description rdf:about\x3d"" xmlns:jspdf\x3d"' + n + '"\x3e\x3cjspdf:metadata\x3e', o = '\x3c/jspdf:metadata\x3e\x3c/rdf:Description\x3e\x3c/rdf:RDF\x3e', a = '\x3c/x:xmpmeta\x3e', s = unescape(encodeURIComponent(t)), c = unescape(encodeURIComponent(i)), l = unescape(encodeURIComponent(e)), u = unescape(encodeURIComponent(o)), h = unescape(encodeURIComponent(a)), 
          f = c.length + l.length + u.length + s.length + h.length;
          r = this.internal.newObject(), this.internal.write('\x3c\x3c /Type /Metadata /Subtype /XML /Length ' + f + ' \x3e\x3e'), this.internal.write('stream'), this.internal.write(s + c + l + u + h), this.internal.write('endstream'), this.internal.write('endobj');
        } else {
          r = '';
        }
      }), this.internal.events.subscribe('putCatalog', function() {
        r && this.internal.write('/Metadata ' + r + ' 0 R');
      }), this;
    };
  }(e.API), function(t) {
    if (t.URL = t.URL || t.webkitURL, t.Blob && t.URL) {
      try {
        return void new Blob;
      } catch (t$41) {
      }
    }
    var e = t.BlobBuilder || t.WebKitBlobBuilder || t.MozBlobBuilder || function(t) {
      var e = function(t) {
        return Object.prototype.toString.call(t).match(/^\[object\s(.*)\]$/)[1];
      }, n = function() {
        this.data = [];
      }, r = function(t, e, n) {
        this.data = t, this.size = t.length, this.type = e, this.encoding = n;
      }, i = n.prototype, o = r.prototype, a = t.FileReaderSync, s = function(t) {
        this.code = this[this.name = t];
      }, c = 'NOT_FOUND_ERR SECURITY_ERR ABORT_ERR NOT_READABLE_ERR ENCODING_ERR NO_MODIFICATION_ALLOWED_ERR INVALID_STATE_ERR SYNTAX_ERR'.split(' '), l = c.length, u = t.URL || t.webkitURL || t, h = u.createObjectURL, f = u.revokeObjectURL, d = u, p = t.btoa, g = t.atob, m = t.ArrayBuffer, w = t.Uint8Array, y = /^[\w-]+:\/*\[?[\w\.:-]+\]?(?::[0-9]+)?/;
      for (r.fake = o.fake = !0; l--;) {
        s.prototype[c[l]] = l + 1;
      }
      return u.createObjectURL || (d = t.URL = function(t) {
        var e, n = document.createElementNS('http://www.w3.org/1999/xhtml', 'a');
        return n.href = t, 'origin' in n || ('data:' === n.protocol.toLowerCase() ? n.origin = null : (e = t.match(y), n.origin = e && e[1])), n;
      }), d.createObjectURL = function(t) {
        var e, n = t.type;
        return null === n && (n = 'application/octet-stream'), t instanceof r ? (e = 'data:' + n, 'base64' === t.encoding ? e + ';base64,' + t.data : 'URI' === t.encoding ? e + ',' + decodeURIComponent(t.data) : p ? e + ';base64,' + p(t.data) : e + ',' + encodeURIComponent(t.data)) : h ? h.call(u, t) : void 0;
      }, d.revokeObjectURL = function(t) {
        'data:' !== t.substring(0, 5) && f && f.call(u, t);
      }, i.append = function(t) {
        var n = this.data;
        if (w && (t instanceof m || t instanceof w)) {
          for (var i = '', o = new w(t), c = 0, l = o.length; c < l; c++) {
            i += String.fromCharCode(o[c]);
          }
          n.push(i);
        } else {
          if ('Blob' === e(t) || 'File' === e(t)) {
            if (!a) {
              throw new s('NOT_READABLE_ERR');
            }
            var u = new a;
            n.push(u.readAsBinaryString(t));
          } else {
            t instanceof r ? 'base64' === t.encoding && g ? n.push(g(t.data)) : 'URI' === t.encoding ? n.push(decodeURIComponent(t.data)) : 'raw' === t.encoding && n.push(t.data) : ('string' != typeof t && (t += ''), n.push(unescape(encodeURIComponent(t))));
          }
        }
      }, i.getBlob = function(t) {
        return arguments.length || (t = null), new r(this.data.join(''), t, 'raw');
      }, i.toString = function() {
        return '[object BlobBuilder]';
      }, o.slice = function(t, e, n) {
        var i = arguments.length;
        return i < 3 && (n = null), new r(this.data.slice(t, i > 1 ? e : this.data.length), n, this.encoding);
      }, o.toString = function() {
        return '[object Blob]';
      }, o.close = function() {
        this.size = 0, delete this.data;
      }, n;
    }(t);
    t.Blob = function(t, n) {
      var r = n ? n.type || '' : '', i = new e;
      if (t) {
        for (var o = 0, a = t.length; o < a; o++) {
          Uint8Array && t[o] instanceof Uint8Array ? i.append(t[o].buffer) : i.append(t[o]);
        }
      }
      var s = i.getBlob(r);
      return !s.slice && s.webkitSlice && (s.slice = s.webkitSlice), s;
    };
    var n = Object.getPrototypeOf || function(t) {
      return t.__proto__;
    };
    t.Blob.prototype = n(new t.Blob);
  }('undefined' != typeof self && self || 'undefined' != typeof window && window || (void 0).content || void 0);
  var i = i || function(t) {
    if ('undefined' == typeof navigator || !/MSIE [1-9]\./.test(navigator.userAgent)) {
      var e = t.document, n = function() {
        return t.URL || t.webkitURL || t;
      }, r = e.createElementNS('http://www.w3.org/1999/xhtml', 'a'), i = 'download' in r, o = function(t) {
        var e = new MouseEvent('click');
        t.dispatchEvent(e);
      }, a = /Version\/[\d\.]+.*Safari/.test(navigator.userAgent), s = t.webkitRequestFileSystem, c = t.requestFileSystem || s || t.mozRequestFileSystem, l = function(e) {
        (t.setImmediate || t.setTimeout)(function() {
          throw e;
        }, 0);
      }, u = 'application/octet-stream', h = 0, f = 500, d = function(e) {
        var r = function() {
          'string' == typeof e ? n().revokeObjectURL(e) : e.remove();
        };
        t.chrome ? r() : setTimeout(r, f);
      }, p = function(t, e, n) {
        e = [].concat(e);
        for (var r = e.length; r--;) {
          var i = t['on' + e[r]];
          if ('function' == typeof i) {
            try {
              i.call(t, n || t);
            } catch (t$42) {
              l(t$42);
            }
          }
        }
      }, g = function(t) {
        return /^\s*(?:text\/\S*|application\/xml|\S*\/\S*\+xml)\s*;.*charset\s*=\s*utf-8/i.test(t.type) ? new Blob(['', t], {type:t.type}) : t;
      }, m = function(e, l, f) {
        f || (e = g(e));
        var m, w, y, v = this, b = e.type, x = !1, k = function() {
          p(v, 'writestart progress write writeend'.split(' '));
        }, _ = function() {
          if (w && a && 'undefined' != typeof FileReader) {
            var r = new FileReader;
            return r.onloadend = function() {
              var t = r.result;
              w.location.href = 'data:attachment/file' + t.slice(t.search(/[,;]/)), v.readyState = v.DONE, k();
            }, r.readAsDataURL(e), void(v.readyState = v.INIT);
          }
          if (!x && m || (m = n().createObjectURL(e)), w) {
            w.location.href = m;
          } else {
            var i = t.open(m, '_blank');
            void 0 == i && a && (t.location.href = m);
          }
          v.readyState = v.DONE, k(), d(m);
        }, C = function(t) {
          return function() {
            if (v.readyState !== v.DONE) {
              return t.apply(this, arguments);
            }
          };
        }, A = {create:!0, exclusive:!1};
        return v.readyState = v.INIT, l || (l = 'download'), i ? (m = n().createObjectURL(e), void setTimeout(function() {
          r.href = m, r.download = l, o(r), k(), d(m), v.readyState = v.DONE;
        })) : (t.chrome && b && b !== u && (y = e.slice || e.webkitSlice, e = y.call(e, 0, e.size, u), x = !0), s && 'download' !== l && (l += '.download'), (b === u || s) && (w = t), c ? (h += e.size, void c(t.TEMPORARY, h, C(function(t) {
          t.root.getDirectory('saved', A, C(function(t) {
            var n = function() {
              t.getFile(l, A, C(function(t) {
                t.createWriter(C(function(n) {
                  n.onwriteend = function(e) {
                    w.location.href = t.toURL(), v.readyState = v.DONE, p(v, 'writeend', e), d(t);
                  }, n.onerror = function() {
                    var t = n.error;
                    t.code !== t.ABORT_ERR && _();
                  }, 'writestart progress write abort'.split(' ').forEach(function(t) {
                    n['on' + t] = v['on' + t];
                  }), n.write(e), v.abort = function() {
                    n.abort(), v.readyState = v.DONE;
                  }, v.readyState = v.WRITING;
                }), _);
              }), _);
            };
            t.getFile(l, {create:!1}, C(function(t) {
              t.remove(), n();
            }), C(function(t) {
              t.code === t.NOT_FOUND_ERR ? n() : _();
            }));
          }), _);
        }), _)) : void _());
      }, w = m.prototype, y = function(t, e, n) {
        return new m(t, e, n);
      };
      return 'undefined' != typeof navigator && navigator.msSaveOrOpenBlob ? function(t, e, n) {
        return n || (t = g(t)), navigator.msSaveOrOpenBlob(t, e || 'download');
      } : (w.abort = function() {
        var t = this;
        t.readyState = t.DONE, p(t, 'abort');
      }, w.readyState = w.INIT = 0, w.WRITING = 1, w.DONE = 2, w.error = w.onwritestart = w.onprogress = w.onwrite = w.onabort = w.onerror = w.onwriteend = null, y);
    }
  }('undefined' != typeof self && self || 'undefined' != typeof window && window || (void 0).content);
  'undefined' != typeof module && module.exports ? module.exports.saveAs = i : 'undefined' != typeof define && null !== define && null != define.amd && define([], function() {
    return i;
  }), void function(t, e) {
    'object' == typeof module ? module.exports = e() : 'function' == typeof define ? define(e) : t.adler32cs = e();
  }(e, function() {
    var t = 'function' == typeof ArrayBuffer && 'function' == typeof Uint8Array, e = null, n = function() {
      if (!t) {
        return function() {
          return !1;
        };
      }
      try {
        var n = {};
        'function' == typeof n.Buffer && (e = n.Buffer);
      } catch (t$43) {
      }
      return function(t) {
        return t instanceof ArrayBuffer || null !== e && t instanceof e;
      };
    }(), r = function() {
      return null !== e ? function(t) {
        return (new e(t, 'utf8')).toString('binary');
      } : function(t) {
        return unescape(encodeURIComponent(t));
      };
    }(), i = 65521, o = function(t, e) {
      for (var n = 65535 & t, r = t >>> 16, o = 0, a = e.length; o < a; o++) {
        n = (n + (255 & e.charCodeAt(o))) % i, r = (r + n) % i;
      }
      return (r << 16 | n) >>> 0;
    }, a = function(t, e) {
      for (var n = 65535 & t, r = t >>> 16, o = 0, a = e.length; o < a; o++) {
        n = (n + e[o]) % i, r = (r + n) % i;
      }
      return (r << 16 | n) >>> 0;
    }, s = {}, c = s.Adler32 = function() {
      var e = function(t) {
        if (!(this instanceof e)) {
          throw new TypeError('Constructor cannot called be as a function.');
        }
        if (!isFinite(t = null == t ? 1 : +t)) {
          throw new Error('First arguments needs to be a finite number.');
        }
        this.checksum = t >>> 0;
      }, i = e.prototype = {};
      return i.constructor = e, e.from = function(t) {
        return t.prototype = i, t;
      }(function(t) {
        if (!(this instanceof e)) {
          throw new TypeError('Constructor cannot called be as a function.');
        }
        if (null == t) {
          throw new Error('First argument needs to be a string.');
        }
        this.checksum = o(1, t.toString());
      }), e.fromUtf8 = function(t) {
        return t.prototype = i, t;
      }(function(t) {
        if (!(this instanceof e)) {
          throw new TypeError('Constructor cannot called be as a function.');
        }
        if (null == t) {
          throw new Error('First argument needs to be a string.');
        }
        var n = r(t.toString());
        this.checksum = o(1, n);
      }), t && (e.fromBuffer = function(t) {
        return t.prototype = i, t;
      }(function(t) {
        if (!(this instanceof e)) {
          throw new TypeError('Constructor cannot called be as a function.');
        }
        if (!n(t)) {
          throw new Error('First argument needs to be ArrayBuffer.');
        }
        var r = new Uint8Array(t);
        return this.checksum = a(1, r);
      })), i.update = function(t) {
        if (null == t) {
          throw new Error('First argument needs to be a string.');
        }
        return t = t.toString(), this.checksum = o(this.checksum, t);
      }, i.updateUtf8 = function(t) {
        if (null == t) {
          throw new Error('First argument needs to be a string.');
        }
        var e = r(t.toString());
        return this.checksum = o(this.checksum, e);
      }, t && (i.updateBuffer = function(t) {
        if (!n(t)) {
          throw new Error('First argument needs to be ArrayBuffer.');
        }
        var e = new Uint8Array(t);
        return this.checksum = a(this.checksum, e);
      }), i.clone = function() {
        return new c(this.checksum);
      }, e;
    }();
    return s.from = function(t) {
      if (null == t) {
        throw new Error('First argument needs to be a string.');
      }
      return o(1, t.toString());
    }, s.fromUtf8 = function(t) {
      if (null == t) {
        throw new Error('First argument needs to be a string.');
      }
      var e = r(t.toString());
      return o(1, e);
    }, t && (s.fromBuffer = function(t) {
      if (!n(t)) {
        throw new Error('First argument need to be ArrayBuffer.');
      }
      var e = new Uint8Array(t);
      return a(1, e);
    }), s;
  });
  var o = {};
  o._colorsTable = {aliceblue:'#f0f8ff', antiquewhite:'#faebd7', aqua:'#00ffff', aquamarine:'#7fffd4', azure:'#f0ffff', beige:'#f5f5dc', bisque:'#ffe4c4', black:'#000000', blanchedalmond:'#ffebcd', blue:'#0000ff', blueviolet:'#8a2be2', brown:'#a52a2a', burlywood:'#deb887', cadetblue:'#5f9ea0', chartreuse:'#7fff00', chocolate:'#d2691e', coral:'#ff7f50', cornflowerblue:'#6495ed', cornsilk:'#fff8dc', crimson:'#dc143c', cyan:'#00ffff', darkblue:'#00008b', darkcyan:'#008b8b', darkgoldenrod:'#b8860b', 
  darkgray:'#a9a9a9', darkgreen:'#006400', darkkhaki:'#bdb76b', darkmagenta:'#8b008b', darkolivegreen:'#556b2f', darkorange:'#ff8c00', darkorchid:'#9932cc', darkred:'#8b0000', darksalmon:'#e9967a', darkseagreen:'#8fbc8f', darkslateblue:'#483d8b', darkslategray:'#2f4f4f', darkturquoise:'#00ced1', darkviolet:'#9400d3', deeppink:'#ff1493', deepskyblue:'#00bfff', dimgray:'#696969', dodgerblue:'#1e90ff', firebrick:'#b22222', floralwhite:'#fffaf0', forestgreen:'#228b22', fuchsia:'#ff00ff', gainsboro:'#dcdcdc', 
  ghostwhite:'#f8f8ff', gold:'#ffd700', goldenrod:'#daa520', gray:'#808080', green:'#008000', greenyellow:'#adff2f', honeydew:'#f0fff0', hotpink:'#ff69b4', 'indianred ':'#cd5c5c', indigo:'#4b0082', ivory:'#fffff0', khaki:'#f0e68c', lavender:'#e6e6fa', lavenderblush:'#fff0f5', lawngreen:'#7cfc00', lemonchiffon:'#fffacd', lightblue:'#add8e6', lightcoral:'#f08080', lightcyan:'#e0ffff', lightgoldenrodyellow:'#fafad2', lightgrey:'#d3d3d3', lightgreen:'#90ee90', lightpink:'#ffb6c1', lightsalmon:'#ffa07a', 
  lightseagreen:'#20b2aa', lightskyblue:'#87cefa', lightslategray:'#778899', lightsteelblue:'#b0c4de', lightyellow:'#ffffe0', lime:'#00ff00', limegreen:'#32cd32', linen:'#faf0e6', magenta:'#ff00ff', maroon:'#800000', mediumaquamarine:'#66cdaa', mediumblue:'#0000cd', mediumorchid:'#ba55d3', mediumpurple:'#9370d8', mediumseagreen:'#3cb371', mediumslateblue:'#7b68ee', mediumspringgreen:'#00fa9a', mediumturquoise:'#48d1cc', mediumvioletred:'#c71585', midnightblue:'#191970', mintcream:'#f5fffa', mistyrose:'#ffe4e1', 
  moccasin:'#ffe4b5', navajowhite:'#ffdead', navy:'#000080', oldlace:'#fdf5e6', olive:'#808000', olivedrab:'#6b8e23', orange:'#ffa500', orangered:'#ff4500', orchid:'#da70d6', palegoldenrod:'#eee8aa', palegreen:'#98fb98', paleturquoise:'#afeeee', palevioletred:'#d87093', papayawhip:'#ffefd5', peachpuff:'#ffdab9', peru:'#cd853f', pink:'#ffc0cb', plum:'#dda0dd', powderblue:'#b0e0e6', purple:'#800080', red:'#ff0000', rosybrown:'#bc8f8f', royalblue:'#4169e1', saddlebrown:'#8b4513', salmon:'#fa8072', sandybrown:'#f4a460', 
  seagreen:'#2e8b57', seashell:'#fff5ee', sienna:'#a0522d', silver:'#c0c0c0', skyblue:'#87ceeb', slateblue:'#6a5acd', slategray:'#708090', snow:'#fffafa', springgreen:'#00ff7f', steelblue:'#4682b4', tan:'#d2b48c', teal:'#008080', thistle:'#d8bfd8', tomato:'#ff6347', turquoise:'#40e0d0', violet:'#ee82ee', wheat:'#f5deb3', white:'#ffffff', whitesmoke:'#f5f5f5', yellow:'#ffff00', yellowgreen:'#9acd32'}, o.colorNameToHex = function(t) {
    return t = t.toLowerCase(), 'undefined' != typeof this._colorsTable[t] && this._colorsTable[t];
  };
  var a = function(t) {
    function e() {
      function t(t) {
        var e, n, i, o, a, c, l = r.dyn_tree, u = r.stat_desc.static_tree, h = r.stat_desc.extra_bits, f = r.stat_desc.extra_base, p = r.stat_desc.max_length, g = 0;
        for (o = 0; o <= s; o++) {
          t.bl_count[o] = 0;
        }
        for (l[2 * t.heap[t.heap_max] + 1] = 0, e = t.heap_max + 1; e < d; e++) {
          n = t.heap[e], o = l[2 * l[2 * n + 1] + 1] + 1, o > p && (o = p, g++), l[2 * n + 1] = o, n > r.max_code || (t.bl_count[o]++, a = 0, n >= f && (a = h[n - f]), c = l[2 * n], t.opt_len += c * (o + a), u && (t.static_len += c * (u[2 * n + 1] + a)));
        }
        if (0 !== g) {
          do {
            for (o = p - 1; 0 === t.bl_count[o];) {
              o--;
            }
            t.bl_count[o]--, t.bl_count[o + 1] += 2, t.bl_count[p]--, g -= 2;
          } while (g > 0);
          for (o = p; 0 !== o; o--) {
            for (n = t.bl_count[o]; 0 !== n;) {
              i = t.heap[--e], i > r.max_code || (l[2 * i + 1] != o && (t.opt_len += (o - l[2 * i + 1]) * l[2 * i], l[2 * i + 1] = o), n--);
            }
          }
        }
      }
      function e(t, e) {
        var n = 0;
        do {
          n |= 1 & t, t >>>= 1, n <<= 1;
        } while (--e > 0);
        return n >>> 1;
      }
      function n(t, n, r) {
        var i, o, a, c = [], l = 0;
        for (i = 1; i <= s; i++) {
          c[i] = l = l + r[i - 1] << 1;
        }
        for (o = 0; o <= n; o++) {
          a = t[2 * o + 1], 0 !== a && (t[2 * o] = e(c[a]++, a));
        }
      }
      var r = this;
      r.build_tree = function(e) {
        var i, o, a, s = r.dyn_tree, c = r.stat_desc.static_tree, l = r.stat_desc.elems, u = -1;
        for (e.heap_len = 0, e.heap_max = d, i = 0; i < l; i++) {
          0 !== s[2 * i] ? (e.heap[++e.heap_len] = u = i, e.depth[i] = 0) : s[2 * i + 1] = 0;
        }
        for (; e.heap_len < 2;) {
          a = e.heap[++e.heap_len] = u < 2 ? ++u : 0, s[2 * a] = 1, e.depth[a] = 0, e.opt_len--, c && (e.static_len -= c[2 * a + 1]);
        }
        for (r.max_code = u, i = Math.floor(e.heap_len / 2); i >= 1; i--) {
          e.pqdownheap(s, i);
        }
        a = l;
        do {
          i = e.heap[1], e.heap[1] = e.heap[e.heap_len--], e.pqdownheap(s, 1), o = e.heap[1], e.heap[--e.heap_max] = i, e.heap[--e.heap_max] = o, s[2 * a] = s[2 * i] + s[2 * o], e.depth[a] = Math.max(e.depth[i], e.depth[o]) + 1, s[2 * i + 1] = s[2 * o + 1] = a, e.heap[1] = a++, e.pqdownheap(s, 1);
        } while (e.heap_len >= 2);
        e.heap[--e.heap_max] = e.heap[1], t(e), n(s, r.max_code, e.bl_count);
      };
    }
    function n(t, e, n, r, i) {
      var o = this;
      o.static_tree = t, o.extra_bits = e, o.extra_base = n, o.elems = r, o.max_length = i;
    }
    function r(t, e, n, r, i) {
      var o = this;
      o.good_length = t, o.max_lazy = e, o.nice_length = n, o.max_chain = r, o.func = i;
    }
    function i(t, e, n, r) {
      var i = t[2 * e], o = t[2 * n];
      return i < o || i == o && r[e] <= r[n];
    }
    function o() {
      function t() {
        var t;
        for (It = 2 * St, Ot[Rt - 1] = 0, t = 0; t < Rt - 1; t++) {
          Ot[t] = 0;
        }
        Yt = L[Gt].max_lazy, Qt = L[Gt].good_length, Kt = L[Gt].nice_length, Vt = L[Gt].max_chain, Ut = 0, zt = 0, Wt = 0, Nt = Xt = tt - 1, Mt = 0, Ft = 0;
      }
      function r() {
        var t;
        for (t = 0; t < f; t++) {
          $t[2 * t] = 0;
        }
        for (t = 0; t < c; t++) {
          Zt[2 * t] = 0;
        }
        for (t = 0; t < l; t++) {
          te[2 * t] = 0;
        }
        $t[2 * p] = 1, ee.opt_len = ee.static_len = 0, se = le = 0;
      }
      function o() {
        ne.dyn_tree = $t, ne.stat_desc = n.static_l_desc, re.dyn_tree = Zt, re.stat_desc = n.static_d_desc, ie.dyn_tree = te, ie.stat_desc = n.static_bl_desc, he = 0, fe = 0, ue = 8, r();
      }
      function a(t, e) {
        var n, r, i = -1, o = t[1], a = 0, s = 7, c = 4;
        for (0 === o && (s = 138, c = 3), t[2 * (e + 1) + 1] = 65535, n = 0; n <= e; n++) {
          r = o, o = t[2 * (n + 1) + 1], ++a < s && r == o || (a < c ? te[2 * r] += a : 0 !== r ? (r != i && te[2 * r]++, te[2 * m]++) : a <= 10 ? te[2 * w]++ : te[2 * y]++, a = 0, i = r, 0 === o ? (s = 138, c = 3) : r == o ? (s = 6, c = 3) : (s = 7, c = 4));
        }
      }
      function s() {
        var t;
        for (a($t, ne.max_code), a(Zt, re.max_code), ie.build_tree(ee), t = l - 1; t >= 3 && 0 === te[2 * e.bl_order[t] + 1]; t--) {
        }
        return ee.opt_len += 3 * (t + 1) + 5 + 5 + 4, t;
      }
      function u(t) {
        ee.pending_buf[ee.pending++] = t;
      }
      function d(t) {
        u(255 & t), u(t >>> 8 & 255);
      }
      function g(t) {
        u(t >> 8 & 255), u(255 & t & 255);
      }
      function R(t, e) {
        var n, r = e;
        fe > v - r ? (n = t, he |= n << fe & 65535, d(he), he = n >>> v - fe, fe += r - v) : (he |= t << fe & 65535, fe += r);
      }
      function rt(t, e) {
        var n = 2 * t;
        R(65535 & e[n], 65535 & e[n + 1]);
      }
      function it(t, e) {
        var n, r, i = -1, o = t[1], a = 0, s = 7, c = 4;
        for (0 === o && (s = 138, c = 3), n = 0; n <= e; n++) {
          if (r = o, o = t[2 * (n + 1) + 1], !(++a < s && r == o)) {
            if (a < c) {
              do {
                rt(r, te);
              } while (0 !== --a);
            } else {
              0 !== r ? (r != i && (rt(r, te), a--), rt(m, te), R(a - 3, 2)) : a <= 10 ? (rt(w, te), R(a - 3, 3)) : (rt(y, te), R(a - 11, 7));
            }
            a = 0, i = r, 0 === o ? (s = 138, c = 3) : r == o ? (s = 6, c = 3) : (s = 7, c = 4);
          }
        }
      }
      function ot(t, n, r) {
        var i;
        for (R(t - 257, 5), R(n - 1, 5), R(r - 4, 4), i = 0; i < r; i++) {
          R(te[2 * e.bl_order[i] + 1], 3);
        }
        it($t, t - 1), it(Zt, n - 1);
      }
      function at() {
        16 == fe ? (d(he), he = 0, fe = 0) : fe >= 8 && (u(255 & he), he >>>= 8, fe -= 8);
      }
      function st() {
        R($ << 1, 3), rt(p, n.static_ltree), at(), 1 + ue + 10 - fe < 9 && (R($ << 1, 3), rt(p, n.static_ltree), at()), ue = 7;
      }
      function ct(t, n) {
        var r, i, o;
        if (ee.pending_buf[ce + 2 * se] = t >>> 8 & 255, ee.pending_buf[ce + 2 * se + 1] = 255 & t, ee.pending_buf[oe + se] = 255 & n, se++, 0 === t ? $t[2 * n]++ : (le++, t--, $t[2 * (e._length_code[n] + h + 1)]++, Zt[2 * e.d_code(t)]++), 0 === (8191 & se) && Gt > 2) {
          for (r = 8 * se, i = Ut - zt, o = 0; o < c; o++) {
            r += Zt[2 * o] * (5 + e.extra_dbits[o]);
          }
          if (r >>>= 3, le < Math.floor(se / 2) && r < Math.floor(i / 2)) {
            return !0;
          }
        }
        return se == ae - 1;
      }
      function lt(t, n) {
        var r, i, o, a, s = 0;
        if (0 !== se) {
          do {
            r = ee.pending_buf[ce + 2 * s] << 8 & 65280 | 255 & ee.pending_buf[ce + 2 * s + 1], i = 255 & ee.pending_buf[oe + s], s++, 0 === r ? rt(i, t) : (o = e._length_code[i], rt(o + h + 1, t), a = e.extra_lbits[o], 0 !== a && (i -= e.base_length[o], R(i, a)), r--, o = e.d_code(r), rt(o, n), a = e.extra_dbits[o], 0 !== a && (r -= e.base_dist[o], R(r, a)));
          } while (s < se);
        }
        rt(p, t), ue = t[2 * p + 1];
      }
      function ut() {
        fe > 8 ? d(he) : fe > 0 && u(255 & he), he = 0, fe = 0;
      }
      function ht(t, e, n) {
        ut(), ue = 8, n && (d(e), d(~e)), ee.pending_buf.set(Pt.subarray(t, t + e), ee.pending), ee.pending += e;
      }
      function ft(t, e, n) {
        R((K << 1) + (n ? 1 : 0), 3), ht(t, e, !0);
      }
      function dt(t, e, i) {
        var o, a, c = 0;
        Gt > 0 ? (ne.build_tree(ee), re.build_tree(ee), c = s(), o = ee.opt_len + 3 + 7 >>> 3, a = ee.static_len + 3 + 7 >>> 3, a <= o && (o = a)) : o = a = e + 5, e + 4 <= o && t != -1 ? ft(t, e, i) : a == o ? (R(($ << 1) + (i ? 1 : 0), 3), lt(n.static_ltree, n.static_dtree)) : (R((Z << 1) + (i ? 1 : 0), 3), ot(ne.max_code + 1, re.max_code + 1, c + 1), lt($t, Zt)), r(), i && ut();
      }
      function pt(t) {
        dt(zt >= 0 ? zt : -1, Ut - zt, t), zt = Ut, xt.flush_pending();
      }
      function gt() {
        var t, e, n, r;
        do {
          if (r = It - Wt - Ut, 0 === r && 0 === Ut && 0 === Wt) {
            r = St;
          } else {
            if (r == -1) {
              r--;
            } else {
              if (Ut >= St + St - nt) {
                Pt.set(Pt.subarray(St, St + St), 0), Ht -= St, Ut -= St, zt -= St, t = Rt, n = t;
                do {
                  e = 65535 & Ot[--n], Ot[n] = e >= St ? e - St : 0;
                } while (0 !== --t);
                t = St, n = t;
                do {
                  e = 65535 & Et[--n], Et[n] = e >= St ? e - St : 0;
                } while (0 !== --t);
                r += St;
              }
            }
          }
          if (0 === xt.avail_in) {
            return;
          }
          t = xt.read_buf(Pt, Ut + Wt, r), Wt += t, Wt >= tt && (Ft = 255 & Pt[Ut], Ft = (Ft << jt ^ 255 & Pt[Ut + 1]) & Dt);
        } while (Wt < nt && 0 !== xt.avail_in);
      }
      function mt(t) {
        var e, n = 65535;
        for (n > _t - 5 && (n = _t - 5);;) {
          if (Wt <= 1) {
            if (gt(), 0 === Wt && t == C) {
              return U;
            }
            if (0 === Wt) {
              break;
            }
          }
          if (Ut += Wt, Wt = 0, e = zt + n, (0 === Ut || Ut >= e) && (Wt = Ut - e, Ut = e, pt(!1), 0 === xt.avail_out)) {
            return U;
          }
          if (Ut - zt >= St - nt && (pt(!1), 0 === xt.avail_out)) {
            return U;
          }
        }
        return pt(t == q), 0 === xt.avail_out ? t == q ? W : U : t == q ? X : H;
      }
      function wt(t) {
        var e, n, r = Vt, i = Ut, o = Xt, a = Ut > St - nt ? Ut - (St - nt) : 0, s = Kt, c = Tt, l = Ut + et, u = Pt[i + o - 1], h = Pt[i + o];
        Xt >= Qt && (r >>= 2), s > Wt && (s = Wt);
        do {
          if (e = t, Pt[e + o] == h && Pt[e + o - 1] == u && Pt[e] == Pt[i] && Pt[++e] == Pt[i + 1]) {
            i += 2, e++;
            do {
            } while (Pt[++i] == Pt[++e] && Pt[++i] == Pt[++e] && Pt[++i] == Pt[++e] && Pt[++i] == Pt[++e] && Pt[++i] == Pt[++e] && Pt[++i] == Pt[++e] && Pt[++i] == Pt[++e] && Pt[++i] == Pt[++e] && i < l);
            if (n = et - (l - i), i = l - et, n > o) {
              if (Ht = t, o = n, n >= s) {
                break;
              }
              u = Pt[i + o - 1], h = Pt[i + o];
            }
          }
        } while ((t = 65535 & Et[t & c]) > a && 0 !== --r);
        return o <= Wt ? o : Wt;
      }
      function yt(t) {
        for (var e, n = 0;;) {
          if (Wt < nt) {
            if (gt(), Wt < nt && t == C) {
              return U;
            }
            if (0 === Wt) {
              break;
            }
          }
          if (Wt >= tt && (Ft = (Ft << jt ^ 255 & Pt[Ut + (tt - 1)]) & Dt, n = 65535 & Ot[Ft], Et[Ut & Tt] = Ot[Ft], Ot[Ft] = Ut), 0 !== n && (Ut - n & 65535) <= St - nt && Jt != k && (Nt = wt(n)), Nt >= tt) {
            if (e = ct(Ut - Ht, Nt - tt), Wt -= Nt, Nt <= Yt && Wt >= tt) {
              Nt--;
              do {
                Ut++, Ft = (Ft << jt ^ 255 & Pt[Ut + (tt - 1)]) & Dt, n = 65535 & Ot[Ft], Et[Ut & Tt] = Ot[Ft], Ot[Ft] = Ut;
              } while (0 !== --Nt);
              Ut++;
            } else {
              Ut += Nt, Nt = 0, Ft = 255 & Pt[Ut], Ft = (Ft << jt ^ 255 & Pt[Ut + 1]) & Dt;
            }
          } else {
            e = ct(0, 255 & Pt[Ut]), Wt--, Ut++;
          }
          if (e && (pt(!1), 0 === xt.avail_out)) {
            return U;
          }
        }
        return pt(t == q), 0 === xt.avail_out ? t == q ? W : U : t == q ? X : H;
      }
      function vt(t) {
        for (var e, n, r = 0;;) {
          if (Wt < nt) {
            if (gt(), Wt < nt && t == C) {
              return U;
            }
            if (0 === Wt) {
              break;
            }
          }
          if (Wt >= tt && (Ft = (Ft << jt ^ 255 & Pt[Ut + (tt - 1)]) & Dt, r = 65535 & Ot[Ft], Et[Ut & Tt] = Ot[Ft], Ot[Ft] = Ut), Xt = Nt, Lt = Ht, Nt = tt - 1, 0 !== r && Xt < Yt && (Ut - r & 65535) <= St - nt && (Jt != k && (Nt = wt(r)), Nt <= 5 && (Jt == x || Nt == tt && Ut - Ht > 4096) && (Nt = tt - 1)), Xt >= tt && Nt <= Xt) {
            n = Ut + Wt - tt, e = ct(Ut - 1 - Lt, Xt - tt), Wt -= Xt - 1, Xt -= 2;
            do {
              ++Ut <= n && (Ft = (Ft << jt ^ 255 & Pt[Ut + (tt - 1)]) & Dt, r = 65535 & Ot[Ft], Et[Ut & Tt] = Ot[Ft], Ot[Ft] = Ut);
            } while (0 !== --Xt);
            if (Mt = 0, Nt = tt - 1, Ut++, e && (pt(!1), 0 === xt.avail_out)) {
              return U;
            }
          } else {
            if (0 !== Mt) {
              if (e = ct(0, 255 & Pt[Ut - 1]), e && pt(!1), Ut++, Wt--, 0 === xt.avail_out) {
                return U;
              }
            } else {
              Mt = 1, Ut++, Wt--;
            }
          }
        }
        return 0 !== Mt && (e = ct(0, 255 & Pt[Ut - 1]), Mt = 0), pt(t == q), 0 === xt.avail_out ? t == q ? W : U : t == q ? X : H;
      }
      function bt(e) {
        return e.total_in = e.total_out = 0, e.msg = null, ee.pending = 0, ee.pending_out = 0, kt = G, At = C, o(), t(), T;
      }
      var xt, kt, _t, Ct, At, St, qt, Tt, Pt, It, Et, Ot, Ft, Rt, Bt, Dt, jt, zt, Nt, Lt, Mt, Ut, Ht, Wt, Xt, Vt, Yt, Gt, Jt, Qt, Kt, $t, Zt, te, ee = this, ne = new e, re = new e, ie = new e;
      ee.depth = [];
      var oe, ae, se, ce, le, ue, he, fe;
      ee.bl_count = [], ee.heap = [], $t = [], Zt = [], te = [], ee.pqdownheap = function(t, e) {
        for (var n = ee.heap, r = n[e], o = e << 1; o <= ee.heap_len && (o < ee.heap_len && i(t, n[o + 1], n[o], ee.depth) && o++, !i(t, r, n[o], ee.depth));) {
          n[e] = n[o], e = o, o <<= 1;
        }
        n[e] = r;
      }, ee.deflateInit = function(t, e, n, r, i, o) {
        return r || (r = Q), i || (i = D), o || (o = _), t.msg = null, e == b && (e = 6), i < 1 || i > B || r != Q || n < 9 || n > 15 || e < 0 || e > 9 || o < 0 || o > k ? E : (t.dstate = ee, qt = n, St = 1 << qt, Tt = St - 1, Bt = i + 7, Rt = 1 << Bt, Dt = Rt - 1, jt = Math.floor((Bt + tt - 1) / tt), Pt = new Uint8Array(2 * St), Et = [], Ot = [], ae = 1 << i + 6, ee.pending_buf = new Uint8Array(4 * ae), _t = 4 * ae, ce = Math.floor(ae / 2), oe = 3 * ae, Gt = e, Jt = o, Ct = 255 & r, bt(t));
      }, ee.deflateEnd = function() {
        return kt != Y && kt != G && kt != J ? E : (ee.pending_buf = null, Ot = null, Et = null, Pt = null, ee.dstate = null, kt == G ? O : T);
      }, ee.deflateParams = function(t, e, n) {
        var r = T;
        return e == b && (e = 6), e < 0 || e > 9 || n < 0 || n > k ? E : (L[Gt].func != L[e].func && 0 !== t.total_in && (r = t.deflate(A)), Gt != e && (Gt = e, Yt = L[Gt].max_lazy, Qt = L[Gt].good_length, Kt = L[Gt].nice_length, Vt = L[Gt].max_chain), Jt = n, r);
      }, ee.deflateSetDictionary = function(t, e, n) {
        var r, i = n, o = 0;
        if (!e || kt != Y) {
          return E;
        }
        if (i < tt) {
          return T;
        }
        for (i > St - nt && (i = St - nt, o = n - i), Pt.set(e.subarray(o, o + i), 0), Ut = i, zt = i, Ft = 255 & Pt[0], Ft = (Ft << jt ^ 255 & Pt[1]) & Dt, r = 0; r <= i - tt; r++) {
          Ft = (Ft << jt ^ 255 & Pt[r + (tt - 1)]) & Dt, Et[r & Tt] = Ot[Ft], Ot[Ft] = r;
        }
        return T;
      }, ee.deflate = function(t, e) {
        var n, r, i, o, a;
        if (e > q || e < 0) {
          return E;
        }
        if (!t.next_out || !t.next_in && 0 !== t.avail_in || kt == J && e != q) {
          return t.msg = M[I - E], E;
        }
        if (0 === t.avail_out) {
          return t.msg = M[I - F], F;
        }
        if (xt = t, o = At, At = e, kt == Y && (r = Q + (qt - 8 << 4) << 8, i = (Gt - 1 & 255) >> 1, i > 3 && (i = 3), r |= i << 6, 0 !== Ut && (r |= V), r += 31 - r % 31, kt = G, g(r)), 0 !== ee.pending) {
          if (xt.flush_pending(), 0 === xt.avail_out) {
            return At = -1, T;
          }
        } else {
          if (0 === xt.avail_in && e <= o && e != q) {
            return xt.msg = M[I - F], F;
          }
        }
        if (kt == J && 0 !== xt.avail_in) {
          return t.msg = M[I - F], F;
        }
        if (0 !== xt.avail_in || 0 !== Wt || e != C && kt != J) {
          switch(a = -1, L[Gt].func) {
            case j:
              a = mt(e);
              break;
            case z:
              a = yt(e);
              break;
            case N:
              a = vt(e);
          }
          if (a != W && a != X || (kt = J), a == U || a == W) {
            return 0 === xt.avail_out && (At = -1), T;
          }
          if (a == H) {
            if (e == A) {
              st();
            } else {
              if (ft(0, 0, !1), e == S) {
                for (n = 0; n < Rt; n++) {
                  Ot[n] = 0;
                }
              }
            }
            if (xt.flush_pending(), 0 === xt.avail_out) {
              return At = -1, T;
            }
          }
        }
        return e != q ? T : P;
      };
    }
    function a() {
      var t = this;
      t.next_in_index = 0, t.next_out_index = 0, t.avail_in = 0, t.total_in = 0, t.avail_out = 0, t.total_out = 0;
    }
    var s = 15, c = 30, l = 19, u = 29, h = 256, f = h + 1 + u, d = 2 * f + 1, p = 256, g = 7, m = 16, w = 17, y = 18, v = 16, b = -1, x = 1, k = 2, _ = 0, C = 0, A = 1, S = 3, q = 4, T = 0, P = 1, I = 2, E = -2, O = -3, F = -5, R = [0, 1, 2, 3, 4, 4, 5, 5, 6, 6, 6, 6, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 9, 9, 9, 9, 9, 9, 9, 9, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 10, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 11, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 
    12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 12, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 13, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 14, 15, 15, 15, 15, 15, 15, 15, 15, 
    15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 15, 0, 0, 16, 17, 18, 18, 19, 19, 20, 20, 20, 20, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 26, 26, 26, 26, 26, 
    26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 28, 29, 29, 
    29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29, 29];
    e._length_code = [0, 1, 2, 3, 4, 5, 6, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 12, 12, 13, 13, 13, 13, 14, 14, 14, 14, 15, 15, 15, 15, 16, 16, 16, 16, 16, 16, 16, 16, 17, 17, 17, 17, 17, 17, 17, 17, 18, 18, 18, 18, 18, 18, 18, 18, 19, 19, 19, 19, 19, 19, 19, 19, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 20, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 21, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 22, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 23, 
    23, 23, 23, 23, 23, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 24, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 25, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 26, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 27, 
    27, 27, 27, 27, 27, 27, 27, 28], e.base_length = [0, 1, 2, 3, 4, 5, 6, 7, 8, 10, 12, 14, 16, 20, 24, 28, 32, 40, 48, 56, 64, 80, 96, 112, 128, 160, 192, 224, 0], e.base_dist = [0, 1, 2, 3, 4, 6, 8, 12, 16, 24, 32, 48, 64, 96, 128, 192, 256, 384, 512, 768, 1024, 1536, 2048, 3072, 4096, 6144, 8192, 12288, 16384, 24576], e.d_code = function(t) {
      return t < 256 ? R[t] : R[256 + (t >>> 7)];
    }, e.extra_lbits = [0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 1, 2, 2, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 5, 5, 5, 5, 0], e.extra_dbits = [0, 0, 0, 0, 1, 1, 2, 2, 3, 3, 4, 4, 5, 5, 6, 6, 7, 7, 8, 8, 9, 9, 10, 10, 11, 11, 12, 12, 13, 13], e.extra_blbits = [0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 2, 3, 7], e.bl_order = [16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15], n.static_ltree = [12, 8, 140, 8, 76, 8, 204, 8, 44, 8, 172, 8, 108, 8, 236, 8, 28, 8, 156, 8, 92, 8, 220, 8, 60, 8, 
    188, 8, 124, 8, 252, 8, 2, 8, 130, 8, 66, 8, 194, 8, 34, 8, 162, 8, 98, 8, 226, 8, 18, 8, 146, 8, 82, 8, 210, 8, 50, 8, 178, 8, 114, 8, 242, 8, 10, 8, 138, 8, 74, 8, 202, 8, 42, 8, 170, 8, 106, 8, 234, 8, 26, 8, 154, 8, 90, 8, 218, 8, 58, 8, 186, 8, 122, 8, 250, 8, 6, 8, 134, 8, 70, 8, 198, 8, 38, 8, 166, 8, 102, 8, 230, 8, 22, 8, 150, 8, 86, 8, 214, 8, 54, 8, 182, 8, 118, 8, 246, 8, 14, 8, 142, 8, 78, 8, 206, 8, 46, 8, 174, 8, 110, 8, 238, 8, 30, 8, 158, 8, 94, 8, 222, 8, 62, 8, 190, 8, 126, 
    8, 254, 8, 1, 8, 129, 8, 65, 8, 193, 8, 33, 8, 161, 8, 97, 8, 225, 8, 17, 8, 145, 8, 81, 8, 209, 8, 49, 8, 177, 8, 113, 8, 241, 8, 9, 8, 137, 8, 73, 8, 201, 8, 41, 8, 169, 8, 105, 8, 233, 8, 25, 8, 153, 8, 89, 8, 217, 8, 57, 8, 185, 8, 121, 8, 249, 8, 5, 8, 133, 8, 69, 8, 197, 8, 37, 8, 165, 8, 101, 8, 229, 8, 21, 8, 149, 8, 85, 8, 213, 8, 53, 8, 181, 8, 117, 8, 245, 8, 13, 8, 141, 8, 77, 8, 205, 8, 45, 8, 173, 8, 109, 8, 237, 8, 29, 8, 157, 8, 93, 8, 221, 8, 61, 8, 189, 8, 125, 8, 253, 8, 19, 
    9, 275, 9, 147, 9, 403, 9, 83, 9, 339, 9, 211, 9, 467, 9, 51, 9, 307, 9, 179, 9, 435, 9, 115, 9, 371, 9, 243, 9, 499, 9, 11, 9, 267, 9, 139, 9, 395, 9, 75, 9, 331, 9, 203, 9, 459, 9, 43, 9, 299, 9, 171, 9, 427, 9, 107, 9, 363, 9, 235, 9, 491, 9, 27, 9, 283, 9, 155, 9, 411, 9, 91, 9, 347, 9, 219, 9, 475, 9, 59, 9, 315, 9, 187, 9, 443, 9, 123, 9, 379, 9, 251, 9, 507, 9, 7, 9, 263, 9, 135, 9, 391, 9, 71, 9, 327, 9, 199, 9, 455, 9, 39, 9, 295, 9, 167, 9, 423, 9, 103, 9, 359, 9, 231, 9, 487, 9, 23, 
    9, 279, 9, 151, 9, 407, 9, 87, 9, 343, 9, 215, 9, 471, 9, 55, 9, 311, 9, 183, 9, 439, 9, 119, 9, 375, 9, 247, 9, 503, 9, 15, 9, 271, 9, 143, 9, 399, 9, 79, 9, 335, 9, 207, 9, 463, 9, 47, 9, 303, 9, 175, 9, 431, 9, 111, 9, 367, 9, 239, 9, 495, 9, 31, 9, 287, 9, 159, 9, 415, 9, 95, 9, 351, 9, 223, 9, 479, 9, 63, 9, 319, 9, 191, 9, 447, 9, 127, 9, 383, 9, 255, 9, 511, 9, 0, 7, 64, 7, 32, 7, 96, 7, 16, 7, 80, 7, 48, 7, 112, 7, 8, 7, 72, 7, 40, 7, 104, 7, 24, 7, 88, 7, 56, 7, 120, 7, 4, 7, 68, 7, 
    36, 7, 100, 7, 20, 7, 84, 7, 52, 7, 116, 7, 3, 8, 131, 8, 67, 8, 195, 8, 35, 8, 163, 8, 99, 8, 227, 8], n.static_dtree = [0, 5, 16, 5, 8, 5, 24, 5, 4, 5, 20, 5, 12, 5, 28, 5, 2, 5, 18, 5, 10, 5, 26, 5, 6, 5, 22, 5, 14, 5, 30, 5, 1, 5, 17, 5, 9, 5, 25, 5, 5, 5, 21, 5, 13, 5, 29, 5, 3, 5, 19, 5, 11, 5, 27, 5, 7, 5, 23, 5], n.static_l_desc = new n(n.static_ltree, e.extra_lbits, h + 1, f, s), n.static_d_desc = new n(n.static_dtree, e.extra_dbits, 0, c, s), n.static_bl_desc = new n(null, e.extra_blbits, 
    0, l, g);
    var B = 9, D = 8, j = 0, z = 1, N = 2, L = [new r(0, 0, 0, 0, j), new r(4, 4, 8, 4, z), new r(4, 5, 16, 8, z), new r(4, 6, 32, 32, z), new r(4, 4, 16, 16, N), new r(8, 16, 32, 32, N), new r(8, 16, 128, 128, N), new r(8, 32, 128, 256, N), new r(32, 128, 258, 1024, N), new r(32, 258, 258, 4096, N)], M = ['need dictionary', 'stream end', '', '', 'stream error', 'data error', '', 'buffer error', '', ''], U = 0, H = 1, W = 2, X = 3, V = 32, Y = 42, G = 113, J = 666, Q = 8, K = 0, $ = 1, Z = 2, tt = 
    3, et = 258, nt = et + tt + 1;
    return a.prototype = {deflateInit:function(t, e) {
      var n = this;
      return n.dstate = new o, e || (e = s), n.dstate.deflateInit(n, t, e);
    }, deflate:function(t) {
      var e = this;
      return e.dstate ? e.dstate.deflate(e, t) : E;
    }, deflateEnd:function() {
      var t = this;
      if (!t.dstate) {
        return E;
      }
      var e = t.dstate.deflateEnd();
      return t.dstate = null, e;
    }, deflateParams:function(t, e) {
      var n = this;
      return n.dstate ? n.dstate.deflateParams(n, t, e) : E;
    }, deflateSetDictionary:function(t, e) {
      var n = this;
      return n.dstate ? n.dstate.deflateSetDictionary(n, t, e) : E;
    }, read_buf:function(t, e, n) {
      var r = this, i = r.avail_in;
      return i > n && (i = n), 0 === i ? 0 : (r.avail_in -= i, t.set(r.next_in.subarray(r.next_in_index, r.next_in_index + i), e), r.next_in_index += i, r.total_in += i, i);
    }, flush_pending:function() {
      var t = this, e = t.dstate.pending;
      e > t.avail_out && (e = t.avail_out), 0 !== e && (t.next_out.set(t.dstate.pending_buf.subarray(t.dstate.pending_out, t.dstate.pending_out + e), t.next_out_index), t.next_out_index += e, t.dstate.pending_out += e, t.total_out += e, t.avail_out -= e, t.dstate.pending -= e, 0 === t.dstate.pending && (t.dstate.pending_out = 0));
    }}, function(t) {
      var e = this, n = new a, r = 512, i = C, o = new Uint8Array(r);
      'undefined' == typeof t && (t = b), n.deflateInit(t), n.next_out = o, e.append = function(t, e) {
        var a, s, c = [], l = 0, u = 0, h = 0;
        if (t.length) {
          n.next_in_index = 0, n.next_in = t, n.avail_in = t.length;
          do {
            if (n.next_out_index = 0, n.avail_out = r, a = n.deflate(i), a != T) {
              throw 'deflating: ' + n.msg;
            }
            n.next_out_index && (n.next_out_index == r ? c.push(new Uint8Array(o)) : c.push(new Uint8Array(o.subarray(0, n.next_out_index)))), h += n.next_out_index, e && n.next_in_index > 0 && n.next_in_index != l && (e(n.next_in_index), l = n.next_in_index);
          } while (n.avail_in > 0 || 0 === n.avail_out);
          return s = new Uint8Array(h), c.forEach(function(t) {
            s.set(t, u), u += t.length;
          }), s;
        }
      }, e.flush = function() {
        var t, e, i = [], a = 0, s = 0;
        do {
          if (n.next_out_index = 0, n.avail_out = r, t = n.deflate(q), t != P && t != T) {
            throw 'deflating: ' + n.msg;
          }
          r - n.avail_out > 0 && i.push(new Uint8Array(o.subarray(0, n.next_out_index))), s += n.next_out_index;
        } while (n.avail_in > 0 || 0 === n.avail_out);
        return n.deflateEnd(), e = new Uint8Array(s), i.forEach(function(t) {
          e.set(t, a), a += t.length;
        }), e;
      };
    };
  }(void 0);
  !function(t) {
    if ('object' == typeof exports && 'undefined' != typeof module) {
      module.exports = t();
    } else {
      if ('function' == typeof define && define.amd) {
        define([], t);
      } else {
        var e;
        'undefined' != typeof window ? e = window : 'undefined' != typeof global ? e = global : 'undefined' != typeof self && (e = self), e.html2canvas = t();
      }
    }
  }(function() {
    var t;
    return function t(e, n, r) {
      function i(a, s) {
        if (!n[a]) {
          if (!e[a]) {
            var c = 'function' == typeof require && require;
            if (!s && c) {
              return c(a, !0);
            }
            if (o) {
              return o(a, !0);
            }
            var l = new Error("Cannot find module '" + a + "'");
            throw l.code = 'MODULE_NOT_FOUND', l;
          }
          var u = n[a] = {exports:{}};
          e[a][0].call(u.exports, function(t) {
            var n = e[a][1][t];
            return i(n ? n : t);
          }, u, u.exports, t, e, n, r);
        }
        return n[a].exports;
      }
      for (var o = 'function' == typeof require && require, a = 0; a < r.length; a++) {
        i(r[a]);
      }
      return i;
    }({1:[function(e, n, r) {
      (function(e) {
        !function(i) {
          function o(t) {
            throw RangeError(R[t]);
          }
          function a(t, e) {
            for (var n = t.length; n--;) {
              t[n] = e(t[n]);
            }
            return t;
          }
          function s(t, e) {
            return a(t.split(F), e).join('.');
          }
          function c(t) {
            for (var e, n, r = [], i = 0, o = t.length; i < o;) {
              e = t.charCodeAt(i++), e >= 55296 && e <= 56319 && i < o ? (n = t.charCodeAt(i++), 56320 == (64512 & n) ? r.push(((1023 & e) << 10) + (1023 & n) + 65536) : (r.push(e), i--)) : r.push(e);
            }
            return r;
          }
          function l(t) {
            return a(t, function(t) {
              var e = '';
              return t > 65535 && (t -= 65536, e += j(t >>> 10 & 1023 | 55296), t = 56320 | 1023 & t), e += j(t);
            }).join('');
          }
          function u(t) {
            return t - 48 < 10 ? t - 22 : t - 65 < 26 ? t - 65 : t - 97 < 26 ? t - 97 : _;
          }
          function h(t, e) {
            return t + 22 + 75 * (t < 26) - ((0 != e) << 5);
          }
          function f(t, e, n) {
            var r = 0;
            for (t = n ? D(t / q) : t >> 1, t += D(t / e); t > B * A >> 1; r += _) {
              t = D(t / B);
            }
            return D(r + (B + 1) * t / (t + S));
          }
          function d(t) {
            var e, n, r, i, a, s, c, h, d, p, g = [], m = t.length, w = 0, y = P, v = T;
            for (n = t.lastIndexOf(I), n < 0 && (n = 0), r = 0; r < n; ++r) {
              t.charCodeAt(r) >= 128 && o('not-basic'), g.push(t.charCodeAt(r));
            }
            for (i = n > 0 ? n + 1 : 0; i < m;) {
              for (a = w, s = 1, c = _; i >= m && o('invalid-input'), h = u(t.charCodeAt(i++)), (h >= _ || h > D((k - w) / s)) && o('overflow'), w += h * s, d = c <= v ? C : c >= v + A ? A : c - v, !(h < d); c += _) {
                p = _ - d, s > D(k / p) && o('overflow'), s *= p;
              }
              e = g.length + 1, v = f(w - a, e, 0 == a), D(w / e) > k - y && o('overflow'), y += D(w / e), w %= e, g.splice(w++, 0, y);
            }
            return l(g);
          }
          function p(t) {
            var e, n, r, i, a, s, l, u, d, p, g, m, w, y, v, b = [];
            for (t = c(t), m = t.length, e = P, n = 0, a = T, s = 0; s < m; ++s) {
              g = t[s], g < 128 && b.push(j(g));
            }
            for (r = i = b.length, i && b.push(I); r < m;) {
              for (l = k, s = 0; s < m; ++s) {
                g = t[s], g >= e && g < l && (l = g);
              }
              for (w = r + 1, l - e > D((k - n) / w) && o('overflow'), n += (l - e) * w, e = l, s = 0; s < m; ++s) {
                if (g = t[s], g < e && ++n > k && o('overflow'), g == e) {
                  for (u = n, d = _; p = d <= a ? C : d >= a + A ? A : d - a, !(u < p); d += _) {
                    v = u - p, y = _ - p, b.push(j(h(p + v % y, 0))), u = D(v / y);
                  }
                  b.push(j(h(u, 0))), a = f(n, w, r == i), n = 0, ++r;
                }
              }
              ++n, ++e;
            }
            return b.join('');
          }
          function g(t) {
            return s(t, function(t) {
              return E.test(t) ? d(t.slice(4).toLowerCase()) : t;
            });
          }
          function m(t) {
            return s(t, function(t) {
              return O.test(t) ? 'xn--' + p(t) : t;
            });
          }
          var w = 'object' == typeof r && r, y = 'object' == typeof n && n && n.exports == w && n, v = 'object' == typeof e && e;
          v.global !== v && v.window !== v || (i = v);
          var b, x, k = 2147483647, _ = 36, C = 1, A = 26, S = 38, q = 700, T = 72, P = 128, I = '-', E = /^xn--/, O = /[^ -~]/, F = /\x2E|\u3002|\uFF0E|\uFF61/g, R = {overflow:'Overflow: input needs wider integers to process', 'not-basic':'Illegal input \x3e\x3d 0x80 (not a basic code point)', 'invalid-input':'Invalid input'}, B = _ - C, D = Math.floor, j = String.fromCharCode;
          if (b = {version:'1.2.4', ucs2:{decode:c, encode:l}, decode:d, encode:p, toASCII:m, toUnicode:g}, 'function' == typeof t && 'object' == typeof t.amd && t.amd) {
            t('punycode', function() {
              return b;
            });
          } else {
            if (w && !w.nodeType) {
              if (y) {
                y.exports = b;
              } else {
                for (x in b) {
                  b.hasOwnProperty(x) && (w[x] = b[x]);
                }
              }
            } else {
              i.punycode = b;
            }
          }
        }(this);
      }).call(this, 'undefined' != typeof global ? global : 'undefined' != typeof self ? self : 'undefined' != typeof window ? window : {});
    }, {}], 2:[function(t, e, n) {
      function r(t, e, n) {
        !t.defaultView || e === t.defaultView.pageXOffset && n === t.defaultView.pageYOffset || t.defaultView.scrollTo(e, n);
      }
      function i(t, e) {
        try {
          e && (e.width = t.width, e.height = t.height, e.getContext('2d').putImageData(t.getContext('2d').getImageData(0, 0, t.width, t.height), 0, 0));
        } catch (e$44) {
          s('Unable to copy canvas content from', t, e$44);
        }
      }
      function o(t, e) {
        for (var n = 3 === t.nodeType ? document.createTextNode(t.nodeValue) : t.cloneNode(!1), r = t.firstChild; r;) {
          e !== !0 && 1 === r.nodeType && 'SCRIPT' === r.nodeName || n.appendChild(o(r, e)), r = r.nextSibling;
        }
        return 1 === t.nodeType && (n._scrollTop = t.scrollTop, n._scrollLeft = t.scrollLeft, 'CANVAS' === t.nodeName ? i(t, n) : 'TEXTAREA' !== t.nodeName && 'SELECT' !== t.nodeName || (n.value = t.value)), n;
      }
      function a(t) {
        if (1 === t.nodeType) {
          t.scrollTop = t._scrollTop, t.scrollLeft = t._scrollLeft;
          for (var e = t.firstChild; e;) {
            a(e), e = e.nextSibling;
          }
        }
      }
      var s = t('./log');
      e.exports = function(t, e, n, i, s, c, l) {
        var u = o(t.documentElement, s.javascriptEnabled), h = e.createElement('iframe');
        return h.className = 'html2canvas-container', h.style.visibility = 'hidden', h.style.position = 'fixed', h.style.left = '-10000px', h.style.top = '0px', h.style.border = '0', h.width = n, h.height = i, h.scrolling = 'no', e.body.appendChild(h), new Promise(function(e) {
          var n = h.contentWindow.document;
          h.contentWindow.onload = h.onload = function() {
            var t = setInterval(function() {
              n.body.childNodes.length > 0 && (a(n.documentElement), clearInterval(t), 'view' === s.type && (h.contentWindow.scrollTo(c, l), !/(iPad|iPhone|iPod)/g.test(navigator.userAgent) || h.contentWindow.scrollY === l && h.contentWindow.scrollX === c || (n.documentElement.style.top = -l + 'px', n.documentElement.style.left = -c + 'px', n.documentElement.style.position = 'absolute')), e(h));
            }, 50);
          }, n.open(), n.write('\x3c!DOCTYPE html\x3e\x3chtml\x3e\x3c/html\x3e'), r(t, c, l), n.replaceChild(n.adoptNode(u), n.documentElement), n.close();
        });
      };
    }, {'./log':13}], 3:[function(t, e, n) {
      function r(t) {
        this.r = 0, this.g = 0, this.b = 0, this.a = null;
        this.fromArray(t) || this.namedColor(t) || this.rgb(t) || this.rgba(t) || this.hex6(t) || this.hex3(t);
      }
      r.prototype.darken = function(t) {
        var e = 1 - t;
        return new r([Math.round(this.r * e), Math.round(this.g * e), Math.round(this.b * e), this.a]);
      }, r.prototype.isTransparent = function() {
        return 0 === this.a;
      }, r.prototype.isBlack = function() {
        return 0 === this.r && 0 === this.g && 0 === this.b;
      }, r.prototype.fromArray = function(t) {
        return Array.isArray(t) && (this.r = Math.min(t[0], 255), this.g = Math.min(t[1], 255), this.b = Math.min(t[2], 255), t.length > 3 && (this.a = t[3])), Array.isArray(t);
      };
      var i = /^#([a-f0-9]{3})$/i;
      r.prototype.hex3 = function(t) {
        var e = null;
        return null !== (e = t.match(i)) && (this.r = parseInt(e[1][0] + e[1][0], 16), this.g = parseInt(e[1][1] + e[1][1], 16), this.b = parseInt(e[1][2] + e[1][2], 16)), null !== e;
      };
      var o = /^#([a-f0-9]{6})$/i;
      r.prototype.hex6 = function(t) {
        var e = null;
        return null !== (e = t.match(o)) && (this.r = parseInt(e[1].substring(0, 2), 16), this.g = parseInt(e[1].substring(2, 4), 16), this.b = parseInt(e[1].substring(4, 6), 16)), null !== e;
      };
      var a = /^rgb\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*\)$/;
      r.prototype.rgb = function(t) {
        var e = null;
        return null !== (e = t.match(a)) && (this.r = Number(e[1]), this.g = Number(e[2]), this.b = Number(e[3])), null !== e;
      };
      var s = /^rgba\(\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d{1,3})\s*,\s*(\d?\.?\d+)\s*\)$/;
      r.prototype.rgba = function(t) {
        var e = null;
        return null !== (e = t.match(s)) && (this.r = Number(e[1]), this.g = Number(e[2]), this.b = Number(e[3]), this.a = Number(e[4])), null !== e;
      }, r.prototype.toString = function() {
        return null !== this.a && 1 !== this.a ? 'rgba(' + [this.r, this.g, this.b, this.a].join(',') + ')' : 'rgb(' + [this.r, this.g, this.b].join(',') + ')';
      }, r.prototype.namedColor = function(t) {
        t = t.toLowerCase();
        var e = c[t];
        if (e) {
          this.r = e[0], this.g = e[1], this.b = e[2];
        } else {
          if ('transparent' === t) {
            return this.r = this.g = this.b = this.a = 0, !0;
          }
        }
        return !!e;
      }, r.prototype.isColor = !0;
      var c = {aliceblue:[240, 248, 255], antiquewhite:[250, 235, 215], aqua:[0, 255, 255], aquamarine:[127, 255, 212], azure:[240, 255, 255], beige:[245, 245, 220], bisque:[255, 228, 196], black:[0, 0, 0], blanchedalmond:[255, 235, 205], blue:[0, 0, 255], blueviolet:[138, 43, 226], brown:[165, 42, 42], burlywood:[222, 184, 135], cadetblue:[95, 158, 160], chartreuse:[127, 255, 0], chocolate:[210, 105, 30], coral:[255, 127, 80], cornflowerblue:[100, 149, 237], cornsilk:[255, 248, 220], crimson:[220, 
      20, 60], cyan:[0, 255, 255], darkblue:[0, 0, 139], darkcyan:[0, 139, 139], darkgoldenrod:[184, 134, 11], darkgray:[169, 169, 169], darkgreen:[0, 100, 0], darkgrey:[169, 169, 169], darkkhaki:[189, 183, 107], darkmagenta:[139, 0, 139], darkolivegreen:[85, 107, 47], darkorange:[255, 140, 0], darkorchid:[153, 50, 204], darkred:[139, 0, 0], darksalmon:[233, 150, 122], darkseagreen:[143, 188, 143], darkslateblue:[72, 61, 139], darkslategray:[47, 79, 79], darkslategrey:[47, 79, 79], darkturquoise:[0, 
      206, 209], darkviolet:[148, 0, 211], deeppink:[255, 20, 147], deepskyblue:[0, 191, 255], dimgray:[105, 105, 105], dimgrey:[105, 105, 105], dodgerblue:[30, 144, 255], firebrick:[178, 34, 34], floralwhite:[255, 250, 240], forestgreen:[34, 139, 34], fuchsia:[255, 0, 255], gainsboro:[220, 220, 220], ghostwhite:[248, 248, 255], gold:[255, 215, 0], goldenrod:[218, 165, 32], gray:[128, 128, 128], green:[0, 128, 0], greenyellow:[173, 255, 47], grey:[128, 128, 128], honeydew:[240, 255, 240], hotpink:[255, 
      105, 180], indianred:[205, 92, 92], indigo:[75, 0, 130], ivory:[255, 255, 240], khaki:[240, 230, 140], lavender:[230, 230, 250], lavenderblush:[255, 240, 245], lawngreen:[124, 252, 0], lemonchiffon:[255, 250, 205], lightblue:[173, 216, 230], lightcoral:[240, 128, 128], lightcyan:[224, 255, 255], lightgoldenrodyellow:[250, 250, 210], lightgray:[211, 211, 211], lightgreen:[144, 238, 144], lightgrey:[211, 211, 211], lightpink:[255, 182, 193], lightsalmon:[255, 160, 122], lightseagreen:[32, 178, 
      170], lightskyblue:[135, 206, 250], lightslategray:[119, 136, 153], lightslategrey:[119, 136, 153], lightsteelblue:[176, 196, 222], lightyellow:[255, 255, 224], lime:[0, 255, 0], limegreen:[50, 205, 50], linen:[250, 240, 230], magenta:[255, 0, 255], maroon:[128, 0, 0], mediumaquamarine:[102, 205, 170], mediumblue:[0, 0, 205], mediumorchid:[186, 85, 211], mediumpurple:[147, 112, 219], mediumseagreen:[60, 179, 113], mediumslateblue:[123, 104, 238], mediumspringgreen:[0, 250, 154], mediumturquoise:[72, 
      209, 204], mediumvioletred:[199, 21, 133], midnightblue:[25, 25, 112], mintcream:[245, 255, 250], mistyrose:[255, 228, 225], moccasin:[255, 228, 181], navajowhite:[255, 222, 173], navy:[0, 0, 128], oldlace:[253, 245, 230], olive:[128, 128, 0], olivedrab:[107, 142, 35], orange:[255, 165, 0], orangered:[255, 69, 0], orchid:[218, 112, 214], palegoldenrod:[238, 232, 170], palegreen:[152, 251, 152], paleturquoise:[175, 238, 238], palevioletred:[219, 112, 147], papayawhip:[255, 239, 213], peachpuff:[255, 
      218, 185], peru:[205, 133, 63], pink:[255, 192, 203], plum:[221, 160, 221], powderblue:[176, 224, 230], purple:[128, 0, 128], rebeccapurple:[102, 51, 153], red:[255, 0, 0], rosybrown:[188, 143, 143], royalblue:[65, 105, 225], saddlebrown:[139, 69, 19], salmon:[250, 128, 114], sandybrown:[244, 164, 96], seagreen:[46, 139, 87], seashell:[255, 245, 238], sienna:[160, 82, 45], silver:[192, 192, 192], skyblue:[135, 206, 235], slateblue:[106, 90, 205], slategray:[112, 128, 144], slategrey:[112, 128, 
      144], snow:[255, 250, 250], springgreen:[0, 255, 127], steelblue:[70, 130, 180], tan:[210, 180, 140], teal:[0, 128, 128], thistle:[216, 191, 216], tomato:[255, 99, 71], turquoise:[64, 224, 208], violet:[238, 130, 238], wheat:[245, 222, 179], white:[255, 255, 255], whitesmoke:[245, 245, 245], yellow:[255, 255, 0], yellowgreen:[154, 205, 50]};
      e.exports = r;
    }, {}], 4:[function(e, n, r) {
      function i(t, e) {
        var n = _++;
        if (e = e || {}, e.logging && (w.options.logging = !0, w.options.start = Date.now()), e.async = 'undefined' == typeof e.async || e.async, e.allowTaint = 'undefined' != typeof e.allowTaint && e.allowTaint, e.removeContainer = 'undefined' == typeof e.removeContainer || e.removeContainer, e.javascriptEnabled = 'undefined' != typeof e.javascriptEnabled && e.javascriptEnabled, e.imageTimeout = 'undefined' == typeof e.imageTimeout ? 10000 : e.imageTimeout, e.renderer = 'function' == typeof e.renderer ? 
        e.renderer : d, e.strict = !!e.strict, 'string' == typeof t) {
          if ('string' != typeof e.proxy) {
            return Promise.reject('Proxy must be used when rendering url');
          }
          var r = null != e.width ? e.width : window.innerWidth, i = null != e.height ? e.height : window.innerHeight;
          return b(h(t), e.proxy, document, r, i, e).then(function(t) {
            return a(t.contentWindow.document.documentElement, t, e, r, i);
          });
        }
        var s = (void 0 === t ? [document.documentElement] : t.length ? t : [t])[0];
        return s.setAttribute(k + n, n), o(s.ownerDocument, e, s.ownerDocument.defaultView.innerWidth, s.ownerDocument.defaultView.innerHeight, n).then(function(t) {
          return 'function' == typeof e.onrendered && (w('options.onrendered is deprecated, html2canvas returns a Promise containing the canvas'), e.onrendered(t)), t;
        });
      }
      function o(t, e, n, r, i) {
        return v(t, t, n, r, e, t.defaultView.pageXOffset, t.defaultView.pageYOffset).then(function(o) {
          w('Document cloned');
          var s = k + i, c = '[' + s + "\x3d'" + i + "']";
          t.querySelector(c).removeAttribute(s);
          var l = o.contentWindow, u = l.document.querySelector(c), h = 'function' == typeof e.onclone ? Promise.resolve(e.onclone(l.document)) : Promise.resolve(!0);
          return h.then(function() {
            return a(u, o, e, n, r);
          });
        });
      }
      function a(t, e, n, r, i) {
        var o = e.contentWindow, a = new f(o.document), h = new p(n, a), d = x(t), m = 'view' === n.type ? r : l(o.document), y = 'view' === n.type ? i : u(o.document), v = new n.renderer(m, y, h, n, document), b = new g(t, v, a, h, n);
        return b.ready.then(function() {
          w('Finished rendering');
          var r;
          return r = 'view' === n.type ? c(v.canvas, {width:v.canvas.width, height:v.canvas.height, top:0, left:0, x:0, y:0}) : t === o.document.body || t === o.document.documentElement || null != n.canvas ? v.canvas : c(v.canvas, {width:null != n.width ? n.width : d.width, height:null != n.height ? n.height : d.height, top:d.top, left:d.left, x:0, y:0}), s(e, n), r;
        });
      }
      function s(t, e) {
        e.removeContainer && (t.parentNode.removeChild(t), w('Cleaned up container'));
      }
      function c(t, e) {
        var n = document.createElement('canvas'), r = Math.min(t.width - 1, Math.max(0, e.left)), i = Math.min(t.width, Math.max(1, e.left + e.width)), o = Math.min(t.height - 1, Math.max(0, e.top)), a = Math.min(t.height, Math.max(1, e.top + e.height));
        n.width = e.width, n.height = e.height;
        var s = i - r, c = a - o;
        return w('Cropping canvas at:', 'left:', e.left, 'top:', e.top, 'width:', s, 'height:', c), w('Resulting crop with width', e.width, 'and height', e.height, 'with x', r, 'and y', o), n.getContext('2d').drawImage(t, r, o, s, c, e.x, e.y, s, c), n;
      }
      function l(t) {
        return Math.max(Math.max(t.body.scrollWidth, t.documentElement.scrollWidth), Math.max(t.body.offsetWidth, t.documentElement.offsetWidth), Math.max(t.body.clientWidth, t.documentElement.clientWidth));
      }
      function u(t) {
        return Math.max(Math.max(t.body.scrollHeight, t.documentElement.scrollHeight), Math.max(t.body.offsetHeight, t.documentElement.offsetHeight), Math.max(t.body.clientHeight, t.documentElement.clientHeight));
      }
      function h(t) {
        var e = document.createElement('a');
        return e.href = t, e.href = e.href, e;
      }
      var f = e('./support'), d = e('./renderers/canvas'), p = e('./imageloader'), g = e('./nodeparser'), m = e('./nodecontainer'), w = e('./log'), y = e('./utils'), v = e('./clone'), b = e('./proxy').loadUrlDocument, x = y.getBounds, k = 'data-html2canvas-node', _ = 0;
      i.CanvasRenderer = d, i.NodeContainer = m, i.log = w, i.utils = y;
      var C = 'undefined' == typeof document || 'function' != typeof Object.create || 'function' != typeof document.createElement('canvas').getContext ? function() {
        return Promise.reject('No canvas support');
      } : i;
      n.exports = C, 'function' == typeof t && t.amd && t('html2canvas', [], function() {
        return C;
      });
    }, {'./clone':2, './imageloader':11, './log':13, './nodecontainer':14, './nodeparser':15, './proxy':16, './renderers/canvas':20, './support':22, './utils':26}], 5:[function(t, e, n) {
      function r(t) {
        if (this.src = t, i('DummyImageContainer for', t), !this.promise || !this.image) {
          i('Initiating DummyImageContainer'), r.prototype.image = new Image;
          var e = this.image;
          r.prototype.promise = new Promise(function(t, n) {
            e.onload = t, e.onerror = n, e.src = o(), e.complete === !0 && t(e);
          });
        }
      }
      var i = t('./log'), o = t('./utils').smallImage;
      e.exports = r;
    }, {'./log':13, './utils':26}], 6:[function(t, e, n) {
      function r(t, e) {
        var n, r, o = document.createElement('div'), a = document.createElement('img'), s = document.createElement('span'), c = 'Hidden Text';
        o.style.visibility = 'hidden', o.style.fontFamily = t, o.style.fontSize = e, o.style.margin = 0, o.style.padding = 0, document.body.appendChild(o), a.src = i(), a.width = 1, a.height = 1, a.style.margin = 0, a.style.padding = 0, a.style.verticalAlign = 'baseline', s.style.fontFamily = t, s.style.fontSize = e, s.style.margin = 0, s.style.padding = 0, s.appendChild(document.createTextNode(c)), o.appendChild(s), o.appendChild(a), n = a.offsetTop - s.offsetTop + 1, o.removeChild(s), o.appendChild(document.createTextNode(c)), 
        o.style.lineHeight = 'normal', a.style.verticalAlign = 'super', r = a.offsetTop - o.offsetTop + 1, document.body.removeChild(o), this.baseline = n, this.lineWidth = 1, this.middle = r;
      }
      var i = t('./utils').smallImage;
      e.exports = r;
    }, {'./utils':26}], 7:[function(t, e, n) {
      function r() {
        this.data = {};
      }
      var i = t('./font');
      r.prototype.getMetrics = function(t, e) {
        return void 0 === this.data[t + '-' + e] && (this.data[t + '-' + e] = new i(t, e)), this.data[t + '-' + e];
      }, e.exports = r;
    }, {'./font':6}], 8:[function(t, e, n) {
      function r(e, n, r) {
        this.image = null, this.src = e;
        var i = this, a = o(e);
        this.promise = (n ? new Promise(function(t) {
          'about:blank' === e.contentWindow.document.URL || null == e.contentWindow.document.documentElement ? e.contentWindow.onload = e.onload = function() {
            t(e);
          } : t(e);
        }) : this.proxyLoad(r.proxy, a, r)).then(function(e) {
          var n = t('./core');
          return n(e.contentWindow.document.documentElement, {type:'view', width:e.width, height:e.height, proxy:r.proxy, javascriptEnabled:r.javascriptEnabled, removeContainer:r.removeContainer, allowTaint:r.allowTaint, imageTimeout:r.imageTimeout / 2});
        }).then(function(t) {
          return i.image = t;
        });
      }
      var i = t('./utils'), o = i.getBounds, a = t('./proxy').loadUrlDocument;
      r.prototype.proxyLoad = function(t, e, n) {
        var r = this.src;
        return a(r.src, t, r.ownerDocument, e.width, e.height, n);
      }, e.exports = r;
    }, {'./core':4, './proxy':16, './utils':26}], 9:[function(t, e, n) {
      function r(t) {
        this.src = t.value, this.colorStops = [], this.type = null, this.x0 = 0.5, this.y0 = 0.5, this.x1 = 0.5, this.y1 = 0.5, this.promise = Promise.resolve(!0);
      }
      r.TYPES = {LINEAR:1, RADIAL:2}, r.REGEXP_COLORSTOP = /^\s*(rgba?\(\s*\d{1,3},\s*\d{1,3},\s*\d{1,3}(?:,\s*[0-9\.]+)?\s*\)|[a-z]{3,20}|#[a-f0-9]{3,6})(?:\s+(\d{1,3}(?:\.\d+)?)(%|px)?)?(?:\s|$)/i, e.exports = r;
    }, {}], 10:[function(t, e, n) {
      function r(t, e) {
        this.src = t, this.image = new Image;
        var n = this;
        this.tainted = null, this.promise = new Promise(function(r, i) {
          n.image.onload = r, n.image.onerror = i, e && (n.image.crossOrigin = 'anonymous'), n.image.src = t, n.image.complete === !0 && r(n.image);
        });
      }
      e.exports = r;
    }, {}], 11:[function(t, e, n) {
      function r(t, e) {
        this.link = null, this.options = t, this.support = e, this.origin = this.getOrigin(window.location.href);
      }
      var i = t('./log'), o = t('./imagecontainer'), a = t('./dummyimagecontainer'), s = t('./proxyimagecontainer'), c = t('./framecontainer'), l = t('./svgcontainer'), u = t('./svgnodecontainer'), h = t('./lineargradientcontainer'), f = t('./webkitgradientcontainer'), d = t('./utils').bind;
      r.prototype.findImages = function(t) {
        var e = [];
        return t.reduce(function(t, e) {
          switch(e.node.nodeName) {
            case 'IMG':
              return t.concat([{args:[e.node.src], method:'url'}]);
            case 'svg':
            case 'IFRAME':
              return t.concat([{args:[e.node], method:e.node.nodeName}]);
          }
          return t;
        }, []).forEach(this.addImage(e, this.loadImage), this), e;
      }, r.prototype.findBackgroundImage = function(t, e) {
        return e.parseBackgroundImages().filter(this.hasImageBackground).forEach(this.addImage(t, this.loadImage), this), t;
      }, r.prototype.addImage = function(t, e) {
        return function(n) {
          n.args.forEach(function(r) {
            this.imageExists(t, r) || (t.splice(0, 0, e.call(this, n)), i('Added image #' + t.length, 'string' == typeof r ? r.substring(0, 100) : r));
          }, this);
        };
      }, r.prototype.hasImageBackground = function(t) {
        return 'none' !== t.method;
      }, r.prototype.loadImage = function(t) {
        if ('url' === t.method) {
          var e = t.args[0];
          return !this.isSVG(e) || this.support.svg || this.options.allowTaint ? e.match(/data:image\/.*;base64,/i) ? new o(e.replace(/url\(['"]{0,}|['"]{0,}\)$/gi, ''), !1) : this.isSameOrigin(e) || this.options.allowTaint === !0 || this.isSVG(e) ? new o(e, !1) : this.support.cors && !this.options.allowTaint && this.options.useCORS ? new o(e, !0) : this.options.proxy ? new s(e, this.options.proxy) : new a(e) : new l(e);
        }
        return 'linear-gradient' === t.method ? new h(t) : 'gradient' === t.method ? new f(t) : 'svg' === t.method ? new u(t.args[0], this.support.svg) : 'IFRAME' === t.method ? new c(t.args[0], this.isSameOrigin(t.args[0].src), this.options) : new a(t);
      }, r.prototype.isSVG = function(t) {
        return 'svg' === t.substring(t.length - 3).toLowerCase() || l.prototype.isInline(t);
      }, r.prototype.imageExists = function(t, e) {
        return t.some(function(t) {
          return t.src === e;
        });
      }, r.prototype.isSameOrigin = function(t) {
        return this.getOrigin(t) === this.origin;
      }, r.prototype.getOrigin = function(t) {
        var e = this.link || (this.link = document.createElement('a'));
        return e.href = t, e.href = e.href, e.protocol + e.hostname + e.port;
      }, r.prototype.getPromise = function(t) {
        return this.timeout(t, this.options.imageTimeout)['catch'](function() {
          var e = new a(t.src);
          return e.promise.then(function(e) {
            t.image = e;
          });
        });
      }, r.prototype.get = function(t) {
        var e = null;
        return this.images.some(function(n) {
          return (e = n).src === t;
        }) ? e : null;
      }, r.prototype.fetch = function(t) {
        return this.images = t.reduce(d(this.findBackgroundImage, this), this.findImages(t)), this.images.forEach(function(t, e) {
          t.promise.then(function() {
            i('Succesfully loaded image #' + (e + 1), t);
          }, function(n) {
            i('Failed loading image #' + (e + 1), t, n);
          });
        }), this.ready = Promise.all(this.images.map(this.getPromise, this)), i('Finished searching images'), this;
      }, r.prototype.timeout = function(t, e) {
        var n, r = Promise.race([t.promise, new Promise(function(r, o) {
          n = setTimeout(function() {
            i('Timed out loading image', t), o(t);
          }, e);
        })]).then(function(t) {
          return clearTimeout(n), t;
        });
        return r['catch'](function() {
          clearTimeout(n);
        }), r;
      }, e.exports = r;
    }, {'./dummyimagecontainer':5, './framecontainer':8, './imagecontainer':10, './lineargradientcontainer':12, './log':13, './proxyimagecontainer':17, './svgcontainer':23, './svgnodecontainer':24, './utils':26, './webkitgradientcontainer':27}], 12:[function(t, e, n) {
      function r(t) {
        i.apply(this, arguments), this.type = i.TYPES.LINEAR;
        var e = r.REGEXP_DIRECTION.test(t.args[0]) || !i.REGEXP_COLORSTOP.test(t.args[0]);
        e ? t.args[0].split(/\s+/).reverse().forEach(function(t, e) {
          switch(t) {
            case 'left':
              this.x0 = 0, this.x1 = 1;
              break;
            case 'top':
              this.y0 = 0, this.y1 = 1;
              break;
            case 'right':
              this.x0 = 1, this.x1 = 0;
              break;
            case 'bottom':
              this.y0 = 1, this.y1 = 0;
              break;
            case 'to':
              var n = this.y0, r = this.x0;
              this.y0 = this.y1, this.x0 = this.x1, this.x1 = r, this.y1 = n;
              break;
            case 'center':
              break;
            default:
              var i = 0.01 * parseFloat(t, 10);
              if (isNaN(i)) {
                break;
              }
              0 === e ? (this.y0 = i, this.y1 = 1 - this.y0) : (this.x0 = i, this.x1 = 1 - this.x0);
          }
        }, this) : (this.y0 = 0, this.y1 = 1), this.colorStops = t.args.slice(e ? 1 : 0).map(function(t) {
          var e = t.match(i.REGEXP_COLORSTOP), n = +e[2], r = 0 === n ? '%' : e[3];
          return {color:new o(e[1]), stop:'%' === r ? n / 100 : null};
        }), null === this.colorStops[0].stop && (this.colorStops[0].stop = 0), null === this.colorStops[this.colorStops.length - 1].stop && (this.colorStops[this.colorStops.length - 1].stop = 1), this.colorStops.forEach(function(t, e) {
          null === t.stop && this.colorStops.slice(e).some(function(n, r) {
            return null !== n.stop && (t.stop = (n.stop - this.colorStops[e - 1].stop) / (r + 1) + this.colorStops[e - 1].stop, !0);
          }, this);
        }, this);
      }
      var i = t('./gradientcontainer'), o = t('./color');
      r.prototype = Object.create(i.prototype), r.REGEXP_DIRECTION = /^\s*(?:to|left|right|top|bottom|center|\d{1,3}(?:\.\d+)?%?)(?:\s|$)/i, e.exports = r;
    }, {'./color':3, './gradientcontainer':9}], 13:[function(t, e, n) {
      var r = function() {
        r.options.logging && window.console && window.console.log && Function.prototype.bind.call(window.console.log, window.console).apply(window.console, [Date.now() - r.options.start + 'ms', 'html2canvas:'].concat([].slice.call(arguments, 0)));
      };
      r.options = {logging:!1}, e.exports = r;
    }, {}], 14:[function(t, e, n) {
      function r(t, e) {
        this.node = t, this.parent = e, this.stack = null, this.bounds = null, this.borders = null, this.clip = [], this.backgroundClip = [], this.offsetBounds = null, this.visible = null, this.computedStyles = null, this.colors = {}, this.styles = {}, this.backgroundImages = null, this.transformData = null, this.transformMatrix = null, this.isPseudoElement = !1, this.opacity = null;
      }
      function i(t) {
        var e = t.options[t.selectedIndex || 0];
        return e ? e.text || '' : '';
      }
      function o(t) {
        if (t && 'matrix' === t[1]) {
          return t[2].split(',').map(function(t) {
            return parseFloat(t.trim());
          });
        }
        if (t && 'matrix3d' === t[1]) {
          var e = t[2].split(',').map(function(t) {
            return parseFloat(t.trim());
          });
          return [e[0], e[1], e[4], e[5], e[12], e[13]];
        }
      }
      function a(t) {
        return t.toString().indexOf('%') !== -1;
      }
      function s(t) {
        return t.replace('px', '');
      }
      function c(t) {
        return parseFloat(t);
      }
      var l = t('./color'), u = t('./utils'), h = u.getBounds, f = u.parseBackgrounds, d = u.offsetBounds;
      r.prototype.cloneTo = function(t) {
        t.visible = this.visible, t.borders = this.borders, t.bounds = this.bounds, t.clip = this.clip, t.backgroundClip = this.backgroundClip, t.computedStyles = this.computedStyles, t.styles = this.styles, t.backgroundImages = this.backgroundImages, t.opacity = this.opacity;
      }, r.prototype.getOpacity = function() {
        return null === this.opacity ? this.opacity = this.cssFloat('opacity') : this.opacity;
      }, r.prototype.assignStack = function(t) {
        this.stack = t, t.children.push(this);
      }, r.prototype.isElementVisible = function() {
        return this.node.nodeType === Node.TEXT_NODE ? this.parent.visible : 'none' !== this.css('display') && 'hidden' !== this.css('visibility') && !this.node.hasAttribute('data-html2canvas-ignore') && ('INPUT' !== this.node.nodeName || 'hidden' !== this.node.getAttribute('type'));
      }, r.prototype.css = function(t) {
        return this.computedStyles || (this.computedStyles = this.isPseudoElement ? this.parent.computedStyle(this.before ? ':before' : ':after') : this.computedStyle(null)), this.styles[t] || (this.styles[t] = this.computedStyles[t]);
      }, r.prototype.prefixedCss = function(t) {
        var e = ['webkit', 'moz', 'ms', 'o'], n = this.css(t);
        return void 0 === n && e.some(function(e) {
          return n = this.css(e + t.substr(0, 1).toUpperCase() + t.substr(1)), void 0 !== n;
        }, this), void 0 === n ? null : n;
      }, r.prototype.computedStyle = function(t) {
        return this.node.ownerDocument.defaultView.getComputedStyle(this.node, t);
      }, r.prototype.cssInt = function(t) {
        var e = parseInt(this.css(t), 10);
        return isNaN(e) ? 0 : e;
      }, r.prototype.color = function(t) {
        return this.colors[t] || (this.colors[t] = new l(this.css(t)));
      }, r.prototype.cssFloat = function(t) {
        var e = parseFloat(this.css(t));
        return isNaN(e) ? 0 : e;
      }, r.prototype.fontWeight = function() {
        var t = this.css('fontWeight');
        switch(parseInt(t, 10)) {
          case 401:
            t = 'bold';
            break;
          case 400:
            t = 'normal';
        }
        return t;
      }, r.prototype.parseClip = function() {
        var t = this.css('clip').match(this.CLIP);
        return t ? {top:parseInt(t[1], 10), right:parseInt(t[2], 10), bottom:parseInt(t[3], 10), left:parseInt(t[4], 10)} : null;
      }, r.prototype.parseBackgroundImages = function() {
        return this.backgroundImages || (this.backgroundImages = f(this.css('backgroundImage')));
      }, r.prototype.cssList = function(t, e) {
        var n = (this.css(t) || '').split(',');
        return n = n[e || 0] || n[0] || 'auto', n = n.trim().split(' '), 1 === n.length && (n = [n[0], a(n[0]) ? 'auto' : n[0]]), n;
      }, r.prototype.parseBackgroundSize = function(t, e, n) {
        var r, i, o = this.cssList('backgroundSize', n);
        if (a(o[0])) {
          r = t.width * parseFloat(o[0]) / 100;
        } else {
          if (/contain|cover/.test(o[0])) {
            var s = t.width / t.height, c = e.width / e.height;
            return s < c ^ 'contain' === o[0] ? {width:t.height * c, height:t.height} : {width:t.width, height:t.width / c};
          }
          r = parseInt(o[0], 10);
        }
        return i = 'auto' === o[0] && 'auto' === o[1] ? e.height : 'auto' === o[1] ? r / e.width * e.height : a(o[1]) ? t.height * parseFloat(o[1]) / 100 : parseInt(o[1], 10), 'auto' === o[0] && (r = i / e.height * e.width), {width:r, height:i};
      }, r.prototype.parseBackgroundPosition = function(t, e, n, r) {
        var i, o, s = this.cssList('backgroundPosition', n);
        return i = a(s[0]) ? (t.width - (r || e).width) * (parseFloat(s[0]) / 100) : parseInt(s[0], 10), o = 'auto' === s[1] ? i / e.width * e.height : a(s[1]) ? (t.height - (r || e).height) * parseFloat(s[1]) / 100 : parseInt(s[1], 10), 'auto' === s[0] && (i = o / e.height * e.width), {left:i, top:o};
      }, r.prototype.parseBackgroundRepeat = function(t) {
        return this.cssList('backgroundRepeat', t)[0];
      }, r.prototype.parseTextShadows = function() {
        var t = this.css('textShadow'), e = [];
        if (t && 'none' !== t) {
          for (var n = t.match(this.TEXT_SHADOW_PROPERTY), r = 0; n && r < n.length; r++) {
            var i = n[r].match(this.TEXT_SHADOW_VALUES);
            e.push({color:new l(i[0]), offsetX:i[1] ? parseFloat(i[1].replace('px', '')) : 0, offsetY:i[2] ? parseFloat(i[2].replace('px', '')) : 0, blur:i[3] ? i[3].replace('px', '') : 0});
          }
        }
        return e;
      }, r.prototype.parseTransform = function() {
        if (!this.transformData) {
          if (this.hasTransform()) {
            var t = this.parseBounds(), e = this.prefixedCss('transformOrigin').split(' ').map(s).map(c);
            e[0] += t.left, e[1] += t.top, this.transformData = {origin:e, matrix:this.parseTransformMatrix()};
          } else {
            this.transformData = {origin:[0, 0], matrix:[1, 0, 0, 1, 0, 0]};
          }
        }
        return this.transformData;
      }, r.prototype.parseTransformMatrix = function() {
        if (!this.transformMatrix) {
          var t = this.prefixedCss('transform'), e = t ? o(t.match(this.MATRIX_PROPERTY)) : null;
          this.transformMatrix = e ? e : [1, 0, 0, 1, 0, 0];
        }
        return this.transformMatrix;
      }, r.prototype.parseBounds = function() {
        return this.bounds || (this.bounds = this.hasTransform() ? d(this.node) : h(this.node));
      }, r.prototype.hasTransform = function() {
        return '1,0,0,1,0,0' !== this.parseTransformMatrix().join(',') || this.parent && this.parent.hasTransform();
      }, r.prototype.getValue = function() {
        var t = this.node.value || '';
        return 'SELECT' === this.node.tagName ? t = i(this.node) : 'password' === this.node.type && (t = Array(t.length + 1).join('')), 0 === t.length ? this.node.placeholder || '' : t;
      }, r.prototype.MATRIX_PROPERTY = /(matrix|matrix3d)\((.+)\)/, r.prototype.TEXT_SHADOW_PROPERTY = /((rgba|rgb)\([^\)]+\)(\s-?\d+px){0,})/g, r.prototype.TEXT_SHADOW_VALUES = /(-?\d+px)|(#.+)|(rgb\(.+\))|(rgba\(.+\))/g, r.prototype.CLIP = /^rect\((\d+)px,? (\d+)px,? (\d+)px,? (\d+)px\)$/, e.exports = r;
    }, {'./color':3, './utils':26}], 15:[function(t, e, n) {
      function r(t, e, n, r, i) {
        L('Starting NodeParser'), this.renderer = e, this.options = i, this.range = null, this.support = n, this.renderQueue = [], this.stack = new Y(!0, 1, t.ownerDocument, null);
        var o = new U(t, null);
        if (i.background && e.rectangle(0, 0, e.width, e.height, new V(i.background)), t === t.ownerDocument.documentElement) {
          var a = new U(o.color('backgroundColor').isTransparent() ? t.ownerDocument.body : t.ownerDocument.documentElement, null);
          e.rectangle(0, 0, e.width, e.height, a.color('backgroundColor'));
        }
        o.visibile = o.isElementVisible(), this.createPseudoHideStyles(t.ownerDocument), this.disableAnimations(t.ownerDocument), this.nodes = B([o].concat(this.getChildren(o)).filter(function(t) {
          return t.visible = t.isElementVisible();
        }).map(this.getPseudoElements, this)), this.fontMetrics = new X, L('Fetched nodes, total:', this.nodes.length), L('Calculate overflow clips'), this.calculateOverflowClips(), L('Start fetching images'), this.images = r.fetch(this.nodes.filter(q)), this.ready = this.images.ready.then(J(function() {
          return L('Images loaded, starting parsing'), L('Creating stacking contexts'), this.createStackingContexts(), L('Sorting stacking contexts'), this.sortStackingContexts(this.stack), this.parse(this.stack), L('Render queue created with ' + this.renderQueue.length + ' items'), new Promise(J(function(t) {
            i.async ? 'function' == typeof i.async ? i.async.call(this, this.renderQueue, t) : this.renderQueue.length > 0 ? (this.renderIndex = 0, this.asyncRenderer(this.renderQueue, t)) : t() : (this.renderQueue.forEach(this.paint, this), t());
          }, this));
        }, this));
      }
      function i(t) {
        return t.parent && t.parent.clip.length;
      }
      function o(t) {
        return t.replace(/(\-[a-z])/g, function(t) {
          return t.toUpperCase().replace('-', '');
        });
      }
      function a() {
      }
      function s(t, e, n, r) {
        return t.map(function(i, o) {
          if (i.width > 0) {
            var a = e.left, s = e.top, c = e.width, l = e.height - t[2].width;
            switch(o) {
              case 0:
                l = t[0].width, i.args = h({c1:[a, s], c2:[a + c, s], c3:[a + c - t[1].width, s + l], c4:[a + t[3].width, s + l]}, r[0], r[1], n.topLeftOuter, n.topLeftInner, n.topRightOuter, n.topRightInner);
                break;
              case 1:
                a = e.left + e.width - t[1].width, c = t[1].width, i.args = h({c1:[a + c, s], c2:[a + c, s + l + t[2].width], c3:[a, s + l], c4:[a, s + t[0].width]}, r[1], r[2], n.topRightOuter, n.topRightInner, n.bottomRightOuter, n.bottomRightInner);
                break;
              case 2:
                s = s + e.height - t[2].width, l = t[2].width, i.args = h({c1:[a + c, s + l], c2:[a, s + l], c3:[a + t[3].width, s], c4:[a + c - t[3].width, s]}, r[2], r[3], n.bottomRightOuter, n.bottomRightInner, n.bottomLeftOuter, n.bottomLeftInner);
                break;
              case 3:
                c = t[3].width, i.args = h({c1:[a, s + l + t[2].width], c2:[a, s], c3:[a + c, s + t[0].width], c4:[a + c, s + l]}, r[3], r[0], n.bottomLeftOuter, n.bottomLeftInner, n.topLeftOuter, n.topLeftInner);
            }
          }
          return i;
        });
      }
      function c(t, e, n, r) {
        var i = 4 * ((Math.sqrt(2) - 1) / 3), o = n * i, a = r * i, s = t + n, c = e + r;
        return {topLeft:u({x:t, y:c}, {x:t, y:c - a}, {x:s - o, y:e}, {x:s, y:e}), topRight:u({x:t, y:e}, {x:t + o, y:e}, {x:s, y:c - a}, {x:s, y:c}), bottomRight:u({x:s, y:e}, {x:s, y:e + a}, {x:t + o, y:c}, {x:t, y:c}), bottomLeft:u({x:s, y:c}, {x:s - o, y:c}, {x:t, y:e + a}, {x:t, y:e})};
      }
      function l(t, e, n) {
        var r = t.left, i = t.top, o = t.width, a = t.height, s = e[0][0] < o / 2 ? e[0][0] : o / 2, l = e[0][1] < a / 2 ? e[0][1] : a / 2, u = e[1][0] < o / 2 ? e[1][0] : o / 2, h = e[1][1] < a / 2 ? e[1][1] : a / 2, f = e[2][0] < o / 2 ? e[2][0] : o / 2, d = e[2][1] < a / 2 ? e[2][1] : a / 2, p = e[3][0] < o / 2 ? e[3][0] : o / 2, g = e[3][1] < a / 2 ? e[3][1] : a / 2, m = o - u, w = a - d, y = o - f, v = a - g;
        return {topLeftOuter:c(r, i, s, l).topLeft.subdivide(0.5), topLeftInner:c(r + n[3].width, i + n[0].width, Math.max(0, s - n[3].width), Math.max(0, l - n[0].width)).topLeft.subdivide(0.5), topRightOuter:c(r + m, i, u, h).topRight.subdivide(0.5), topRightInner:c(r + Math.min(m, o + n[3].width), i + n[0].width, m > o + n[3].width ? 0 : u - n[3].width, h - n[0].width).topRight.subdivide(0.5), bottomRightOuter:c(r + y, i + w, f, d).bottomRight.subdivide(0.5), bottomRightInner:c(r + Math.min(y, 
        o - n[3].width), i + Math.min(w, a + n[0].width), Math.max(0, f - n[1].width), d - n[2].width).bottomRight.subdivide(0.5), bottomLeftOuter:c(r, i + v, p, g).bottomLeft.subdivide(0.5), bottomLeftInner:c(r + n[3].width, i + v, Math.max(0, p - n[3].width), g - n[2].width).bottomLeft.subdivide(0.5)};
      }
      function u(t, e, n, r) {
        var i = function(t, e, n) {
          return {x:t.x + (e.x - t.x) * n, y:t.y + (e.y - t.y) * n};
        };
        return {start:t, startControl:e, endControl:n, end:r, subdivide:function(o) {
          var a = i(t, e, o), s = i(e, n, o), c = i(n, r, o), l = i(a, s, o), h = i(s, c, o), f = i(l, h, o);
          return [u(t, a, l, f), u(f, h, c, r)];
        }, curveTo:function(t) {
          t.push(['bezierCurve', e.x, e.y, n.x, n.y, r.x, r.y]);
        }, curveToReversed:function(r) {
          r.push(['bezierCurve', n.x, n.y, e.x, e.y, t.x, t.y]);
        }};
      }
      function h(t, e, n, r, i, o, a) {
        var s = [];
        return e[0] > 0 || e[1] > 0 ? (s.push(['line', r[1].start.x, r[1].start.y]), r[1].curveTo(s)) : s.push(['line', t.c1[0], t.c1[1]]), n[0] > 0 || n[1] > 0 ? (s.push(['line', o[0].start.x, o[0].start.y]), o[0].curveTo(s), s.push(['line', a[0].end.x, a[0].end.y]), a[0].curveToReversed(s)) : (s.push(['line', t.c2[0], t.c2[1]]), s.push(['line', t.c3[0], t.c3[1]])), e[0] > 0 || e[1] > 0 ? (s.push(['line', i[1].end.x, i[1].end.y]), i[1].curveToReversed(s)) : s.push(['line', t.c4[0], t.c4[1]]), s;
      }
      function f(t, e, n, r, i, o, a) {
        e[0] > 0 || e[1] > 0 ? (t.push(['line', r[0].start.x, r[0].start.y]), r[0].curveTo(t), r[1].curveTo(t)) : t.push(['line', o, a]), (n[0] > 0 || n[1] > 0) && t.push(['line', i[0].start.x, i[0].start.y]);
      }
      function d(t) {
        return t.cssInt('zIndex') < 0;
      }
      function p(t) {
        return t.cssInt('zIndex') > 0;
      }
      function g(t) {
        return 0 === t.cssInt('zIndex');
      }
      function m(t) {
        return ['inline', 'inline-block', 'inline-table'].indexOf(t.css('display')) !== -1;
      }
      function w(t) {
        return t instanceof Y;
      }
      function y(t) {
        return t.node.data.trim().length > 0;
      }
      function v(t) {
        return /^(normal|none|0px)$/.test(t.parent.css('letterSpacing'));
      }
      function b(t) {
        return ['TopLeft', 'TopRight', 'BottomRight', 'BottomLeft'].map(function(e) {
          var n = t.css('border' + e + 'Radius'), r = n.split(' ');
          return r.length <= 1 && (r[1] = r[0]), r.map(O);
        });
      }
      function x(t) {
        return t.nodeType === Node.TEXT_NODE || t.nodeType === Node.ELEMENT_NODE;
      }
      function k(t) {
        var e = t.css('position'), n = ['absolute', 'relative', 'fixed'].indexOf(e) !== -1 ? t.css('zIndex') : 'auto';
        return 'auto' !== n;
      }
      function _(t) {
        return 'static' !== t.css('position');
      }
      function C(t) {
        return 'none' !== t.css('float');
      }
      function A(t) {
        return ['inline-block', 'inline-table'].indexOf(t.css('display')) !== -1;
      }
      function S(t) {
        var e = this;
        return function() {
          return !t.apply(e, arguments);
        };
      }
      function q(t) {
        return t.node.nodeType === Node.ELEMENT_NODE;
      }
      function T(t) {
        return t.isPseudoElement === !0;
      }
      function P(t) {
        return t.node.nodeType === Node.TEXT_NODE;
      }
      function I(t) {
        return function(e, n) {
          return e.cssInt('zIndex') + t.indexOf(e) / t.length - (n.cssInt('zIndex') + t.indexOf(n) / t.length);
        };
      }
      function E(t) {
        return t.getOpacity() < 1;
      }
      function O(t) {
        return parseInt(t, 10);
      }
      function F(t) {
        return t.width;
      }
      function R(t) {
        return t.node.nodeType !== Node.ELEMENT_NODE || ['SCRIPT', 'HEAD', 'TITLE', 'OBJECT', 'BR', 'OPTION'].indexOf(t.node.nodeName) === -1;
      }
      function B(t) {
        return [].concat.apply([], t);
      }
      function D(t) {
        var e = t.substr(0, 1);
        return e === t.substr(t.length - 1) && e.match(/'|"/) ? t.substr(1, t.length - 2) : t;
      }
      function j(t) {
        for (var e, n = [], r = 0, i = !1; t.length;) {
          z(t[r]) === i ? (e = t.splice(0, r), e.length && n.push(M.ucs2.encode(e)), i = !i, r = 0) : r++, r >= t.length && (e = t.splice(0, r), e.length && n.push(M.ucs2.encode(e)));
        }
        return n;
      }
      function z(t) {
        return [32, 13, 10, 9, 45].indexOf(t) !== -1;
      }
      function N(t) {
        return /[^\u0000-\u00ff]/.test(t);
      }
      var L = t('./log'), M = t('punycode'), U = t('./nodecontainer'), H = t('./textcontainer'), W = t('./pseudoelementcontainer'), X = t('./fontmetrics'), V = t('./color'), Y = t('./stackingcontext'), G = t('./utils'), J = G.bind, Q = G.getBounds, K = G.parseBackgrounds, $ = G.offsetBounds;
      r.prototype.calculateOverflowClips = function() {
        this.nodes.forEach(function(t) {
          if (q(t)) {
            T(t) && t.appendToDOM(), t.borders = this.parseBorders(t);
            var e = 'hidden' === t.css('overflow') ? [t.borders.clip] : [], n = t.parseClip();
            n && ['absolute', 'fixed'].indexOf(t.css('position')) !== -1 && e.push([['rect', t.bounds.left + n.left, t.bounds.top + n.top, n.right - n.left, n.bottom - n.top]]), t.clip = i(t) ? t.parent.clip.concat(e) : e, t.backgroundClip = 'hidden' !== t.css('overflow') ? t.clip.concat([t.borders.clip]) : t.clip, T(t) && t.cleanDOM();
          } else {
            P(t) && (t.clip = i(t) ? t.parent.clip : []);
          }
          T(t) || (t.bounds = null);
        }, this);
      }, r.prototype.asyncRenderer = function(t, e, n) {
        n = n || Date.now(), this.paint(t[this.renderIndex++]), t.length === this.renderIndex ? e() : n + 20 > Date.now() ? this.asyncRenderer(t, e, n) : setTimeout(J(function() {
          this.asyncRenderer(t, e);
        }, this), 0);
      }, r.prototype.createPseudoHideStyles = function(t) {
        this.createStyles(t, '.' + W.prototype.PSEUDO_HIDE_ELEMENT_CLASS_BEFORE + ':before { content: "" !important; display: none !important; }.' + W.prototype.PSEUDO_HIDE_ELEMENT_CLASS_AFTER + ':after { content: "" !important; display: none !important; }');
      }, r.prototype.disableAnimations = function(t) {
        this.createStyles(t, '* { -webkit-animation: none !important; -moz-animation: none !important; -o-animation: none !important; animation: none !important; -webkit-transition: none !important; -moz-transition: none !important; -o-transition: none !important; transition: none !important;}');
      }, r.prototype.createStyles = function(t, e) {
        var n = t.createElement('style');
        n.innerHTML = e, t.body.appendChild(n);
      }, r.prototype.getPseudoElements = function(t) {
        var e = [[t]];
        if (t.node.nodeType === Node.ELEMENT_NODE) {
          var n = this.getPseudoElement(t, ':before'), r = this.getPseudoElement(t, ':after');
          n && e.push(n), r && e.push(r);
        }
        return B(e);
      }, r.prototype.getPseudoElement = function(t, e) {
        var n = t.computedStyle(e);
        if (!n || !n.content || 'none' === n.content || '-moz-alt-content' === n.content || 'none' === n.display) {
          return null;
        }
        for (var r = D(n.content), i = 'url' === r.substr(0, 3), a = document.createElement(i ? 'img' : 'html2canvaspseudoelement'), s = new W(a, t, e), c = n.length - 1; c >= 0; c--) {
          var l = o(n.item(c));
          a.style[l] = n[l];
        }
        if (a.className = W.prototype.PSEUDO_HIDE_ELEMENT_CLASS_BEFORE + ' ' + W.prototype.PSEUDO_HIDE_ELEMENT_CLASS_AFTER, i) {
          return a.src = K(r)[0].args[0], [s];
        }
        var u = document.createTextNode(r);
        return a.appendChild(u), [s, new H(u, s)];
      }, r.prototype.getChildren = function(t) {
        return B([].filter.call(t.node.childNodes, x).map(function(e) {
          var n = [e.nodeType === Node.TEXT_NODE ? new H(e, t) : new U(e, t)].filter(R);
          return e.nodeType === Node.ELEMENT_NODE && n.length && 'TEXTAREA' !== e.tagName ? n[0].isElementVisible() ? n.concat(this.getChildren(n[0])) : [] : n;
        }, this));
      }, r.prototype.newStackingContext = function(t, e) {
        var n = new Y(e, t.getOpacity(), t.node, t.parent);
        t.cloneTo(n);
        var r = e ? n.getParentStack(this) : n.parent.stack;
        r.contexts.push(n), t.stack = n;
      }, r.prototype.createStackingContexts = function() {
        this.nodes.forEach(function(t) {
          q(t) && (this.isRootElement(t) || E(t) || k(t) || this.isBodyWithTransparentRoot(t) || t.hasTransform()) ? this.newStackingContext(t, !0) : q(t) && (_(t) && g(t) || A(t) || C(t)) ? this.newStackingContext(t, !1) : t.assignStack(t.parent.stack);
        }, this);
      }, r.prototype.isBodyWithTransparentRoot = function(t) {
        return 'BODY' === t.node.nodeName && t.parent.color('backgroundColor').isTransparent();
      }, r.prototype.isRootElement = function(t) {
        return null === t.parent;
      }, r.prototype.sortStackingContexts = function(t) {
        t.contexts.sort(I(t.contexts.slice(0))), t.contexts.forEach(this.sortStackingContexts, this);
      }, r.prototype.parseTextBounds = function(t) {
        return function(e, n, r) {
          if ('none' !== t.parent.css('textDecoration').substr(0, 4) || 0 !== e.trim().length) {
            if (this.support.rangeBounds && !t.parent.hasTransform()) {
              var i = r.slice(0, n).join('').length;
              return this.getRangeBounds(t.node, i, e.length);
            }
            if (t.node && 'string' == typeof t.node.data) {
              var o = t.node.splitText(e.length), a = this.getWrapperBounds(t.node, t.parent.hasTransform());
              return t.node = o, a;
            }
          } else {
            this.support.rangeBounds && !t.parent.hasTransform() || (t.node = t.node.splitText(e.length));
          }
          return {};
        };
      }, r.prototype.getWrapperBounds = function(t, e) {
        var n = t.ownerDocument.createElement('html2canvaswrapper'), r = t.parentNode, i = t.cloneNode(!0);
        n.appendChild(t.cloneNode(!0)), r.replaceChild(n, t);
        var o = e ? $(n) : Q(n);
        return r.replaceChild(i, n), o;
      }, r.prototype.getRangeBounds = function(t, e, n) {
        var r = this.range || (this.range = t.ownerDocument.createRange());
        return r.setStart(t, e), r.setEnd(t, e + n), r.getBoundingClientRect();
      }, r.prototype.parse = function(t) {
        var e = t.contexts.filter(d), n = t.children.filter(q), r = n.filter(S(C)), i = r.filter(S(_)).filter(S(m)), o = n.filter(S(_)).filter(C), s = r.filter(S(_)).filter(m), c = t.contexts.concat(r.filter(_)).filter(g), l = t.children.filter(P).filter(y), u = t.contexts.filter(p);
        e.concat(i).concat(o).concat(s).concat(c).concat(l).concat(u).forEach(function(t) {
          this.renderQueue.push(t), w(t) && (this.parse(t), this.renderQueue.push(new a));
        }, this);
      }, r.prototype.paint = function(t) {
        try {
          t instanceof a ? this.renderer.ctx.restore() : P(t) ? (T(t.parent) && t.parent.appendToDOM(), this.paintText(t), T(t.parent) && t.parent.cleanDOM()) : this.paintNode(t);
        } catch (t$45) {
          if (L(t$45), this.options.strict) {
            throw t$45;
          }
        }
      }, r.prototype.paintNode = function(t) {
        w(t) && (this.renderer.setOpacity(t.opacity), this.renderer.ctx.save(), t.hasTransform() && this.renderer.setTransform(t.parseTransform())), 'INPUT' === t.node.nodeName && 'checkbox' === t.node.type ? this.paintCheckbox(t) : 'INPUT' === t.node.nodeName && 'radio' === t.node.type ? this.paintRadio(t) : this.paintElement(t);
      }, r.prototype.paintElement = function(t) {
        var e = t.parseBounds();
        this.renderer.clip(t.backgroundClip, function() {
          this.renderer.renderBackground(t, e, t.borders.borders.map(F));
        }, this), this.renderer.clip(t.clip, function() {
          this.renderer.renderBorders(t.borders.borders);
        }, this), this.renderer.clip(t.backgroundClip, function() {
          switch(t.node.nodeName) {
            case 'svg':
            case 'IFRAME':
              var n = this.images.get(t.node);
              n ? this.renderer.renderImage(t, e, t.borders, n) : L('Error loading \x3c' + t.node.nodeName + '\x3e', t.node);
              break;
            case 'IMG':
              var r = this.images.get(t.node.src);
              r ? this.renderer.renderImage(t, e, t.borders, r) : L('Error loading \x3cimg\x3e', t.node.src);
              break;
            case 'CANVAS':
              this.renderer.renderImage(t, e, t.borders, {image:t.node});
              break;
            case 'SELECT':
            case 'INPUT':
            case 'TEXTAREA':
              this.paintFormValue(t);
          }
        }, this);
      }, r.prototype.paintCheckbox = function(t) {
        var e = t.parseBounds(), n = Math.min(e.width, e.height), r = {width:n - 1, height:n - 1, top:e.top, left:e.left}, i = [3, 3], o = [i, i, i, i], a = [1, 1, 1, 1].map(function(t) {
          return {color:new V('#A5A5A5'), width:t};
        }), c = l(r, o, a);
        this.renderer.clip(t.backgroundClip, function() {
          this.renderer.rectangle(r.left + 1, r.top + 1, r.width - 2, r.height - 2, new V('#DEDEDE')), this.renderer.renderBorders(s(a, r, c, o)), t.node.checked && (this.renderer.font(new V('#424242'), 'normal', 'normal', 'bold', n - 3 + 'px', 'arial'), this.renderer.text('', r.left + n / 6, r.top + n - 1));
        }, this);
      }, r.prototype.paintRadio = function(t) {
        var e = t.parseBounds(), n = Math.min(e.width, e.height) - 2;
        this.renderer.clip(t.backgroundClip, function() {
          this.renderer.circleStroke(e.left + 1, e.top + 1, n, new V('#DEDEDE'), 1, new V('#A5A5A5')), t.node.checked && this.renderer.circle(Math.ceil(e.left + n / 4) + 1, Math.ceil(e.top + n / 4) + 1, Math.floor(n / 2), new V('#424242'));
        }, this);
      }, r.prototype.paintFormValue = function(t) {
        var e = t.getValue();
        if (e.length > 0) {
          var n = t.node.ownerDocument, r = n.createElement('html2canvaswrapper'), i = ['lineHeight', 'textAlign', 'fontFamily', 'fontWeight', 'fontSize', 'color', 'paddingLeft', 'paddingTop', 'paddingRight', 'paddingBottom', 'width', 'height', 'borderLeftStyle', 'borderTopStyle', 'borderLeftWidth', 'borderTopWidth', 'boxSizing', 'whiteSpace', 'wordWrap'];
          i.forEach(function(e) {
            try {
              r.style[e] = t.css(e);
            } catch (t$46) {
              L('html2canvas: Parse: Exception caught in renderFormValue: ' + t$46.message);
            }
          });
          var o = t.parseBounds();
          r.style.position = 'fixed', r.style.left = o.left + 'px', r.style.top = o.top + 'px', r.textContent = e, n.body.appendChild(r), this.paintText(new H(r.firstChild, t)), n.body.removeChild(r);
        }
      }, r.prototype.paintText = function(t) {
        t.applyTextTransform();
        var e = M.ucs2.decode(t.node.data), n = this.options.letterRendering && !v(t) || N(t.node.data) ? e.map(function(t) {
          return M.ucs2.encode([t]);
        }) : j(e), r = t.parent.fontWeight(), i = t.parent.css('fontSize'), o = t.parent.css('fontFamily'), a = t.parent.parseTextShadows();
        this.renderer.font(t.parent.color('color'), t.parent.css('fontStyle'), t.parent.css('fontVariant'), r, i, o), a.length ? this.renderer.fontShadow(a[0].color, a[0].offsetX, a[0].offsetY, a[0].blur) : this.renderer.clearShadow(), this.renderer.clip(t.parent.clip, function() {
          n.map(this.parseTextBounds(t), this).forEach(function(e, r) {
            e && (this.renderer.text(n[r], e.left, e.bottom), this.renderTextDecoration(t.parent, e, this.fontMetrics.getMetrics(o, i)));
          }, this);
        }, this);
      }, r.prototype.renderTextDecoration = function(t, e, n) {
        switch(t.css('textDecoration').split(' ')[0]) {
          case 'underline':
            this.renderer.rectangle(e.left, Math.round(e.top + n.baseline + n.lineWidth), e.width, 1, t.color('color'));
            break;
          case 'overline':
            this.renderer.rectangle(e.left, Math.round(e.top), e.width, 1, t.color('color'));
            break;
          case 'line-through':
            this.renderer.rectangle(e.left, Math.ceil(e.top + n.middle + n.lineWidth), e.width, 1, t.color('color'));
        }
      };
      var Z = {inset:[['darken', 0.6], ['darken', 0.1], ['darken', 0.1], ['darken', 0.6]]};
      r.prototype.parseBorders = function(t) {
        var e = t.parseBounds(), n = b(t), r = ['Top', 'Right', 'Bottom', 'Left'].map(function(e, n) {
          var r = t.css('border' + e + 'Style'), i = t.color('border' + e + 'Color');
          'inset' === r && i.isBlack() && (i = new V([255, 255, 255, i.a]));
          var o = Z[r] ? Z[r][n] : null;
          return {width:t.cssInt('border' + e + 'Width'), color:o ? i[o[0]](o[1]) : i, args:null};
        }), i = l(e, n, r);
        return {clip:this.parseBackgroundClip(t, i, r, n, e), borders:s(r, e, i, n)};
      }, r.prototype.parseBackgroundClip = function(t, e, n, r, i) {
        var o = t.css('backgroundClip'), a = [];
        switch(o) {
          case 'content-box':
          case 'padding-box':
            f(a, r[0], r[1], e.topLeftInner, e.topRightInner, i.left + n[3].width, i.top + n[0].width), f(a, r[1], r[2], e.topRightInner, e.bottomRightInner, i.left + i.width - n[1].width, i.top + n[0].width), f(a, r[2], r[3], e.bottomRightInner, e.bottomLeftInner, i.left + i.width - n[1].width, i.top + i.height - n[2].width), f(a, r[3], r[0], e.bottomLeftInner, e.topLeftInner, i.left + n[3].width, i.top + i.height - n[2].width);
            break;
          default:
            f(a, r[0], r[1], e.topLeftOuter, e.topRightOuter, i.left, i.top), f(a, r[1], r[2], e.topRightOuter, e.bottomRightOuter, i.left + i.width, i.top), f(a, r[2], r[3], e.bottomRightOuter, e.bottomLeftOuter, i.left + i.width, i.top + i.height), f(a, r[3], r[0], e.bottomLeftOuter, e.topLeftOuter, i.left, i.top + i.height);
        }
        return a;
      }, e.exports = r;
    }, {'./color':3, './fontmetrics':7, './log':13, './nodecontainer':14, './pseudoelementcontainer':18, './stackingcontext':21, './textcontainer':25, './utils':26, punycode:1}], 16:[function(t, e, n) {
      function r(t, e, n) {
        var r = 'withCredentials' in new XMLHttpRequest;
        if (!e) {
          return Promise.reject('No proxy configured');
        }
        var i = a(r), c = s(e, t, i);
        return r ? u(c) : o(n, c, i).then(function(t) {
          return p(t.content);
        });
      }
      function i(t, e, n) {
        var r = 'crossOrigin' in new Image, i = a(r), c = s(e, t, i);
        return r ? Promise.resolve(c) : o(n, c, i).then(function(t) {
          return 'data:' + t.type + ';base64,' + t.content;
        });
      }
      function o(t, e, n) {
        return new Promise(function(r, i) {
          var o = t.createElement('script'), a = function() {
            delete window.html2canvas.proxy[n], t.body.removeChild(o);
          };
          window.html2canvas.proxy[n] = function(t) {
            a(), r(t);
          }, o.src = e, o.onerror = function(t) {
            a(), i(t);
          }, t.body.appendChild(o);
        });
      }
      function a(t) {
        return t ? '' : 'html2canvas_' + Date.now() + '_' + ++g + '_' + Math.round(100000 * Math.random());
      }
      function s(t, e, n) {
        return t + '?url\x3d' + encodeURIComponent(e) + (n.length ? '\x26callback\x3dhtml2canvas.proxy.' + n : '');
      }
      function c(t) {
        return function(e) {
          var n, r = new DOMParser;
          try {
            n = r.parseFromString(e, 'text/html');
          } catch (t$48) {
            f('DOMParser not supported, falling back to createHTMLDocument'), n = document.implementation.createHTMLDocument('');
            try {
              n.open(), n.write(e), n.close();
            } catch (t$47) {
              f('createHTMLDocument write not supported, falling back to document.body.innerHTML'), n.body.innerHTML = e;
            }
          }
          var i = n.querySelector('base');
          if (!i || !i.href.host) {
            var o = n.createElement('base');
            o.href = t, n.head.insertBefore(o, n.head.firstChild);
          }
          return n;
        };
      }
      function l(t, e, n, i, o, a) {
        return (new r(t, e, window.document)).then(c(t)).then(function(t) {
          return d(t, n, i, o, a, 0, 0);
        });
      }
      var u = t('./xhr'), h = t('./utils'), f = t('./log'), d = t('./clone'), p = h.decode64, g = 0;
      n.Proxy = r, n.ProxyURL = i, n.loadUrlDocument = l;
    }, {'./clone':2, './log':13, './utils':26, './xhr':28}], 17:[function(t, e, n) {
      function r(t, e) {
        var n = document.createElement('a');
        n.href = t, t = n.href, this.src = t, this.image = new Image;
        var r = this;
        this.promise = new Promise(function(n, o) {
          r.image.crossOrigin = 'Anonymous', r.image.onload = n, r.image.onerror = o, (new i(t, e, document)).then(function(t) {
            r.image.src = t;
          })['catch'](o);
        });
      }
      var i = t('./proxy').ProxyURL;
      e.exports = r;
    }, {'./proxy':16}], 18:[function(t, e, n) {
      function r(t, e, n) {
        i.call(this, t, e), this.isPseudoElement = !0, this.before = ':before' === n;
      }
      var i = t('./nodecontainer');
      r.prototype.cloneTo = function(t) {
        r.prototype.cloneTo.call(this, t), t.isPseudoElement = !0, t.before = this.before;
      }, r.prototype = Object.create(i.prototype), r.prototype.appendToDOM = function() {
        this.before ? this.parent.node.insertBefore(this.node, this.parent.node.firstChild) : this.parent.node.appendChild(this.node), this.parent.node.className += ' ' + this.getHideClass();
      }, r.prototype.cleanDOM = function() {
        this.node.parentNode.removeChild(this.node), this.parent.node.className = this.parent.node.className.replace(this.getHideClass(), '');
      }, r.prototype.getHideClass = function() {
        return this['PSEUDO_HIDE_ELEMENT_CLASS_' + (this.before ? 'BEFORE' : 'AFTER')];
      }, r.prototype.PSEUDO_HIDE_ELEMENT_CLASS_BEFORE = '___html2canvas___pseudoelement_before', r.prototype.PSEUDO_HIDE_ELEMENT_CLASS_AFTER = '___html2canvas___pseudoelement_after', e.exports = r;
    }, {'./nodecontainer':14}], 19:[function(t, e, n) {
      function r(t, e, n, r, i) {
        this.width = t, this.height = e, this.images = n, this.options = r, this.document = i;
      }
      var i = t('./log');
      r.prototype.renderImage = function(t, e, n, r) {
        var i = t.cssInt('paddingLeft'), o = t.cssInt('paddingTop'), a = t.cssInt('paddingRight'), s = t.cssInt('paddingBottom'), c = n.borders, l = e.width - (c[1].width + c[3].width + i + a), u = e.height - (c[0].width + c[2].width + o + s);
        this.drawImage(r, 0, 0, r.image.width || l, r.image.height || u, e.left + i + c[3].width, e.top + o + c[0].width, l, u);
      }, r.prototype.renderBackground = function(t, e, n) {
        e.height > 0 && e.width > 0 && (this.renderBackgroundColor(t, e), this.renderBackgroundImage(t, e, n));
      }, r.prototype.renderBackgroundColor = function(t, e) {
        var n = t.color('backgroundColor');
        n.isTransparent() || this.rectangle(e.left, e.top, e.width, e.height, n);
      }, r.prototype.renderBorders = function(t) {
        t.forEach(this.renderBorder, this);
      }, r.prototype.renderBorder = function(t) {
        t.color.isTransparent() || null === t.args || this.drawShape(t.args, t.color);
      }, r.prototype.renderBackgroundImage = function(t, e, n) {
        var r = t.parseBackgroundImages();
        r.reverse().forEach(function(r, o, a) {
          switch(r.method) {
            case 'url':
              var s = this.images.get(r.args[0]);
              s ? this.renderBackgroundRepeating(t, e, s, a.length - (o + 1), n) : i('Error loading background-image', r.args[0]);
              break;
            case 'linear-gradient':
            case 'gradient':
              var c = this.images.get(r.value);
              c ? this.renderBackgroundGradient(c, e, n) : i('Error loading background-image', r.args[0]);
              break;
            case 'none':
              break;
            default:
              i('Unknown background-image type', r.args[0]);
          }
        }, this);
      }, r.prototype.renderBackgroundRepeating = function(t, e, n, r, i) {
        var o = t.parseBackgroundSize(e, n.image, r), a = t.parseBackgroundPosition(e, n.image, r, o), s = t.parseBackgroundRepeat(r);
        switch(s) {
          case 'repeat-x':
          case 'repeat no-repeat':
            this.backgroundRepeatShape(n, a, o, e, e.left + i[3], e.top + a.top + i[0], 99999, o.height, i);
            break;
          case 'repeat-y':
          case 'no-repeat repeat':
            this.backgroundRepeatShape(n, a, o, e, e.left + a.left + i[3], e.top + i[0], o.width, 99999, i);
            break;
          case 'no-repeat':
            this.backgroundRepeatShape(n, a, o, e, e.left + a.left + i[3], e.top + a.top + i[0], o.width, o.height, i);
            break;
          default:
            this.renderBackgroundRepeat(n, a, o, {top:e.top, left:e.left}, i[3], i[0]);
        }
      }, e.exports = r;
    }, {'./log':13}], 20:[function(t, e, n) {
      function r(t, e) {
        o.apply(this, arguments), this.canvas = this.options.canvas || this.document.createElement('canvas'), this.options.canvas || (this.canvas.width = t, this.canvas.height = e), this.ctx = this.canvas.getContext('2d'), this.taintCtx = this.document.createElement('canvas').getContext('2d'), this.ctx.textBaseline = 'bottom', this.variables = {}, s('Initialized CanvasRenderer with size', t, 'x', e);
      }
      function i(t) {
        return t.length > 0;
      }
      var o = t('../renderer'), a = t('../lineargradientcontainer'), s = t('../log');
      r.prototype = Object.create(o.prototype), r.prototype.setFillStyle = function(t) {
        return this.ctx.fillStyle = 'object' == typeof t && t.isColor ? t.toString() : t, this.ctx;
      }, r.prototype.rectangle = function(t, e, n, r, i) {
        this.setFillStyle(i).fillRect(t, e, n, r);
      }, r.prototype.circle = function(t, e, n, r) {
        this.setFillStyle(r), this.ctx.beginPath(), this.ctx.arc(t + n / 2, e + n / 2, n / 2, 0, 2 * Math.PI, !0), this.ctx.closePath(), this.ctx.fill();
      }, r.prototype.circleStroke = function(t, e, n, r, i, o) {
        this.circle(t, e, n, r), this.ctx.strokeStyle = o.toString(), this.ctx.stroke();
      }, r.prototype.drawShape = function(t, e) {
        this.shape(t), this.setFillStyle(e).fill();
      }, r.prototype.taints = function(t) {
        if (null === t.tainted) {
          this.taintCtx.drawImage(t.image, 0, 0);
          try {
            this.taintCtx.getImageData(0, 0, 1, 1), t.tainted = !1;
          } catch (e$49) {
            this.taintCtx = document.createElement('canvas').getContext('2d'), t.tainted = !0;
          }
        }
        return t.tainted;
      }, r.prototype.drawImage = function(t, e, n, r, i, o, a, s, c) {
        this.taints(t) && !this.options.allowTaint || this.ctx.drawImage(t.image, e, n, r, i, o, a, s, c);
      }, r.prototype.clip = function(t, e, n) {
        this.ctx.save(), t.filter(i).forEach(function(t) {
          this.shape(t).clip();
        }, this), e.call(n), this.ctx.restore();
      }, r.prototype.shape = function(t) {
        return this.ctx.beginPath(), t.forEach(function(t, e) {
          'rect' === t[0] ? this.ctx.rect.apply(this.ctx, t.slice(1)) : this.ctx[0 === e ? 'moveTo' : t[0] + 'To'].apply(this.ctx, t.slice(1));
        }, this), this.ctx.closePath(), this.ctx;
      }, r.prototype.font = function(t, e, n, r, i, o) {
        this.setFillStyle(t).font = [e, n, r, i, o].join(' ').split(',')[0];
      }, r.prototype.fontShadow = function(t, e, n, r) {
        this.setVariable('shadowColor', t.toString()).setVariable('shadowOffsetY', e).setVariable('shadowOffsetX', n).setVariable('shadowBlur', r);
      }, r.prototype.clearShadow = function() {
        this.setVariable('shadowColor', 'rgba(0,0,0,0)');
      }, r.prototype.setOpacity = function(t) {
        this.ctx.globalAlpha = t;
      }, r.prototype.setTransform = function(t) {
        this.ctx.translate(t.origin[0], t.origin[1]), this.ctx.transform.apply(this.ctx, t.matrix), this.ctx.translate(-t.origin[0], -t.origin[1]);
      }, r.prototype.setVariable = function(t, e) {
        return this.variables[t] !== e && (this.variables[t] = this.ctx[t] = e), this;
      }, r.prototype.text = function(t, e, n) {
        this.ctx.fillText(t, e, n);
      }, r.prototype.backgroundRepeatShape = function(t, e, n, r, i, o, a, s, c) {
        var l = [['line', Math.round(i), Math.round(o)], ['line', Math.round(i + a), Math.round(o)], ['line', Math.round(i + a), Math.round(s + o)], ['line', Math.round(i), Math.round(s + o)]];
        this.clip([l], function() {
          this.renderBackgroundRepeat(t, e, n, r, c[3], c[0]);
        }, this);
      }, r.prototype.renderBackgroundRepeat = function(t, e, n, r, i, o) {
        var a = Math.round(r.left + e.left + i), s = Math.round(r.top + e.top + o);
        this.setFillStyle(this.ctx.createPattern(this.resizeImage(t, n), 'repeat')), this.ctx.translate(a, s), this.ctx.fill(), this.ctx.translate(-a, -s);
      }, r.prototype.renderBackgroundGradient = function(t, e) {
        if (t instanceof a) {
          var n = this.ctx.createLinearGradient(e.left + e.width * t.x0, e.top + e.height * t.y0, e.left + e.width * t.x1, e.top + e.height * t.y1);
          t.colorStops.forEach(function(t) {
            n.addColorStop(t.stop, t.color.toString());
          }), this.rectangle(e.left, e.top, e.width, e.height, n);
        }
      }, r.prototype.resizeImage = function(t, e) {
        var n = t.image;
        if (n.width === e.width && n.height === e.height) {
          return n;
        }
        var r, i = document.createElement('canvas');
        return i.width = e.width, i.height = e.height, r = i.getContext('2d'), r.drawImage(n, 0, 0, n.width, n.height, 0, 0, e.width, e.height), i;
      }, e.exports = r;
    }, {'../lineargradientcontainer':12, '../log':13, '../renderer':19}], 21:[function(t, e, n) {
      function r(t, e, n, r) {
        i.call(this, n, r), this.ownStacking = t, this.contexts = [], this.children = [], this.opacity = (this.parent ? this.parent.stack.opacity : 1) * e;
      }
      var i = t('./nodecontainer');
      r.prototype = Object.create(i.prototype), r.prototype.getParentStack = function(t) {
        var e = this.parent ? this.parent.stack : null;
        return e ? e.ownStacking ? e : e.getParentStack(t) : t.stack;
      }, e.exports = r;
    }, {'./nodecontainer':14}], 22:[function(t, e, n) {
      function r(t) {
        this.rangeBounds = this.testRangeBounds(t), this.cors = this.testCORS(), this.svg = this.testSVG();
      }
      r.prototype.testRangeBounds = function(t) {
        var e, n, r, i, o = !1;
        return t.createRange && (e = t.createRange(), e.getBoundingClientRect && (n = t.createElement('boundtest'), n.style.height = '123px', n.style.display = 'block', t.body.appendChild(n), e.selectNode(n), r = e.getBoundingClientRect(), i = r.height, 123 === i && (o = !0), t.body.removeChild(n))), o;
      }, r.prototype.testCORS = function() {
        return 'undefined' != typeof(new Image).crossOrigin;
      }, r.prototype.testSVG = function() {
        var t = new Image, e = document.createElement('canvas'), n = e.getContext('2d');
        t.src = "data:image/svg+xml,\x3csvg xmlns\x3d'http://www.w3.org/2000/svg'\x3e\x3c/svg\x3e";
        try {
          n.drawImage(t, 0, 0), e.toDataURL();
        } catch (t$50) {
          return !1;
        }
        return !0;
      }, e.exports = r;
    }, {}], 23:[function(t, e, n) {
      function r(t) {
        this.src = t, this.image = null;
        var e = this;
        this.promise = this.hasFabric().then(function() {
          return e.isInline(t) ? Promise.resolve(e.inlineFormatting(t)) : i(t);
        }).then(function(t) {
          return new Promise(function(n) {
            window.html2canvas.svg.fabric.loadSVGFromString(t, e.createCanvas.call(e, n));
          });
        });
      }
      var i = t('./xhr'), o = t('./utils').decode64;
      r.prototype.hasFabric = function() {
        return window.html2canvas.svg && window.html2canvas.svg.fabric ? Promise.resolve() : Promise.reject(new Error('html2canvas.svg.js is not loaded, cannot render svg'));
      }, r.prototype.inlineFormatting = function(t) {
        return /^data:image\/svg\+xml;base64,/.test(t) ? this.decode64(this.removeContentType(t)) : this.removeContentType(t);
      }, r.prototype.removeContentType = function(t) {
        return t.replace(/^data:image\/svg\+xml(;base64)?,/, '');
      }, r.prototype.isInline = function(t) {
        return /^data:image\/svg\+xml/i.test(t);
      }, r.prototype.createCanvas = function(t) {
        var e = this;
        return function(n, r) {
          var i = new window.html2canvas.svg.fabric.StaticCanvas('c');
          e.image = i.lowerCanvasEl, i.setWidth(r.width).setHeight(r.height).add(window.html2canvas.svg.fabric.util.groupSVGElements(n, r)).renderAll(), t(i.lowerCanvasEl);
        };
      }, r.prototype.decode64 = function(t) {
        return 'function' == typeof window.atob ? window.atob(t) : o(t);
      }, e.exports = r;
    }, {'./utils':26, './xhr':28}], 24:[function(t, e, n) {
      function r(t, e) {
        this.src = t, this.image = null;
        var n = this;
        this.promise = e ? new Promise(function(e, r) {
          n.image = new Image, n.image.onload = e, n.image.onerror = r, n.image.src = 'data:image/svg+xml,' + (new XMLSerializer).serializeToString(t), n.image.complete === !0 && e(n.image);
        }) : this.hasFabric().then(function() {
          return new Promise(function(e) {
            window.html2canvas.svg.fabric.parseSVGDocument(t, n.createCanvas.call(n, e));
          });
        });
      }
      var i = t('./svgcontainer');
      r.prototype = Object.create(i.prototype), e.exports = r;
    }, {'./svgcontainer':23}], 25:[function(t, e, n) {
      function r(t, e) {
        o.call(this, t, e);
      }
      function i(t, e, n) {
        if (t.length > 0) {
          return e + n.toUpperCase();
        }
      }
      var o = t('./nodecontainer');
      r.prototype = Object.create(o.prototype), r.prototype.applyTextTransform = function() {
        this.node.data = this.transform(this.parent.css('textTransform'));
      }, r.prototype.transform = function(t) {
        var e = this.node.data;
        switch(t) {
          case 'lowercase':
            return e.toLowerCase();
          case 'capitalize':
            return e.replace(/(^|\s|:|-|\(|\))([a-z])/g, i);
          case 'uppercase':
            return e.toUpperCase();
          default:
            return e;
        }
      }, e.exports = r;
    }, {'./nodecontainer':14}], 26:[function(t, e, n) {
      n.smallImage = function() {
        return 'data:image/gif;base64,R0lGODlhAQABAIAAAAAAAP///yH5BAEAAAAALAAAAAABAAEAAAIBRAA7';
      }, n.bind = function(t, e) {
        return function() {
          return t.apply(e, arguments);
        };
      }, n.decode64 = function(t) {
        var e, n, r, i, o, a, s, c, l = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/', u = t.length, h = '';
        for (e = 0; e < u; e += 4) {
          n = l.indexOf(t[e]), r = l.indexOf(t[e + 1]), i = l.indexOf(t[e + 2]), o = l.indexOf(t[e + 3]), a = n << 2 | r >> 4, s = (15 & r) << 4 | i >> 2, c = (3 & i) << 6 | o, h += 64 === i ? String.fromCharCode(a) : 64 === o || o === -1 ? String.fromCharCode(a, s) : String.fromCharCode(a, s, c);
        }
        return h;
      }, n.getBounds = function(t) {
        if (t.getBoundingClientRect) {
          var e = t.getBoundingClientRect(), n = null == t.offsetWidth ? e.width : t.offsetWidth;
          return {top:e.top, bottom:e.bottom || e.top + e.height, right:e.left + n, left:e.left, width:n, height:null == t.offsetHeight ? e.height : t.offsetHeight};
        }
        return {};
      }, n.offsetBounds = function(t) {
        var e = t.offsetParent ? n.offsetBounds(t.offsetParent) : {top:0, left:0};
        return {top:t.offsetTop + e.top, bottom:t.offsetTop + t.offsetHeight + e.top, right:t.offsetLeft + e.left + t.offsetWidth, left:t.offsetLeft + e.left, width:t.offsetWidth, height:t.offsetHeight};
      }, n.parseBackgrounds = function(t) {
        var e, n, r, i, o, a, s, c = ' \r\n\t', l = [], u = 0, h = 0, f = function() {
          e && ('"' === n.substr(0, 1) && (n = n.substr(1, n.length - 2)), n && s.push(n), '-' === e.substr(0, 1) && (i = e.indexOf('-', 1) + 1) > 0 && (r = e.substr(0, i), e = e.substr(i)), l.push({prefix:r, method:e.toLowerCase(), value:o, args:s, image:null})), s = [], e = r = n = o = '';
        };
        return s = [], e = r = n = o = '', t.split('').forEach(function(t) {
          if (!(0 === u && c.indexOf(t) > -1)) {
            switch(t) {
              case '"':
                a ? a === t && (a = null) : a = t;
                break;
              case '(':
                if (a) {
                  break;
                }
                if (0 === u) {
                  return u = 1, void(o += t);
                }
                h++;
                break;
              case ')':
                if (a) {
                  break;
                }
                if (1 === u) {
                  if (0 === h) {
                    return u = 0, o += t, void f();
                  }
                  h--;
                }
                break;
              case ',':
                if (a) {
                  break;
                }
                if (0 === u) {
                  return void f();
                }
                if (1 === u && 0 === h && !e.match(/^url$/i)) {
                  return s.push(n), n = '', void(o += t);
                }
            }
            o += t, 0 === u ? e += t : n += t;
          }
        }), f(), l;
      };
    }, {}], 27:[function(t, e, n) {
      function r(t) {
        i.apply(this, arguments), this.type = 'linear' === t.args[0] ? i.TYPES.LINEAR : i.TYPES.RADIAL;
      }
      var i = t('./gradientcontainer');
      r.prototype = Object.create(i.prototype), e.exports = r;
    }, {'./gradientcontainer':9}], 28:[function(t, e, n) {
      function r(t) {
        return new Promise(function(e, n) {
          var r = new XMLHttpRequest;
          r.open('GET', t), r.onload = function() {
            200 === r.status ? e(r.responseText) : n(new Error(r.statusText));
          }, r.onerror = function() {
            n(new Error('Network Error'));
          }, r.send();
        });
      }
      e.exports = r;
    }, {}]}, {}, [4])(4);
  }), function(t) {
    var e;
    e = function() {
      function e(t) {
        var e, n, r, i, o, a, s, c, l, u, h, f, d, p, g;
        for (this.data = t, this.pos = 8, this.palette = [], this.imgData = [], this.transparency = {}, this.animation = null, this.text = {}, a = null;;) {
          switch(e = this.readUInt32(), u = function() {
            var t, e;
            for (e = [], s = t = 0; t < 4; s = ++t) {
              e.push(String.fromCharCode(this.data[this.pos++]));
            }
            return e;
          }.call(this).join('')) {
            case 'IHDR':
              this.width = this.readUInt32(), this.height = this.readUInt32(), this.bits = this.data[this.pos++], this.colorType = this.data[this.pos++], this.compressionMethod = this.data[this.pos++], this.filterMethod = this.data[this.pos++], this.interlaceMethod = this.data[this.pos++];
              break;
            case 'acTL':
              this.animation = {numFrames:this.readUInt32(), numPlays:this.readUInt32() || 1 / 0, frames:[]};
              break;
            case 'PLTE':
              this.palette = this.read(e);
              break;
            case 'fcTL':
              a && this.animation.frames.push(a), this.pos += 4, a = {width:this.readUInt32(), height:this.readUInt32(), xOffset:this.readUInt32(), yOffset:this.readUInt32()}, o = this.readUInt16(), i = this.readUInt16() || 100, a.delay = 1000 * o / i, a.disposeOp = this.data[this.pos++], a.blendOp = this.data[this.pos++], a.data = [];
              break;
            case 'IDAT':
            case 'fdAT':
              for ('fdAT' === u && (this.pos += 4, e -= 4), t = (null != a ? a.data : void 0) || this.imgData, s = d = 0; 0 <= e ? d < e : d > e; s = 0 <= e ? ++d : --d) {
                t.push(this.data[this.pos++]);
              }
              break;
            case 'tRNS':
              switch(this.transparency = {}, this.colorType) {
                case 3:
                  if (r = this.palette.length / 3, this.transparency.indexed = this.read(e), this.transparency.indexed.length > r) {
                    throw new Error('More transparent colors than palette size');
                  }
                  if (h = r - this.transparency.indexed.length, h > 0) {
                    for (s = p = 0; 0 <= h ? p < h : p > h; s = 0 <= h ? ++p : --p) {
                      this.transparency.indexed.push(255);
                    }
                  }
                  break;
                case 0:
                  this.transparency.grayscale = this.read(e)[0];
                  break;
                case 2:
                  this.transparency.rgb = this.read(e);
              }break;
            case 'tEXt':
              f = this.read(e), c = f.indexOf(0), l = String.fromCharCode.apply(String, f.slice(0, c)), this.text[l] = String.fromCharCode.apply(String, f.slice(c + 1));
              break;
            case 'IEND':
              return a && this.animation.frames.push(a), this.colors = function() {
                switch(this.colorType) {
                  case 0:
                  case 3:
                  case 4:
                    return 1;
                  case 2:
                  case 6:
                    return 3;
                }
              }.call(this), this.hasAlphaChannel = 4 === (g = this.colorType) || 6 === g, n = this.colors + (this.hasAlphaChannel ? 1 : 0), this.pixelBitlength = this.bits * n, this.colorSpace = function() {
                switch(this.colors) {
                  case 1:
                    return 'DeviceGray';
                  case 3:
                    return 'DeviceRGB';
                }
              }.call(this), void(this.imgData = new Uint8Array(this.imgData));
            default:
              this.pos += e;
          }
          if (this.pos += 4, this.pos > this.data.length) {
            throw new Error('Incomplete or corrupt PNG file');
          }
        }
      }
      var n, r, i, o, a, s, l, u;
      e.load = function(t, n, r) {
        var i;
        return 'function' == typeof n && (r = n), i = new XMLHttpRequest, i.open('GET', t, !0), i.responseType = 'arraybuffer', i.onload = function() {
          var t, o;
          return t = new Uint8Array(i.response || i.mozResponseArrayBuffer), o = new e(t), 'function' == typeof(null != n ? n.getContext : void 0) && o.render(n), 'function' == typeof r ? r(o) : void 0;
        }, i.send(null);
      }, o = 0, i = 1, a = 2, r = 0, n = 1, e.prototype.read = function(t) {
        var e, n, r;
        for (r = [], e = n = 0; 0 <= t ? n < t : n > t; e = 0 <= t ? ++n : --n) {
          r.push(this.data[this.pos++]);
        }
        return r;
      }, e.prototype.readUInt32 = function() {
        var t, e, n, r;
        return t = this.data[this.pos++] << 24, e = this.data[this.pos++] << 16, n = this.data[this.pos++] << 8, r = this.data[this.pos++], t | e | n | r;
      }, e.prototype.readUInt16 = function() {
        var t, e;
        return t = this.data[this.pos++] << 8, e = this.data[this.pos++], t | e;
      }, e.prototype.decodePixels = function(t) {
        var e, n, r, i, o, a, s, l, u, h, f, d, p, g, m, w, y, v, b, x, k, _, C;
        if (null == t && (t = this.imgData), 0 === t.length) {
          return new Uint8Array(0);
        }
        for (t = new c(t), t = t.getBytes(), d = this.pixelBitlength / 8, w = d * this.width, p = new Uint8Array(w * this.height), a = t.length, m = 0, g = 0, n = 0; g < a;) {
          switch(t[g++]) {
            case 0:
              for (i = b = 0; b < w; i = b += 1) {
                p[n++] = t[g++];
              }
              break;
            case 1:
              for (i = x = 0; x < w; i = x += 1) {
                e = t[g++], o = i < d ? 0 : p[n - d], p[n++] = (e + o) % 256;
              }
              break;
            case 2:
              for (i = k = 0; k < w; i = k += 1) {
                e = t[g++], r = (i - i % d) / d, y = m && p[(m - 1) * w + r * d + i % d], p[n++] = (y + e) % 256;
              }
              break;
            case 3:
              for (i = _ = 0; _ < w; i = _ += 1) {
                e = t[g++], r = (i - i % d) / d, o = i < d ? 0 : p[n - d], y = m && p[(m - 1) * w + r * d + i % d], p[n++] = (e + Math.floor((o + y) / 2)) % 256;
              }
              break;
            case 4:
              for (i = C = 0; C < w; i = C += 1) {
                e = t[g++], r = (i - i % d) / d, o = i < d ? 0 : p[n - d], 0 === m ? y = v = 0 : (y = p[(m - 1) * w + r * d + i % d], v = r && p[(m - 1) * w + (r - 1) * d + i % d]), s = o + y - v, l = Math.abs(s - o), h = Math.abs(s - y), f = Math.abs(s - v), u = l <= h && l <= f ? o : h <= f ? y : v, p[n++] = (e + u) % 256;
              }
              break;
            default:
              throw new Error('Invalid filter algorithm: ' + t[g - 1]);
          }
          m++;
        }
        return p;
      }, e.prototype.decodePalette = function() {
        var t, e, n, r, i, o, a, s, c, l;
        for (r = this.palette, a = this.transparency.indexed || [], o = new Uint8Array((a.length || 0) + r.length), i = 0, n = r.length, t = 0, e = s = 0, c = r.length; s < c; e = s += 3) {
          o[i++] = r[e], o[i++] = r[e + 1], o[i++] = r[e + 2], o[i++] = null != (l = a[t++]) ? l : 255;
        }
        return o;
      }, e.prototype.copyToImageData = function(t, e) {
        var n, r, i, o, a, s, c, l, u, h, f;
        if (r = this.colors, u = null, n = this.hasAlphaChannel, this.palette.length && (u = null != (f = this._decodedPalette) ? f : this._decodedPalette = this.decodePalette(), r = 4, n = !0), i = t.data || t, l = i.length, a = u || e, o = s = 0, 1 === r) {
          for (; o < l;) {
            c = u ? 4 * e[o / 4] : s, h = a[c++], i[o++] = h, i[o++] = h, i[o++] = h, i[o++] = n ? a[c++] : 255, s = c;
          }
        } else {
          for (; o < l;) {
            c = u ? 4 * e[o / 4] : s, i[o++] = a[c++], i[o++] = a[c++], i[o++] = a[c++], i[o++] = n ? a[c++] : 255, s = c;
          }
        }
      }, e.prototype.decode = function() {
        var t;
        return t = new Uint8Array(this.width * this.height * 4), this.copyToImageData(t, this.decodePixels()), t;
      };
      try {
        l = t.document.createElement('canvas'), u = l.getContext('2d');
      } catch (t$51) {
        return -1;
      }
      return s = function(t) {
        var e;
        return u.width = t.width, u.height = t.height, u.clearRect(0, 0, t.width, t.height), u.putImageData(t, 0, 0), e = new Image, e.src = l.toDataURL(), e;
      }, e.prototype.decodeFrames = function(t) {
        var e, n, r, i, o, a, c, l;
        if (this.animation) {
          for (c = this.animation.frames, l = [], n = o = 0, a = c.length; o < a; n = ++o) {
            e = c[n], r = t.createImageData(e.width, e.height), i = this.decodePixels(new Uint8Array(e.data)), this.copyToImageData(r, i), e.imageData = r, l.push(e.image = s(r));
          }
          return l;
        }
      }, e.prototype.renderFrame = function(t, e) {
        var n, o, s;
        return o = this.animation.frames, n = o[e], s = o[e - 1], 0 === e && t.clearRect(0, 0, this.width, this.height), (null != s ? s.disposeOp : void 0) === i ? t.clearRect(s.xOffset, s.yOffset, s.width, s.height) : (null != s ? s.disposeOp : void 0) === a && t.putImageData(s.imageData, s.xOffset, s.yOffset), n.blendOp === r && t.clearRect(n.xOffset, n.yOffset, n.width, n.height), t.drawImage(n.image, n.xOffset, n.yOffset);
      }, e.prototype.animate = function(t) {
        var e, n, r, i, o, a, s = this;
        return n = 0, a = this.animation, i = a.numFrames, r = a.frames, o = a.numPlays, (e = function() {
          var a, c;
          if (a = n++ % i, c = r[a], s.renderFrame(t, a), i > 1 && n / i < o) {
            return s.animation._timeout = setTimeout(e, c.delay);
          }
        })();
      }, e.prototype.stopAnimation = function() {
        var t;
        return clearTimeout(null != (t = this.animation) ? t._timeout : void 0);
      }, e.prototype.render = function(t) {
        var e, n;
        return t._png && t._png.stopAnimation(), t._png = this, t.width = this.width, t.height = this.height, e = t.getContext('2d'), this.animation ? (this.decodeFrames(e), this.animate(e)) : (n = e.createImageData(this.width, this.height), this.copyToImageData(n, this.decodePixels()), e.putImageData(n, 0, 0));
      }, e;
    }(), t.PNG = e;
  }('undefined' != typeof window && window || void 0);
  var s = function() {
    function t() {
      this.pos = 0, this.bufferLength = 0, this.eof = !1, this.buffer = null;
    }
    return t.prototype = {ensureBuffer:function(t) {
      var e = this.buffer, n = e ? e.byteLength : 0;
      if (t < n) {
        return e;
      }
      for (var r = 512; r < t;) {
        r <<= 1;
      }
      for (var i = new Uint8Array(r), o = 0; o < n; ++o) {
        i[o] = e[o];
      }
      return this.buffer = i;
    }, getByte:function() {
      for (var t = this.pos; this.bufferLength <= t;) {
        if (this.eof) {
          return null;
        }
        this.readBlock();
      }
      return this.buffer[this.pos++];
    }, getBytes:function(t) {
      var e = this.pos;
      if (t) {
        this.ensureBuffer(e + t);
        for (var n = e + t; !this.eof && this.bufferLength < n;) {
          this.readBlock();
        }
        var r = this.bufferLength;
        n > r && (n = r);
      } else {
        for (; !this.eof;) {
          this.readBlock();
        }
        var n = this.bufferLength;
      }
      return this.pos = n, this.buffer.subarray(e, n);
    }, lookChar:function() {
      for (var t = this.pos; this.bufferLength <= t;) {
        if (this.eof) {
          return null;
        }
        this.readBlock();
      }
      return String.fromCharCode(this.buffer[this.pos]);
    }, getChar:function() {
      for (var t = this.pos; this.bufferLength <= t;) {
        if (this.eof) {
          return null;
        }
        this.readBlock();
      }
      return String.fromCharCode(this.buffer[this.pos++]);
    }, makeSubStream:function(t, e, n) {
      for (var r = t + e; this.bufferLength <= r && !this.eof;) {
        this.readBlock();
      }
      return new Stream(this.buffer, t, e, n);
    }, skip:function(t) {
      t || (t = 1), this.pos += t;
    }, reset:function() {
      this.pos = 0;
    }}, t;
  }(), c = function() {
    function t(t) {
      throw new Error(t);
    }
    function e(e) {
      var n = 0, r = e[n++], i = e[n++];
      r != -1 && i != -1 || t('Invalid header in flate stream'), 8 != (15 & r) && t('Unknown compression method in flate stream'), ((r << 8) + i) % 31 != 0 && t('Bad FCHECK in flate stream'), 32 & i && t('FDICT bit set in flate stream'), this.bytes = e, this.bytesPos = n, this.codeSize = 0, this.codeBuf = 0, s.call(this);
    }
    if ('undefined' != typeof Uint32Array) {
      var n = new Uint32Array([16, 17, 18, 0, 8, 7, 9, 6, 10, 5, 11, 4, 12, 3, 13, 2, 14, 1, 15]), r = new Uint32Array([3, 4, 5, 6, 7, 8, 9, 10, 65547, 65549, 65551, 65553, 131091, 131095, 131099, 131103, 196643, 196651, 196659, 196667, 262211, 262227, 262243, 262259, 327811, 327843, 327875, 327907, 258, 258, 258]), i = new Uint32Array([1, 2, 3, 4, 65541, 65543, 131081, 131085, 196625, 196633, 262177, 262193, 327745, 327777, 393345, 393409, 459009, 459137, 524801, 525057, 590849, 591361, 657409, 
      658433, 724993, 727041, 794625, 798721, 868353, 876545]), o = [new Uint32Array([459008, 524368, 524304, 524568, 459024, 524400, 524336, 590016, 459016, 524384, 524320, 589984, 524288, 524416, 524352, 590048, 459012, 524376, 524312, 589968, 459028, 524408, 524344, 590032, 459020, 524392, 524328, 590000, 524296, 524424, 524360, 590064, 459010, 524372, 524308, 524572, 459026, 524404, 524340, 590024, 459018, 524388, 524324, 589992, 524292, 524420, 524356, 590056, 459014, 524380, 524316, 589976, 
      459030, 524412, 524348, 590040, 459022, 524396, 524332, 590008, 524300, 524428, 524364, 590072, 459009, 524370, 524306, 524570, 459025, 524402, 524338, 590020, 459017, 524386, 524322, 589988, 524290, 524418, 524354, 590052, 459013, 524378, 524314, 589972, 459029, 524410, 524346, 590036, 459021, 524394, 524330, 590004, 524298, 524426, 524362, 590068, 459011, 524374, 524310, 524574, 459027, 524406, 524342, 590028, 459019, 524390, 524326, 589996, 524294, 524422, 524358, 590060, 459015, 524382, 
      524318, 589980, 459031, 524414, 524350, 590044, 459023, 524398, 524334, 590012, 524302, 524430, 524366, 590076, 459008, 524369, 524305, 524569, 459024, 524401, 524337, 590018, 459016, 524385, 524321, 589986, 524289, 524417, 524353, 590050, 459012, 524377, 524313, 589970, 459028, 524409, 524345, 590034, 459020, 524393, 524329, 590002, 524297, 524425, 524361, 590066, 459010, 524373, 524309, 524573, 459026, 524405, 524341, 590026, 459018, 524389, 524325, 589994, 524293, 524421, 524357, 590058, 
      459014, 524381, 524317, 589978, 459030, 524413, 524349, 590042, 459022, 524397, 524333, 590010, 524301, 524429, 524365, 590074, 459009, 524371, 524307, 524571, 459025, 524403, 524339, 590022, 459017, 524387, 524323, 589990, 524291, 524419, 524355, 590054, 459013, 524379, 524315, 589974, 459029, 524411, 524347, 590038, 459021, 524395, 524331, 590006, 524299, 524427, 524363, 590070, 459011, 524375, 524311, 524575, 459027, 524407, 524343, 590030, 459019, 524391, 524327, 589998, 524295, 524423, 
      524359, 590062, 459015, 524383, 524319, 589982, 459031, 524415, 524351, 590046, 459023, 524399, 524335, 590014, 524303, 524431, 524367, 590078, 459008, 524368, 524304, 524568, 459024, 524400, 524336, 590017, 459016, 524384, 524320, 589985, 524288, 524416, 524352, 590049, 459012, 524376, 524312, 589969, 459028, 524408, 524344, 590033, 459020, 524392, 524328, 590001, 524296, 524424, 524360, 590065, 459010, 524372, 524308, 524572, 459026, 524404, 524340, 590025, 459018, 524388, 524324, 589993, 
      524292, 524420, 524356, 590057, 459014, 524380, 524316, 589977, 459030, 524412, 524348, 590041, 459022, 524396, 524332, 590009, 524300, 524428, 524364, 590073, 459009, 524370, 524306, 524570, 459025, 524402, 524338, 590021, 459017, 524386, 524322, 589989, 524290, 524418, 524354, 590053, 459013, 524378, 524314, 589973, 459029, 524410, 524346, 590037, 459021, 524394, 524330, 590005, 524298, 524426, 524362, 590069, 459011, 524374, 524310, 524574, 459027, 524406, 524342, 590029, 459019, 524390, 
      524326, 589997, 524294, 524422, 524358, 590061, 459015, 524382, 524318, 589981, 459031, 524414, 524350, 590045, 459023, 524398, 524334, 590013, 524302, 524430, 524366, 590077, 459008, 524369, 524305, 524569, 459024, 524401, 524337, 590019, 459016, 524385, 524321, 589987, 524289, 524417, 524353, 590051, 459012, 524377, 524313, 589971, 459028, 524409, 524345, 590035, 459020, 524393, 524329, 590003, 524297, 524425, 524361, 590067, 459010, 524373, 524309, 524573, 459026, 524405, 524341, 590027, 
      459018, 524389, 524325, 589995, 524293, 524421, 524357, 590059, 459014, 524381, 524317, 589979, 459030, 524413, 524349, 590043, 459022, 524397, 524333, 590011, 524301, 524429, 524365, 590075, 459009, 524371, 524307, 524571, 459025, 524403, 524339, 590023, 459017, 524387, 524323, 589991, 524291, 524419, 524355, 590055, 459013, 524379, 524315, 589975, 459029, 524411, 524347, 590039, 459021, 524395, 524331, 590007, 524299, 524427, 524363, 590071, 459011, 524375, 524311, 524575, 459027, 524407, 
      524343, 590031, 459019, 524391, 524327, 589999, 524295, 524423, 524359, 590063, 459015, 524383, 524319, 589983, 459031, 524415, 524351, 590047, 459023, 524399, 524335, 590015, 524303, 524431, 524367, 590079]), 9], a = [new Uint32Array([327680, 327696, 327688, 327704, 327684, 327700, 327692, 327708, 327682, 327698, 327690, 327706, 327686, 327702, 327694, 0, 327681, 327697, 327689, 327705, 327685, 327701, 327693, 327709, 327683, 327699, 327691, 327707, 327687, 327703, 327695, 0]), 5];
      return e.prototype = Object.create(s.prototype), e.prototype.getBits = function(e) {
        for (var n, r = this.codeSize, i = this.codeBuf, o = this.bytes, a = this.bytesPos; r < e;) {
          'undefined' == typeof(n = o[a++]) && t('Bad encoding in flate stream'), i |= n << r, r += 8;
        }
        return n = i & (1 << e) - 1, this.codeBuf = i >> e, this.codeSize = r -= e, this.bytesPos = a, n;
      }, e.prototype.getCode = function(e) {
        for (var n = e[0], r = e[1], i = this.codeSize, o = this.codeBuf, a = this.bytes, s = this.bytesPos; i < r;) {
          var c;
          'undefined' == typeof(c = a[s++]) && t('Bad encoding in flate stream'), o |= c << i, i += 8;
        }
        var l = n[o & (1 << r) - 1], u = l >> 16, h = 65535 & l;
        return (0 == i || i < u || 0 == u) && t('Bad encoding in flate stream'), this.codeBuf = o >> u, this.codeSize = i - u, this.bytesPos = s, h;
      }, e.prototype.generateHuffmanTable = function(t) {
        for (var e = t.length, n = 0, r = 0; r < e; ++r) {
          t[r] > n && (n = t[r]);
        }
        for (var i = 1 << n, o = new Uint32Array(i), a = 1, s = 0, c = 2; a <= n; ++a, s <<= 1, c <<= 1) {
          for (var l = 0; l < e; ++l) {
            if (t[l] == a) {
              for (var u = 0, h = s, r = 0; r < a; ++r) {
                u = u << 1 | 1 & h, h >>= 1;
              }
              for (var r = u; r < i; r += c) {
                o[r] = a << 16 | l;
              }
              ++s;
            }
          }
        }
        return [o, n];
      }, e.prototype.readBlock = function() {
        function e(t, e, n, r, i) {
          for (var o = t.getBits(n) + r; o-- > 0;) {
            e[_++] = i;
          }
        }
        var s = this.getBits(3);
        if (1 & s && (this.eof = !0), s >>= 1, 0 == s) {
          var c, l = this.bytes, u = this.bytesPos;
          'undefined' == typeof(c = l[u++]) && t('Bad block header in flate stream');
          var h = c;
          'undefined' == typeof(c = l[u++]) && t('Bad block header in flate stream'), h |= c << 8, 'undefined' == typeof(c = l[u++]) && t('Bad block header in flate stream');
          var f = c;
          'undefined' == typeof(c = l[u++]) && t('Bad block header in flate stream'), f |= c << 8, f != (65535 & ~h) && t('Bad uncompressed block length in flate stream'), this.codeBuf = 0, this.codeSize = 0;
          var d = this.bufferLength, p = this.ensureBuffer(d + h), g = d + h;
          this.bufferLength = g;
          for (var m = d; m < g; ++m) {
            if ('undefined' == typeof(c = l[u++])) {
              this.eof = !0;
              break;
            }
            p[m] = c;
          }
          return void(this.bytesPos = u);
        }
        var w, y;
        if (1 == s) {
          w = o, y = a;
        } else {
          if (2 == s) {
            for (var v = this.getBits(5) + 257, b = this.getBits(5) + 1, x = this.getBits(4) + 4, k = Array(n.length), _ = 0; _ < x;) {
              k[n[_++]] = this.getBits(3);
            }
            for (var C = this.generateHuffmanTable(k), A = 0, _ = 0, S = v + b, q = new Array(S); _ < S;) {
              var T = this.getCode(C);
              16 == T ? e(this, q, 2, 3, A) : 17 == T ? e(this, q, 3, 3, A = 0) : 18 == T ? e(this, q, 7, 11, A = 0) : q[_++] = A = T;
            }
            w = this.generateHuffmanTable(q.slice(0, v)), y = this.generateHuffmanTable(q.slice(v, S));
          } else {
            t('Unknown block type in flate stream');
          }
        }
        for (var p = this.buffer, P = p ? p.length : 0, I = this.bufferLength;;) {
          var E = this.getCode(w);
          if (E < 256) {
            I + 1 >= P && (p = this.ensureBuffer(I + 1), P = p.length), p[I++] = E;
          } else {
            if (256 == E) {
              return void(this.bufferLength = I);
            }
            E -= 257, E = r[E];
            var O = E >> 16;
            O > 0 && (O = this.getBits(O));
            var A = (65535 & E) + O;
            E = this.getCode(y), E = i[E], O = E >> 16, O > 0 && (O = this.getBits(O));
            var F = (65535 & E) + O;
            I + A >= P && (p = this.ensureBuffer(I + A), P = p.length);
            for (var R = 0; R < A; ++R, ++I) {
              p[I] = p[I - F];
            }
          }
        }
      }, e;
    }
  }();
  return function(t) {
    var e = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\x3d';
    'undefined' == typeof t.btoa && (t.btoa = function(t) {
      var n, r, i, o, a, s, c, l, u = 0, h = 0, f = '', d = [];
      if (!t) {
        return t;
      }
      do {
        n = t.charCodeAt(u++), r = t.charCodeAt(u++), i = t.charCodeAt(u++), l = n << 16 | r << 8 | i, o = l >> 18 & 63, a = l >> 12 & 63, s = l >> 6 & 63, c = 63 & l, d[h++] = e.charAt(o) + e.charAt(a) + e.charAt(s) + e.charAt(c);
      } while (u < t.length);
      f = d.join('');
      var p = t.length % 3;
      return (p ? f.slice(0, p - 3) : f) + '\x3d\x3d\x3d'.slice(p || 3);
    }), 'undefined' == typeof t.atob && (t.atob = function(t) {
      var n, r, i, o, a, s, c, l, u = 0, h = 0, f = '', d = [];
      if (!t) {
        return t;
      }
      t += '';
      do {
        o = e.indexOf(t.charAt(u++)), a = e.indexOf(t.charAt(u++)), s = e.indexOf(t.charAt(u++)), c = e.indexOf(t.charAt(u++)), l = o << 18 | a << 12 | s << 6 | c, n = l >> 16 & 255, r = l >> 8 & 255, i = 255 & l, 64 == s ? d[h++] = String.fromCharCode(n) : 64 == c ? d[h++] = String.fromCharCode(n, r) : d[h++] = String.fromCharCode(n, r, i);
      } while (u < t.length);
      return f = d.join('');
    }), Array.prototype.map || (Array.prototype.map = function(t) {
      if (void 0 === this || null === this || 'function' != typeof t) {
        throw new TypeError;
      }
      for (var e = Object(this), n = e.length >>> 0, r = new Array(n), i = arguments.length > 1 ? arguments[1] : void 0, o = 0; o < n; o++) {
        o in e && (r[o] = t.call(i, e[o], o, e));
      }
      return r;
    }), Array.isArray || (Array.isArray = function(t) {
      return '[object Array]' === Object.prototype.toString.call(t);
    }), Array.prototype.forEach || (Array.prototype.forEach = function(t, e) {
      if (void 0 === this || null === this || 'function' != typeof t) {
        throw new TypeError;
      }
      for (var n = Object(this), r = n.length >>> 0, i = 0; i < r; i++) {
        i in n && t.call(e, n[i], i, n);
      }
    }), Object.keys || (Object.keys = function() {
      var t = Object.prototype.hasOwnProperty, e = !{toString:null}.propertyIsEnumerable('toString'), n = ['toString', 'toLocaleString', 'valueOf', 'hasOwnProperty', 'isPrototypeOf', 'propertyIsEnumerable', 'constructor'], r = n.length;
      return function(i) {
        if ('object' != typeof i && ('function' != typeof i || null === i)) {
          throw new TypeError;
        }
        var o, a, s = [];
        for (o in i) {
          t.call(i, o) && s.push(o);
        }
        if (e) {
          for (a = 0; a < r; a++) {
            t.call(i, n[a]) && s.push(n[a]);
          }
        }
        return s;
      };
    }()), String.prototype.trim || (String.prototype.trim = function() {
      return this.replace(/^\s+|\s+$/g, '');
    }), String.prototype.trimLeft || (String.prototype.trimLeft = function() {
      return this.replace(/^\s+/g, '');
    }), String.prototype.trimRight || (String.prototype.trimRight = function() {
      return this.replace(/\s+$/g, '');
    });
  }('undefined' != typeof self && self || 'undefined' != typeof window && window || void 0), e;
});
Ext.Loader.setConfig({});
Ext.application({models:['model_gestion_cliente', 'model_gestion_producto', 'model_gestion_empresa', 'model_gestion_factura', 'model_facturas', 'model_info_count', 'model_gestion_usuarios'], stores:['store_gestion_cliente', 'store_gestion_producto', 'store_gestion_factura', 'store_gestion_empresa', 'store_gestion_all_factura', 'store_factura_productos', 'store_gestion_all_producto_factura', 'store_gestion_producto_factura', 'store_info_count', 'store_gestion_usuarios'], views:['vtn_generar_producto', 
'tbp_menu', 'vtn_generar_cliente', 'vtn_generar_empresa', 'grd_client', 'grd_company', 'grd_invoice', 'ctn_invoice_view', 'ctn_product_view', 'ctn_client_view', 'ctn_company_view', 'ctn_statistics_view', 'vtn_generar_factura', 'vtn_seleccionar_detalle_factura', 'ctn_account', 'ctn_user_view', 'grd_user', 'vtn_generar_usuario'], name:'facturaElecWeb', init:function() {
  window.filtro = 0;
  window.oldFactura = [];
}, launch:function() {
  Ext.create('facturaElecWeb.view.tbp_menu', {fullscreen:true});
}});
"use strict";

var _get = function get(object, property, receiver) { if (object === null) object = Function.prototype; var desc = Object.getOwnPropertyDescriptor(object, property); if (desc === undefined) { var parent = Object.getPrototypeOf(object); if (parent === null) { return undefined; } else { return get(parent, property, receiver); } } else if ("value" in desc) { return desc.value; } else { var getter = desc.get; if (getter === undefined) { return undefined; } return getter.call(receiver); } };

var _createClass = function () { function defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } } return function (Constructor, protoProps, staticProps) { if (protoProps) defineProperties(Constructor.prototype, protoProps); if (staticProps) defineProperties(Constructor, staticProps); return Constructor; }; }();

var _typeof = typeof Symbol === "function" && typeof Symbol.iterator === "symbol" ? function (obj) { return typeof obj; } : function (obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; };

function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

(function (f) {
    if ((typeof exports === "undefined" ? "undefined" : _typeof(exports)) === "object" && typeof module !== "undefined") {
        module.exports = f();
    } else if (typeof define === "function" && define.amd) {
        define([], f);
    } else {
        var g;if (typeof window !== "undefined") {
            g = window;
        } else if (typeof global !== "undefined") {
            g = global;
        } else if (typeof self !== "undefined") {
            g = self;
        } else {
            g = this;
        }g.Fashion = f();
    }
})(function () {
    var define, module, exports;return function () {
        function r(e, n, t) {
            function o(i, f) {
                if (!n[i]) {
                    if (!e[i]) {
                        var c = "function" == typeof require && require;if (!f && c) return c(i, !0);if (u) return u(i, !0);var a = new Error("Cannot find module '" + i + "'");throw a.code = "MODULE_NOT_FOUND", a;
                    }var p = n[i] = { exports: {} };e[i][0].call(p.exports, function (r) {
                        var n = e[i][1][r];return o(n || r);
                    }, p, p.exports, r, e, n, t);
                }return n[i].exports;
            }for (var u = "function" == typeof require && require, i = 0; i < t.length; i++) {
                o(t[i]);
            }return o;
        }return r;
    }()({ 1: [function (require, module, exports) {
            var _Fashion$apply;

            var Fashion = require('./src/export/Base.js');
            var CssVariableManager = require('./src/export/css/CssVariableManager.js'),
                css = new CssVariableManager();

            Fashion.apply(Fashion, (_Fashion$apply = {
                css: css,
                CssExport: CssVariableManager,
                Types: require('./src/export/type/Types.js'),
                ValueParser: require('./src/export/parse/ValueParser.js'),
                Type: require('./src/export/type/Type.js'),
                Bool: require('./src/export/type/Bool.js'),
                Literal: require('./src/export/type/Literal.js'),
                ParentheticalExpression: require('./src/export/type/ParentheticalExpression.js'),
                Text: require('./src/export/type/Text.js'),
                Numeric: require('./src/export/type/Numeric.js'),
                List: require('./src/export/type/List.js'),
                Map: require('./src/export/type/Map.js'),
                Color: require('./src/export/type/Color.js'),
                ColorRGBA: require('./src/export/type/ColorRGBA.js'),
                ColorHSLA: require('./src/export/type/ColorHSLA.js'),
                ColorStop: require('./src/export/type/ColorStop.js'),
                FunctionCall: require('./src/export/type/FunctionCall.js'),
                LinearGradient: require('./src/export/type/LinearGradient.js'),
                RadialGradient: require('./src/export/type/RadialGradient.js'),
                Statics: require('./src/export/type/Statics.js'),
                SourceBuilder: require('./src/export/type/SourceBuilder.js')
            }, _defineProperty(_Fashion$apply, "Types", require('./src/export/type/Types.js')), _defineProperty(_Fashion$apply, "TypeVisitor", require('./src/export/type/TypeVisitor.js')), _defineProperty(_Fashion$apply, "Output", require('./src/export/Output.js')), _defineProperty(_Fashion$apply, "Runtime", require('./src/export/Runtime.js')), _Fashion$apply));

            module.exports = Fashion;
        }, { "./src/export/Base.js": 3, "./src/export/Output.js": 4, "./src/export/Runtime.js": 5, "./src/export/css/CssVariableManager.js": 6, "./src/export/parse/ValueParser.js": 7, "./src/export/type/Bool.js": 8, "./src/export/type/Color.js": 9, "./src/export/type/ColorHSLA.js": 10, "./src/export/type/ColorRGBA.js": 11, "./src/export/type/ColorStop.js": 12, "./src/export/type/FunctionCall.js": 13, "./src/export/type/LinearGradient.js": 14, "./src/export/type/List.js": 15, "./src/export/type/Literal.js": 16, "./src/export/type/Map.js": 17, "./src/export/type/Numeric.js": 18, "./src/export/type/ParentheticalExpression.js": 19, "./src/export/type/RadialGradient.js": 20, "./src/export/type/SourceBuilder.js": 21, "./src/export/type/Statics.js": 22, "./src/export/type/Text.js": 23, "./src/export/type/Type.js": 24, "./src/export/type/TypeVisitor.js": 25, "./src/export/type/Types.js": 26 }], 2: [function (require, module, exports) {
            "use strict";

            function getJsName(name) {
                return name.replace(/\-/g, '_').replace(/\//g, '_fs_').replace(/\\/g, '_bs_');
            }

            var NameConverter = function () {
                function NameConverter() {
                    _classCallCheck(this, NameConverter);

                    this.variableNameMap = {};
                }

                _createClass(NameConverter, [{
                    key: "convertName",
                    value: function convertName(name) {
                        var map = this.variableNameMap,
                            converted = map[name];

                        if (converted === undefined) {
                            converted = map[name] = getJsName(name);
                        }
                        return converted;
                    }
                }]);

                return NameConverter;
            }();

            var converter = new NameConverter();

            module.exports = {
                NameConverter: NameConverter,
                getJsName: function getJsName(name) {
                    return converter.convertName(name);
                }
            };
        }, {}], 3: [function (require, module, exports) {
            /*
             * Copyright (c) 2012-2016. Sencha Inc.
             */

            "use strict";

            var NameConverter = require('./../NameConverter.js');

            var debugging = {
                trace: false
            };

            var Base = function Base(config) {
                _classCallCheck(this, Base);

                if (config) {
                    merge(this, config);
                }
            };

            var BaseSet = function () {
                function BaseSet() {
                    _classCallCheck(this, BaseSet);
                }

                _createClass(BaseSet, [{
                    key: "first",
                    value: function first() {
                        return _first(this.items);
                    }
                }, {
                    key: "last",
                    value: function last() {
                        return _last(this.items);
                    }
                }, {
                    key: "tail",
                    value: function tail() {
                        return _tail(this.items);
                    }
                }]);

                return BaseSet;
            }();

            BaseSet.prototype.items = null;

            function _chainFunc() {}

            function apply(target, source) {
                target = target || {};

                if (source) {
                    for (var name in source) {
                        target[name] = source[name];
                    }
                }

                return target;
            }

            function merge(destination, object) {
                destination = destination || {};
                var key, value, sourceKey;

                if (object) {
                    for (key in object) {
                        value = object[key];
                        if (value && value.constructor === Object) {
                            sourceKey = destination[key];
                            if (sourceKey && sourceKey.constructor === Object) {
                                merge(sourceKey, value);
                            } else {
                                destination[key] = value;
                            }
                        } else {
                            destination[key] = value;
                        }
                    }
                }

                return destination;
            }

            var chain = Object.create || function (Parent) {
                _chainFunc.prototype = Parent;
                return new _chainFunc();
            };

            function createMessage(message, source) {
                if (source && source.isFashionScanner) {
                    message += ': ' + source.currentFile + ':' + source.lineNumber;
                } else if (source) {
                    message += ': ' + source.file + ':' + source.lineNumber;
                }

                return message;
            }

            function isFunction(obj) {
                return obj && typeof obj === 'function';
            }

            function trace(message, source) {
                if (debugging.trace) {
                    console.log(createMessage('[DBG] ' + message, source));
                }
            }

            function debug(message, source) {
                console.log(createMessage('[DBG] ' + message, source));
            }

            function log(message, source) {
                console.log(createMessage('[LOG] ' + message, source));
            }

            function info(message, source) {
                console.log(createMessage('[INF] ' + message, source));
            }

            function warn(message, source) {
                console.log(createMessage('[WRN] ' + message, source));
            }

            function error(message, source) {
                console.log(createMessage('[ERR] ' + message, source));
            }

            function raise(message, extra) {
                if (Fashion.inspect) {
                    debugger;
                }

                if (typeof message !== 'string') {
                    extra = message;
                    message = extra.message;
                    delete extra.message;
                }

                var error = new Error(message);
                error.$isFashionError = true;
                throw apply(error, extra);
            }

            function raiseAt(message, source, stack) {
                var extra;

                if (source) {
                    message = createMessage(message, source);

                    if (source.isFashionScanner) {
                        extra = {
                            file: source.currentFile,
                            lineNumber: source.lineNumber
                        };
                    } else {
                        extra = {
                            node: source,
                            lineNumber: source.lineNumber,
                            file: source.file
                        };
                    }
                }

                if (stack) {
                    if (!extra) {
                        extra = {};
                    }
                    extra.fashionStack = stack;
                }

                raise(message, extra);
            }

            function filter(array, func) {
                var result = [];
                for (var i = 0; i < array.length; i++) {
                    var item = array[i];
                    if (func(item, i)) {
                        result.push(item);
                    }
                }
                return result;
            }

            function convert(array, func) {
                var converted = [];
                for (var i = 0; i < array.length; i++) {
                    converted.push(func(array[i]));
                }
                return converted;
            }

            function _first(array) {
                return array.length && array[0];
            }

            function _last(array) {
                return array.length && array[array.length - 1];
            }

            function _tail(array) {
                if (array.length > 2) {
                    return array.slice(1);
                }
                return [];
            }

            function getAllKeys(obj, stop) {
                var keys = [],
                    map = {},
                    i,
                    key,
                    n,
                    names;

                for (; obj && obj !== stop; obj = Object.getPrototypeOf(obj)) {
                    names = Object.getOwnPropertyNames(obj);

                    for (i = 0, n = names.length; i < n; ++i) {
                        key = names[i];

                        if (!map[key]) {
                            map[key] = true;
                            keys.push(key);
                        }
                    }
                }

                return keys;
            }

            function mixin(target, bases) {
                if (!Array.isArray(bases)) {
                    bases = Array.prototype.slice.call(arguments, 1);
                }

                var proto = target.prototype;

                for (var b = 0; b < bases.length; b++) {
                    var base = bases[b],
                        baseProto = base.prototype;

                    getAllKeys(baseProto, Base.prototype).forEach(function (name) {
                        if (name in baseProto) {
                            if (!(name in proto)) {
                                proto[name] = baseProto[name];
                            }
                        }
                    });
                }
            }

            function flatten(array, level, output) {
                output = output || [];
                level = typeof level === 'undefined' ? 1000 : level;

                for (var i = 0; i < array.length; i++) {
                    var item = array[i];
                    if (Array.isArray(item) && level) {
                        flatten(item, level - 1, output);
                    } else {
                        output.push(item);
                    }
                }
                return output;
            }

            module.exports = {
                EmptyArray: [],
                getJsName: NameConverter.getJsName,
                chain: chain,
                Base: Base,
                BaseSet: BaseSet,
                apply: apply,
                merge: merge,
                createMessage: createMessage,
                isFunction: isFunction,
                debugging: debugging,
                trace: trace,
                debug: debug,
                log: log,
                info: info,
                warn: warn,
                error: error,
                raise: raise,
                raiseAt: raiseAt,
                filter: filter,
                convert: convert,
                first: _first,
                last: _last,
                tail: _tail,
                mixin: mixin,
                flatten: flatten
            };
        }, { "./../NameConverter.js": 2 }], 4: [function (require, module, exports) {
            /*
             * Copyright (c) 2012-2016. Sencha Inc.
             */

            "use strict";

            var Fashion = require('./Base.js'),
                Base = Fashion.Base;

            var Output = function (_Base) {
                _inherits(Output, _Base);

                function Output() {
                    _classCallCheck(this, Output);

                    var _this = _possibleConstructorReturn(this, (Output.__proto__ || Object.getPrototypeOf(Output)).call(this));

                    _this.output = '';
                    return _this;
                }

                _createClass(Output, [{
                    key: "space",
                    value: function space() {
                        this.add(' ');
                    }
                }, {
                    key: "add",
                    value: function add(text) {
                        this.output += text;
                    }
                }, {
                    key: "addComment",
                    value: function addComment(text) {
                        this.output += text;
                    }
                }, {
                    key: "indent",
                    value: function indent() {
                        this.indentation += this.indentstr;
                    }
                }, {
                    key: "unindent",
                    value: function unindent() {
                        this.indentation = this.indentation.substr(this.indentstr.length);
                    }
                }, {
                    key: "addln",
                    value: function addln(ln) {
                        this.output += '\n' + this.indentation + (ln || '');
                    }
                }, {
                    key: "addCommentLn",
                    value: function addCommentLn(ln) {
                        if (ln && ln.indexOf('//') === 0) {
                            return;
                        }
                        this.addln(ln);
                    }
                }, {
                    key: "get",
                    value: function get() {
                        return this.output;
                    }
                }, {
                    key: "indentln",
                    value: function indentln(ln) {
                        this.addln(ln);
                        this.indent();
                    }
                }, {
                    key: "unindentln",
                    value: function unindentln(ln) {
                        this.unindent();
                        this.addln(ln);
                    }
                }, {
                    key: "reset",
                    value: function reset() {
                        this.indentation = '';
                        this.output = '';
                    }
                }]);

                return Output;
            }(Base);

            Fashion.apply(Output.prototype, {
                indentation: '',
                output: '',
                isCompressed: false,
                indentstr: '    ',
                splitThreshold: 1000000,
                selectorCount: 0
            });

            module.exports = Output;
        }, { "./Base.js": 3 }], 5: [function (require, module, exports) {
            "use strict";

            var Fashion = require('./Base.js'),
                Base = Fashion.Base;

            var Type = require('./type/Type.js');
            var List = require('./type/List.js');
            var Bool = require('./type/Bool.js');

            var Color = require('./type/Color.js');
            var ColorRGBA = require('./type/ColorRGBA.js');
            var Text = require('./type/Text.js');

            var Literal = require('./type/Literal.js');

            var Statics = require('./type/Statics.js');
            var TypeVisitor = require('./type/TypeVisitor.js');
            var Types = require('./type/Types.js');

            var Scope = function () {
                function Scope(prev) {
                    _classCallCheck(this, Scope);

                    this.prev = prev;
                    this.map = {};
                    this.sourceInfo = null;
                }

                _createClass(Scope, [{
                    key: "get",
                    value: function get(name) {
                        var map = this.map,
                            prev = this,
                            value;

                        while (map) {
                            value = map[name];
                            if (value) {
                                return value;
                            }
                            prev = prev.prev;
                            map = prev && prev.map;
                        }

                        return value;
                    }
                }, {
                    key: "has",
                    value: function has(name) {
                        //return name in this.map;
                        var map = this.map,
                            prev = this;

                        while (map) {
                            if (name in map) {
                                return true;
                            }
                            prev = prev.prev;
                            map = prev && prev.map;
                        }

                        return false;
                    }
                }, {
                    key: "put",
                    value: function put(name, value) {
                        this.map[name] = value;
                        return value;
                    }
                }, {
                    key: "addEntries",
                    value: function addEntries(names) {
                        if (this.prev) {
                            this.prev.addEntries(names);
                        }
                        for (var name in this.map) {
                            names[name] = this.map[name];
                        }
                    }
                }, {
                    key: "getEntries",
                    value: function getEntries(entries) {
                        entries = entries || {};
                        this.addEntries(entries);
                        return entries;
                    }
                }, {
                    key: "getSourceInfo",
                    value: function getSourceInfo() {
                        return this.sourceInfo;
                    }
                }, {
                    key: "getCallStack",
                    value: function getCallStack(stack) {
                        stack = stack || [];
                        if (this.sourceInfo) {
                            stack.push(this.sourceInfo);
                        }
                        if (this.prev) {
                            this.prev.getCallStack(stack);
                        }
                        return stack;
                    }
                }]);

                return Scope;
            }();

            Fashion.apply(Scope.prototype, {
                $isScope: true,
                map: undefined,
                prev: undefined,

                // placeholder used to track what to reset the _currentScope to,
                resetScope: undefined
            });

            var Runtime = function (_Base2) {
                _inherits(Runtime, _Base2);

                function Runtime(config) {
                    _classCallCheck(this, Runtime);

                    var _this2 = _possibleConstructorReturn(this, (Runtime.__proto__ || Object.getPrototypeOf(Runtime)).call(this, config));

                    var me = _this2;
                    me.mixins = {};
                    me.functions = {};
                    me.processors = [];
                    me.registered = {
                        runtime: me,
                        box: Statics.boxType,
                        unbox: Statics.unboxType,
                        isArray: function isArray(array) {
                            return Array.isArray(array);
                        },

                        getRuntime: function getRuntime() {
                            return this.runtime;
                        },

                        handleArgs: function handleArgs(args, keys) {
                            var scope = {},
                                index = 0,
                                key;

                            for (var a = 0; a < args.length; a++) {
                                var arg = args[a];
                                if (arg === undefined) {
                                    continue;
                                }

                                // Named arguments
                                if (arg === true || arg === false) {
                                    scope[keys[index]] = arg;
                                    index++;
                                } else if (arg.type === undefined) {
                                    for (key in arg) {
                                        scope[key.replace(/^\$/, '')] = arg[key];
                                    }
                                }
                                // Required arguments
                                else {
                                        key = keys[index];
                                        if (key instanceof Array) {
                                            key = key[0];
                                            scope[key] = scope[key] || new List();
                                            scope[key].add(arg);
                                        } else {
                                            scope[key] = arg;
                                            index++;
                                        }
                                    }
                            }
                            return scope;
                        },

                        sliceArgs: function sliceArgs(args, start, end) {
                            return this.getRuntime().sliceArgs(args, start, end).items;
                        },

                        tailArgs: function tailArgs(start, args) {
                            var tail = Array.prototype.slice.call(args, start);

                            if (tail.length == 1 && this.isArray(tail)) {
                                tail = tail[0];
                            }

                            return tail;
                        }
                    };
                    return _this2;
                }

                _createClass(Runtime, [{
                    key: "bool",
                    value: function bool(value) {
                        return new Bool(value);
                    }
                }, {
                    key: "color",
                    value: function color(name) {
                        var rgb = Color.map[name],
                            color = new ColorRGBA(rgb[0], rgb[1], rgb[2], rgb[3]);
                        color.stringified = name;
                        return color;
                    }
                }, {
                    key: "quote",
                    value: function quote(value) {
                        if (value.type === 'string') {
                            return value;
                        }

                        return new Text(value.toString());
                    }
                }, {
                    key: "unquote",
                    value: function unquote(value) {
                        if (value.$isFashionType) {
                            return value.unquote();
                        }
                        return new Literal(value.toString());
                    }
                }, {
                    key: "not",
                    value: function not(expression) {
                        return this.box(this.unbox(expression) == false);
                    }
                }, {
                    key: "operate",
                    value: function operate(operation, left, right) {
                        if (left == null || left.$isFashionNull) {
                            if (operation != '==' && operation != '!=') {
                                return Literal.Null;
                            }
                        }
                        if (right == null || right.$isFashionNull) {
                            if (operation != '==' && operation != '!=') {
                                return Literal.Null;
                            }
                        }
                        return left.operate(operation, right);
                    }
                }, {
                    key: "reset",
                    value: function reset() {
                        this._currentScope = null;
                        this._currentCallStackScope = this.createCallStackScope();
                        this._globalScope = this.createScope();
                        this._dynamics = {};
                    }
                }, {
                    key: "run",
                    value: function run(code, metadata) {
                        this.load(code);
                        this.compile(code);
                        return this.execute(metadata);
                    }
                }, {
                    key: "createTypesBlock",
                    value: function createTypesBlock(types) {
                        types = types || this.types;
                        var keys = Object.getOwnPropertyNames(types),
                            buff = [],
                            name;
                        for (var i = 0; i < keys.length; i++) {
                            name = keys[i];
                            buff.push(name + ' = Types.' + name);
                            buff.push("__" + name + ' = ' + name);
                        }

                        if (buff.length === 0) {
                            return '';
                        }
                        return 'var ' + buff.join(',\n    ') + ';\n';
                    }
                }, {
                    key: "createMethodBlock",
                    value: function createMethodBlock(proto) {
                        proto = proto || this.constructor.prototype;

                        var buff = [],
                            keys,
                            name;

                        while (proto) {
                            keys = Object.getOwnPropertyNames(proto);
                            for (var i = 0; i < keys.length; i++) {
                                name = keys[i];
                                if (typeof proto[name] === 'function') {
                                    buff.push("__rt_" + name + ' = __rt.' + name + '.bind(__rt)');
                                }
                            }
                            proto = Object.getPrototypeOf(proto);
                        }

                        if (buff.length === 0) {
                            return '';
                        }
                        return 'var ' + buff.join(',\n    ') + ';\n';
                    }
                }, {
                    key: "createPropertyBlock",
                    value: function createPropertyBlock() {
                        var keys = Object.getOwnPropertyNames(this),
                            buff = [],
                            name;
                        for (var i = 0; i < keys.length; i++) {
                            name = keys[i];
                            buff.push("__rt_" + name + ' = __rt.' + name);
                        }

                        if (buff.length === 0) {
                            return '';
                        }
                        return 'var ' + buff.join(',\n    ') + ';\n';
                    }
                }, {
                    key: "createPrefixedFunctionBody",
                    value: function createPrefixedFunctionBody(code) {
                        code = this.createTypesBlock() + this.createMethodBlock() + this.createPropertyBlock() + code;
                        return code;
                    }
                }, {
                    key: "createWrappedFn",
                    value: function createWrappedFn(code) {
                        return new Function('Types', '__rt', '__gs', '__udf', '__dyn', this.createPrefixedFunctionBody(code));
                    }
                }, {
                    key: "callWrappedFn",
                    value: function callWrappedFn(fn, dynamics) {
                        return fn(Fashion, this, this._globalScope, undefined, dynamics || {});
                    }
                }, {
                    key: "compile",
                    value: function compile(code) {
                        var me = this,
                            theFn;

                        //code = '"use strict";\n' + code;
                        this.code = code;

                        new Function();

                        theFn = this.createWrappedFn(code);

                        this.fn = function (rt, overrides, dyn) {
                            var runtime = rt || me,
                                dynamics = dyn || {};

                            runtime.reset();

                            if (overrides) {
                                if (overrides.$isScope) {
                                    runtime._globalScope = overrides;
                                } else {
                                    runtime._globalScope.map = overrides;
                                }
                            }

                            if (dyn) {
                                runtime._dynamics = dyn;
                            }
                            runtime._currentScope = runtime._globalScope;
                            runtime._scopeStack = [runtime._currentScope];
                            try {
                                theFn(me.types, runtime, runtime._globalScope, undefined, dynamics);
                            } catch (err) {
                                Fashion.raiseAt(err.message || err, null, runtime.getCallStack());
                            }

                            return runtime._globalScope;
                        };

                        return this.fn;
                    }
                }, {
                    key: "execute",
                    value: function execute(metadata) {
                        return this.fn(this, metadata);
                    }
                }, {
                    key: "load",
                    value: function load(code) {
                        this.code = code;
                        return this;
                    }
                }, {
                    key: "registerProcessor",
                    value: function registerProcessor(proc) {
                        this.processors.push(new TypeVisitor(proc));
                    }
                }, {
                    key: "register",
                    value: function register(methods) {
                        if (methods['dynamic']) {
                            Fashion.error('Cannot register javascript function named "dynamic"');
                            delete methods['dynamic'];
                        }
                        if (methods['require']) {
                            Fashion.error('Cannot register javascript function named "require"');
                            delete methods['require'];
                        }
                        Fashion.apply(this.registered, methods);
                    }
                }, {
                    key: "isRegistered",
                    value: function isRegistered(name) {
                        name = this.reserved[name] ? '__' + name : name;
                        return !!this.registered[name];
                    }
                }, {
                    key: "getGlobalScope",
                    value: function getGlobalScope() {
                        return this._globalScope;
                    }
                }, {
                    key: "getCurrentScope",
                    value: function getCurrentScope() {
                        return this._currentScope;
                    }
                }, {
                    key: "getRegisteredFunctions",
                    value: function getRegisteredFunctions() {
                        return this.registered;
                    }
                }, {
                    key: "getFunctions",
                    value: function getFunctions() {
                        return this.functions;
                    }
                }, {
                    key: "getMixins",
                    value: function getMixins() {
                        return this.mixins;
                    }
                }, {
                    key: "createScope",
                    value: function createScope(scope) {
                        var currScope = scope || this._currentScope,
                            newScope = new Scope(currScope);
                        return this.pushScope(newScope);
                    }
                }, {
                    key: "pushScope",
                    value: function pushScope(scope) {
                        scope.resetScope = this._currentScope;
                        this._currentScope = scope;
                        return scope;
                    }
                }, {
                    key: "popScope",
                    value: function popScope() {
                        this._currentScope = this._currentScope.resetScope;
                        return this._currentScope;
                    }
                }, {
                    key: "createCallStackScope",
                    value: function createCallStackScope(scope) {
                        var currScope = scope || this._currentCallStackScope,
                            newScope = new Scope(currScope);
                        return this.pushCallStackScope(newScope);
                    }
                }, {
                    key: "pushCallStackScope",
                    value: function pushCallStackScope(scope) {
                        scope.resetScope = this._currentCallStackScope;
                        this._currentCallStackScope = scope;
                        return scope;
                    }
                }, {
                    key: "popCallStackScope",
                    value: function popCallStackScope() {
                        this._currentCallStackScope = this._currentCallStackScope.resetScope;
                        return this._currentCallStackScope;
                    }
                }, {
                    key: "getCallStack",
                    value: function getCallStack() {
                        if (this._currentCallStackScope) {
                            return this._currentCallStackScope.getCallStack();
                        }
                        return null;
                    }
                }, {
                    key: "pushSourceInfo",
                    value: function pushSourceInfo(info) {
                        if (this._currentCallStackScope) {
                            this._currentCallStackScope.sourceInfo = info;
                        }
                        return true;
                    }
                }, {
                    key: "getSourceInfo",
                    value: function getSourceInfo() {
                        var stack = this._currentCallStackScope,
                            info = stack && stack.sourceInfo;

                        if (info && info.length) {
                            return {
                                lineNumber: info[0],
                                file: info[1]
                            };
                        }
                        return null;
                    }
                }, {
                    key: "get",
                    value: function get(name) {
                        var scope = this.getScopeForName(name),
                            res = scope.map[name];

                        if (typeof res === 'undefined') {
                            if (!(name in scope.map)) {
                                Fashion.raiseAt('Reference to undeclared variable : ' + name, null, this.getCallStack());
                            }
                        }

                        return this.box(res);
                    }
                }, {
                    key: "getScopeForName",
                    value: function getScopeForName(jsName) {
                        var scope = this._currentScope;
                        while (scope) {
                            if (jsName in scope.map) {
                                return scope;
                            }
                            scope = scope.prev;
                        }
                        return this._currentScope;
                    }
                }, {
                    key: "getDefault",
                    value: function getDefault(val) {
                        if (val == null || typeof val === 'undefined') {
                            // === null || undefined
                            return undefined;
                        }

                        if (val.$isFashionNull) {
                            if (this.constructor.allowNullDefaults) {
                                return val;
                            }
                            return undefined;
                        }

                        return this.box(val);
                    }
                }, {
                    key: "getGlobalDefault",
                    value: function getGlobalDefault(jsName) {
                        var obj = this._globalScope.get(jsName);
                        return this.getDefault(obj);
                    }
                }, {
                    key: "getLocalDefault",
                    value: function getLocalDefault(jsName) {
                        var obj = this._currentScope.get(jsName);
                        return this.getDefault(obj);
                    }
                }, {
                    key: "setGlobal",
                    value: function setGlobal(jsName, value, astNodeId) {
                        var currScope = this._globalScope;

                        if (!value || !value.$isFashionLiteral) {
                            value = this.box(value);
                        }

                        value.ast = value.ast || this.getAstNode(astNodeId);
                        currScope.map[jsName] = value;
                        return value;
                    }
                }, {
                    key: "setDynamic",
                    value: function setDynamic(name, value, astNodeId) {
                        var jsName = Fashion.getJsName(name),
                            currScope = this._globalScope,
                            newValue;

                        if (!value || !value.$isFashionLiteral) {
                            value = this.box(value);
                        }

                        value.ast = value.ast || this.getAstNode(astNodeId);

                        if (value.$referenceName || value.$constant) {
                            newValue = value.clone();
                            newValue.$previousReference = value;
                            value = newValue;
                            value.ast = this.getAstNode(astNodeId);
                        } else {
                            value.$referenceName = name;
                        }

                        currScope.map[jsName] = value;
                        return value;
                    }
                }, {
                    key: "setScoped",
                    value: function setScoped(jsName, value) {
                        var currScope = this.getScopeForName(jsName);

                        if (!value || !value.$isFashionLiteral) {
                            value = this.box(value);
                        }

                        currScope.map[jsName] = value;
                        return value;
                    }
                }, {
                    key: "set",
                    value: function set(jsName, value) {
                        var currScope = this._currentScope;

                        if (!value || !value.$isFashionLiteral) {
                            value = this.box(value);
                        }

                        currScope.map[jsName] = value;
                        return value;
                    }
                }, {
                    key: "getDocs",
                    value: function getDocs(id) {
                        if (this.docCache) {
                            return this.docCache.get(id);
                        }
                    }
                }, {
                    key: "getString",
                    value: function getString(id) {
                        if (this.stringCache) {
                            return this.stringCache.get(id);
                        }
                    }
                }, {
                    key: "getAstNode",
                    value: function getAstNode(id) {
                        if (this.nodeCache) {
                            return this.nodeCache.get(id);
                        }
                    }
                }, {
                    key: "applySpread",
                    value: function applySpread(arg) {
                        arg.spread = true;
                        return arg;
                    }
                }, {
                    key: "sliceArgs",
                    value: function sliceArgs(args, start, end) {
                        start = start || 0;
                        end = end || args.length;

                        var filtered = [],
                            newArgs = [],
                            separator = ', ',
                            spread,
                            a,
                            arg;

                        for (a = start; a < end; a++) {
                            arg = args[a];
                            if (!arg) {
                                if (!spread) {
                                    filtered.push(arg);
                                }
                                continue;
                            }
                            if (arg.spread && arg.$isFashionList) {
                                if (spread) {
                                    filtered.push(spread);
                                }
                                spread = arg;
                                separator = spread.separator || separator;
                            } else {
                                filtered.push(arg);
                            }
                        }

                        for (a = 0; a < filtered.length; a++) {
                            arg = filtered[a];
                            separator = arg && arg.splatSeparator || separator;
                            newArgs.push(filtered[a]);
                        }

                        if (spread) {
                            newArgs.push.apply(newArgs, spread.items);
                        }

                        return new List(newArgs, separator);
                    }
                }, {
                    key: "applySpreadArgs",
                    value: function applySpreadArgs(args, name) {
                        var newArgs = [],
                            hadSpread = false,
                            offset = 0,
                            arg,
                            a,
                            item,
                            i,
                            items,
                            key,
                            map,
                            defaults,
                            proc,
                            param,
                            paramName;

                        proc = this.context && this.context.preprocessor;
                        if (proc) {
                            defaults = proc.mixinDeclarations[name];

                            if (defaults) {
                                offset = 1;
                            } else {
                                defaults = proc.functionDeclarations[name];
                            }

                            defaults = defaults && defaults.parameters;
                        }

                        for (a = 0; a < args.length; a++) {
                            arg = args[a];
                            if (arg && arg.spread && arg.$isFashionMap && defaults) {
                                items = arg.items;
                                map = {};
                                for (key in arg.map) {
                                    map['$' + Fashion.getJsName(key)] = arg.map[key];
                                }

                                for (var p = 0; p < defaults.length; p++) {
                                    param = defaults[p];
                                    paramName = Fashion.getJsName(param.name);
                                    if (paramName in map) {
                                        newArgs.push(items[map[paramName]]);
                                        delete map[paramName];
                                    } else if (!param.varArgs) {
                                        newArgs.push(undefined);
                                    }
                                }
                                for (key in map) {
                                    item = items[map[key]];
                                    newArgs.push(item);
                                }
                                hadSpread = true;
                            } else if (arg && arg.spread && arg.$isFashionList) {
                                items = arg.getItems();
                                for (i = 0; i < items.length; i++) {
                                    item = items[i];
                                    item && (item.splatSeparator = arg.separator);
                                    newArgs.push(item);
                                }
                                hadSpread = true;
                            } else if (arg || !hadSpread) {
                                newArgs.push(arg);
                            }
                            // clear the flag indicating the spread argument
                            // so subsequent calls using this same variable will not
                            // be contaminated
                            arg && (arg.spread = undefined);
                        }

                        var misisngParams = this.context && this.context.missingParameters;

                        if (misisngParams && misisngParams == 'error') {
                            if (defaults) {
                                for (var d = 0; d < defaults.length; d++) {
                                    if (!defaults[d].hasOwnProperty('default') && !defaults[d].varArgs) {
                                        if (newArgs[d + offset] === undefined) {
                                            Fashion.raiseAt("No value supplied for argument : " + defaults[d].name, null, this.getCallStack());
                                        }
                                    }
                                }
                            }
                        }
                        return newArgs;
                    }
                }, {
                    key: "warn",
                    value: function warn(arg) {
                        Fashion.warn(arg, this.getSourceInfo());
                    }
                }, {
                    key: "error",
                    value: function error(arg) {
                        Fashion.raiseAt(arg, null, this.getCallStack());
                    }
                }, {
                    key: "debug",
                    value: function debug() {
                        Fashion.debug.apply(Fashion, arguments);
                    }
                }, {
                    key: "setCaches",
                    value: function setCaches(transpiler) {
                        this.docCache = transpiler.docCache;
                        this.stringCache = transpiler.stringCache;
                        this.nodeCache = transpiler.nodeCache;
                    }
                }, {
                    key: "copyRuntimeState",
                    value: function copyRuntimeState(runtime) {
                        this._dynamics = runtime._dynamics;
                        this.registered = runtime.registered;
                        this.functions = runtime.functions;
                        this.mixins = runtime.mixins;
                    }
                }, {
                    key: "test",
                    value: function test(val) {
                        val = this.unbox(val);
                        if (val == null || val === false) {
                            return false;
                        }
                        return true;
                    }
                }, {
                    key: "and",
                    value: function and(a, b) {
                        if (this.test(a)) {
                            return b;
                        }
                        return a;
                    }
                }, {
                    key: "or",
                    value: function or(a, b) {
                        if (this.test(a)) {
                            return a;
                        }
                        return b;
                    }
                }]);

                return Runtime;
            }(Base);

            Fashion.apply(Runtime.prototype, {
                box: Type.box,
                unbox: Type.unbox,
                Scope: Scope,

                isFashionRuntime: true,
                functions: null,
                code: null,
                fn: null,

                stringCache: null,
                docCache: null,
                types: Types,

                _globalScope: null,
                _currentScope: null,
                _dynamics: null,
                context: null,
                reserved: {
                    'if': true,
                    'else': true
                }
            });

            module.exports = Runtime;
        }, { "./Base.js": 3, "./type/Bool.js": 8, "./type/Color.js": 9, "./type/ColorRGBA.js": 11, "./type/List.js": 15, "./type/Literal.js": 16, "./type/Statics.js": 22, "./type/Text.js": 23, "./type/Type.js": 24, "./type/TypeVisitor.js": 25, "./type/Types.js": 26 }], 6: [function (require, module, exports) {
            "use strict";

            var Fashion = require('../Base.js');
            var Runtime = require('../Runtime.js');
            var ValueParser = require('../parse/ValueParser.js');
            var SourceBuilder = require('../type/SourceBuilder.js');

            var CssVariableManager = function () {
                function CssVariableManager() {
                    _classCallCheck(this, CssVariableManager);

                    this.reset();
                }

                _createClass(CssVariableManager, [{
                    key: "reset",
                    value: function reset() {
                        this.initFns = [];
                        this.calcFns = [];
                        this.variableMap = {};
                        this.runtime = null;
                    }
                }, {
                    key: "createRuntime",
                    value: function createRuntime() {
                        return new Runtime();
                    }
                }, {
                    key: "getRuntime",
                    value: function getRuntime() {
                        var me = this,
                            rt = me.runtime;
                        if (!rt) {
                            rt = me.createRuntime();
                            for (var i = 0; i < me.initFns.length; i++) {
                                me.initFns[i](rt);
                            }
                            me.runtime = rt;
                        }
                        return rt;
                    }
                }, {
                    key: "calculate",
                    value: function calculate(vars) {
                        var me = this,
                            rt = me.getRuntime(),
                            globals = {},
                            parser = new ValueParser(),
                            map = me.variableMap,
                            key,
                            scope,
                            sb,
                            name,
                            names,
                            jsName,
                            value,
                            wrapper;

                        scope = new rt.Scope();
                        for (name in vars) {
                            key = Fashion.getJsName(name.replace(me.nameRe, ''));
                            if (key.indexOf('$') !== 0) {
                                key = '$' + key;
                            }
                            scope.put(key, parser.parse(vars[name]));
                        }

                        rt._globalScope = scope;
                        rt._currentScope = scope;
                        for (var i = 0; i < me.calcFns.length; i++) {
                            me.calcFns[i](rt);
                        }

                        sb = new SourceBuilder();

                        vars = {};
                        for (name in map) {
                            names = map[name];
                            for (var i = 0; i < names.length; i++) {
                                key = names[i];
                                jsName = '$' + Fashion.getJsName(key);
                                value = scope.get(jsName);
                                if (value) {
                                    if (value.$isWrapper) {
                                        value = value.value;
                                    }
                                    vars[key] = sb.toSource(value);
                                }
                            }
                        }

                        return vars;
                    }
                }, {
                    key: "applyVariables",
                    value: function applyVariables(vars) {
                        var me = this,
                            map = me.variableMap;

                        for (var selector in map) {
                            var variables = map[selector];
                            var els = document.querySelectorAll(selector);
                            if (els) {
                                for (var i = 0; i < els.length; i++) {
                                    for (var j = 0; j < variables.length; j++) {
                                        var varName = variables[j];
                                        els[i].style.setProperty('--' + varName, vars[varName]);
                                    }
                                }
                            }
                        }
                    }
                }, {
                    key: "setVariables",
                    value: function setVariables(vars) {
                        this.applyVariables(this.calculate(vars));
                    }
                }, {
                    key: "register",
                    value: function register(init, calc, map) {
                        if (init) {
                            this.initFns.push(init);
                        }

                        if (calc) {
                            this.calcFns.push(calc);
                        }

                        if (map) {
                            var vars = this.variableMap;
                            for (var name in map) {
                                var curr = vars[name];
                                if (!curr) {
                                    vars[name] = map[name];
                                } else {
                                    curr.push.apply(curr, map[name]);
                                }
                            }
                        }
                    }
                }, {
                    key: "buildName",
                    value: function buildName(name) {
                        return name.replace(/^--/, '').replace(/^\$/, '');
                    }
                }, {
                    key: "buildJsName",
                    value: function buildJsName(name) {
                        return Fashion.getJsName(name);
                    }
                }, {
                    key: "buildNames",
                    value: function buildNames(names) {
                        var out = {},
                            name;
                        for (name in names) {
                            out[name] = this.buildName(names[name]);
                        }
                        return out;
                    }
                }, {
                    key: "buildJsNames",
                    value: function buildJsNames(names) {
                        var out = {},
                            name;
                        for (name in names) {
                            out[name] = this.buildJsName(names[name]);
                        }
                        return out;
                    }
                }, {
                    key: "getVariables",
                    value: function getVariables() {
                        var me = this,
                            map = me.variableMap,
                            out = {};

                        for (var selector in map) {
                            var variables = map[selector];
                            var els = document.querySelectorAll(selector);
                            if (els) {
                                for (var i = 0; i < els.length; i++) {
                                    for (var j = 0; j < variables.length; j++) {
                                        var varName = variables[j];
                                        out[varName] = els[i].style.getPropertyValue('--' + varName);
                                    }
                                }
                            }
                        }
                        return out;
                    }
                }]);

                return CssVariableManager;
            }();

            Fashion.apply(CssVariableManager.prototype, {
                $isExport: true,
                nameRe: /^--/
            });

            module.exports = CssVariableManager;
        }, { "../Base.js": 3, "../Runtime.js": 5, "../parse/ValueParser.js": 7, "../type/SourceBuilder.js": 21 }], 7: [function (require, module, exports) {
            "use strict";

            var Fashion = require('../Base.js');
            var Type = require('../type/Type.js');
            var Statics = require('../type/Statics.js');
            var Types = require('../type/Types.js'),
                Color = Types.Color,
                Text = Types.Text,
                Numeric = Types.Numeric,
                List = Types.List,
                Bool = Types.Bool,
                Literal = Types.Literal,
                ColorRGBA = Types.ColorRGBA,
                ColorHSLA = Types.ColorHSLA,
                FunctionCall = Types.FunctionCall;

            var Parser = function () {
                function Parser() {
                    _classCallCheck(this, Parser);

                    this.index = 0;
                }

                _createClass(Parser, [{
                    key: "_advance",
                    value: function _advance() {
                        var me = this,
                            buff = '',
                            str = me.str,
                            len = str.length,
                            isString = false,
                            escaped = false,
                            isParen = 0,
                            ch;

                        while (me.index < len) {
                            ch = str[me.index];
                            me.index++;

                            // whitespace
                            if (ch <= ' ') {
                                if (!isString && !isParen) {
                                    if (buff.length) {
                                        break;
                                    }
                                    continue;
                                }
                            }

                            // terminal char
                            if (ch === ';' && !isString && !escaped) {
                                break;
                            }

                            if (ch === '(') {
                                isParen++;
                            }

                            if (ch === ')') {
                                isParen && isParen--;
                            }

                            if (ch === ',' && !isString && !escaped && !isParen) {
                                if (buff.length) {
                                    me.index--;
                                    break;
                                } else {
                                    return ch;
                                }
                            }

                            if (ch === '\\') {
                                if (isString) {
                                    escaped = 1;
                                    me.index++;
                                    continue;
                                }
                            }

                            if (ch === '"' || ch === "'") {
                                if (!isString) {
                                    isString = ch;
                                } else if (isString === ch) {
                                    isString = false;
                                }
                            }

                            escaped = false;
                            buff += ch;
                        }

                        return buff;
                    }
                }, {
                    key: "parseValue",
                    value: function parseValue(token) {
                        var rx = {
                            number: /^(\d+)(px|pt|pc|cm|mm|in|em|rem|ex)?$/g,
                            shortHexColor: /^#([A-Fa-f0-9]{3})$/,
                            longHexColor: /^#([A-Fa-f0-9]{6})$/,
                            functionCall: /^([A-Za-z0-9_]+)\((.*)\)$/,
                            parenList: /^\((.*?)\)$/

                        },
                            match,
                            value;

                        if (token[0] === '"' || token[0] === "'") {
                            value = token = token.substring(1, token.length - 1);
                            return new Text(value, token[0]);
                        }

                        if (token === 'true') {
                            return new Bool(true);
                        }

                        if (token === 'false') {
                            return new Bool(false);
                        }

                        if (token === 'null') {
                            return Literal.Null;
                        }

                        if (token === 'none') {
                            return Literal.None;
                        }

                        if (Fashion.Color.map[token]) {
                            var rgb = Color.map[token],
                                color = new ColorRGBA(rgb[0], rgb[1], rgb[2], rgb[3]);
                            color.stringified = token;
                            return color;
                        }

                        if (match = rx.number.exec(token)) {
                            return new Numeric(parseFloat(match[1]), match[2]);
                        }

                        if (match = rx.shortHexColor.exec(token)) {
                            return ColorRGBA.fromHex(match[1]);
                        }

                        if (match = rx.longHexColor.exec(token)) {
                            return ColorRGBA.fromHex(match[1]);
                        }

                        if (match = rx.functionCall.exec(token)) {
                            var name = match[1],
                                args = this.parse(match[2]).items;
                            if (name === 'hsla' || name === 'hsl') {
                                return new ColorHSLA(Type.unbox(args[0]), Type.unbox(args[1]), Type.unbox(args[2]), Type.unbox(args[3]) || 1);
                            } else if (name === 'rgba' || name === 'rgb') {
                                return new ColorRGBA(Type.unbox(args[0]), Type.unbox(args[1]), Type.unbox(args[2]), Type.unbox(args[3]) || 1);
                            }
                            return new FunctionCall(name, args);
                        }

                        if (match = rx.parenList.exec(token)) {
                            return new FunctionCall(this.parse(match[1]));
                        }

                        return new Fashion.Literal(token);
                    }
                }, {
                    key: "parse",
                    value: function parse(str) {
                        var me = this,
                            tokens = [],
                            values = [],
                            csv = null,
                            token;

                        me.str = str;
                        me.index = 0;

                        while (token = me._advance()) {
                            tokens.push(token);
                        }

                        for (var i = 0; i < tokens.length; i++) {
                            token = tokens[i].trim();
                            if (tokens[i + 1] === ',') {
                                csv = csv || [];
                                csv.push(me.parseValue(token));
                                i++;
                            } else if (csv) {
                                csv.push(me.parseValue(token));
                                values.push(new List(csv, ', '));
                                csv = null;
                            } else {
                                values.push(me.parseValue(token));
                            }
                        }

                        if (values.length === 1) {
                            return values[0];
                        }

                        return new List(values, ' ');
                    }
                }]);

                return Parser;
            }();

            // Fashion.apply(Parser.prototype, {
            //     regex:
            // });

            module.exports = Parser;
        }, { "../Base.js": 3, "../type/Statics.js": 22, "../type/Type.js": 24, "../type/Types.js": 26 }], 8: [function (require, module, exports) {
            /*
             * Copyright (c) 2012-2016. Sencha Inc.
             */

            "use strict";

            var Fashion = require('../Base.js');
            var Type = require('./Type.js');

            var Bool = function (_Type) {
                _inherits(Bool, _Type);

                function Bool(value) {
                    _classCallCheck(this, Bool);

                    var _this3 = _possibleConstructorReturn(this, (Bool.__proto__ || Object.getPrototypeOf(Bool)).call(this));

                    _this3.value = !!value;
                    return _this3;
                }

                _createClass(Bool, [{
                    key: "doVisit",
                    value: function doVisit(visitor) {
                        visitor.bool(this);
                    }
                }, {
                    key: "toString",
                    value: function toString() {
                        return this.value ? 'true' : 'false';
                    }
                }, {
                    key: "copy",
                    value: function copy() {
                        return new Bool(this.value);
                    }
                }]);

                return Bool;
            }(Type);

            Fashion.apply(Bool.prototype, {
                type: 'bool',
                $isFashionBool: true,
                value: null
            });

            Bool.True = new Bool(true);
            Bool.True.$constant = true;

            Bool.False = new Bool(false);
            Bool.False.$constant = true;

            module.exports = Bool;
        }, { "../Base.js": 3, "./Type.js": 24 }], 9: [function (require, module, exports) {
            /*
             * Copyright (c) 2012-2016. Sencha Inc.
             */

            "use strict";

            var Fashion = require('../Base.js');
            var Type = require('./Type.js');
            var Bool = require('./Bool.js');
            var Numeric = require('./Numeric.js');

            var Color = function (_Type2) {
                _inherits(Color, _Type2);

                function Color() {
                    _classCallCheck(this, Color);

                    return _possibleConstructorReturn(this, (Color.__proto__ || Object.getPrototypeOf(Color)).call(this));
                }

                _createClass(Color, [{
                    key: "toBoolean",
                    value: function toBoolean() {
                        return Bool.True;
                    }

                    // These two references need to be left out of the comment section above
                    // so as to prevent ordering issue during builds;

                }, {
                    key: "getRGBA",
                    value: function getRGBA() {
                        return this;
                    }
                }, {
                    key: "getHSLA",
                    value: function getHSLA() {
                        return this;
                    }
                }], [{
                    key: "component",
                    value: function component(color, _component) {
                        var unit = Color.units[_component],
                            type = Color.types[_component],
                            prop = Color.comps[_component],
                            targetColor;

                        if (type == 'hsla') {
                            targetColor = color.getHSLA();
                        } else {
                            targetColor = color.getRGBA();
                        }

                        return new Numeric(targetColor[prop], unit);
                    }
                }, {
                    key: "adjust",
                    value: function adjust(color, component, amount) {
                        var hsl = color.getHSLA().copy(),
                            prop = Color.comps[component],
                            value = amount.value;

                        //    if (component === 'saturation' && hsl.s === 0)  {
                        //        return color.clone();
                        //    }
                        //
                        hsl[prop] += value;

                        hsl.h = Color.constrainDegrees(hsl.h);
                        hsl.s = Color.constrainPercentage(hsl.s);
                        hsl.l = Color.constrainPercentage(hsl.l);

                        return hsl.getRGBA();
                    }
                }, {
                    key: "constrainChannel",
                    value: function constrainChannel(channel) {
                        return Math.max(0, Math.min(channel, 255));
                    }
                }, {
                    key: "constrainPercentage",
                    value: function constrainPercentage(per) {
                        return Math.max(0, Math.min(per, 100));
                    }
                }, {
                    key: "constrainDegrees",
                    value: function constrainDegrees(deg) {
                        deg = deg % 360;
                        return deg < 0 ? 360 + deg : deg;
                    }
                }, {
                    key: "constrainAlpha",
                    value: function constrainAlpha(alpha) {
                        if (alpha === undefined) {
                            return 1;
                        }
                        return Math.max(0, Math.min(alpha, 1));
                    }
                }]);

                return Color;
            }(Type);

            Fashion.apply(Color, {
                units: {
                    lightness: '%',
                    saturation: '%',
                    hue: 'deg'
                },

                types: {
                    red: 'rgba',
                    blue: 'rgba',
                    green: 'rgba',
                    alpha: 'rgba',
                    hue: 'hsla',
                    saturation: 'hsla',
                    lightness: 'hsla'
                },

                comps: {
                    red: 'r',
                    green: 'g',
                    blue: 'b',
                    alpha: 'a',
                    hue: 'h',
                    saturation: 's',
                    lightness: 'l'
                },

                map: {
                    aliceblue: [240, 248, 255],
                    antiquewhite: [250, 235, 215],
                    aqua: [0, 255, 255],
                    aquamarine: [127, 255, 212],
                    azure: [240, 255, 255],
                    beige: [245, 245, 220],
                    bisque: [255, 228, 196],
                    black: [0, 0, 0],
                    blanchedalmond: [255, 235, 205],
                    blue: [0, 0, 255],
                    blueviolet: [138, 43, 226],
                    brown: [165, 42, 42],
                    burlywood: [222, 184, 135],
                    cadetblue: [95, 158, 160],
                    chartreuse: [127, 255, 0],
                    chocolate: [210, 105, 30],
                    coral: [255, 127, 80],
                    cornflowerblue: [100, 149, 237],
                    cornsilk: [255, 248, 220],
                    crimson: [220, 20, 60],
                    cyan: [0, 255, 255],
                    darkblue: [0, 0, 139],
                    darkcyan: [0, 139, 139],
                    darkgoldenrod: [184, 132, 11],
                    darkgray: [169, 169, 169],
                    darkgreen: [0, 100, 0],
                    darkgrey: [169, 169, 169],
                    darkkhaki: [189, 183, 107],
                    darkmagenta: [139, 0, 139],
                    darkolivegreen: [85, 107, 47],
                    darkorange: [255, 140, 0],
                    darkorchid: [153, 50, 204],
                    darkred: [139, 0, 0],
                    darksalmon: [233, 150, 122],
                    darkseagreen: [143, 188, 143],
                    darkslateblue: [72, 61, 139],
                    darkslategray: [47, 79, 79],
                    darkslategrey: [47, 79, 79],
                    darkturquoise: [0, 206, 209],
                    darkviolet: [148, 0, 211],
                    deeppink: [255, 20, 147],
                    deepskyblue: [0, 191, 255],
                    dimgray: [105, 105, 105],
                    dimgrey: [105, 105, 105],
                    dodgerblue: [30, 144, 255],
                    firebrick: [178, 34, 34],
                    floralwhite: [255, 255, 240],
                    forestgreen: [34, 139, 34],
                    fuchsia: [255, 0, 255],
                    gainsboro: [220, 220, 220],
                    ghostwhite: [248, 248, 255],
                    gold: [255, 215, 0],
                    goldenrod: [218, 165, 32],
                    gray: [128, 128, 128],
                    green: [0, 128, 0],
                    greenyellow: [173, 255, 47],
                    grey: [128, 128, 128],
                    honeydew: [240, 255, 240],
                    hotpink: [255, 105, 180],
                    indianred: [205, 92, 92],
                    indigo: [75, 0, 130],
                    ivory: [255, 255, 240],
                    khaki: [240, 230, 140],
                    lavender: [230, 230, 250],
                    lavenderblush: [255, 240, 245],
                    lawngreen: [124, 252, 0],
                    lemonchiffon: [255, 250, 205],
                    lightblue: [173, 216, 230],
                    lightcoral: [240, 128, 128],
                    lightcyan: [224, 255, 255],
                    lightgoldenrodyellow: [250, 250, 210],
                    lightgray: [211, 211, 211],
                    lightgreen: [144, 238, 144],
                    lightgrey: [211, 211, 211],
                    lightpink: [255, 182, 193],
                    lightsalmon: [255, 160, 122],
                    lightseagreen: [32, 178, 170],
                    lightskyblue: [135, 206, 250],
                    lightslategray: [119, 136, 153],
                    lightslategrey: [119, 136, 153],
                    lightsteelblue: [176, 196, 222],
                    lightyellow: [255, 255, 224],
                    lime: [0, 255, 0],
                    limegreen: [50, 205, 50],
                    linen: [250, 240, 230],
                    magenta: [255, 0, 255],
                    maroon: [128, 0, 0],
                    mediumaquamarine: [102, 205, 170],
                    mediumblue: [0, 0, 205],
                    mediumorchid: [186, 85, 211],
                    mediumpurple: [147, 112, 219],
                    mediumseagreen: [60, 179, 113],
                    mediumslateblue: [123, 104, 238],
                    mediumspringgreen: [0, 250, 154],
                    mediumturquoise: [72, 209, 204],
                    mediumvioletred: [199, 21, 133],
                    midnightblue: [25, 25, 112],
                    mintcream: [245, 255, 250],
                    mistyrose: [255, 228, 225],
                    moccasin: [255, 228, 181],
                    navajowhite: [255, 222, 173],
                    navy: [0, 0, 128],
                    oldlace: [253, 245, 230],
                    olive: [128, 128, 0],
                    olivedrab: [107, 142, 35],
                    orange: [255, 165, 0],
                    orangered: [255, 69, 0],
                    orchid: [218, 112, 214],
                    palegoldenrod: [238, 232, 170],
                    palegreen: [152, 251, 152],
                    paleturquoise: [175, 238, 238],
                    palevioletred: [219, 112, 147],
                    papayawhip: [255, 239, 213],
                    peachpuff: [255, 218, 185],
                    peru: [205, 133, 63],
                    pink: [255, 192, 203],
                    plum: [221, 160, 203],
                    powderblue: [176, 224, 230],
                    purple: [128, 0, 128],
                    red: [255, 0, 0],
                    rosybrown: [188, 143, 143],
                    royalblue: [65, 105, 225],
                    saddlebrown: [139, 69, 19],
                    salmon: [250, 128, 114],
                    sandybrown: [244, 164, 96],
                    seagreen: [46, 139, 87],
                    seashell: [255, 245, 238],
                    sienna: [160, 82, 45],
                    silver: [192, 192, 192],
                    skyblue: [135, 206, 235],
                    slateblue: [106, 90, 205],
                    slategray: [119, 128, 144],
                    slategrey: [119, 128, 144],
                    snow: [255, 255, 250],
                    springgreen: [0, 255, 127],
                    steelblue: [70, 130, 180],
                    tan: [210, 180, 140],
                    teal: [0, 128, 128],
                    thistle: [216, 191, 216],
                    tomato: [255, 99, 71],
                    turquoise: [64, 224, 208],
                    violet: [238, 130, 238],
                    wheat: [245, 222, 179],
                    white: [255, 255, 255],
                    whitesmoke: [245, 245, 245],
                    yellow: [255, 255, 0],
                    yellowgreen: [154, 205, 5],
                    transparent: [0, 0, 0, 0]
                }
            });

            Fashion.apply(Color.prototype, {
                type: 'color',
                $isFashionColor: true,
                $isFashionRGBA: false,
                $isFashionHSLA: false,
                $canUnbox: false
            });

            module.exports = Color;
        }, { "../Base.js": 3, "./Bool.js": 8, "./Numeric.js": 18, "./Type.js": 24 }], 10: [function (require, module, exports) {
            /*
             * Copyright (c) 2012-2016. Sencha Inc.
             */

            "use strict";

            var Fashion = require('../Base.js');
            var Color = require('./Color.js');
            var ColorRGBA = require('./ColorRGBA.js');

            var ColorHSLA = function (_Color) {
                _inherits(ColorHSLA, _Color);

                function ColorHSLA(h, s, l, a) {
                    _classCallCheck(this, ColorHSLA);

                    var _this5 = _possibleConstructorReturn(this, (ColorHSLA.__proto__ || Object.getPrototypeOf(ColorHSLA)).call(this));

                    _this5.h = Color.constrainDegrees(h);
                    _this5.s = s;
                    _this5.l = l;
                    if (a !== undefined) {
                        _this5.a = a;
                    }
                    return _this5;
                }

                _createClass(ColorHSLA, [{
                    key: "doVisit",
                    value: function doVisit(visitor) {
                        visitor.hsla(this);
                    }
                }, {
                    key: "operate",
                    value: function operate(operation, right) {
                        return this.getRGBA().operate(operation, right);
                    }
                }, {
                    key: "copy",
                    value: function copy() {
                        return new ColorHSLA(this.h, this.s, this.l, this.a);
                    }
                }, {
                    key: "getRGBA",
                    value: function getRGBA() {
                        return ColorRGBA.fromHSLA(this);
                    }
                }, {
                    key: "toString",
                    value: function toString() {
                        return this.getRGBA().toString();
                    }
                }, {
                    key: "add",
                    value: function add(h, s, l, a) {
                        return new ColorHSLA(Color.constrainDegrees(this.h + h), Color.constrainPercentage(this.s + s), Color.constrainPercentage(this.l + l), Color.constrainAlpha(this.a * a));
                    }
                }, {
                    key: "subtract",
                    value: function subtract(h, s, l) {
                        return this.add(-h, -s, -l);
                    }
                }, {
                    key: "adjustLightness",
                    value: function adjustLightness(percent) {
                        this.l = Color.constrainPercentage(this.l + percent);
                        return this;
                    }
                }, {
                    key: "adjustHue",
                    value: function adjustHue(deg) {
                        this.h = Color.constrainDegrees(this.h + deg);
                        return this;
                    }
                }], [{
                    key: "fromRGBA",
                    value: function fromRGBA(rgba) {
                        if (rgba.$isFashionHSLA) {
                            return rgba.clone();
                        }

                        var r = rgba.r / 255,
                            g = rgba.g / 255,
                            b = rgba.b / 255,
                            a = rgba.a,
                            max = Math.max(r, g, b),
                            min = Math.min(r, g, b),
                            delta = max - min,
                            h = 0,
                            s = 0,
                            l = 0.5 * (max + min);

                        // min==max means achromatic (hue is undefined)
                        if (min != max) {
                            s = l < 0.5 ? delta / (max + min) : delta / (2 - max - min);
                            if (r == max) {
                                h = 60 * (g - b) / delta;
                            } else if (g == max) {
                                h = 120 + 60 * (b - r) / delta;
                            } else {
                                h = 240 + 60 * (r - g) / delta;
                            }
                            if (h < 0) {
                                h += 360;
                            }
                            if (h >= 360) {
                                h -= 360;
                            }
                        }

                        return new ColorHSLA(Color.constrainDegrees(h), Color.constrainPercentage(s * 100), Color.constrainPercentage(l * 100), a);
                    }
                }]);

                return ColorHSLA;
            }(Color);

            ColorRGBA.prototype.getHSLA = function () {
                return ColorHSLA.fromRGBA(this);
            };

            Fashion.apply(ColorHSLA.prototype, {
                type: 'hsla',
                $isFashionHSLA: true,
                h: null,
                s: null,
                l: null,
                a: 1
            });

            module.exports = ColorHSLA;
        }, { "../Base.js": 3, "./Color.js": 9, "./ColorRGBA.js": 11 }], 11: [function (require, module, exports) {
            /*
             * Copyright (c) 2012-2016. Sencha Inc.
             */

            "use strict";

            var Fashion = require('../Base.js');
            var Color = require('./Color.js');

            function hex2(v) {
                var s = v.toString(16);
                if (s.length < 2) {
                    s = '0' + s;
                }
                return s;
            }

            var ColorRGBA = function (_Color2) {
                _inherits(ColorRGBA, _Color2);

                function ColorRGBA(r, g, b, a) {
                    _classCallCheck(this, ColorRGBA);

                    var _this6 = _possibleConstructorReturn(this, (ColorRGBA.__proto__ || Object.getPrototypeOf(ColorRGBA)).call(this));

                    _this6.r = Math.min(0xff, Math.max(0, r));
                    _this6.g = Math.min(0xff, Math.max(0, g));
                    _this6.b = Math.min(0xff, Math.max(0, b));
                    if (a !== undefined) {
                        _this6.a = Math.min(1.0, Math.max(0.0, a));
                    }
                    return _this6;
                }

                _createClass(ColorRGBA, [{
                    key: "doVisit",
                    value: function doVisit(visitor) {
                        visitor.rgba(this);
                    }
                }, {
                    key: "copy",
                    value: function copy() {
                        return new ColorRGBA(this.r, this.g, this.b, this.a);
                    }
                }, {
                    key: "getHSLA",
                    value: function getHSLA() {
                        return null;
                    }
                }, {
                    key: "stringify",
                    value: function stringify() {
                        var me = this,
                            round = Math.round,
                            r = round(me.r),
                            g = round(me.g),
                            b = round(me.b),
                            a = me.a,
                            stringified = '';

                        // If there is no transparency we will use hex value
                        if (a === 1) {
                            stringified = '#' + hex2(r) + hex2(g) + hex2(b);
                        } else {
                            // Else use rgba
                            stringified = 'rgba(' + r + ', ' + g + ', ' + b + ', ' + a + ')';
                        }

                        stringified = stringified.toLowerCase();
                        return stringified;
                    }
                }, {
                    key: "getCompressedValue",
                    value: function getCompressedValue(lowerVal) {
                        var name = ColorRGBA.stringifiedMap[lowerVal],
                            shortName = ColorRGBA.shortFormMap[lowerVal];

                        if (name) {
                            lowerVal = lowerVal.length > name.length ? name : lowerVal;
                        }

                        if (ColorRGBA.useShortValues && shortName) {
                            lowerVal = lowerVal.length > shortName.length ? shortName : lowerVal;
                        }

                        return lowerVal;
                    }
                }, {
                    key: "toString",
                    value: function toString() {
                        if (!this.stringified) {
                            this.stringified = this.getCompressedValue(this.stringify());
                        }
                        return this.stringified;
                    }
                }, {
                    key: "toIeHexStr",
                    value: function toIeHexStr() {
                        var me = this,
                            round = Math.round,
                            r = round(me.r),
                            g = round(me.g),
                            b = round(me.b),
                            a = round(0xff * me.a);

                        return '#' + hex2(a) + hex2(r) + hex2(g) + hex2(b);
                    }
                }, {
                    key: "add",
                    value: function add(r, g, b, a) {
                        return new ColorRGBA(this.r + r, this.g + g, this.b + b, this.a * a);
                    }
                }, {
                    key: "subtract",
                    value: function subtract(r, g, b) {
                        return new ColorRGBA(this.r - r, this.g - g, this.b - b, this.a);
                    }
                }, {
                    key: "multiply",
                    value: function multiply(number) {
                        return new ColorRGBA(this.r * number, this.g * number, this.b * number, this.a);
                    }
                }, {
                    key: "divide",
                    value: function divide(number) {
                        return new ColorRGBA(this.r / number, this.g / number, this.b / number, this.a);
                    }
                }], [{
                    key: "fromHex",
                    value: function fromHex(value) {
                        if (value.charAt(0) == '#') {
                            value = value.substr(1);
                        }

                        var r, g, b;

                        if (value.length === 3) {
                            r = parseInt(value.charAt(0), 16);
                            g = parseInt(value.charAt(1), 16);
                            b = parseInt(value.charAt(2), 16);

                            r = (r << 4) + r;
                            g = (g << 4) + g;
                            b = (b << 4) + b;
                        } else {
                            r = parseInt(value.substring(0, 2), 16);
                            g = parseInt(value.substring(2, 4), 16);
                            b = parseInt(value.substring(4, 6), 16);
                        }

                        var result = new ColorRGBA(r, g, b);
                        if (ColorRGBA.preserveInputStrings) {
                            result.stringified = "#" + value;
                        }
                        return result;
                    }
                }, {
                    key: "fromHSLA",
                    value: function fromHSLA(color) {
                        if (color.$isFashionRGBA) {
                            return color.clone();
                        }

                        var hsla = color,
                            h = hsla.h / 360,
                            s = hsla.s / 100,
                            l = hsla.l / 100,
                            a = hsla.a;

                        var m2 = l <= 0.5 ? l * (s + 1) : l + s - l * s,
                            m1 = l * 2 - m2;

                        function hue(h) {
                            if (h < 0) ++h;
                            if (h > 1) --h;
                            if (h * 6 < 1) return m1 + (m2 - m1) * h * 6;
                            if (h * 2 < 1) return m2;
                            if (h * 3 < 2) return m1 + (m2 - m1) * (2 / 3 - h) * 6;
                            return m1;
                        }

                        var r = Color.constrainChannel(hue(h + 1 / 3) * 0xff),
                            g = Color.constrainChannel(hue(h) * 0xff),
                            b = Color.constrainChannel(hue(h - 1 / 3) * 0xff);

                        return new ColorRGBA(r, g, b, a);
                    }
                }]);

                return ColorRGBA;
            }(Color);

            Fashion.apply(ColorRGBA, {
                stringifiedMap: {
                    'rgba(0, 0, 0, 0)': 'transparent'
                },

                shortFormMap: {},

                useShortValues: true,
                preserveInputStrings: false
            });

            Fashion.apply(ColorRGBA.prototype, {
                type: 'rgba',
                $isFashionRGBA: true,
                r: null,
                g: null,
                b: null,
                a: 1,
                stringified: null,

                "+.number": function number(right) {
                    var value = right.value,
                        unit = right.unit;

                    switch (unit) {
                        case '%':
                            return this.getHSLA().adjustLightness(value).getRGBA();
                        case 'deg':
                            return this.getHSLA().adjustHue(value).getRGBA();
                        default:
                            return this.add(value, value, value, 1);
                    }
                },

                "+.rgba": function rgba(right) {
                    return this.add(right.r, right.g, right.b, right.a);
                },

                "+.hsla": function hsla(right) {
                    return this.getHSLA().add(right.h, right.s, right.l);
                },

                "-.number": function number(right) {
                    var value = right.value,
                        unit = right.unit;
                    switch (unit) {
                        case '%':
                            return this.getHSLA().adjustLightness(-value).getRGBA();
                        case 'deg':
                            return this.getHSLA().adjustHue(-value).getRGBA();
                        default:
                            return this.subtract(value, value, value);
                    }
                },

                "-.rgba": function rgba(right) {
                    return this.subtract(right.r, right.g, right.b);
                },

                "-.hsla": function hsla(right) {
                    return this.getHSLA().subtract(right.h, right.s, right.l);
                },

                "*.number": function number(right) {
                    return this.multiply(right.value);
                },

                "/.number": function number(right) {
                    return this.divide(right.value);
                },

                "*.rgba": function rgba(right) {
                    return new ColorRGBA(this.r * right.r, this.g * right.g, this.b * right.b, this.a * right.a);
                },

                "/.rgba": function rgba(right) {
                    return new ColorRGBA(Math.floor(this.r / right.r), Math.floor(this.g / right.g), Math.floor(this.b / right.b), Math.floor(this.a / right.a));
                }
            });

            module.exports = ColorRGBA;

            (function (ColorRGBA, stringifiedMap, colorMap, shortMap) {
                var colorChars = ['0', '1', '2', '3', '4', '5', '6', '7', '8', '9', 'a', 'b', 'c', 'd', 'e', 'f'],
                    names = Object.keys(colorMap),
                    i;

                names.sort();
                for (i = 0; i < names.length; i++) {
                    var name = names[i],
                        val = colorMap[name],
                        color = new ColorRGBA(val[0], val[1], val[2], val[3]),
                        str = color.stringify();

                    stringifiedMap[str] = name;
                }

                colorChars.forEach(function (short1) {
                    var long1 = short1 + short1;
                    colorChars.forEach(function (short2) {
                        var long2 = short2 + short2;
                        colorChars.forEach(function (short3) {
                            var long3 = short3 + short3,
                                shortName = '#' + short1 + short2 + short3,
                                longName = '#' + long1 + long2 + long3;

                            if (shortMap[longName]) {
                                var curr = shortMap[longName];
                                shortName = curr.length > shortName.length ? shortName : curr;
                                //if(curr.indexOf("#") === 0) {
                                //    short = (curr.length > short.length) ? short : curr;
                                //} else {
                                //    short = curr;
                                //}
                            }
                            shortMap[longName] = shortName;
                        });
                    });
                });
            })(ColorRGBA, ColorRGBA.stringifiedMap, Color.map, ColorRGBA.shortFormMap);
        }, { "../Base.js": 3, "./Color.js": 9 }], 12: [function (require, module, exports) {
            /*
             * Copyright (c) 2012-2016. Sencha Inc.
             */

            "use strict";

            var Fashion = require('../Base.js');
            var Type = require('./Type.js');
            var Numeric = require('./Numeric.js');

            var ColorStop = function (_Type3) {
                _inherits(ColorStop, _Type3);

                function ColorStop(color, stop) {
                    _classCallCheck(this, ColorStop);

                    var _this7 = _possibleConstructorReturn(this, (ColorStop.__proto__ || Object.getPrototypeOf(ColorStop)).call(this));

                    _this7.color = color;
                    _this7.stop = stop;
                    return _this7;
                }

                _createClass(ColorStop, [{
                    key: "doVisit",
                    value: function doVisit(visitor) {
                        visitor.colorstop(this);
                    }
                }, {
                    key: "descend",
                    value: function descend(visitor) {
                        visitor.visit(this.color);
                        visitor.visit(this.stop);
                    }
                }, {
                    key: "toString",
                    value: function toString() {
                        var string = this.color.toString(),
                            stop = this.stop;

                        if (stop) {
                            stop = stop.copy();
                            string += ' ';
                            if (!stop.unit) {
                                stop.value *= 100;
                                stop.unit = '%';
                            }
                            string += stop.toString();
                        }

                        return string;
                    }
                }, {
                    key: "toOriginalWebkitString",
                    value: function toOriginalWebkitString() {
                        var stop = this.stop;

                        if (!stop) {
                            stop = new Numeric(0, '%');
                        }

                        stop = stop.copy();
                        if (!stop.unit) {
                            stop.value *= 100;
                            stop.unit = '%';
                        }

                        return 'color-stop(' + stop.toString() + ', ' + this.color.toString() + ')';
                    }
                }, {
                    key: "copy",
                    value: function copy() {
                        return new ColorStop(this.color && this.color.clone(), this.stop && this.stop.clone());
                    }
                }]);

                return ColorStop;
            }(Type);

            Fashion.apply(ColorStop.prototype, {
                type: 'colorstop',
                $isFashionColorStop: true,
                $canUnbox: false,
                color: null,
                stop: null
            });

            module.exports = ColorStop;
        }, { "../Base.js": 3, "./Numeric.js": 18, "./Type.js": 24 }], 13: [function (require, module, exports) {
            /*
             * Copyright (c) 2012-2016. Sencha Inc.
             */

            "use strict";

            var Fashion = require('../Base.js');
            var Type = require('./Type.js');
            var List = require('./List.js');

            var FunctionCall = function (_Type4) {
                _inherits(FunctionCall, _Type4);

                function FunctionCall(name, args) {
                    _classCallCheck(this, FunctionCall);

                    var _this8 = _possibleConstructorReturn(this, (FunctionCall.__proto__ || Object.getPrototypeOf(FunctionCall)).call(this));

                    _this8.name = name;
                    if (Array.isArray(args)) {
                        args = new List(args);
                    }
                    _this8.args = args;
                    return _this8;
                }

                _createClass(FunctionCall, [{
                    key: "toString",
                    value: function toString() {
                        var args = this.args,
                            argsStr;
                        if (Array.isArray(args)) {
                            argsStr = args.join(', ');
                        } else {
                            argsStr = args.toString();
                        }
                        return this.name + "(" + argsStr + ')';
                    }
                }, {
                    key: "doVisit",
                    value: function doVisit(visitor) {
                        visitor.functioncall(this);
                    }
                }, {
                    key: "descend",
                    value: function descend(visitor) {
                        this.args && visitor.visit(this.args);
                    }
                }, {
                    key: "copy",
                    value: function copy() {
                        return new FunctionCall(this.name, this.args && this.args.copy());
                    }
                }]);

                return FunctionCall;
            }(Type);

            Fashion.apply(FunctionCall.prototype, {
                type: 'functioncall',
                $isFashionFunctionCall: true,
                $canUnbox: false,
                name: null,
                args: null
            });

            module.exports = FunctionCall;
        }, { "../Base.js": 3, "./List.js": 15, "./Type.js": 24 }], 14: [function (require, module, exports) {
            /*
             * Copyright (c) 2012-2016. Sencha Inc.
             */

            "use strict";

            var Fashion = require('../Base.js');
            var Type = require('./Type.js');

            var LinearGradient = function (_Type5) {
                _inherits(LinearGradient, _Type5);

                function LinearGradient(position, stops) {
                    _classCallCheck(this, LinearGradient);

                    var _this9 = _possibleConstructorReturn(this, (LinearGradient.__proto__ || Object.getPrototypeOf(LinearGradient)).call(this));

                    _this9.position = position;
                    _this9.stops = stops;
                    return _this9;
                }

                _createClass(LinearGradient, [{
                    key: "doVisit",
                    value: function doVisit(visitor) {
                        visitor.lineargradient(this);
                    }
                }, {
                    key: "descend",
                    value: function descend(visitor) {
                        visitor.visit(this.position);
                        visitor.visit(this.stops);
                    }
                }, {
                    key: "copy",
                    value: function copy() {
                        return new LinearGradient(this.position && this.position.clone(), this.stops && this.stops.clone());
                    }
                }, {
                    key: "gradientPoints",
                    value: function gradientPoints(position) {}
                }, {
                    key: "operate",
                    value: function operate(operation, right) {
                        switch (operation) {
                            case "!=":
                                if (right.type == 'literal' && (right.value == 'null' || right.value == 'none')) {
                                    return true;
                                }
                            case "==":
                                if (right.type == 'literal' && (right.value == 'null' || right.value == 'none')) {
                                    return false;
                                }
                        }
                        return _get(LinearGradient.prototype.__proto__ || Object.getPrototypeOf(LinearGradient.prototype), "operate", this).call(this, operation, right);
                    }
                }, {
                    key: "supports",
                    value: function supports(prefix) {
                        return !!this.vendorPrefixes[prefix.toLowerCase()];
                    }
                }, {
                    key: "toString",
                    value: function toString() {
                        var string = 'linear-gradient(';
                        if (this.position) {
                            string += this.position + ', ';
                        }
                        return string + this.stops + ')';
                    }
                }, {
                    key: "toOriginalWebkitString",
                    value: function toOriginalWebkitString() {
                        // args = []
                        // args << grad_point(position_or_angle || Sass::Script::String.new("top"))
                        // args << linear_end_position(position_or_angle, color_stops)
                        // args << grad_color_stops(color_stops)
                        // args.each{|a| a.options = options}
                        // Sass::Script::String.new("-webkit-gradient(linear, #{args.join(', ')})")
                        //this.gradientPoints(this.position);
                        var args = [],
                            stops = this.stops.items,
                            ln = stops.length,
                            i;

                        args.push('top');
                        args.push('bottom');

                        for (i = 0; i < ln; i++) {
                            args.push(stops[i].toOriginalWebkitString());
                        }

                        return '-webkit-gradient(linear, ' + args.join(', ') + ')';
                    }
                }, {
                    key: "toPrefixedString",
                    value: function toPrefixedString(prefix) {
                        if (prefix === 'owg') {
                            return this.toOriginalWebkitString();
                        }
                        return prefix + this.toString();
                    }
                }]);

                return LinearGradient;
            }(Type);

            Fashion.apply(LinearGradient.prototype, {
                type: 'lineargradient',
                $isFashionLinearGradient: true,
                $canUnbox: false,
                position: null,
                stops: null,
                vendorPrefixes: {
                    webkit: true,
                    moz: true,
                    svg: true,
                    pie: true,
                    css2: true,
                    o: true,
                    owg: true
                }
            });

            module.exports = LinearGradient;
        }, { "../Base.js": 3, "./Type.js": 24 }], 15: [function (require, module, exports) {
            /*
             * Copyright (c) 2012-2016. Sencha Inc.
             */

            "use strict";

            var Fashion = require('../Base.js');
            var Type = require('./Type.js');

            var List = function (_Type6) {
                _inherits(List, _Type6);

                function List(items, separator) {
                    _classCallCheck(this, List);

                    var _this10 = _possibleConstructorReturn(this, (List.__proto__ || Object.getPrototypeOf(List)).call(this));

                    _this10.items = items || [];
                    _this10.separator = typeof separator === 'undefined' ? ' ' : separator;
                    return _this10;
                }

                _createClass(List, [{
                    key: "doVisit",
                    value: function doVisit(visitor) {
                        visitor.list(this);
                    }
                }, {
                    key: "descend",
                    value: function descend(visitor) {
                        for (var i = 0; i < this.items.length; i++) {
                            visitor.visit(this.items[i]);
                        }
                    }
                }, {
                    key: "copy",
                    value: function copy() {
                        var items = this.items,
                            len = items.length,
                            newItems = [];
                        for (var i = 0; i < len; i++) {
                            newItems.push(items[i].clone());
                        }
                        return new List(newItems, this.separator);
                    }
                }, {
                    key: "clone",
                    value: function clone(match, replace) {
                        if (replace && this.matches(match)) {
                            return replace.clone();
                        }
                        var items = this.items,
                            len = items.length,
                            newItems = [];

                        for (var i = 0; i < len; i++) {
                            var item = items[i];
                            if (item) {
                                newItems.push(item.clone(match, replace));
                            } else {
                                newItems.push(item);
                            }
                        }

                        var copy = new List(newItems, this.separator);
                        copy.$referenceName = this.$referenceName;
                        copy.$referenceBase = this.$referenceBase;
                        copy.$previousReference = this.$previousReference;
                        return copy;
                    }
                }, {
                    key: "add",
                    value: function add(item) {
                        return this.items.push(item);
                    }
                }, {
                    key: "get",
                    value: function get(index) {
                        return this.items[index - 1] || null;
                    }
                }, {
                    key: "operate",
                    value: function operate(operation, right) {
                        switch (operation) {
                            case '!=':
                                if (right.$isFashionLiteral) {
                                    if (right.value === 'null' || right.value === 'none') {
                                        return true;
                                    }
                                }
                                break;

                            case '==':
                                if (right.$isFashionLiteral) {
                                    if (right.value === 'null' || right.value === 'none') {
                                        return false;
                                    }
                                }
                                break;
                        }

                        return _get(List.prototype.__proto__ || Object.getPrototypeOf(List.prototype), "operate", this).call(this, operation, right);
                    }
                }, {
                    key: "supports",
                    value: function supports(prefix) {
                        for (var i = 0; i < this.items.length; i++) {
                            var item = this.items[i];

                            if (item.supports(prefix)) {
                                return true;
                            }
                        }

                        return false;
                    }
                }, {
                    key: "toBoolean",
                    value: function toBoolean() {
                        return !!this.items.length;
                    }
                }, {
                    key: "getItems",
                    value: function getItems() {
                        return this.items;
                        // return Fashion.filter(this.items, (item) => {
                        //     var unboxed = Type.unbox(item);
                        //     return unboxed !== null && unboxed !== undefined;
                        // });
                    }
                }, {
                    key: "toString",
                    value: function toString() {
                        return this.items.join(this.separator);
                    }
                }, {
                    key: "unquote",
                    value: function unquote() {
                        var items = [],
                            item;
                        for (var i = 0; i < this.items.length; i++) {
                            item = this.items[i];
                            if (item) {
                                items.push(item.unquote());
                            } else {
                                items.push(item);
                            }
                        }
                        return new List(items, this.separator);
                    }
                }, {
                    key: "toPrefixedString",
                    value: function toPrefixedString(prefix) {
                        var items = [];
                        for (var i = 0; i < this.items.length; i++) {
                            var item = this.items[i];
                            if (item) {
                                items.push(item.toPrefixedString(prefix));
                            }
                        }
                        return items.join(this.separator);
                    }

                    //----------------------------------------------------------------------
                    // Operations

                }, {
                    key: '==.list',
                    value: function list(right) {
                        var equals = this.separator == right.separator && this.items.length == right.items.length;

                        for (var i = 0; equals && i < this.items.length; ++i) {
                            equals = this.items[i].operate("==", right.items[i]);
                        }

                        return equals;
                    }
                }]);

                return List;
            }(Type);

            Fashion.apply(List.prototype, {
                type: 'list',
                $isFashionList: true,
                items: null,
                separator: null
            });

            module.exports = List;
        }, { "../Base.js": 3, "./Type.js": 24 }], 16: [function (require, module, exports) {
            /*
             * Copyright (c) 2012-2016. Sencha Inc.
             */

            "use strict";

            var Fashion = require('../Base.js');
            var Type = require('./Type.js');
            var Numeric = require('./Numeric.js');

            var Literal = function (_Type7) {
                _inherits(Literal, _Type7);

                function Literal(value) {
                    _classCallCheck(this, Literal);

                    var _this11 = _possibleConstructorReturn(this, (Literal.__proto__ || Object.getPrototypeOf(Literal)).call(this));

                    _this11.value = value;
                    return _this11;
                }

                _createClass(Literal, [{
                    key: "doVisit",
                    value: function doVisit(visitor) {
                        visitor.literal(this);
                    }
                }, {
                    key: "_getHash",
                    value: function _getHash() {
                        return this.value;
                    }
                }, {
                    key: "toString",
                    value: function toString() {
                        return this.value || '';
                    }
                }, {
                    key: "toBoolean",
                    value: function toBoolean() {
                        return this.value.length;
                    }
                }, {
                    key: "copy",
                    value: function copy() {
                        return new Literal(this.value);
                    }
                }, {
                    key: '+',
                    value: function _(right) {
                        return new Literal(this.value + right.getHash());
                    }
                }, {
                    key: '+.number',
                    value: function number(right) {
                        if (this.value === null) {
                            return right;
                        }
                        return new Literal(this.value + right.toString());
                    }
                }, {
                    key: '/',
                    value: function _(right) {
                        return new Literal(this.value + '/' + right.getHash());
                    }
                }, {
                    key: '-',
                    value: function _(right) {
                        return new Literal(this.value + '-' + right.getHash());
                    }
                }, {
                    key: '%',
                    value: function _(right) {
                        return new Literal(this.value + '%' + right.getHash());
                    }
                }, {
                    key: "normalizeStart",
                    value: function normalizeStart(startVal) {
                        var start = Type.unbox(startVal) || 0;
                        if (start > 0) {
                            start = start - 1;
                        }

                        if (start < 0) {
                            start = this.value.length + start;
                        }

                        if (start < 0) {
                            start = 0;
                        }

                        return start;
                    }
                }, {
                    key: "normalizeEnd",
                    value: function normalizeEnd(endVal) {
                        var end = Type.unbox(endVal) || -1;
                        if (end > 0) {
                            end = end - 1;
                        }
                        if (end < 0) {
                            end = this.value.length + end;
                        }

                        if (end < 0) {
                            end = 0;
                        }

                        if (end > 0) {
                            end = end + 1;
                        }
                        return end;
                    }
                }, {
                    key: "slice",
                    value: function slice(start, end) {
                        start = this.normalizeStart(start);
                        end = this.normalizeEnd(end);
                        return new Literal(this.value.slice(start, end));
                    }
                }, {
                    key: "toUpperCase",
                    value: function toUpperCase() {
                        return new Literal(this.value.toUpperCase());
                    }
                }, {
                    key: "toLowerCase",
                    value: function toLowerCase() {
                        return new Literal(this.value.toLowerCase());
                    }
                }, {
                    key: "indexOf",
                    value: function indexOf(str) {
                        var idx = this.value.indexOf(str.value);
                        if (idx === -1) {
                            return undefined;
                        }
                        return new Numeric(idx + 1);
                    }
                }, {
                    key: "insert",
                    value: function insert(str, startVal) {
                        var start = Type.unbox(startVal) || 0,
                            inserted = this.value;

                        if (start > 0) {
                            start = Math.min(start - 1, inserted.length);
                        }
                        if (start < 0) {
                            start = inserted.length + start + 1;
                            start = Math.max(start, 0);
                        }

                        inserted = inserted.substring(0, start) + str.value + inserted.substring(start);
                        return new Literal(Literal.deEscape(inserted));
                    }
                }, {
                    key: "toDisplayString",
                    value: function toDisplayString() {
                        var val = this.value;
                        if (val === null) {
                            return "null";
                        }
                        return this.toString();
                    }
                }], [{
                    key: "tryCoerce",
                    value: function tryCoerce(obj) {
                        if (obj.$isFashionNumber) {
                            return undefined;
                        }
                        if (obj.$isFashionString) {
                            return new Literal(obj.value);
                        }
                        if (obj.$isFashionLiteral) {
                            return obj;
                        }
                        return new Literal(obj.getHash());
                    }
                }, {
                    key: "deEscape",
                    value: function deEscape(str) {
                        var buff = '',
                            i,
                            ch;
                        for (i = 0; i < str.length; i++) {
                            ch = str.charAt(i);
                            if (ch === '\\') {
                                i++;
                                ch = str.charAt(i);
                            }
                            buff += ch;
                        }
                        return buff;
                    }
                }]);

                return Literal;
            }(Type);

            Fashion.apply(Literal.prototype, {
                type: 'literal',
                $isFashionLiteral: true,
                value: null
            });

            var FashionNull = function (_Literal) {
                _inherits(FashionNull, _Literal);

                function FashionNull(value) {
                    _classCallCheck(this, FashionNull);

                    return _possibleConstructorReturn(this, (FashionNull.__proto__ || Object.getPrototypeOf(FashionNull)).call(this, value || null));
                }

                _createClass(FashionNull, [{
                    key: "copy",
                    value: function copy() {
                        return new FashionNull(this.value);
                    }
                }]);

                return FashionNull;
            }(Literal);

            Fashion.apply(FashionNull.prototype, {
                $isFashionNull: true,
                $constant: true
            });

            FashionNull.prototype.$isFashionNull = true;

            Literal.Null = new FashionNull(null);
            Literal.None = new Literal('none');

            module.exports = Literal;
        }, { "../Base.js": 3, "./Numeric.js": 18, "./Type.js": 24 }], 17: [function (require, module, exports) {
            /*
             * Copyright (c) 2012-2016. Sencha Inc.
             */

            "use strict";

            var Fashion = require('../Base.js');
            var List = require('./List.js');
            var Type = require('./Type.js');
            var Literal = require('./Literal.js'),
                Null = Literal.Null;

            var Numeric = require('./Numeric.js');

            var Map = function (_List) {
                _inherits(Map, _List);

                function Map(pairs) {
                    _classCallCheck(this, Map);

                    var _this13 = _possibleConstructorReturn(this, (Map.__proto__ || Object.getPrototypeOf(Map)).call(this, pairs));

                    _this13.map = {};
                    if (pairs) {
                        for (var i = 0; i < pairs.length - 1; i += 2) {
                            var key = _this13.toKey(pairs[i]),
                                value = pairs[i + 1];
                            _this13.map[key] = i + 1;
                        }
                    }
                    return _this13;
                }

                _createClass(Map, [{
                    key: "doVisit",
                    value: function doVisit(visitor) {
                        visitor.map(this);
                    }
                }, {
                    key: "descend",
                    value: function descend(visitor) {
                        for (var i = 0; i < this.items.length; i++) {
                            visitor.visit(this.items[i]);
                        }
                    }
                }, {
                    key: "get",
                    value: function get(key) {
                        if (key instanceof Numeric) {
                            key = Type.unbox(key);
                        }

                        if (typeof key === 'number') {
                            return new List([this.items[2 * key - 2], this.items[2 * key - 1]], ' ');
                        }

                        key = this.toKey(key);
                        return this.items[this.map[key]] || Null;
                    }
                }, {
                    key: "getItems",
                    value: function getItems() {
                        var values = [];
                        for (var i = 0; i < this.items.length - 1; i += 2) {
                            var key = this.toKey(this.items[i]);
                            values.push(this.map[key]);
                        }
                        return values;
                    }
                }, {
                    key: "put",
                    value: function put(key, value) {
                        var keyStr = this.toKey(key);
                        if (!this.map.hasOwnProperty(keyStr)) {
                            this.items.push(key, value);
                            this.map[keyStr] = this.items.length - 1;
                        } else {
                            this.items[this.map[keyStr]] = value;
                        }
                    }
                }, {
                    key: "toString",
                    value: function toString() {
                        var str = '',
                            count = 0;
                        for (var i = 0; i < this.items.length - 1; i += 2) {
                            var key = this.toKey(this.items[i]),
                                value = this.map[key];
                            if (value) {
                                if (count > 0) {
                                    str += ', ';
                                }
                                str += key + ": " + value.toString();
                                count++;
                            }
                        }
                        return str;
                    }
                }, {
                    key: "toKey",
                    value: function toKey(key) {
                        return this.unquoteKey(key).toString();
                    }
                }, {
                    key: "unquoteKey",
                    value: function unquoteKey(string) {
                        if (string.$isFashionType) {
                            return string.unquote();
                        }
                        return string;
                    }
                }, {
                    key: "remove",
                    value: function remove(key) {
                        key = this.toKey(key);
                        if (this.map[key]) {
                            var idx = this.map[key];
                            delete this.items[idx - 1];
                            delete this.items[idx];
                            delete this.map[key];
                        }
                    }
                }, {
                    key: "getKeys",
                    value: function getKeys() {
                        var keys = [];
                        for (var i = 0; i < this.items.length; i += 2) {
                            var k = this.items[i];
                            if (k) {
                                keys.push(k);
                            }
                        }
                        return keys;
                    }
                }, {
                    key: "getValues",
                    value: function getValues() {
                        var values = [];
                        for (var i = 1; i < this.items.length; i += 2) {
                            var v = this.items[i];
                            if (v) {
                                values.push(v);
                            }
                        }
                        return values;
                    }
                }, {
                    key: "hasKey",
                    value: function hasKey(key) {
                        key = this.toKey(key);
                        if (this.map.hasOwnProperty(key)) {
                            return true;
                        }
                        return false;
                    }
                }]);

                return Map;
            }(List);

            Fashion.apply(Map.prototype, {
                type: "map",
                $isFashionMap: true,
                $canUnbox: false,
                map: null
            });

            module.exports = Map;
        }, { "../Base.js": 3, "./List.js": 15, "./Literal.js": 16, "./Numeric.js": 18, "./Type.js": 24 }], 18: [function (require, module, exports) {
            /*
             * Copyright (c) 2012-2016. Sencha Inc.
             */

            "use strict";

            var Fashion = require('../Base.js');
            var Type = require('./Type.js');
            var Bool = require('./Bool.js');
            var Literal = require('./Literal.js');

            var Numeric = function (_Type8) {
                _inherits(Numeric, _Type8);

                function Numeric(value, unit, numeratorUnits, denominatorUnits) {
                    _classCallCheck(this, Numeric);

                    var _this14 = _possibleConstructorReturn(this, (Numeric.__proto__ || Object.getPrototypeOf(Numeric)).call(this));

                    _this14.value = value;
                    _this14.unit = unit;
                    if (unit && !numeratorUnits) {
                        _this14.numeratorUnits = [unit];
                    } else {
                        _this14.numeratorUnits = numeratorUnits || [];
                    }
                    _this14.denominatorUnits = denominatorUnits || [];
                    return _this14;
                }

                _createClass(Numeric, [{
                    key: "doVisit",
                    value: function doVisit(visitor) {
                        visitor.number(this);
                    }
                }, {
                    key: "unitless",
                    value: function unitless() {
                        if (this.numeratorUnits && this.numeratorUnits.length) {
                            return false;
                        }

                        if (this.denominatorUnits && this.denominatorUnits.length) {
                            return false;
                        }

                        return true;
                    }
                }, {
                    key: "getUnitStr",
                    value: function getUnitStr() {
                        this.normalizeUnits();
                        var unitStr = this.numeratorUnits.join('*');
                        if (this.denominatorUnits.length) {
                            unitStr += '/' + this.denominatorUnits.join('*');
                        }
                        return unitStr;
                    }
                }, {
                    key: "_getHash",
                    value: function _getHash() {
                        return this.value;
                    }
                }, {
                    key: "stringify",
                    value: function stringify() {
                        this.normalizeUnits();

                        var value = this.value,
                            valStr;

                        // prevent 0.020000000000000004 type numbers in output
                        valStr = Math.round(value * 100000) / 100000 + '';
                        //unitStr = valStr === '0' ? '' : this.getUnitStr();
                        return valStr + this.getUnitStr();
                    }
                }, {
                    key: "toString",
                    value: function toString() {
                        return this.stringify();
                    }
                }, {
                    key: "toBoolean",
                    value: function toBoolean() {
                        return this.unit ? true : !!this.value;
                    }
                }, {
                    key: "copy",
                    value: function copy() {
                        return new Numeric(this.value, this.unit);
                    }
                }, {
                    key: '-.literal',
                    value: function literal(right) {
                        if (this.value === 0 && this.unitless()) {
                            return new Literal(['-', right.toString()].join(''));
                        }
                        return new Literal([this.toString(), '-', right.toString()].join(''));
                    }
                }, {
                    key: '-.string',
                    value: function string(right) {
                        if (this.value === 0 && this.unitless()) {
                            return new Literal(['-', right.toString()].join(''));
                        }
                        return new Literal([this.toString(), '-', right.toString()].join(''));
                    }
                }, {
                    key: '-.number',
                    value: function number(right) {
                        var value = right.value;

                        if (right.unit == '%' && right.unit !== this.unit) {
                            value = this.value * (right.value / 100);
                        }

                        return new Numeric(this.value - value, this.unit || right.unit);
                    }
                }, {
                    key: '+.literal',
                    value: function literal(right) {
                        if (right.$isFashionString) {
                            return new Literal([this.toString(), right.value].join(''));
                        }

                        return new Literal([this.toString(), right.toString()].join(''));
                    }
                }, {
                    key: '+.number',
                    value: function number(right) {
                        var value = right.value;

                        if (right.unit == '%' && right.unit !== this.unit) {
                            value = this.value * (right.value / 100);
                        }

                        return new Numeric(this.value + value, this.unit || right.unit);
                    }
                }, {
                    key: '/',
                    value: function _(right) {
                        return new Numeric(this.value / right.value, this.unit == right.unit ? null : this.unit || right.unit);
                    }
                }, {
                    key: '*',
                    value: function _(right) {
                        return new Numeric(this.value * right.value, this.unit || right.unit);
                    }
                }, {
                    key: '%',
                    value: function _(right) {
                        return new Numeric(this.value % right.value, this.unit || right.unit);
                    }
                }, {
                    key: '**',
                    value: function _(right) {
                        return new Numeric(Math.pow(this.value, right.value), this.unit || right.unit);
                    }
                }, {
                    key: "operate",
                    value: function operate(operation, right) {
                        var unit = this.unit || right.unit,
                            normalized;

                        if (right.$isFashionRGBA || right.$isFashionHSLA) {
                            return new Literal(this + operation + right);
                        }

                        if (right.$isFashionNumber) {
                            return this.numericOperate(operation, right);
                        } else if (right.$isFashionLiteral) {
                            normalized = this.tryCoerce(right);

                            if (normalized) {
                                return this.performOperation(operation, normalized);
                            }
                        }

                        return _get(Numeric.prototype.__proto__ || Object.getPrototypeOf(Numeric.prototype), "operate", this).call(this, operation, right);
                    }
                }, {
                    key: "tryNormalize",
                    value: function tryNormalize(other) {
                        var value = other.value,
                            unit = other.unit;

                        if (other.$isFashionNumber) {
                            switch (this.unit) {
                                case 'mm':
                                    switch (unit) {
                                        case 'in':
                                            return new Numeric(value * 25.4, 'mm');
                                        case 'cm':
                                            return new Numeric(value * 2.54, 'mm');
                                    }
                                    break;

                                case 'cm':
                                    switch (unit) {
                                        case 'in':
                                            return new Numeric(value * 2.54, 'cm');
                                        case 'mm':
                                            return new Numeric(value / 10, 'cm');
                                    }
                                    break;

                                case 'in':
                                    switch (unit) {
                                        case 'mm':
                                            return new Numeric(value / 25.4, 'in');
                                        case 'cm':
                                            return new Numeric(value / 2.54, 'in');
                                    }
                                    break;

                                case 'ms':
                                    switch (unit) {
                                        case 's':
                                            return new Numeric(value * 1000, 'ms');
                                    }
                                    break;

                                case 's':
                                    switch (unit) {
                                        case 'ms':
                                            return new Numeric(value / 1000, 's');
                                    }
                                    break;

                                case 'Hz':
                                    switch (unit) {
                                        case 'kHz':
                                            return new Numeric(value * 1000, 'Hz');
                                    }
                                    break;

                                case 'kHz':
                                    switch (unit) {
                                        case 'Hz':
                                            return new Numeric(value / 1000, 'kHz');
                                    }
                                    break;
                                case '%':
                                    switch (unit) {
                                        default:
                                            return new Numeric(value);
                                    }
                                default:
                                    break;
                            }
                        }

                        return undefined;
                    }
                }, {
                    key: "normalize",
                    value: function normalize(other) {
                        var norm = this.tryNormalize(other);

                        if (norm === undefined) {
                            raise('Could not normalize ' + this + ' with ' + other);
                        }

                        return norm;
                    }
                }, {
                    key: "comparable",
                    value: function comparable(other) {
                        var unit1 = this.unit,
                            unit2 = other.unit;

                        if (!other.$isFashionNumber) {
                            return false;
                        }

                        return unit1 === unit2 || unit1 === 'mm' && (unit2 === 'in' || unit2 === 'cm') || unit1 === 'cm' && (unit2 === 'in' || unit2 === 'mm') || unit1 === 'in' && (unit2 === 'mm' || unit2 === 'cm') || unit1 === 'ms' && unit2 === 's' || unit1 === 's' && unit2 === 'ms' || unit1 === 'Hz' && unit2 === 'kHz' || unit1 === 'kHz' && unit2 === 'Hz';
                    }

                    //---------------------------------------------------------------

                }, {
                    key: "normalizeUnits",
                    value: function normalizeUnits() {
                        if (this.normalized) {
                            return;
                        }

                        this.normalized = true;

                        if (!this.unitless()) {
                            var clean = this.removeCommonUnits(this.numeratorUnits, this.denominatorUnits),
                                converted;

                            //var num = [],
                            //    den = [];
                            //
                            //for(var d = 0; d < clean.den.length; d++) {
                            //    var dn = clean.den[d];
                            //    if(this.convertable(dn)) {
                            //        converted = false;
                            //        for (var n = 0; n < clean.num.length; n++) {
                            //            var nm = clean.num[n];
                            //            if(this.convertable(nm)) {
                            //                this.value = this.value / this.conversionFactor(dn, nm);
                            //                converted = true;
                            //            } else {
                            //                num.push(nm);
                            //            }
                            //        }
                            //        if(!converted) {
                            //            den.push(dn);
                            //        }
                            //    }
                            //}
                            //
                            //this.numeratorUnits = num;
                            //this.denominatorUnits = den;

                            clean.num = Fashion.filter(clean.num, function (val) {
                                return !!val;
                            });
                            clean.den = Fashion.filter(clean.den, function (val) {
                                return !!val;
                            });
                            this.numeratorUnits = clean.num;
                            this.denominatorUnits = clean.den;
                        }
                    }
                }, {
                    key: "numericOperate",
                    value: function numericOperate(operation, right) {
                        this.normalizeUnits();
                        right.normalizeUnits();

                        var me = this,
                            other = right,
                            ops = Numeric.OPERATIONS,
                            moreOps = Numeric.NON_COERCE_OPERATIONS,
                            op = ops[operation],
                            result;

                        if (op) {
                            try {
                                if (me.unitless()) {
                                    me = me.coerceUnits(other.numeratorUnits, other.denominatorUnits);
                                } else {
                                    other = other.coerceUnits(me.numeratorUnits, me.denominatorUnits);
                                }
                            } catch (e) {
                                if (operation == '==') {
                                    return Bool.False;
                                }
                                if (operation == '!=') {
                                    return Bool.True;
                                }
                                throw e;
                            }
                        } else {
                            op = moreOps[operation];
                        }

                        if (op) {
                            result = op(me.value, other.value);
                        }

                        if (typeof result === 'number') {
                            var units = this.computeUnits(me, other, operation);
                            return new Numeric(result, units.num.length ? units.num[0] : null, units.num, units.den);
                        }

                        return new Bool(result);
                    }
                }, {
                    key: "computeUnits",
                    value: function computeUnits(left, right, op) {
                        switch (op) {
                            case '*':
                                return {
                                    num: left.numeratorUnits.slice().concat(right.numeratorUnits),
                                    den: left.denominatorUnits.slice().concat(right.denominatorUnits)
                                };
                            case '/':
                                return {
                                    num: left.numeratorUnits.slice().concat(right.denominatorUnits),
                                    den: left.denominatorUnits.slice().concat(right.numeratorUnits)
                                };
                            default:
                                return {
                                    num: left.numeratorUnits,
                                    den: left.denominatorUnits
                                };
                        }
                    }
                }, {
                    key: "coerceUnits",
                    value: function coerceUnits(units, denominatorUnits) {
                        var value = this.value;
                        if (!this.unitless()) {
                            value = value * this.coercionFactor(this.numeratorUnits, units) / this.coercionFactor(this.denominatorUnits, denominatorUnits);
                        }
                        return new Numeric(value, units && units[0], units, denominatorUnits);
                    }
                }, {
                    key: "coercionFactor",
                    value: function coercionFactor(units, otherUnits) {
                        var res = this.removeCommonUnits(units, otherUnits),
                            fromUnits = res.num,
                            toUnits = res.den;

                        if (fromUnits.length !== toUnits.length || !this.convertable(fromUnits || toUnits)) {
                            Fashion.raise('Incompatible units: ' + fromUnits.join('*') + ' and ' + toUnits.join('*'));
                        }

                        for (var i = 0; i < fromUnits.length; i++) {
                            var fromUnit = fromUnits[i];
                            for (var j = 0; j < toUnits.length; j++) {
                                var toUnit = toUnits[j],
                                    factor = this.conversionFactor(fromUnit, toUnit);

                                if (factor !== null) {
                                    return factor;
                                }
                            }
                        }

                        return 1;
                    }
                }, {
                    key: "conversionFactor",
                    value: function conversionFactor(fromUnit, toUnit) {
                        var cUnits = Numeric.CONVERTABLE_UNITS,
                            cTable = Numeric.CONVERSION_TABLE,
                            factor = null;

                        if (cUnits[fromUnit]) {
                            if (cUnits[toUnit]) {
                                factor = cTable[cUnits[fromUnit]][cUnits[toUnit]];
                            }
                        }

                        if (factor === null && cUnits[toUnit]) {
                            if (cUnits[fromUnit]) {
                                factor = 1.0 / cTable[cUnits[toUnit]][cUnits[fromUnit]];
                            }
                        }

                        return factor;
                    }
                }, {
                    key: "convertable",
                    value: function convertable(units) {
                        if (units && !Array.isArray(units)) {
                            units = [units];
                        }

                        if (units && units.length) {
                            var convertableUnits = Numeric.CONVERTABLE_UNITS;
                            for (var i = 0; i < units.length; i++) {
                                if (convertableUnits[units[i]] === undefined) {
                                    return false;
                                }
                            }
                        }
                        return true;
                    }
                }, {
                    key: "removeCommonUnits",
                    value: function removeCommonUnits(numUnits, denUnits) {
                        var map = {},
                            num = [],
                            den = [],
                            i,
                            unit,
                            unit;

                        for (i = 0; i < numUnits.length; i++) {
                            unit = numUnits[i];
                            map[unit] = (map[unit] || 0) + 1;
                        }

                        for (i = 0; i < denUnits.length; i++) {
                            unit = denUnits[i];
                            map[unit] = (map[unit] || 0) - 1;
                        }

                        for (i = 0; i < numUnits.length; i++) {
                            unit = numUnits[i];
                            if (map[unit] > 0) {
                                num.push(unit);
                                map[unit]--;
                            }
                        }

                        for (i = 0; i < denUnits.length; i++) {
                            unit = denUnits[i];
                            if (map[unit] < 0) {
                                den.push(unit);
                                map[unit]++;
                            }
                        }

                        return {
                            num: num,
                            den: den
                        };
                    }
                }], [{
                    key: "tryGetNumber",
                    value: function tryGetNumber(value) {
                        if (/^\d*$/.test(value)) {
                            value = parseFloat(value);
                        }

                        if (!isNaN(value)) {
                            return new Numeric(value);
                        }

                        return undefined;
                    }
                }, {
                    key: "tryCoerce",
                    value: function tryCoerce(obj) {
                        if (obj.$isFashionNumber) {
                            return obj;
                        }

                        if (obj.$isFashionLiteral) {
                            return this.tryGetNumber(obj.value);
                        }

                        return undefined;
                    }
                }]);

                return Numeric;
            }(Type);

            Fashion.apply(Numeric, {
                OPERATIONS: {
                    '!=': function _(l, r) {
                        return l != r;
                    },
                    '+': function _(l, r) {
                        return l + r;
                    },
                    '-': function _(l, r) {
                        return l - r;
                    },
                    '<=': function _(l, r) {
                        return l <= r;
                    },
                    '<': function _(l, r) {
                        return l < r;
                    },
                    '>': function _(l, r) {
                        return l > r;
                    },
                    '>=': function _(l, r) {
                        return l >= r;
                    },
                    '==': function _(l, r) {
                        return l == r;
                    },
                    '%': function _(l, r) {
                        return Math.abs(l % r);
                    }
                },

                NON_COERCE_OPERATIONS: {
                    '*': function _(l, r) {
                        return l * r;
                    },
                    '**': function _(l, r) {
                        return Math.pow(l, r);
                    },
                    '/': function _(l, r) {
                        return l / r;
                    }
                },

                CONVERTABLE_UNITS: {
                    'in': 0,
                    'cm': 1,
                    'pc': 2,
                    'mm': 3,
                    'pt': 4,
                    'px': 5
                },

                CONVERSION_TABLE: [[1, 2.54, 6, 25.4, 72, 96], // in
                [null, 1, 2.36220473, 10, 28.3464567, 37.795276], // cm
                [null, null, 1, 4.23333333, 12, 16], // pc
                [null, null, null, 1, 2.83464567, 3.7795276], // mm
                [null, null, null, null, 1, 1.3333333], // pt
                [null, null, null, null, null, 1] // px
                ]
            });

            Fashion.apply(Numeric.prototype, {
                type: 'number',
                $isFashionNumber: true,
                value: undefined,
                unit: undefined,

                numeratorUnits: undefined,
                denominatorUnits: undefined,
                normalized: false
            });

            module.exports = Numeric;
        }, { "../Base.js": 3, "./Bool.js": 8, "./Literal.js": 16, "./Type.js": 24 }], 19: [function (require, module, exports) {
            /*
             * Copyright (c) 2012-2016. Sencha Inc.
             */

            "use strict";

            var Fashion = require('../Base.js');
            var Type = require('./Type.js');

            var ParentheticalExpression = function (_Type9) {
                _inherits(ParentheticalExpression, _Type9);

                function ParentheticalExpression(value) {
                    _classCallCheck(this, ParentheticalExpression);

                    var _this15 = _possibleConstructorReturn(this, (ParentheticalExpression.__proto__ || Object.getPrototypeOf(ParentheticalExpression)).call(this));

                    _this15.value = value;
                    return _this15;
                }

                _createClass(ParentheticalExpression, [{
                    key: "toString",
                    value: function toString() {
                        return '(' + (this.value && this.value.toString()) + ')';
                    }
                }, {
                    key: "doVisit",
                    value: function doVisit(visitor) {
                        visitor.parenthetical(this);
                    }
                }]);

                return ParentheticalExpression;
            }(Type);

            Fashion.apply(ParentheticalExpression.prototype, {
                value: null,
                type: 'parenthetical'
            });

            module.exports = ParentheticalExpression;
        }, { "../Base.js": 3, "./Type.js": 24 }], 20: [function (require, module, exports) {
            /*
             * Copyright (c) 2012-2016. Sencha Inc.
             */

            "use strict";

            var Fashion = require('../Base.js');
            var Type = require('./Type.js');

            var RadialGradient = function (_Type10) {
                _inherits(RadialGradient, _Type10);

                function RadialGradient(position, shape, stops) {
                    _classCallCheck(this, RadialGradient);

                    var _this16 = _possibleConstructorReturn(this, (RadialGradient.__proto__ || Object.getPrototypeOf(RadialGradient)).call(this));

                    _this16.position = position;
                    _this16.stops = stops;
                    _this16.shape = shape;
                    return _this16;
                }

                _createClass(RadialGradient, [{
                    key: "doVisit",
                    value: function doVisit(visitor) {
                        visitor.radialgradient(this);
                    }
                }, {
                    key: "descend",
                    value: function descend(visitor) {
                        visitor.visit(this.position);
                        visitor.visit(this.stops);
                        visitor.visit(this.shape);
                    }
                }, {
                    key: "copy",
                    value: function copy() {
                        return new RadialGradient(this.position, this.shape, this.stops);
                    }
                }, {
                    key: "toString",
                    value: function toString() {
                        var string = 'radial-gradient(';

                        if (this.position) {
                            string += this.position + ', ';
                        }

                        if (this.shape) {
                            string += this.shape + ', ';
                        }

                        return string + this.stops + ')';
                    }
                }, {
                    key: "toOriginalWebkitString",
                    value: function toOriginalWebkitString() {
                        var args = [],
                            stops = this.stops.items,
                            ln = stops.length,
                            i;

                        args.push('center 0%');
                        args.push('center 100%');

                        for (i = 0; i < ln; i++) {
                            args.push(stops[i].toOriginalWebkitString());
                        }

                        return '-webkit-gradient(radial, ' + args.join(', ') + ')';
                    }
                }, {
                    key: "supports",
                    value: function supports(prefix) {
                        return ['owg', 'webkit'].indexOf(prefix.toLowerCase()) !== -1;
                    }
                }, {
                    key: "toPrefixedString",
                    value: function toPrefixedString(prefix) {
                        if (prefix === 'owg') {
                            return this.toOriginalWebkitString();
                        }
                        return prefix + this.toString();
                    }
                }, {
                    key: "gradientPoints",
                    value: function gradientPoints(position) {
                        //position = (position.type === 'list') ? position.clone() : new Fashion.List([position]);
                        //console.log('gradientpoints', position);
                    }
                }]);

                return RadialGradient;
            }(Type);

            Fashion.apply(RadialGradient.prototype, {
                type: 'radialgradient',
                $isFashionRadialGradient: true,
                $canUnbox: false,
                position: null,
                stops: null,
                shape: null
            });

            module.exports = RadialGradient;
        }, { "../Base.js": 3, "./Type.js": 24 }], 21: [function (require, module, exports) {
            "use strict";

            var Fashion = require('../Base.js');
            var TypeVisitor = require('./TypeVisitor.js');
            var Output = require('../Output.js');

            var SourceBuilder = function (_TypeVisitor) {
                _inherits(SourceBuilder, _TypeVisitor);

                function SourceBuilder(cfg) {
                    _classCallCheck(this, SourceBuilder);

                    var _this17 = _possibleConstructorReturn(this, (SourceBuilder.__proto__ || Object.getPrototypeOf(SourceBuilder)).call(this, cfg));

                    _this17.nullFound = false;
                    return _this17;
                }

                _createClass(SourceBuilder, [{
                    key: "list",
                    value: function list(obj) {
                        var output = this.output,
                            items = obj.items,
                            len = output.output.length,
                            sep = obj.separator,
                            sepLen = sep && sep.length,
                            hasSpace = sep && sep.indexOf(' ') > -1,
                            prev = output.output,
                            delta;

                        for (var i = 0; i < items.length; i++) {
                            if (items[i] && !items[i].$isFashionNull) {
                                this.visit(items[i]);
                                delta = output.output.length - len;
                                if (!delta && sepLen && i > 0) {
                                    output.output = prev;
                                }
                                prev = output.output;
                                if (i < items.length - 1) {
                                    if (sepLen) {
                                        output.add(sep);
                                        if (!hasSpace) {
                                            output.space();
                                        }
                                    }
                                }
                                len = output.output.length;
                            } else {
                                this.nullFound = true;
                            }
                        }
                    }
                }, {
                    key: "map",
                    value: function map(obj) {
                        var output = this.output,
                            items = obj.items,
                            key,
                            value;

                        if (this.currDeclaration) {
                            Fashion.raise('(' + obj.toString() + ") isn't a valid CSS value.");
                        }

                        for (var i = 0; i < items.length - 1; i += 2) {
                            key = items[i];
                            value = items[i + 1];
                            if (key && value) {
                                if (i > 0) {
                                    output.add(',');
                                    output.space();
                                }

                                this.visit(key);
                                output.add(': ');
                                //output.space();
                                this.visit(value);
                            }
                        }
                    }
                }, {
                    key: "literal",
                    value: function literal(obj) {
                        obj.value && this.output.add(obj.value);
                    }
                }, {
                    key: "string",
                    value: function string(obj) {
                        var output = this.output;
                        output.add(obj.quoteChar);
                        output.add(obj.value);
                        output.add(obj.quoteChar);
                    }
                }, {
                    key: "functioncall",
                    value: function functioncall(obj) {
                        var output = this.output;
                        output.add(obj.name);
                        output.add('(');
                        this.visit(obj.args);
                        output.add(')');
                    }
                }, {
                    key: "parenthetical",
                    value: function parenthetical(obj) {
                        this.output.add('(');
                        this.visit(obj.value);
                        this.output.add(')');
                    }
                }, {
                    key: "number",
                    value: function number(obj) {
                        var val = obj.stringify();
                        if (val.indexOf('.') === '.' && !this.output.isCompressed) {
                            val = "0" + val;
                        }
                        this.output.add(val);
                    }
                }, {
                    key: "bool",
                    value: function bool(obj) {
                        this.output.add(obj.value ? 'true' : 'false');
                    }
                }, {
                    key: "hsla",
                    value: function hsla(obj) {
                        this.output.add(obj.toString());
                    }
                }, {
                    key: "rgba",
                    value: function rgba(obj) {
                        this.output.add(obj.toString());
                    }
                }, {
                    key: "colorstop",
                    value: function colorstop(obj) {
                        var output = this.output,
                            stop = obj.stop;

                        this.visit(obj.color);

                        if (stop) {
                            stop = stop.clone();
                            output.add(' ');
                            if (!stop.unit) {
                                stop.value *= 100;
                                stop.unit = '%';
                            }
                            this.visit(stop);
                        }
                    }
                }, {
                    key: "lineargradient",
                    value: function lineargradient(obj) {
                        var output = this.output;
                        output.add("linear-gradient(");
                        if (obj.position) {
                            this.visit(obj.position);
                            output.add(',');
                            output.space();
                        }
                        this.visit(obj.stops);
                        output.add(')');
                    }
                }, {
                    key: "radialgradient",
                    value: function radialgradient(obj) {
                        var output = this.output;
                        output.add("radial-gradient(");
                        if (obj.position) {
                            this.visit(obj.position);
                            output.add(',');
                            output.space();
                        }
                        if (obj.shape) {
                            this.visit(obj.shape);
                            output.add(',');
                            output.space();
                        }
                        this.visit(obj.stops);
                        output.add(')');
                    }
                }, {
                    key: "toSource",
                    value: function toSource(obj, output) {
                        this.output = output || new Output();
                        this.visit(obj);
                        return this.output.get();
                    }
                }], [{
                    key: "toSource",
                    value: function toSource(obj, output) {
                        var sb = new SourceBuilder();
                        return sb.toSource(obj, output);
                    }
                }]);

                return SourceBuilder;
            }(TypeVisitor);

            Fashion.apply(SourceBuilder.prototype, {
                output: null
            });

            module.exports = SourceBuilder;
        }, { "../Base.js": 3, "../Output.js": 4, "./TypeVisitor.js": 25 }], 22: [function (require, module, exports) {
            "use strict";

            var Fashion = require('../Base.js');
            var Type = require('./Type.js');
            var Text = require('./Text.js');
            var Numeric = require('./Numeric.js');

            var Bool = require('./Bool.js'),
                True = Bool.True,
                False = Bool.False;

            var Literal = require('./Literal.js'),
                Null = Literal.Null;

            module.exports = {
                unboxType: function unboxType(expression) {
                    var val = expression;
                    if (val && val.$isFashionType && val.$canUnbox) {
                        val = val.value;
                        if (expression.$isFashionString || expression.$isFashionLiteral) {
                            if (val === 'none' || val === 'null') {
                                val = null;
                            }
                        } else if (expression.$isFashionList) {
                            val = expression.items;
                        }
                    }
                    return val;
                },
                boxType: function boxType(expression) {
                    if (expression && expression.$isFashionType) {
                        return expression;
                    }

                    if (expression == null) {
                        // null || undefined
                        return Null;
                    }
                    if (expression === true) {
                        return True;
                    }
                    if (expression === false) {
                        return False;
                    }

                    var typeOf = typeof expression === "undefined" ? "undefined" : _typeof(expression);
                    switch (typeOf) {
                        case 'string':
                            return new Text(expression);
                        case 'number':
                            return new Numeric(expression);
                        default:
                            break;
                    }

                    return expression;
                }
            };

            Fashion.apply(Type, {
                box: module.exports.boxType,
                unbox: module.exports.unboxType
            });
        }, { "../Base.js": 3, "./Bool.js": 8, "./Literal.js": 16, "./Numeric.js": 18, "./Text.js": 23, "./Type.js": 24 }], 23: [function (require, module, exports) {
            /*
             * Copyright (c) 2012-2016. Sencha Inc.
             */

            "use strict";

            var Fashion = require('../Base.js');
            var Literal = require('./Literal.js');

            var Text = function (_Literal2) {
                _inherits(Text, _Literal2);

                function Text(value, quoteChar) {
                    _classCallCheck(this, Text);

                    var _this18 = _possibleConstructorReturn(this, (Text.__proto__ || Object.getPrototypeOf(Text)).call(this, value));

                    if (quoteChar !== undefined) {
                        if (Text.preferDoubleQuotes && quoteChar === '') {
                            _this18.quoteChar = '';
                        } else {
                            _this18.quoteChar = quoteChar;
                        }
                    }
                    return _this18;
                }

                _createClass(Text, [{
                    key: "doVisit",
                    value: function doVisit(visitor) {
                        visitor.string(this);
                    }
                }, {
                    key: "toString",
                    value: function toString() {
                        return this.quoteChar + this.value + this.quoteChar;
                    }
                }, {
                    key: "unquote",
                    value: function unquote() {
                        return new Literal(this.value);
                    }
                }, {
                    key: "copy",
                    value: function copy() {
                        return new Text(this.value, this.quoteChar);
                    }
                }, {
                    key: "slice",
                    value: function slice(start, end) {
                        return new Text(_get(Text.prototype.__proto__ || Object.getPrototypeOf(Text.prototype), "slice", this).call(this, start, end).value, this.quoteChar);
                    }
                }, {
                    key: "toUpperCase",
                    value: function toUpperCase() {
                        return new Text(this.value.toUpperCase(), this.quoteChar);
                    }
                }, {
                    key: "toLowerCase",
                    value: function toLowerCase() {
                        return new Text(this.value.toLowerCase(), this.quoteChar);
                    }
                }, {
                    key: "insert",
                    value: function insert(str, startVal) {
                        return new Text(_get(Text.prototype.__proto__ || Object.getPrototypeOf(Text.prototype), "insert", this).call(this, str, startVal).value, this.quoteChar);
                    }
                }], [{
                    key: "tryCoerce",
                    value: function tryCoerce(obj) {
                        if (obj.$isFashionNumber) {
                            return undefined;
                        }
                        if (obj.$isFashionLiteral) {
                            return new Text(obj.value);
                        }

                        return new Text(obj.getHash());
                    }
                }]);

                return Text;
            }(Literal);

            Text.preferDoubleQuotes = false;

            Fashion.apply(Text.prototype, {
                type: 'string',
                $isFashionString: true,
                value: null,
                quoteChar: '"',

                '+': function _(right) {
                    return new Text(this.value + right.getHash());
                },
                '+.number': function number(right) {
                    return new Text(this.value + right.toString());
                },
                '/': function _(right) {
                    return new Text(this.value + '/' + right.getHash());
                }
            });

            module.exports = Text;
        }, { "../Base.js": 3, "./Literal.js": 16 }], 24: [function (require, module, exports) {
            /*
             * Copyright (c) 2012-2016. Sencha Inc.
             */

            "use strict";

            var Fashion = require('../Base.js');

            var Type = function () {
                function Type() {
                    _classCallCheck(this, Type);
                }

                _createClass(Type, [{
                    key: "coerce",
                    value: function coerce(obj) {
                        var converted = this.tryCoerce(obj);
                        return converted || obj;
                    }
                }, {
                    key: "_getHash",
                    value: function _getHash() {
                        if (this.visitTarget) {
                            return this.visitTarget.toString();
                        }
                        return this.toString();
                    }
                }, {
                    key: "getHash",
                    value: function getHash() {
                        if (this._hash == null) {
                            this._hash = this._getHash();
                        }
                        return this._hash;
                    }
                }, {
                    key: "tryCoerce",
                    value: function tryCoerce(obj) {
                        var me = this;

                        if (me.constructor === obj.constructor) {
                            return obj;
                        }

                        if (me.constructor.tryCoerce) {
                            return me.constructor.tryCoerce(obj);
                        }

                        return undefined;
                    }
                }, {
                    key: "supports",
                    value: function supports(prefix) {
                        return false;
                    }
                }, {
                    key: "operate",
                    value: function operate(operation, right) {
                        return this.performOperation(operation, this.coerce(right));
                    }
                }, {
                    key: "performOperation",
                    value: function performOperation(operation, right) {
                        // check for <op>.<type> name for class-specific impl,
                        // eg, ==.color or +.list
                        var method = this[operation + "." + right.type] || this[operation];

                        if (!method) {
                            Fashion.raise("Failed to find method for operation " + operation + " on type " + right.type + " with value " + right + ".");
                        }

                        var res = method.call(this, right);

                        if (!res || !res.$isFashionType) {
                            res = Type.box(res);
                        }

                        return res;
                    }
                }, {
                    key: '==',
                    value: function _(right) {
                        return this.getHash() === right.getHash();
                    }
                }, {
                    key: '!=',
                    value: function _(right) {
                        return this.getHash() !== right.getHash();
                    }
                }, {
                    key: '>=',
                    value: function _(right) {
                        return this.getHash() >= right.getHash();
                    }
                }, {
                    key: '<=',
                    value: function _(right) {
                        return this.getHash() <= right.getHash();
                    }
                }, {
                    key: '>',
                    value: function _(right) {
                        return this.getHash() > right.getHash();
                    }
                }, {
                    key: '<',
                    value: function _(right) {
                        return this.getHash() < right.getHash();
                    }
                }, {
                    key: '+',
                    value: function _(right) {
                        return this.getHash() + right.getHash();
                    }
                }, {
                    key: "copy",
                    value: function copy() {
                        return this;
                    }
                }, {
                    key: "matches",
                    value: function matches(match) {
                        if (match && match == this.toString()) {
                            return true;
                        }
                        return false;
                    }
                }, {
                    key: "clone",
                    value: function clone(match, replace) {
                        if (replace && this.matches(match)) {
                            return replace.copy();
                        }
                        var copy = this.copy();
                        copy.ast = this.ast;
                        copy.$referenceName = this.$referenceName;
                        copy.$referenceBase = this.$referenceBase;
                        copy.$previousReference = this.$previousReference;
                        return copy;
                    }
                }, {
                    key: "unquote",
                    value: function unquote() {
                        return this;
                    }
                }, {
                    key: "toPrefixedString",
                    value: function toPrefixedString(prefix) {
                        return this.toString();
                    }
                }, {
                    key: "doVisit",
                    value: function doVisit(visitor) {}
                }, {
                    key: "descend",
                    value: function descend(visitoir) {}

                    /**
                     * A mechanism that enables searching upwards in the type tree for comments with a
                     * particular control tag.  The search begins locally first on the specified node,
                     * and continues upwards until either an enable or disable tag is specified, or the
                     * the root of the tree is reached with no tags specified.
                     *
                     * By testing for both positive and negative matches locally, features can be enabled
                     * or disabled at specific points, potentially overriding state set at a more
                     * generic scope.  Ex:
                     *
                     *      //# fashion -ingline
                     *      @font-face {
                     *          src: url(foo.eot);
                     *          src: url(foo.svg);
                     *          //# fashion +inline
                     *          src: url(foo.ttf);
                     *      }
                     *
                     * @param tag The tag to search for.
                     * @param prefix An optional prefix, such as 'fashion warn'.  Defaults to 'fashion'
                     * @param enable A regex indicating a match for the enable state (+tag).
                     * @param disable A regex indicating a match for the disable state (-tag)
                     * @returns {any} true for enable | false for disable | null for unspecified
                     */

                }, {
                    key: "hasTag",
                    value: function hasTag(tag, prefix, enable, disable) {
                        prefix = prefix || "fashion";
                        enable = enable || new RegExp('^\\s*//#\\s*' + prefix + '\\s*\\+?' + tag + "\s*$");
                        disable = disable || new RegExp('^\\s*//#\\s*' + prefix + '\\s*\\-' + tag + '\\s*$');
                        var docs = this.docs;
                        if (docs && docs.length) {
                            for (var d = 0; d < this.docs.length; d++) {
                                var doc = docs[d];
                                if (enable.test(doc)) {
                                    return true;
                                }
                                if (disable.test(doc)) {
                                    return false;
                                }
                            }
                        }

                        if (this.parentNode) {
                            return this.parentNode.hasTag(tag, prefix, enable, disable);
                        }

                        return null;
                    }
                }, {
                    key: "toDisplayString",
                    value: function toDisplayString() {
                        return '[' + this.constructor.name + ' : ' + this.toString() + ']';
                    }
                }]);

                return Type;
            }();

            Fashion.apply(Type.prototype, {
                visitTarget: undefined,
                $isFashionType: true,
                $canUnbox: true,

                $isFashionLiteral: false,
                $isFashionNumber: false,
                $isFashionString: false,
                $isFashionBool: false,

                $constant: false,

                /**
                 * if this value is a global variable, this field will store the global
                 * variable name by which this value is referenced.
                 */
                $referenceName: undefined,

                $referenceBase: undefined,
                $previousReference: undefined,

                value: undefined,
                unit: undefined,
                parentNode: undefined,
                docs: undefined,
                ast: undefined
            });

            module.exports = Type;
        }, { "../Base.js": 3 }], 25: [function (require, module, exports) {
            "use strict";

            var Fashion = require('../Base.js');

            var TypeVisitor = function () {
                function TypeVisitor(cfg) {
                    _classCallCheck(this, TypeVisitor);

                    if (cfg) {
                        Fashion.apply(this, cfg);
                    }
                }

                _createClass(TypeVisitor, [{
                    key: "literal",
                    value: function literal(obj) {
                        obj.descend(this);
                    }
                }, {
                    key: "bool",
                    value: function bool(obj) {
                        obj.descend(this);
                    }
                }, {
                    key: "string",
                    value: function string(obj) {
                        obj.descend(this);
                    }
                }, {
                    key: "number",
                    value: function number(obj) {
                        obj.descend(this);
                    }
                }, {
                    key: "map",
                    value: function map(obj) {
                        obj.descend(this);
                    }
                }, {
                    key: "functioncall",
                    value: function functioncall(obj) {
                        obj.descend(this);
                    }
                }, {
                    key: "parenthetical",
                    value: function parenthetical(obj) {
                        obj.descend(this);
                    }
                }, {
                    key: "list",
                    value: function list(obj) {
                        obj.descend(this);
                    }
                }, {
                    key: "hsla",
                    value: function hsla(obj) {
                        obj.descend(this);
                    }
                }, {
                    key: "rgba",
                    value: function rgba(obj) {
                        obj.descend(this);
                    }
                }, {
                    key: "colorstop",
                    value: function colorstop(obj) {
                        obj.descend(this);
                    }
                }, {
                    key: "lineargradient",
                    value: function lineargradient(obj) {
                        obj.descend(this);
                    }
                }, {
                    key: "radialgradient",
                    value: function radialgradient(obj) {
                        obj.descend(this);
                    }
                }, {
                    key: "visitItem",
                    value: function visitItem(obj) {
                        obj.doVisit(this);
                    }
                }, {
                    key: "visit",
                    value: function visit(obj) {
                        while (obj && obj.visitTarget !== undefined) {
                            obj = obj.visitTarget;
                        }
                        if (obj) {
                            if (Array.isArray(obj)) {
                                for (var i = 0; i < obj.length; i++) {
                                    this.visit(obj[i]);
                                }
                            } else {
                                this.visitItem(obj);
                            }
                        }
                    }

                    /**
                     * this is an extension point for allowing overrides of the entry visit method
                     * when called duing the post-processing mechanism in CSS.ts
                     * @param obj
                     */

                }, {
                    key: "execute",
                    value: function execute(obj, context) {
                        this.visit(obj);
                    }
                }]);

                return TypeVisitor;
            }();

            TypeVisitor.prototype.context = null;

            module.exports = TypeVisitor;
        }, { "../Base.js": 3 }], 26: [function (require, module, exports) {
            "use strict";

            var Bool = require('./Bool.js');
            var Literal = require('./Literal.js');

            var Types = {
                Bool: Bool,
                Literal: Literal,
                Text: require('./Text.js'),
                Numeric: require('./Numeric.js'),
                Color: require('./Color.js'),
                ColorRGBA: require('./ColorRGBA.js'),
                ColorHSLA: require('./ColorHSLA.js'),
                ColorStop: require('./ColorStop.js'),
                LinearGradient: require('./LinearGradient.js'),
                RadialGradient: require('./RadialGradient.js'),
                List: require('./List.js'),
                Map: require('./Map.js'),
                ParentheticalExpression: require('./ParentheticalExpression.js'),
                FunctionCall: require('./FunctionCall.js'),
                Null: Literal.Null,
                None: Literal.None,
                True: Bool.True,
                False: Bool.False
            };

            module.exports = Types;
        }, { "./Bool.js": 8, "./Color.js": 9, "./ColorHSLA.js": 10, "./ColorRGBA.js": 11, "./ColorStop.js": 12, "./FunctionCall.js": 13, "./LinearGradient.js": 14, "./List.js": 15, "./Literal.js": 16, "./Map.js": 17, "./Numeric.js": 18, "./ParentheticalExpression.js": 19, "./RadialGradient.js": 20, "./Text.js": 23 }] }, {}, [1])(1);
});
(function(Fashion){
	var __udf = undefined,
	    Types = Fashion.Types,
	    __strings = {
    _: "$color",
    $: "$color_name",
    A: "$colorLookup",
    a: "$color_variant"
},

	    __names = Fashion.css.buildNames(__strings),

	    __jsNames = Fashion.css.buildJsNames(__strings);
var Bool = Types.Bool,
    __Bool = Bool,
    Literal = Types.Literal,
    __Literal = Literal,
    Text = Types.Text,
    __Text = Text,
    Numeric = Types.Numeric,
    __Numeric = Numeric,
    Color = Types.Color,
    __Color = Color,
    ColorRGBA = Types.ColorRGBA,
    __ColorRGBA = ColorRGBA,
    ColorHSLA = Types.ColorHSLA,
    __ColorHSLA = ColorHSLA,
    ColorStop = Types.ColorStop,
    __ColorStop = ColorStop,
    LinearGradient = Types.LinearGradient,
    __LinearGradient = LinearGradient,
    RadialGradient = Types.RadialGradient,
    __RadialGradient = RadialGradient,
    List = Types.List,
    __List = List,
    Map = Types.Map,
    __Map = Map,
    ParentheticalExpression = Types.ParentheticalExpression,
    __ParentheticalExpression = ParentheticalExpression,
    FunctionCall = Types.FunctionCall,
    __FunctionCall = FunctionCall,
    Null = Types.Null,
    __Null = Null,
    None = Types.None,
    __None = None,
    True = Types.True,
    __True = True,
    False = Types.False,
    __False = False,
    Ruleset = Types.Ruleset,
    __Ruleset = Ruleset,
    Declaration = Types.Declaration,
    __Declaration = Declaration,
    SelectorPart = Types.SelectorPart,
    __SelectorPart = SelectorPart,
    CompoundSelector = Types.CompoundSelector,
    __CompoundSelector = CompoundSelector,
    MultiPartSelector = Types.MultiPartSelector,
    __MultiPartSelector = MultiPartSelector,
    SelectorList = Types.SelectorList,
    __SelectorList = SelectorList,
    SelectorProperty = Types.SelectorProperty,
    __SelectorProperty = SelectorProperty;

	Fashion.css.register(function(__rt) {
__rt.register({
    rgb:  function (red, green, blue, color) {
                return this.rgba(red, green, blue, new Numeric(1), color);
            },
    rgba:  function (red, green, blue, alpha, color) {
                var colorInst;

                if (!!red && !!color) {
                    Fashion.raise("Unsupported arguments to RGBA");
                }

                if (color && !red) {
                    if (color.$isFashionColor) {
                        colorInst = color;
                    } else {
                        Fashion.raise("Unsupported arguments to RGBA");
                    }
                } else if (red && red.$isFashionColor) {
                    colorInst = red;
                }

                if (colorInst) {
                    alpha = green || alpha;
                    colorInst = colorInst.getRGBA();
                    red = new Numeric(colorInst.r);
                    green = new Numeric(colorInst.g);
                    blue = new Numeric(colorInst.b);
                }

                if (!red || !red.$isFashionNumber) {
                    if (red == null || red.$isFashionNull) {
                        return Literal.Null;
                    }
                    Fashion.raise(red + ' is not a number for \'rgba\' red');
                }
                if (!green || !green.$isFashionNumber) {
                    if (green == null || green.$isFashionNull) {
                        return Literal.Null;
                    }
                    Fashion.raise(green + ' is not a number for \'rgba\' green');
                }
                if (!blue || !blue.$isFashionNumber) {
                    if (blue == null || blue.$isFashionNull) {
                        return Literal.Null;
                    }
                    Fashion.raise(blue + ' is not a number for \'rgba\' blue');
                }
                if (!alpha || !alpha.$isFashionNumber) {
                    if (alpha == null || alpha.$isFashionNull) {
                        return Literal.Null;
                    }
                    Fashion.raise(alpha + ' is not a number for \'rgba\' alpha');
                }

                if (red.unit == '%') {
                    red = new Numeric(Color.constrainPercentage(red.value) / 100 * 255);
                } else if (red.value !== Color.constrainChannel(red.value)) {
                    Fashion.raise('Color value ' + red + ' must be between 0 and 255 inclusive for \'rgba\'');
                }

                if (green.unit == '%') {
                    green = new Numeric(Color.constrainPercentage(green.value) / 100 * 255);
                } else if (green.value !== Color.constrainChannel(green.value)) {
                    Fashion.raise('Color value ' + green + ' must be between 0 and 255 inclusive for \'rgba\'');
                }

                if (blue.unit == '%') {
                    blue = new Numeric(Color.constrainPercentage(blue.value) / 100 * 255);
                } else if (blue.value !== Color.constrainChannel(blue.value)) {
                    Fashion.raise('Color value ' + blue + ' must be between 0 and 255 inclusive for \'rgba\'');
                }

                if (alpha.unit == '%') {
                    alpha = new Numeric(Color.constrainPercentage(alpha.value) / 100);
                } else if (alpha.value !== Color.constrainAlpha(alpha.value)) {
                    Fashion.raise('Alpha channel ' + alpha + ' must be between 0 and 1 inclusive for \'rgba\'');
                }

                return new ColorRGBA(red.value, green.value, blue.value, alpha.value);
            },
    lighten:  function (color, amount) {
                if (color == null || color.$isFashionNull) {
                    return Literal.Null;
                }
                if (color.type !== 'hsla' && color.type !== 'rgba') {
                    Fashion.raise(color + ' is not a color for \'lighten\'');
                }
                if (amount.type !== 'number') {
                    Fashion.raise(amount + ' is not a number for \'lighten\'');
                }
                if (amount.value !== Color.constrainPercentage(amount.value)) {
                    Fashion.raise('Amount ' + amount + ' must be between 0% and 100% for \'lighten\'');
                }

                return Color.adjust(color, 'lightness', amount);
            },
    map_get:  function (map, key) {
                return map.get(key);
            },
    mix:  function (color_1, color_2, weight) {
                if (color_1 == null || color_1.$isFashionNull) {
                    return Literal.Null;
                }
                if (color_2 == null || color_2.$isFashionNull) {
                    return Literal.Null;
                }
                
                weight = (weight !== undefined) ? weight : new Numeric(50, '%');

                if (color_1.type !== 'hsla' && color_1.type !== 'rgba') {
                    Fashion.raise('arg 1 ' + color_1 + ' is not a color for \'mix\'');
                }
                if (color_2.type !== 'hsla' && color_2.type !== 'rgba') {
                    Fashion.raise('arg 2 ' + color_2 + ' is not a color for \'mix\'');
                }
                if (weight.type !== 'number') {
                    Fashion.raise('arg 3 ' + weight + ' is not a number for \'mix\'');
                }
                if (weight.value !== Color.constrainPercentage(weight.value)) {
                    Fashion.raise('Weight ' + weight + ' must be between 0% and 100% for \'mix\'');
                }

                color_1 = color_1.getRGBA();
                color_2 = color_2.getRGBA();

                weight = weight.value / 100;

                var factor = (weight * 2) - 1,
                    alpha = color_1.a - color_2.a,
                    weight1 = (((factor * alpha == -1) ? factor : (factor + alpha) / (1 + factor * alpha)) + 1) / 2,
                    weight2 = 1 - weight1;

                return new ColorRGBA(
                    (weight1 * color_1.r) + (weight2 * color_2.r),
                    (weight1 * color_1.g) + (weight2 * color_2.g),
                    (weight1 * color_1.b) + (weight2 * color_2.b),
                    (weight * color_1.a) + ((1 - weight) * color_2.a)
                );
            }
});
var __rt_constructor = __rt.constructor.bind(__rt),
    __rt_bool = __rt.bool.bind(__rt),
    __rt_color = __rt.color.bind(__rt),
    __rt_quote = __rt.quote.bind(__rt),
    __rt_unquote = __rt.unquote.bind(__rt),
    __rt_not = __rt.not.bind(__rt),
    __rt_operate = __rt.operate.bind(__rt),
    __rt_reset = __rt.reset.bind(__rt),
    __rt_run = __rt.run.bind(__rt),
    __rt_createTypesBlock = __rt.createTypesBlock.bind(__rt),
    __rt_createMethodBlock = __rt.createMethodBlock.bind(__rt),
    __rt_createPropertyBlock = __rt.createPropertyBlock.bind(__rt),
    __rt_createPrefixedFunctionBody = __rt.createPrefixedFunctionBody.bind(__rt),
    __rt_createWrappedFn = __rt.createWrappedFn.bind(__rt),
    __rt_callWrappedFn = __rt.callWrappedFn.bind(__rt),
    __rt_compile = __rt.compile.bind(__rt),
    __rt_execute = __rt.execute.bind(__rt),
    __rt_load = __rt.load.bind(__rt),
    __rt_registerProcessor = __rt.registerProcessor.bind(__rt),
    __rt_register = __rt.register.bind(__rt),
    __rt_isRegistered = __rt.isRegistered.bind(__rt),
    __rt_getGlobalScope = __rt.getGlobalScope.bind(__rt),
    __rt_getCurrentScope = __rt.getCurrentScope.bind(__rt),
    __rt_getRegisteredFunctions = __rt.getRegisteredFunctions.bind(__rt),
    __rt_getFunctions = __rt.getFunctions.bind(__rt),
    __rt_getMixins = __rt.getMixins.bind(__rt),
    __rt_createScope = __rt.createScope.bind(__rt),
    __rt_pushScope = __rt.pushScope.bind(__rt),
    __rt_popScope = __rt.popScope.bind(__rt),
    __rt_createCallStackScope = __rt.createCallStackScope.bind(__rt),
    __rt_pushCallStackScope = __rt.pushCallStackScope.bind(__rt),
    __rt_popCallStackScope = __rt.popCallStackScope.bind(__rt),
    __rt_getCallStack = __rt.getCallStack.bind(__rt),
    __rt_pushSourceInfo = __rt.pushSourceInfo.bind(__rt),
    __rt_getSourceInfo = __rt.getSourceInfo.bind(__rt),
    __rt_get = __rt.get.bind(__rt),
    __rt_getScopeForName = __rt.getScopeForName.bind(__rt),
    __rt_getDefault = __rt.getDefault.bind(__rt),
    __rt_getGlobalDefault = __rt.getGlobalDefault.bind(__rt),
    __rt_getLocalDefault = __rt.getLocalDefault.bind(__rt),
    __rt_setGlobal = __rt.setGlobal.bind(__rt),
    __rt_setDynamic = __rt.setDynamic.bind(__rt),
    __rt_setScoped = __rt.setScoped.bind(__rt),
    __rt_set = __rt.set.bind(__rt),
    __rt_getDocs = __rt.getDocs.bind(__rt),
    __rt_getString = __rt.getString.bind(__rt),
    __rt_getAstNode = __rt.getAstNode.bind(__rt),
    __rt_applySpread = __rt.applySpread.bind(__rt),
    __rt_sliceArgs = __rt.sliceArgs.bind(__rt),
    __rt_applySpreadArgs = __rt.applySpreadArgs.bind(__rt),
    __rt_warn = __rt.warn.bind(__rt),
    __rt_error = __rt.error.bind(__rt),
    __rt_debug = __rt.debug.bind(__rt),
    __rt_setCaches = __rt.setCaches.bind(__rt),
    __rt_copyRuntimeState = __rt.copyRuntimeState.bind(__rt),
    __rt_test = __rt.test.bind(__rt),
    __rt_and = __rt.and.bind(__rt),
    __rt_or = __rt.or.bind(__rt),
    __rt_box = __rt.box.bind(__rt),
    __rt_unbox = __rt.unbox.bind(__rt),
    __rt_Scope = __rt.Scope.bind(__rt),
    __rt_constructor = __rt.constructor.bind(__rt),
    __rt___defineGetter__ = __rt.__defineGetter__.bind(__rt),
    __rt___defineSetter__ = __rt.__defineSetter__.bind(__rt),
    __rt_hasOwnProperty = __rt.hasOwnProperty.bind(__rt),
    __rt___lookupGetter__ = __rt.__lookupGetter__.bind(__rt),
    __rt___lookupSetter__ = __rt.__lookupSetter__.bind(__rt),
    __rt_propertyIsEnumerable = __rt.propertyIsEnumerable.bind(__rt),
    __rt_constructor = __rt.constructor.bind(__rt),
    __rt_toString = __rt.toString.bind(__rt),
    __rt_toLocaleString = __rt.toLocaleString.bind(__rt),
    __rt_valueOf = __rt.valueOf.bind(__rt),
    __rt_isPrototypeOf = __rt.isPrototypeOf.bind(__rt);
var __rt_context = __rt.context,
    __rt_mixins = __rt.mixins,
    __rt_functions = __rt.functions,
    __rt_processors = __rt.processors,
    __rt_registered = __rt.registered,
    __rt_deferredContent = __rt.deferredContent,
    __rt_registerSelectorHooks = __rt.registerSelectorHooks,
    __rt_registerAtRuleHook = __rt.registerAtRuleHook,
    __rt_registerStyleHooks = __rt.registerStyleHooks,
    __rt_registerFunctionCallHooks = __rt.registerFunctionCallHooks,
    __rt_docCache = __rt.docCache,
    __rt_stringCache = __rt.stringCache,
    __rt_nodeCache = __rt.nodeCache,
    __rt_code = __rt.code,
    __rt_fn = __rt.fn,
    __rt__currentScope = __rt._currentScope,
    __rt__currentCallStackScope = __rt._currentCallStackScope,
    __rt__globalScope = __rt._globalScope,
    __rt__dynamics = __rt._dynamics,
    __rt_css = __rt.css,
    __rt_rulesets = __rt.rulesets,
    __rt_extenders = __rt.extenders,
    __rt__scopeStack = __rt._scopeStack;
Fashion.apply(__rt.functions, {
    material_color:  function ($color_name, $color_variant) {
    __rt_createScope(__rt_functions.material_color && __rt_functions.material_color.createdScope);
    var $color_name = $color_name || __Null;
    __rt_set(__strings.$, $color_name, true);
    var $color_variant = $color_variant || new __Text("500", "'");
    __rt_set(__strings.a, $color_variant, true);
    __rt_set(__strings.A, __rt_box(__rt_registered.map_get.apply(__rt.registered, __rt_applySpreadArgs([
        __rt_get("$material_colors"), 
        __rt_get(__strings.$)]))));
    if(__rt_unbox(__rt_get(__strings.A))) {
        __rt_set(__strings._, __rt_box(__rt.registered.map_get.apply(__rt.registered, __rt_applySpreadArgs([
            __rt_get(__strings.A), 
            __rt_get(__strings.a)]))));
        if(__rt_unbox(__rt_get(__strings._))) {
            var $$$r = __rt_get(__strings._);
            __rt_popScope();
            return $$$r;
        }
        else {
            __rt_warn(__rt_unbox(__rt.operate("+",__rt.operate("+",__rt.operate("+",__rt.operate("+",new __Text("=> ERROR: COLOR NOT FOUND! <= | ", "\""), __rt_get(__strings.$)), new __Text(",", "\"")), __rt_get(__strings.a)), new __Text(" combination did not match any of the material design colors.", "\""))));
        }
    }
    else {
        __rt_warn(__rt_unbox(__rt.operate("+",__rt.operate("+",new __Text("=> ERROR: COLOR NOT FOUND! <= | ", "\""), __rt_get(__strings.$)), new __Text(" did not match any of the material design colors.", "\""))));
    }
    var $$$r = __ColorRGBA.fromHex("#ff0000");
    __rt_popScope();
    return $$$r;
},
    material_foreground_color:  function ($color_name) {
    __rt_createScope(__rt_functions.material_foreground_color && __rt_functions.material_foreground_color.createdScope);
    var $color_name = $color_name || __Null;
    __rt_set(__strings.$, $color_name, true);
    __rt_set(__strings._, __rt_box(__rt.registered.map_get.apply(__rt.registered, __rt_applySpreadArgs([
        __rt_get("$material_foreground_colors"), 
        __rt_get(__strings.$)]))));
    if(__rt_unbox(__rt_get(__strings._))) {
        var $$$r = __rt_get(__strings._);
        __rt_popScope();
        return $$$r;
    }
    else {
        __rt_warn(__rt_unbox(__rt.operate("+",__rt.operate("+",new __Text("=> ERROR: COLOR NOT FOUND! <= | ", "\""), __rt_get(__strings.$)), new __Text(" did not match any of the material design colors.", "\""))));
    }
    var $$$r = __ColorRGBA.fromHex("#ff0000");
    __rt_popScope();
    return $$$r;
}
});
},
 function(__rt) {
var __rt_constructor = __rt.constructor.bind(__rt),
    __rt_bool = __rt.bool.bind(__rt),
    __rt_color = __rt.color.bind(__rt),
    __rt_quote = __rt.quote.bind(__rt),
    __rt_unquote = __rt.unquote.bind(__rt),
    __rt_not = __rt.not.bind(__rt),
    __rt_operate = __rt.operate.bind(__rt),
    __rt_reset = __rt.reset.bind(__rt),
    __rt_run = __rt.run.bind(__rt),
    __rt_createTypesBlock = __rt.createTypesBlock.bind(__rt),
    __rt_createMethodBlock = __rt.createMethodBlock.bind(__rt),
    __rt_createPropertyBlock = __rt.createPropertyBlock.bind(__rt),
    __rt_createPrefixedFunctionBody = __rt.createPrefixedFunctionBody.bind(__rt),
    __rt_createWrappedFn = __rt.createWrappedFn.bind(__rt),
    __rt_callWrappedFn = __rt.callWrappedFn.bind(__rt),
    __rt_compile = __rt.compile.bind(__rt),
    __rt_execute = __rt.execute.bind(__rt),
    __rt_load = __rt.load.bind(__rt),
    __rt_registerProcessor = __rt.registerProcessor.bind(__rt),
    __rt_register = __rt.register.bind(__rt),
    __rt_isRegistered = __rt.isRegistered.bind(__rt),
    __rt_getGlobalScope = __rt.getGlobalScope.bind(__rt),
    __rt_getCurrentScope = __rt.getCurrentScope.bind(__rt),
    __rt_getRegisteredFunctions = __rt.getRegisteredFunctions.bind(__rt),
    __rt_getFunctions = __rt.getFunctions.bind(__rt),
    __rt_getMixins = __rt.getMixins.bind(__rt),
    __rt_createScope = __rt.createScope.bind(__rt),
    __rt_pushScope = __rt.pushScope.bind(__rt),
    __rt_popScope = __rt.popScope.bind(__rt),
    __rt_createCallStackScope = __rt.createCallStackScope.bind(__rt),
    __rt_pushCallStackScope = __rt.pushCallStackScope.bind(__rt),
    __rt_popCallStackScope = __rt.popCallStackScope.bind(__rt),
    __rt_getCallStack = __rt.getCallStack.bind(__rt),
    __rt_pushSourceInfo = __rt.pushSourceInfo.bind(__rt),
    __rt_getSourceInfo = __rt.getSourceInfo.bind(__rt),
    __rt_get = __rt.get.bind(__rt),
    __rt_getScopeForName = __rt.getScopeForName.bind(__rt),
    __rt_getDefault = __rt.getDefault.bind(__rt),
    __rt_getGlobalDefault = __rt.getGlobalDefault.bind(__rt),
    __rt_getLocalDefault = __rt.getLocalDefault.bind(__rt),
    __rt_setGlobal = __rt.setGlobal.bind(__rt),
    __rt_setDynamic = __rt.setDynamic.bind(__rt),
    __rt_setScoped = __rt.setScoped.bind(__rt),
    __rt_set = __rt.set.bind(__rt),
    __rt_getDocs = __rt.getDocs.bind(__rt),
    __rt_getString = __rt.getString.bind(__rt),
    __rt_getAstNode = __rt.getAstNode.bind(__rt),
    __rt_applySpread = __rt.applySpread.bind(__rt),
    __rt_sliceArgs = __rt.sliceArgs.bind(__rt),
    __rt_applySpreadArgs = __rt.applySpreadArgs.bind(__rt),
    __rt_warn = __rt.warn.bind(__rt),
    __rt_error = __rt.error.bind(__rt),
    __rt_debug = __rt.debug.bind(__rt),
    __rt_setCaches = __rt.setCaches.bind(__rt),
    __rt_copyRuntimeState = __rt.copyRuntimeState.bind(__rt),
    __rt_test = __rt.test.bind(__rt),
    __rt_and = __rt.and.bind(__rt),
    __rt_or = __rt.or.bind(__rt),
    __rt_box = __rt.box.bind(__rt),
    __rt_unbox = __rt.unbox.bind(__rt),
    __rt_Scope = __rt.Scope.bind(__rt),
    __rt_constructor = __rt.constructor.bind(__rt),
    __rt___defineGetter__ = __rt.__defineGetter__.bind(__rt),
    __rt___defineSetter__ = __rt.__defineSetter__.bind(__rt),
    __rt_hasOwnProperty = __rt.hasOwnProperty.bind(__rt),
    __rt___lookupGetter__ = __rt.__lookupGetter__.bind(__rt),
    __rt___lookupSetter__ = __rt.__lookupSetter__.bind(__rt),
    __rt_propertyIsEnumerable = __rt.propertyIsEnumerable.bind(__rt),
    __rt_constructor = __rt.constructor.bind(__rt),
    __rt_toString = __rt.toString.bind(__rt),
    __rt_toLocaleString = __rt.toLocaleString.bind(__rt),
    __rt_valueOf = __rt.valueOf.bind(__rt),
    __rt_isPrototypeOf = __rt.isPrototypeOf.bind(__rt);
var __rt_context = __rt.context,
    __rt_mixins = __rt.mixins,
    __rt_functions = __rt.functions,
    __rt_processors = __rt.processors,
    __rt_registered = __rt.registered,
    __rt_deferredContent = __rt.deferredContent,
    __rt_registerSelectorHooks = __rt.registerSelectorHooks,
    __rt_registerAtRuleHook = __rt.registerAtRuleHook,
    __rt_registerStyleHooks = __rt.registerStyleHooks,
    __rt_registerFunctionCallHooks = __rt.registerFunctionCallHooks,
    __rt_docCache = __rt.docCache,
    __rt_stringCache = __rt.stringCache,
    __rt_nodeCache = __rt.nodeCache,
    __rt_code = __rt.code,
    __rt_fn = __rt.fn,
    __rt__currentScope = __rt._currentScope,
    __rt__currentCallStackScope = __rt._currentCallStackScope,
    __rt__globalScope = __rt._globalScope,
    __rt__dynamics = __rt._dynamics,
    __rt_css = __rt.css,
    __rt_rulesets = __rt.rulesets,
    __rt_extenders = __rt.extenders,
    __rt__scopeStack = __rt._scopeStack;
__rt_setDynamic("$dark-mode", __rt_getGlobalDefault("$dark_mode") || __False, 0);
__rt_setDynamic("$base-color", __rt_getGlobalDefault("$base_color") || __rt_box(__rt_registered.rgb.apply(__rt.registered, __rt_applySpreadArgs([
    new __Numeric(136), 
    new __Numeric(193), 
    new __Numeric(22), 
    __udf]))), 1);
__rt_setDynamic("$base-dark-color", __rt_getGlobalDefault("$base_dark_color") || __rt_box(__rt.registered.rgba.apply(__rt.registered, __rt_applySpreadArgs([
    new __Numeric(0), 
    new __Numeric(0), 
    new __Numeric(0), 
    new __Numeric(1), 
    __udf]))), 2);
__rt_setDynamic("$base-pressed-color", __rt_getGlobalDefault("$base_pressed_color") || (__rt_test(__rt_get("$dark_mode")) ? __rt_box(__rt.registered.darken.apply(__rt.registered, __rt_applySpreadArgs([
    __rt_get("$base_color"), 
    new __Numeric(15, "%")]))) : __rt_box(__rt.registered.lighten.apply(__rt.registered, __rt_applySpreadArgs([
    __rt_get("$base_color"), 
    new __Numeric(15, "%")])))), 3);
__rt_setDynamic("$base_color_name", __rt_getGlobalDefault("$base_color_name") || new __Text("blue", "'"), 4);
__rt_setDynamic("$material-colors", __rt_getGlobalDefault("$material_colors") || new __Map([new __Text("red", "'"), new __Map([new __Text("50", "'"), __ColorRGBA.fromHex("#ffebee"), new __Text("100", "'"), __ColorRGBA.fromHex("#ffcdd2"), new __Text("200", "'"), __ColorRGBA.fromHex("#ef9a9a"), new __Text("300", "'"), __ColorRGBA.fromHex("#e57373"), new __Text("400", "'"), __ColorRGBA.fromHex("#ef5350"), new __Text("500", "'"), __ColorRGBA.fromHex("#f44336"), new __Text("600", "'"), __ColorRGBA.fromHex("#e53935"), new __Text("700", "'"), __ColorRGBA.fromHex("#d32f2f"), new __Text("800", "'"), __ColorRGBA.fromHex("#c62828"), new __Text("900", "'"), __ColorRGBA.fromHex("#b71c1c"), new __Text("a100", "'"), __ColorRGBA.fromHex("#ff8a80"), new __Text("a200", "'"), __ColorRGBA.fromHex("#ff5252"), new __Text("a400", "'"), __ColorRGBA.fromHex("#ff1744"), new __Text("a700", "'"), __ColorRGBA.fromHex("#d50000")]), new __Text("pink", "'"), new __Map([new __Text("50", "'"), __ColorRGBA.fromHex("#fce4ec"), new __Text("100", "'"), __ColorRGBA.fromHex("#f8bbd0"), new __Text("200", "'"), __ColorRGBA.fromHex("#f48fb1"), new __Text("300", "'"), __ColorRGBA.fromHex("#f06292"), new __Text("400", "'"), __ColorRGBA.fromHex("#ec407a"), new __Text("500", "'"), __ColorRGBA.fromHex("#e91e63"), new __Text("600", "'"), __ColorRGBA.fromHex("#d81b60"), new __Text("700", "'"), __ColorRGBA.fromHex("#c2185b"), new __Text("800", "'"), __ColorRGBA.fromHex("#ad1457"), new __Text("900", "'"), __ColorRGBA.fromHex("#880e4f"), new __Text("a100", "'"), __ColorRGBA.fromHex("#ff80ab"), new __Text("a200", "'"), __ColorRGBA.fromHex("#ff4081"), new __Text("a400", "'"), __ColorRGBA.fromHex("#f50057"), new __Text("a700", "'"), __ColorRGBA.fromHex("#c51162")]), new __Text("purple", "'"), new __Map([new __Text("50", "'"), __ColorRGBA.fromHex("#f3e5f5"), new __Text("100", "'"), __ColorRGBA.fromHex("#e1bee7"), new __Text("200", "'"), __ColorRGBA.fromHex("#ce93d8"), new __Text("300", "'"), __ColorRGBA.fromHex("#ba68c8"), new __Text("400", "'"), __ColorRGBA.fromHex("#ab47bc"), new __Text("500", "'"), __ColorRGBA.fromHex("#9c27b0"), new __Text("600", "'"), __ColorRGBA.fromHex("#8e24aa"), new __Text("700", "'"), __ColorRGBA.fromHex("#7b1fa2"), new __Text("800", "'"), __ColorRGBA.fromHex("#6a1b9a"), new __Text("900", "'"), __ColorRGBA.fromHex("#4a148c"), new __Text("a100", "'"), __ColorRGBA.fromHex("#ea80fc"), new __Text("a200", "'"), __ColorRGBA.fromHex("#e040fb"), new __Text("a400", "'"), __ColorRGBA.fromHex("#d500f9"), new __Text("a700", "'"), __ColorRGBA.fromHex("#aa00ff")]), new __Text("deep-purple", "'"), new __Map([new __Text("50", "'"), __ColorRGBA.fromHex("#ede7f6"), new __Text("100", "'"), __ColorRGBA.fromHex("#d1c4e9"), new __Text("200", "'"), __ColorRGBA.fromHex("#b39ddb"), new __Text("300", "'"), __ColorRGBA.fromHex("#9575cd"), new __Text("400", "'"), __ColorRGBA.fromHex("#7e57c2"), new __Text("500", "'"), __ColorRGBA.fromHex("#673ab7"), new __Text("600", "'"), __ColorRGBA.fromHex("#5e35b1"), new __Text("700", "'"), __ColorRGBA.fromHex("#512da8"), new __Text("800", "'"), __ColorRGBA.fromHex("#4527a0"), new __Text("900", "'"), __ColorRGBA.fromHex("#311b92"), new __Text("a100", "'"), __ColorRGBA.fromHex("#b388ff"), new __Text("a200", "'"), __ColorRGBA.fromHex("#7c4dff"), new __Text("a400", "'"), __ColorRGBA.fromHex("#651fff"), new __Text("a700", "'"), __ColorRGBA.fromHex("#6200ea")]), new __Text("indigo", "'"), new __Map([new __Text("50", "'"), __ColorRGBA.fromHex("#e8eaf6"), new __Text("100", "'"), __ColorRGBA.fromHex("#c5cae9"), new __Text("200", "'"), __ColorRGBA.fromHex("#9fa8da"), new __Text("300", "'"), __ColorRGBA.fromHex("#7986cb"), new __Text("400", "'"), __ColorRGBA.fromHex("#5c6bc0"), new __Text("500", "'"), __ColorRGBA.fromHex("#3f51b5"), new __Text("600", "'"), __ColorRGBA.fromHex("#3949ab"), new __Text("700", "'"), __ColorRGBA.fromHex("#303f9f"), new __Text("800", "'"), __ColorRGBA.fromHex("#283593"), new __Text("900", "'"), __ColorRGBA.fromHex("#1a237e"), new __Text("a100", "'"), __ColorRGBA.fromHex("#8c9eff"), new __Text("a200", "'"), __ColorRGBA.fromHex("#536dfe"), new __Text("a400", "'"), __ColorRGBA.fromHex("#3d5afe"), new __Text("a700", "'"), __ColorRGBA.fromHex("#304ffe")]), new __Text("blue", "'"), new __Map([new __Text("50", "'"), __ColorRGBA.fromHex("#e3f2fd"), new __Text("100", "'"), __ColorRGBA.fromHex("#bbdefb"), new __Text("200", "'"), __ColorRGBA.fromHex("#90caf9"), new __Text("300", "'"), __ColorRGBA.fromHex("#64b5f6"), new __Text("400", "'"), __ColorRGBA.fromHex("#42a5f5"), new __Text("500", "'"), __ColorRGBA.fromHex("#2196f3"), new __Text("600", "'"), __ColorRGBA.fromHex("#1e88e5"), new __Text("700", "'"), __ColorRGBA.fromHex("#1976d2"), new __Text("800", "'"), __ColorRGBA.fromHex("#1565c0"), new __Text("900", "'"), __ColorRGBA.fromHex("#0d47a1"), new __Text("a100", "'"), __ColorRGBA.fromHex("#82b1ff"), new __Text("a200", "'"), __ColorRGBA.fromHex("#448aff"), new __Text("a400", "'"), __ColorRGBA.fromHex("#2979ff"), new __Text("a700", "'"), __ColorRGBA.fromHex("#2962ff")]), new __Text("light-blue", "'"), new __Map([new __Text("50", "'"), __ColorRGBA.fromHex("#e1f5fe"), new __Text("100", "'"), __ColorRGBA.fromHex("#b3e5fc"), new __Text("200", "'"), __ColorRGBA.fromHex("#81d4fa"), new __Text("300", "'"), __ColorRGBA.fromHex("#4fc3f7"), new __Text("400", "'"), __ColorRGBA.fromHex("#29b6f6"), new __Text("500", "'"), __ColorRGBA.fromHex("#03a9f4"), new __Text("600", "'"), __ColorRGBA.fromHex("#039be5"), new __Text("700", "'"), __ColorRGBA.fromHex("#0288d1"), new __Text("800", "'"), __ColorRGBA.fromHex("#0277bd"), new __Text("900", "'"), __ColorRGBA.fromHex("#01579b"), new __Text("a100", "'"), __ColorRGBA.fromHex("#80d8ff"), new __Text("a200", "'"), __ColorRGBA.fromHex("#40c4ff"), new __Text("a400", "'"), __ColorRGBA.fromHex("#00b0ff"), new __Text("a700", "'"), __ColorRGBA.fromHex("#0091ea")]), new __Text("cyan", "'"), new __Map([new __Text("50", "'"), __ColorRGBA.fromHex("#e0f7fa"), new __Text("100", "'"), __ColorRGBA.fromHex("#b2ebf2"), new __Text("200", "'"), __ColorRGBA.fromHex("#80deea"), new __Text("300", "'"), __ColorRGBA.fromHex("#4dd0e1"), new __Text("400", "'"), __ColorRGBA.fromHex("#26c6da"), new __Text("500", "'"), __ColorRGBA.fromHex("#00bcd4"), new __Text("600", "'"), __ColorRGBA.fromHex("#00acc1"), new __Text("700", "'"), __ColorRGBA.fromHex("#0097a7"), new __Text("800", "'"), __ColorRGBA.fromHex("#00838f"), new __Text("900", "'"), __ColorRGBA.fromHex("#006064"), new __Text("a100", "'"), __ColorRGBA.fromHex("#84ffff"), new __Text("a200", "'"), __ColorRGBA.fromHex("#18ffff"), new __Text("a400", "'"), __ColorRGBA.fromHex("#00e5ff"), new __Text("a700", "'"), __ColorRGBA.fromHex("#00b8d4")]), new __Text("teal", "'"), new __Map([new __Text("50", "'"), __ColorRGBA.fromHex("#e0f2f1"), new __Text("100", "'"), __ColorRGBA.fromHex("#b2dfdb"), new __Text("200", "'"), __ColorRGBA.fromHex("#80cbc4"), new __Text("300", "'"), __ColorRGBA.fromHex("#4db6ac"), new __Text("400", "'"), __ColorRGBA.fromHex("#26a69a"), new __Text("500", "'"), __ColorRGBA.fromHex("#009688"), new __Text("600", "'"), __ColorRGBA.fromHex("#00897b"), new __Text("700", "'"), __ColorRGBA.fromHex("#00796b"), new __Text("800", "'"), __ColorRGBA.fromHex("#00695c"), new __Text("900", "'"), __ColorRGBA.fromHex("#004d40"), new __Text("a100", "'"), __ColorRGBA.fromHex("#a7ffeb"), new __Text("a200", "'"), __ColorRGBA.fromHex("#64ffda"), new __Text("a400", "'"), __ColorRGBA.fromHex("#1de9b6"), new __Text("a700", "'"), __ColorRGBA.fromHex("#00bfa5")]), new __Text("green", "'"), new __Map([new __Text("50", "'"), __ColorRGBA.fromHex("#e8f5e9"), new __Text("100", "'"), __ColorRGBA.fromHex("#c8e6c9"), new __Text("200", "'"), __ColorRGBA.fromHex("#a5d6a7"), new __Text("300", "'"), __ColorRGBA.fromHex("#81c784"), new __Text("400", "'"), __ColorRGBA.fromHex("#66bb6a"), new __Text("500", "'"), __ColorRGBA.fromHex("#4caf50"), new __Text("600", "'"), __ColorRGBA.fromHex("#43a047"), new __Text("700", "'"), __ColorRGBA.fromHex("#388e3c"), new __Text("800", "'"), __ColorRGBA.fromHex("#2e7d32"), new __Text("900", "'"), __ColorRGBA.fromHex("#1b5e20"), new __Text("a100", "'"), __ColorRGBA.fromHex("#b9f6ca"), new __Text("a200", "'"), __ColorRGBA.fromHex("#69f0ae"), new __Text("a400", "'"), __ColorRGBA.fromHex("#00e676"), new __Text("a700", "'"), __ColorRGBA.fromHex("#00c853")]), new __Text("light-green", "'"), new __Map([new __Text("50", "'"), __ColorRGBA.fromHex("#f1f8e9"), new __Text("100", "'"), __ColorRGBA.fromHex("#dcedc8"), new __Text("200", "'"), __ColorRGBA.fromHex("#c5e1a5"), new __Text("300", "'"), __ColorRGBA.fromHex("#aed581"), new __Text("400", "'"), __ColorRGBA.fromHex("#9ccc65"), new __Text("500", "'"), __ColorRGBA.fromHex("#8bc34a"), new __Text("600", "'"), __ColorRGBA.fromHex("#7cb342"), new __Text("700", "'"), __ColorRGBA.fromHex("#689f38"), new __Text("800", "'"), __ColorRGBA.fromHex("#558b2f"), new __Text("900", "'"), __ColorRGBA.fromHex("#33691e"), new __Text("a100", "'"), __ColorRGBA.fromHex("#ccff90"), new __Text("a200", "'"), __ColorRGBA.fromHex("#b2ff59"), new __Text("a400", "'"), __ColorRGBA.fromHex("#76ff03"), new __Text("a700", "'"), __ColorRGBA.fromHex("#64dd17")]), new __Text("lime", "'"), new __Map([new __Text("50", "'"), __ColorRGBA.fromHex("#f9fbe7"), new __Text("100", "'"), __ColorRGBA.fromHex("#f0f4c3"), new __Text("200", "'"), __ColorRGBA.fromHex("#e6ee9c"), new __Text("300", "'"), __ColorRGBA.fromHex("#dce775"), new __Text("400", "'"), __ColorRGBA.fromHex("#d4e157"), new __Text("500", "'"), __ColorRGBA.fromHex("#cddc39"), new __Text("600", "'"), __ColorRGBA.fromHex("#c0ca33"), new __Text("700", "'"), __ColorRGBA.fromHex("#afb42b"), new __Text("800", "'"), __ColorRGBA.fromHex("#9e9d24"), new __Text("900", "'"), __ColorRGBA.fromHex("#827717"), new __Text("a100", "'"), __ColorRGBA.fromHex("#f4ff81"), new __Text("a200", "'"), __ColorRGBA.fromHex("#eeff41"), new __Text("a400", "'"), __ColorRGBA.fromHex("#c6ff00"), new __Text("a700", "'"), __ColorRGBA.fromHex("#aeea00")]), new __Text("yellow", "'"), new __Map([new __Text("50", "'"), __ColorRGBA.fromHex("#fffde7"), new __Text("100", "'"), __ColorRGBA.fromHex("#fff9c4"), new __Text("200", "'"), __ColorRGBA.fromHex("#fff59d"), new __Text("300", "'"), __ColorRGBA.fromHex("#fff176"), new __Text("400", "'"), __ColorRGBA.fromHex("#ffee58"), new __Text("500", "'"), __ColorRGBA.fromHex("#ffeb3b"), new __Text("600", "'"), __ColorRGBA.fromHex("#fdd835"), new __Text("700", "'"), __ColorRGBA.fromHex("#fbc02d"), new __Text("800", "'"), __ColorRGBA.fromHex("#f9a825"), new __Text("900", "'"), __ColorRGBA.fromHex("#f57f17"), new __Text("a100", "'"), __ColorRGBA.fromHex("#ffff8d"), new __Text("a200", "'"), __ColorRGBA.fromHex("#ffff00"), new __Text("a400", "'"), __ColorRGBA.fromHex("#ffea00"), new __Text("a700", "'"), __ColorRGBA.fromHex("#ffd600")]), new __Text("amber", "'"), new __Map([new __Text("50", "'"), __ColorRGBA.fromHex("#fff8e1"), new __Text("100", "'"), __ColorRGBA.fromHex("#ffecb3"), new __Text("200", "'"), __ColorRGBA.fromHex("#ffe082"), new __Text("300", "'"), __ColorRGBA.fromHex("#ffd54f"), new __Text("400", "'"), __ColorRGBA.fromHex("#ffca28"), new __Text("500", "'"), __ColorRGBA.fromHex("#ffc107"), new __Text("600", "'"), __ColorRGBA.fromHex("#ffb300"), new __Text("700", "'"), __ColorRGBA.fromHex("#ffa000"), new __Text("800", "'"), __ColorRGBA.fromHex("#ff8f00"), new __Text("900", "'"), __ColorRGBA.fromHex("#ff6f00"), new __Text("a100", "'"), __ColorRGBA.fromHex("#ffe57f"), new __Text("a200", "'"), __ColorRGBA.fromHex("#ffd740"), new __Text("a400", "'"), __ColorRGBA.fromHex("#ffc400"), new __Text("a700", "'"), __ColorRGBA.fromHex("#ffab00")]), new __Text("orange", "'"), new __Map([new __Text("50", "'"), __ColorRGBA.fromHex("#fff3e0"), new __Text("100", "'"), __ColorRGBA.fromHex("#ffe0b2"), new __Text("200", "'"), __ColorRGBA.fromHex("#ffcc80"), new __Text("300", "'"), __ColorRGBA.fromHex("#ffb74d"), new __Text("400", "'"), __ColorRGBA.fromHex("#ffa726"), new __Text("500", "'"), __ColorRGBA.fromHex("#ff9800"), new __Text("600", "'"), __ColorRGBA.fromHex("#fb8c00"), new __Text("700", "'"), __ColorRGBA.fromHex("#f57c00"), new __Text("800", "'"), __ColorRGBA.fromHex("#ef6c00"), new __Text("900", "'"), __ColorRGBA.fromHex("#e65100"), new __Text("a100", "'"), __ColorRGBA.fromHex("#ffd180"), new __Text("a200", "'"), __ColorRGBA.fromHex("#ffab40"), new __Text("a400", "'"), __ColorRGBA.fromHex("#ff9100"), new __Text("a700", "'"), __ColorRGBA.fromHex("#ff6d00")]), new __Text("deep-orange", "'"), new __Map([new __Text("50", "'"), __ColorRGBA.fromHex("#fbe9e7"), new __Text("100", "'"), __ColorRGBA.fromHex("#ffccbc"), new __Text("200", "'"), __ColorRGBA.fromHex("#ffab91"), new __Text("300", "'"), __ColorRGBA.fromHex("#ff8a65"), new __Text("400", "'"), __ColorRGBA.fromHex("#ff7043"), new __Text("500", "'"), __ColorRGBA.fromHex("#ff5722"), new __Text("600", "'"), __ColorRGBA.fromHex("#f4511e"), new __Text("700", "'"), __ColorRGBA.fromHex("#e64a19"), new __Text("800", "'"), __ColorRGBA.fromHex("#d84315"), new __Text("900", "'"), __ColorRGBA.fromHex("#bf360c"), new __Text("a100", "'"), __ColorRGBA.fromHex("#ff9e80"), new __Text("a200", "'"), __ColorRGBA.fromHex("#ff6e40"), new __Text("a400", "'"), __ColorRGBA.fromHex("#ff3d00"), new __Text("a700", "'"), __ColorRGBA.fromHex("#dd2c00")]), new __Text("brown", "'"), new __Map([new __Text("50", "'"), __ColorRGBA.fromHex("#efebe9"), new __Text("100", "'"), __ColorRGBA.fromHex("#d7ccc8"), new __Text("200", "'"), __ColorRGBA.fromHex("#bcaaa4"), new __Text("300", "'"), __ColorRGBA.fromHex("#a1887f"), new __Text("400", "'"), __ColorRGBA.fromHex("#8d6e63"), new __Text("500", "'"), __ColorRGBA.fromHex("#795548"), new __Text("600", "'"), __ColorRGBA.fromHex("#6d4c41"), new __Text("700", "'"), __ColorRGBA.fromHex("#5d4037"), new __Text("800", "'"), __ColorRGBA.fromHex("#4e342e"), new __Text("900", "'"), __ColorRGBA.fromHex("#3e2723")]), new __Text("grey", "'"), new __Map([new __Text("50", "'"), __ColorRGBA.fromHex("#fafafa"), new __Text("100", "'"), __ColorRGBA.fromHex("#f5f5f5"), new __Text("200", "'"), __ColorRGBA.fromHex("#eeeeee"), new __Text("300", "'"), __ColorRGBA.fromHex("#e0e0e0"), new __Text("400", "'"), __ColorRGBA.fromHex("#bdbdbd"), new __Text("500", "'"), __ColorRGBA.fromHex("#9e9e9e"), new __Text("600", "'"), __ColorRGBA.fromHex("#757575"), new __Text("700", "'"), __ColorRGBA.fromHex("#616161"), new __Text("800", "'"), __ColorRGBA.fromHex("#424242"), new __Text("900", "'"), __ColorRGBA.fromHex("#212121")]), new __Text("blue-grey", "'"), new __Map([new __Text("50", "'"), __ColorRGBA.fromHex("#eceff1"), new __Text("100", "'"), __ColorRGBA.fromHex("#cfd8dc"), new __Text("200", "'"), __ColorRGBA.fromHex("#b0bec5"), new __Text("300", "'"), __ColorRGBA.fromHex("#90a4ae"), new __Text("400", "'"), __ColorRGBA.fromHex("#78909c"), new __Text("500", "'"), __ColorRGBA.fromHex("#607d8b"), new __Text("600", "'"), __ColorRGBA.fromHex("#546e7a"), new __Text("700", "'"), __ColorRGBA.fromHex("#455a64"), new __Text("800", "'"), __ColorRGBA.fromHex("#37474f"), new __Text("900", "'"), __ColorRGBA.fromHex("#263238"), new __Text("1000", "'"), __ColorRGBA.fromHex("#11171a")])]), 5);
__rt_setDynamic("$base-focused-color", __rt_getGlobalDefault("$base_focused_color") || __rt_box((__rt_functions.material_color || material_color__fn).apply(__rt.functions, __rt_applySpreadArgs([
    __rt_get("$base_color_name"), 
    new __Text("400", "'")]))), 6);
__rt_setDynamic("$base-invisible-color", __rt_getGlobalDefault("$base_invisible_color") || __rt_box(__rt.registered.rgba.apply(__rt.registered, __rt_applySpreadArgs([
    __rt_get("$base_color"), 
    new __Numeric(0), 
    __udf, 
    __udf, 
    __udf]))), 7);
__rt_setDynamic("$material-foreground-colors", __rt_getGlobalDefault("$material_foreground_colors") || new __Map([new __Text("red", "'"), __ColorRGBA.fromHex("#fff"), new __Text("pink", "'"), __ColorRGBA.fromHex("#fff"), new __Text("purple", "'"), __ColorRGBA.fromHex("#fff"), new __Text("deep-purple", "'"), __ColorRGBA.fromHex("#fff"), new __Text("indigo", "'"), __ColorRGBA.fromHex("#fff"), new __Text("blue", "'"), __ColorRGBA.fromHex("#fff"), new __Text("light-blue", "'"), __ColorRGBA.fromHex("#fff"), new __Text("cyan", "'"), __ColorRGBA.fromHex("#fff"), new __Text("teal", "'"), __ColorRGBA.fromHex("#fff"), new __Text("green", "'"), __ColorRGBA.fromHex("#fff"), new __Text("light-green", "'"), __ColorRGBA.fromHex("#222"), new __Text("lime", "'"), __ColorRGBA.fromHex("#222"), new __Text("yellow", "'"), __ColorRGBA.fromHex("#222"), new __Text("amber", "'"), __ColorRGBA.fromHex("#222"), new __Text("orange", "'"), __ColorRGBA.fromHex("#222"), new __Text("deep-orange", "'"), __ColorRGBA.fromHex("#fff"), new __Text("brown", "'"), __ColorRGBA.fromHex("#fff"), new __Text("grey", "'"), __ColorRGBA.fromHex("#222"), new __Text("blue-grey", "'"), __ColorRGBA.fromHex("#fff")]), 8);
__rt_setDynamic("$base-foreground-color", __rt_getGlobalDefault("$base_foreground_color") || __rt_box((__rt.functions.material_foreground_color || material_foreground_color__fn).apply(__rt.functions, __rt_applySpreadArgs([
    __rt_get("$base_color_name")]))), 9);
__rt_setDynamic("$accent_color_name", __rt_getGlobalDefault("$accent_color_name") || new __Text("orange", "'"), 10);
__rt_setDynamic("$accent-color", __rt_getGlobalDefault("$accent_color") || __rt_box((__rt.functions.material_color || material_color__fn).apply(__rt.functions, __rt_applySpreadArgs([
    __rt_get("$accent_color_name"), 
    new __Text("500", "'")]))), 11);
__rt_setDynamic("$accent-light-color", __rt_getGlobalDefault("$accent_light_color") || __rt_box((__rt.functions.material_color || material_color__fn).apply(__rt.functions, __rt_applySpreadArgs([
    __rt_get("$accent_color_name"), 
    new __Text("100", "'")]))), 12);
__rt_setDynamic("$accent-dark-color", __rt_getGlobalDefault("$accent_dark_color") || __rt_box((__rt.functions.material_color || material_color__fn).apply(__rt.functions, __rt_applySpreadArgs([
    __rt_get("$accent_color_name"), 
    new __Text("700", "'")]))), 13);
__rt_setDynamic("$accent-pressed-color", __rt_getGlobalDefault("$accent_pressed_color") || (__rt_test(__rt_get("$dark_mode")) ? __rt_box(__rt.registered.darken.apply(__rt.registered, __rt_applySpreadArgs([
    __rt_get("$accent_color"), 
    new __Numeric(15, "%")]))) : __rt_box(__rt.registered.lighten.apply(__rt.registered, __rt_applySpreadArgs([
    __rt_get("$accent_color"), 
    new __Numeric(15, "%")])))), 14);
__rt_setDynamic("$accent-invisible-color", __rt_getGlobalDefault("$accent_invisible_color") || __rt_box(__rt.registered.rgba.apply(__rt.registered, __rt_applySpreadArgs([
    __rt_get("$accent_color"), 
    new __Numeric(0), 
    __udf, 
    __udf, 
    __udf]))), 15);
__rt_setDynamic("$accent-foreground-color", __rt_getGlobalDefault("$accent_foreground_color") || __rt_box((__rt.functions.material_foreground_color || material_foreground_color__fn).apply(__rt.functions, __rt_applySpreadArgs([
    __rt_get("$accent_color_name")]))), 16);
__rt_setDynamic("$confirm-color", __rt_getGlobalDefault("$confirm_color") || __rt_box((__rt.functions.material_color || material_color__fn).apply(__rt.functions, __rt_applySpreadArgs([
    new __Text("light-green", "'"), 
    new __Text("600", "'")]))), 17);
__rt_setDynamic("$confirm-pressed-color", __rt_getGlobalDefault("$confirm_pressed_color") || (__rt_test(__rt_get("$dark_mode")) ? __rt_box(__rt.registered.darken.apply(__rt.registered, __rt_applySpreadArgs([
    __rt_get("$confirm_color"), 
    new __Numeric(15, "%")]))) : __rt_box(__rt.registered.lighten.apply(__rt.registered, __rt_applySpreadArgs([
    __rt_get("$confirm_color"), 
    new __Numeric(15, "%")])))), 18);
__rt_setDynamic("$alert-color", __rt_getGlobalDefault("$alert_color") || __rt_box((__rt.functions.material_color || material_color__fn).apply(__rt.functions, __rt_applySpreadArgs([
    new __Text("red", "'"), 
    new __Text("800", "'")]))), 19);
__rt_setDynamic("$alert-pressed-color", __rt_getGlobalDefault("$alert_pressed_color") || (__rt_test(__rt_get("$dark_mode")) ? __rt_box(__rt.registered.darken.apply(__rt.registered, __rt_applySpreadArgs([
    __rt_get("$alert_color"), 
    new __Numeric(15, "%")]))) : __rt_box(__rt.registered.lighten.apply(__rt.registered, __rt_applySpreadArgs([
    __rt_get("$alert_color"), 
    new __Numeric(15, "%")])))), 20);
__rt_setDynamic(__strings._, __rt_getGlobalDefault(__strings._) || (__rt_test(__rt_get("$dark_mode")) ? __ColorRGBA.fromHex("#fff") : __ColorRGBA.fromHex("#111111")), 21);
__rt_setDynamic("$reverse-color", __rt_getGlobalDefault("$reverse_color") || (__rt_test(__rt_get("$dark_mode")) ? __ColorRGBA.fromHex("#222") : __ColorRGBA.fromHex("#fff")), 22);
__rt_setDynamic("$highlight-color", __rt_getGlobalDefault("$highlight_color") || __rt_box(__rt.registered.rgba.apply(__rt.registered, __rt_applySpreadArgs([
    __rt_get(__strings._), 
    new __Numeric(0.54), 
    __udf, 
    __udf, 
    __udf]))), 23);
__rt_setDynamic("$disabled-color", __rt_getGlobalDefault("$disabled_color") || __rt_box(__rt.registered.rgba.apply(__rt.registered, __rt_applySpreadArgs([
    __rt_get(__strings._), 
    new __Numeric(0.38), 
    __udf, 
    __udf, 
    __udf]))), 24);
__rt_setDynamic("$reverse-disabled-color", __rt_getGlobalDefault("$reverse_disabled_color") || __rt_box(__rt.registered.rgba.apply(__rt.registered, __rt_applySpreadArgs([
    __rt_get("$reverse_color"), 
    new __Numeric(0.38), 
    __udf, 
    __udf, 
    __udf]))), 25);
__rt_setDynamic("$divider-color", __rt_getGlobalDefault("$divider_color") || __rt_box(__rt.registered.mix.apply(__rt.registered, __rt_applySpreadArgs([
    __rt_get(__strings._), 
    __rt_get("$reverse_color"), 
    new __Numeric(12, "%")]))), 26);
__rt_setDynamic("$selected-background-color", __rt_getGlobalDefault("$selected_background_color") || (__rt_test(__rt_get("$dark_mode")) ? __rt_get("$base_dark_color") : __rt_box((__rt.functions.material_color || material_color__fn).apply(__rt.functions, __rt_applySpreadArgs([
    new __Text("grey", "'"), 
    new __Text("300", "'")])))), 27);
__rt_setDynamic("$hovered-background-color", __rt_getGlobalDefault("$hovered_background_color") || (__rt_test(__rt_get("$dark_mode")) ? __ColorRGBA.fromHex("#4d4d4d") : __rt_box((__rt.functions.material_color || material_color__fn).apply(__rt.functions, __rt_applySpreadArgs([
    new __Text("grey", "'"), 
    new __Text("200", "'")])))), 28);
__rt_setDynamic("$header-background-color", __rt_getGlobalDefault("$header_background_color") || (__rt_test(__rt_get("$dark_mode")) ? __rt_box((__rt.functions.material_color || material_color__fn).apply(__rt.functions, __rt_applySpreadArgs([
    new __Text("grey", "'"), 
    new __Text("800", "'")]))) : __rt_box((__rt.functions.material_color || material_color__fn).apply(__rt.functions, __rt_applySpreadArgs([
    new __Text("grey", "'"), 
    new __Text("100", "'")])))), 29);
__rt_setDynamic("$faded-color", __rt_getGlobalDefault("$faded_color") || (__rt_test(__rt_get("$dark_mode")) ? __ColorRGBA.fromHex("#4d4d4d") : __ColorRGBA.fromHex("#e1e1e1")), 30);
__rt_setDynamic("$background-color", __rt_getGlobalDefault("$background_color") || (__rt_test(__rt_get("$dark_mode")) ? __ColorRGBA.fromHex("#303030") : __ColorRGBA.fromHex("#fafafa")), 31);
__rt_setDynamic("$alt-background-color", __rt_getGlobalDefault("$alt_background_color") || (__rt_test(__rt_get("$dark_mode")) ? __ColorRGBA.fromHex("#3a3a3a") : __ColorRGBA.fromHex("#f5f5f5")), 32);
__rt_setDynamic("$reverse-background-color", __rt_getGlobalDefault("$reverse_background_color") || (__rt_test(__rt_get("$dark_mode")) ? __ColorRGBA.fromHex("#fafafa") : __ColorRGBA.fromHex("#303030")), 33);
__rt_setDynamic("$reverse-alt-background-color", __rt_getGlobalDefault("$reverse_alt_background_color") || (__rt_test(__rt_get("$dark_mode")) ? __ColorRGBA.fromHex("#f5f5f5") : __ColorRGBA.fromHex("#3a3a3a")), 34);
__rt_setDynamic("$overlay-color", __rt_getGlobalDefault("$overlay_color") || (__rt_test(__rt_get("$dark_mode")) ? __rt_box(__rt.registered.rgba.apply(__rt.registered, __rt_applySpreadArgs([
    __ColorRGBA.fromHex("#fff"), 
    new __Numeric(0.03), 
    __udf, 
    __udf, 
    __udf]))) : __rt_box(__rt.registered.rgba.apply(__rt.registered, __rt_applySpreadArgs([
    __ColorRGBA.fromHex("#000"), 
    new __Numeric(0.03), 
    __udf, 
    __udf, 
    __udf])))), 35);
__rt_setDynamic("$content-padding", __rt_getGlobalDefault("$content_padding") || new __Numeric(16, "px"), 36);
__rt_setDynamic("$dataview_item_selected_background_color", __rt_getGlobalDefault("$dataview_item_selected_background_color") || __rt_get("$selected_background_color"), 37);
__rt_setDynamic("$dataitem_selected_background_color", __rt_getGlobalDefault("$dataitem_selected_background_color") || __rt_get("$dataview_item_selected_background_color"), 38);
__rt_setDynamic("$listitem-selected-background-color", __rt_getGlobalDefault("$listitem_selected_background_color") || __rt_get("$dataitem_selected_background_color"), 39);
},
 {
	":root": [
		"dark-mode",
		"base-color",
		"base-highlight-color",
		"base-light-color",
		"base-dark-color",
		"base-pressed-color",
		"base-focused-color",
		"base-invisible-color",
		"base-foreground-color",
		"accent-color",
		"accent-light-color",
		"accent-dark-color",
		"accent-pressed-color",
		"accent-invisible-color",
		"accent-foreground-color",
		"confirm-color",
		"confirm-pressed-color",
		"alert-color",
		"alert-pressed-color",
		__names._,
		"reverse-color",
		"highlight-color",
		"disabled-color",
		"reverse-disabled-color",
		"divider-color",
		"selected-background-color",
		"hovered-background-color",
		"header-background-color",
		"faded-color",
		"background-color",
		"alt-background-color",
		"reverse-background-color",
		"reverse-alt-background-color",
		"overlay-color",
		"content-padding",
		"listitem-selected-background-color"
	],
	"html": [
		"base_color_name",
		"accent_color_name",
		"dataview_item_selected_background_color",
		"dataitem_selected_background_color"
	]});
})(Fashion);